[{"source": "mbpp-sanitized", "id": 11, "function_name": "remove_Occ", "code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ", "distractor_code": "def minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\ndef remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"}, {"source": "mbpp-sanitized", "id": 12, "function_name": "sort_matrix", "code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "distractor_code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n\ndef minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result\n\ndef buyChoco(prices: List[int], money: int) -> int:\n  x = -1\n  n = len(prices)\n  for i in range(n):\n    for j in range(i + 1, n):\n      x = max(x, money - prices[i] - prices[j])\n  return money if x < 0 else x\n\ndef lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]"}, {"source": "mbpp-sanitized", "id": 14, "function_name": "find_Volume", "code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ", "distractor_code": "def volume_cube(l):\n  volume = l * l * l\n  return volume\n\ndef find_Volume(l,b,h) : \n    return ((l * b * h) / 2) \n\ndef sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}, {"source": "mbpp-sanitized", "id": 16, "function_name": "text_lowercase_underscore", "code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "distractor_code": "from typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\nimport re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False"}, {"source": "mbpp-sanitized", "id": 17, "function_name": "square_perimeter", "code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a, b = -1, -1\n    for i, v in enumerate(nums):\n        if v == 1: a = i \n        if v == n: b = i\n    delta = 0\n    if a > b:\n        delta = 1\n    return a+n-1-b-delta\n\ndef isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef square_perimeter(a):\n  perimeter=4*a\n  return perimeter\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)"}, {"source": "mbpp-sanitized", "id": 18, "function_name": "remove_dirty_chars", "code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ", "distractor_code": "def Find_Min(lst): \n    return min(lst, key=len) \n\ndef maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans\n\ndef add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n\nNO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a, b = -1, -1\n    for i, v in enumerate(nums):\n        if v == 1: a = i \n        if v == n: b = i\n    delta = 0\n    if a > b:\n        delta = 1\n    return a+n-1-b-delta"}, {"source": "mbpp-sanitized", "id": 19, "function_name": "test_duplicate", "code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num\n\ndef test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \n\ndef minimumSeconds(A: List[int]) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = N = len(A)\n    for row in locs.values():\n        gaps = [row[i+1] - row[i] - 1 for i in range(len(row) - 1)]\n        gaps.append(row[0] + N - row[-1] - 1)\n        m = max(gaps)\n        m = (m + 1) // 2\n        ans = min(ans, m)\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans\n\nimport sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i"}, {"source": "mbpp-sanitized", "id": 20, "function_name": "is_woodall", "code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False", "distractor_code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    s = sorted(nums)\n    n = len(nums)\n    for i in range(n + 10):\n        t = [nums[-1]] + nums[:-1][:]\n        if s == t:\n            return (i + 1) % n\n        nums = t[:]\n        # print('t', t, nums)\n    else:\n        return -1\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    \n    lst1 = [s1[0], s1[2]]\n    lst2 = [s2[0], s2[2]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    lst1 = [s1[1], s1[3]]\n    lst2 = [s2[1], s2[3]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    return True"}, {"source": "mbpp-sanitized", "id": 56, "function_name": "check", "code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ", "distractor_code": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\n\nimport re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\n\ndef rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n\nfrom typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a\n\ndef max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum"}, {"source": "mbpp-sanitized", "id": 57, "function_name": "find_Max_Num", "code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer\n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result"}, {"source": "mbpp-sanitized", "id": 58, "function_name": "opposite_Signs", "code": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); ", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\ndef sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\ndef opposite_Signs(x,y): \n    return ((x ^ y) < 0); "}, {"source": "mbpp-sanitized", "id": 59, "function_name": "is_octagonal", "code": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n ", "distractor_code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef is_octagonal(n): \n\treturn 3 * n * n - 2 * n \n\ndef distributeCandies(n: int, limit: int) -> int:\n    res = comb(n + 2, 2)\n    if n >= limit + 1:\n        res -= 3 * comb(n - limit + 1, 2)\n    if n >= 2 * limit + 2:\n        res += 3 * comb(n - 2 * limit, 2)\n    if n >= 3 * (limit + 1):\n        res -= comb(n - 3 * limit - 1, 2)\n    return res\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)"}, {"source": "mbpp-sanitized", "id": 61, "function_name": "count_Substrings", "code": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count", "distractor_code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]\n\nfrom collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n\ndef loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    indexs = []\n    Mod = 10**9 + 7\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            indexs.append(i)\n    if len(indexs) == 0:\n        return 0\n    ans = 1\n    for i in range(1,len(indexs)):\n        ans *= (indexs[i] - indexs[i-1])\n        ans %= Mod\n    return ans\n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2\n\ndef reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string"}, {"source": "mbpp-sanitized", "id": 62, "function_name": "smallest_num", "code": "def smallest_num(xs):\n  return min(xs)\n", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)\n\nimport math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s\n\ndef smallest_num(xs):\n  return min(xs)\n\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False"}, {"source": "mbpp-sanitized", "id": 63, "function_name": "max_difference", "code": "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) ", "distractor_code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n\ndef find(n,m):  \n    q = n//m \n    return (q)\n\ndef minOperations(a: List[int], b: List[int]) -> int:\n    def f():\n        ret = 0\n        aa, bb = a[:], b[:]\n        for i in range(len(a)):\n            if a[i] > a[-1] or b[i] > b[-1]:\n                a[i], b[i] = b[i], a[i]\n                ret += 1\n            if a[i] > a[-1] or b[i] > b[-1]:\n                return inf\n        a[:] = aa\n        b[:] = bb\n        return ret\n    \n    ans = f()\n    a[-1], b[-1] = b[-1], a[-1]\n    ans = min(ans, f() + 1)\n    return -1 if ans > len(a) else ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    n = len(nums)\n    A = sorted(list(Counter(nums).values()))\n    \n    x = A[0]\n    @lru_cache(None)\n    def dp(y,x):\n        if y == 0:\n            return 0\n        if y < x:\n            return math.inf\n        if y==x or y == x+1:\n            return 1\n        return 1+min(dp(y-x,x),dp(y-x-1,x))\n    \n    while x:\n        ans = sum(dp(y,x) for y in A)\n        if ans < math.inf:\n            return ans\n        x=x-1\n\ndef max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res"}, {"source": "mbpp-sanitized", "id": 64, "function_name": "subject_marks", "code": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks", "distractor_code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\ndef sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <3:\n        return True\n    for i,v in enumerate(nums):\n        if i+1 >= len(nums):\n            continue\n        if v + nums[i+1] >= m:\n            return True\n    return False\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans"}, {"source": "mbpp-sanitized", "id": 65, "function_name": "recursive_list_sum", "code": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total", "distractor_code": "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ex = min ((mainTank - 1) // 4, additionalTank)\n    \n    return (ex + mainTank) * 10"}, {"source": "mbpp-sanitized", "id": 66, "function_name": "pos_count", "code": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count ", "distractor_code": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n\nimport cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    empty1 = sum((x == 0) for x in nums1)\n    empty2 = sum((x == 0) for x in nums2)\n    mins1 = s1 + empty1\n    mins2 = s2 + empty2\n    if empty1 == 0 and s1 < mins2:\n        return -1\n    if empty2 == 0 and s2 < mins1:\n        return -1\n    return max(mins1, mins2)\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))"}, {"source": "mbpp-sanitized", "id": 67, "function_name": "bell_number", "code": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] ", "distractor_code": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\ndef remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s "}, {"source": "mbpp-sanitized", "id": 68, "function_name": "is_Monotonic", "code": "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ", "distractor_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if gcd(int(str(nums[i])[0]), int(str(nums[j])[-1])) == 1:\n                ans += 1\n    return ans\n\ndef is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \n\ndef maxIncreasingGroups(x: List[int]) -> int:\n    x.sort()\n    n = len(x)\n    vals = list(accumulate(x))\n    ans = 0\n    for v in vals:\n        if (ans + 1) * (ans + 2) // 2 <= v:\n            ans += 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 69, "function_name": "is_sublist", "code": "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set", "distractor_code": "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2\n\ndef is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set"}, {"source": "mbpp-sanitized", "id": 70, "function_name": "get_equal", "code": "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res\n\nfrom typing import *\n\nfrom math import *\n\n\ndef isFascinating(n: int) -> bool:\n    x = str(n) + str(2 * n) + str(3 * n)\n    return len(set(x)) == 9 and len(x) == 9 and '0' not in x\n\ndef find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n+1) if i % m != 0) - sum(i for i in range(1, n+1) if i % m == 0)"}, {"source": "mbpp-sanitized", "id": 71, "function_name": "comb_sort", "code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums", "distractor_code": "def matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\nimport re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))"}, {"source": "mbpp-sanitized", "id": 72, "function_name": "dif_Square", "code": "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \n\ndef dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\n\ndef sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n\ndef minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret"}, {"source": "mbpp-sanitized", "id": 74, "function_name": "is_samepatterns", "code": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True", "distractor_code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    b = sorted(nums)\n    ans = inf\n    n = len(nums)\n    for i in range(n):\n        a = nums[i:] + nums[:i]\n        if a == b:\n            ans = min(ans, (n - i) % n)\n    return -1 if ans == inf else ans\n\ndef is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\n\ndef is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False"}, {"source": "mbpp-sanitized", "id": 75, "function_name": "find_tuples", "code": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res", "distractor_code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"}, {"source": "mbpp-sanitized", "id": 77, "function_name": "is_Diff", "code": "def is_Diff(n): \n    return (n % 11 == 0) ", "distractor_code": "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result\n\ndef is_Diff(n): \n    return (n % 11 == 0) \n\ndef sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1"}, {"source": "mbpp-sanitized", "id": 79, "function_name": "word_len", "code": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False", "distractor_code": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n\ndef and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums)<target:return -1\n    cnt=[0]*32\n    for a in nums:\n        l=a.bit_length()-1\n        cnt[l]+=1\n    ans=0\n    for k in range(31):\n        if target>>k&1:\n            i=k\n            while cnt[i]==0:i+=1\n            while i>k:\n                cnt[i]-=1\n                cnt[i-1]+=2\n                ans+=1\n                i-=1\n            cnt[k]-=1\n        cnt[k+1]+=cnt[k]//2\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]"}, {"source": "mbpp-sanitized", "id": 80, "function_name": "tetrahedral_number", "code": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6", "distractor_code": "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = []\n    s = 0\n    cur = 1\n    st = set()\n    while len(ans)<n:\n        while k-cur in st:\n            cur+=1\n        ans.append(cur)\n        st.add(cur)\n        s+=cur\n        cur+=1\n    return s\n\ndef tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6"}, {"source": "mbpp-sanitized", "id": 83, "function_name": "get_Char", "code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)", "distractor_code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n\ndef common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False"}, {"source": "mbpp-sanitized", "id": 84, "function_name": "sequence", "code": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))", "distractor_code": "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    a, b, c = 0, 0, 0\n    a = moves.count('L')\n    b = moves.count('R')\n    c = moves.count('_')\n    return max([a + c - b, b + c - a])\n\ndef sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))"}, {"source": "mbpp-sanitized", "id": 86, "function_name": "centered_hexagonal_number", "code": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1", "distractor_code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans\n\ndef matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans\n\ndef replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\n\ndef centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\n\ndef isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9"}, {"source": "mbpp-sanitized", "id": 87, "function_name": "merge_dictionaries_three", "code": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict", "distractor_code": "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\n\nimport collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    beauty = \"\"\n    n = len(s)\n    min_len = None\n    for ln in range(k, n+1):\n        for i in range(n-ln+1):\n            ss = s[i:i+ln]\n            if len([c for c in ss if c == '1']) == k:\n                min_len = ln\n                if not beauty or ss < beauty:\n                    beauty = ss\n        if min_len:\n            break\n    return beauty\n\ndef amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)"}, {"source": "mbpp-sanitized", "id": 88, "function_name": "freq_count", "code": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count", "distractor_code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    N = len(s)\n    \n    left = 0\n    best = 1\n    count = 0\n    \n    for right in range(1, N):\n        if s[right] == s[right - 1]:\n            count += 1\n        while count > 1:\n            if s[left] == s[left + 1]:\n                count -= 1\n            left += 1\n            \n        best = max(best, right - left + 1)\n    return best\n\nimport collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans"}, {"source": "mbpp-sanitized", "id": 89, "function_name": "closest_num", "code": "def closest_num(N):\n  return (N - 1)", "distractor_code": "def closest_num(N):\n  return (N - 1)\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    loc = set(nums)  # 初始有石块的位置\n    for i, j in zip(moveFrom, moveTo):\n        loc.remove(i)  # i不再是有石块的位置\n        loc.add(j)  # 不管之前有没有石块，j成为有石块的位置\n    return sorted(loc)\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot\n\ndef max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max"}, {"source": "mbpp-sanitized", "id": 90, "function_name": "len_log", "code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max", "distractor_code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\n\nimport heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]"}, {"source": "mbpp-sanitized", "id": 91, "function_name": "find_substring", "code": "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False", "distractor_code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1"}, {"source": "mbpp-sanitized", "id": 92, "function_name": "is_undulating", "code": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True", "distractor_code": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n\ndef minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res\n\ndef distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]"}, {"source": "mbpp-sanitized", "id": 93, "function_name": "power", "code": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)", "distractor_code": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    answer = [None for i in range(n)]\n    vowels = []\n    v2 = []\n    for i in range(n):\n        if s[i] not in 'aeiouAEIOU':\n            answer[i] = s[i]\n        else:\n            vowels.append(s[i])\n            v2.append(i)\n    vowels = sorted(vowels, key=lambda a: ord(a))\n    m = len(vowels)\n    for i in range(m):\n        c, j = vowels[i], v2[i]\n        answer[j] = c\n    return ''.join(answer)\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    d = defaultdict(int)\n    for x in nums:\n        d[x] += 1\n    for x,y in zip(moveFrom,moveTo):\n        tmp = d[x]\n        d[x]-=tmp\n        d[y]+=tmp\n    return [x for x in sorted(d) if d[x]>0]"}, {"source": "mbpp-sanitized", "id": 94, "function_name": "index_minimum", "code": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) ", "distractor_code": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \n\ndef sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans\n\ndef trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res"}, {"source": "mbpp-sanitized", "id": 95, "function_name": "Find_Min_Length", "code": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength ", "distractor_code": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans\n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    def cut(s):\n        return (sorted(s[::2]), sorted(s[1::2]))\n    \n    return cut(s1) == cut(s2)"}, {"source": "mbpp-sanitized", "id": 96, "function_name": "divisor", "code": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\ndef minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\n\ndef divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) "}, {"source": "mbpp-sanitized", "id": 97, "function_name": "frequency_lists", "code": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n\ndef lexicographicallySmallestArray(nums: List[int], limit: int) -> List[int]:\n    n = len(nums)\n    \n    order = sorted(range(n), key = lambda x: nums[x])\n    \n    out = [-1] * n\n    \n    l = 0\n    for i in range(n):\n        if i == n - 1 or nums[order[i]] + limit < nums[order[i + 1]]:\n            ind = sorted(order[l: i + 1])\n            for j in range(i - l + 1):\n                out[ind[j]] = nums[order[l + j]]\n            l = i + 1\n    return out\n\ndef frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n"}, {"source": "mbpp-sanitized", "id": 99, "function_name": "decimal_to_binary", "code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") ", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num\n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\n\ndef decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n\ndef list_split(S, step):\n    return [S[i::step] for i in range(step)]"}, {"source": "mbpp-sanitized", "id": 100, "function_name": "next_smallest_palindrome", "code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i", "distractor_code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n\nimport sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef distributeCandies(n: int, limit: int) -> int:\n    limit = min(limit, n)\n    ans = 0\n    for i in range(limit+1):\n        if n-i > limit * 2:\n            continue\n        ans += (min(limit, n-i) - max(0, n-i-limit) + 1)\n    return ans"}, {"source": "mbpp-sanitized", "id": 101, "function_name": "kth_element", "code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]", "distractor_code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n\ndef replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    n = len(nums)\n    for k,v in c.items():\n        if v >= n - v:\n            return v - (n - v)\n    return n % 2"}, {"source": "mbpp-sanitized", "id": 102, "function_name": "snake_to_camel", "code": "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))", "distractor_code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    ans = n = len(nums)\n    i, j = n // 2 - 1, n - 1\n    while i >= 0:\n        while i >= 0 and nums[i] == nums[j]:\n            i -= 1\n        if i >= 0:\n            ans -= 2\n            j -= 1\n            i -= 1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)\n\nimport re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))"}, {"source": "mbpp-sanitized", "id": 103, "function_name": "eulerian_num", "code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))", "distractor_code": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n\ndef newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))"}, {"source": "mbpp-sanitized", "id": 104, "function_name": "sort_sublists", "code": "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    tmp = set(nums)\n    for x, y in zip(moveFrom, moveTo):\n        tmp.remove(x)\n        tmp.add(y)\n    return sorted(tmp)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([x for x in hours if x >= target])\n\ndef sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n"}, {"source": "mbpp-sanitized", "id": 105, "function_name": "count", "code": "def count(lst):   \n    return sum(lst) ", "distractor_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans\n\ndef is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n\ndef count(lst):   \n    return sum(lst) \n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\n\nfrom typing import *\n\nfrom math import *\n\n\ndef makeTheIntegerZero(a: int, b: int) -> int:\n    for i in range(1, 1000):\n        a -= b\n        if a >= i and bin(a)[2:].count('1') <= i:\n            return i\n    return -1"}, {"source": "mbpp-sanitized", "id": 106, "function_name": "add_lists", "code": "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) ", "distractor_code": "def canBeEqual(s1: str, s2: str) -> bool:\n    def sign(s):\n        return sorted(s[::2]), sorted(s[1::2])\n        \n    return sign(s1) == sign(s2)\n\ndef find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    l, r = 0, 0\n    cnt = 0\n    ans = 0\n    n = len(s)\n    while l < n:\n        while r < n and cnt + (s[r] == s[r-1] and r > 0) < 2:\n            cnt += (s[r] == s[r-1] and r > 0)\n            r += 1\n        ans = max(ans, r - l)\n        if l == n-1: break\n        cnt -= s[l] == s[l+1]\n        l += 1\n    return ans\n\ndef add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \n\ndef minimumSum(n: int, k: int) -> int:\n    ans = set()\n    i = 1\n    while len(ans) < n:\n        if k - i not in ans:\n            ans.add(i)\n        i += 1\n    return sum(ans)"}, {"source": "mbpp-sanitized", "id": 108, "function_name": "merge_sorted_list", "code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)", "distractor_code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n\ndef group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] != -1 and abs(nums[j] - nums[i]) <= target:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[n - 1]"}, {"source": "mbpp-sanitized", "id": 109, "function_name": "odd_Equivalent", "code": "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count ", "distractor_code": "def findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\nfrom itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\n\ndef odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n\ndef finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res "}, {"source": "mbpp-sanitized", "id": 113, "function_name": "check_integer", "code": "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False", "distractor_code": "def minimumIndex(nums: List[int]) -> int:\n    x, c = 0, 0\n    for i in nums:\n        if i == x:\n            c += 1\n        else:\n            c -= 1\n            if c < 0:\n                x = i\n                c = 1\n    m = nums.count(x)\n    p = 0\n    for i in range(len(nums)):\n        p += nums[i] == x\n        if p * 2 > i + 1 and (m - p) * 2 > len(nums) - i - 1:\n            return i\n    return -1\n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n\ndef is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    res=0\n    n=len(nums)\n    for i in range(n):\n        for j in range(i+1,n):\n            a=int(str(nums[i])[0])\n            b=int(str(nums[j])[-1])\n            if gcd(a,b)==1:\n                res+=1\n    return res\n\ndef check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False"}, {"source": "mbpp-sanitized", "id": 115, "function_name": "empty_dit", "code": "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1\n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1\n\ndef empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit"}, {"source": "mbpp-sanitized", "id": 116, "function_name": "tuple_to_int", "code": "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result", "distractor_code": "def list_split(S, step):\n    return [S[i::step] for i in range(step)]\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\ndef tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\ndef makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)\n\ndef tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result"}, {"source": "mbpp-sanitized", "id": 117, "function_name": "list_to_float", "code": "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res", "distractor_code": "def minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1\n\ndef list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    res = 0\n    deq = deque()\n    for n in nums:\n        deq.append(n)\n        while deq[0] < n - 2 * k:\n            deq.popleft()\n        res = max(res, len(deq))\n    return res"}, {"source": "mbpp-sanitized", "id": 118, "function_name": "string_to_list", "code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans\n\ndef string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n\ndef distributeCandies(n: int, limit: int) -> int:\n    limit = min(limit, n)\n    ans = 0\n    for i in range(limit+1):\n        if n-i > limit * 2:\n            continue\n        ans += (min(limit, n-i) - max(0, n-i-limit) + 1)\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans"}, {"source": "mbpp-sanitized", "id": 119, "function_name": "search", "code": "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans\n\ndef search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n\nimport math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret"}, {"source": "mbpp-sanitized", "id": 120, "function_name": "max_product_tuple", "code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9\n\ndef max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n\ndef common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\n\ndef is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s"}, {"source": "mbpp-sanitized", "id": 123, "function_name": "amicable_numbers_sum", "code": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)", "distractor_code": "def maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax\n\ndef amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\n\ndef remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s \n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(str(nums[i])[0])\n            b = int(str(nums[j])[-1])\n            if gcd(a, b) == 1:\n                ans += 1\n    return ans\n\nimport re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)"}, {"source": "mbpp-sanitized", "id": 125, "function_name": "find_length", "code": "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0", "distractor_code": "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\n\ndef check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res\n\ndef find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0"}, {"source": "mbpp-sanitized", "id": 126, "function_name": "sum", "code": "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum", "distractor_code": "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\n\ndef distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]\n\ndef minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans"}, {"source": "mbpp-sanitized", "id": 127, "function_name": "multiply_int", "code": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)", "distractor_code": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n\nimport re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()\n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"}, {"source": "mbpp-sanitized", "id": 128, "function_name": "long_words", "code": "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t", "distractor_code": "def minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)\n\ndef long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n\nimport re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n"}, {"source": "mbpp-sanitized", "id": 129, "function_name": "magic_square_test", "code": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True", "distractor_code": "def minimumPossibleSum(n: int, target: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n and i <= target//2:\n        a.append(i)\n        i += 1\n    i = target\n    while len(a) < n:\n        a.append(i)\n        i += 1\n    return sum(a)\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr"}, {"source": "mbpp-sanitized", "id": 130, "function_name": "max_occurrences", "code": "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]", "distractor_code": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)\n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans\n\nfrom collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    ans = [-1]\n    for i in range(len(s)-1):\n        if s[i+1] == s[i]: ans.append(i)\n    ans.append(len(s)-1)\n    if len(ans) == 2: return len(s)\n    return max(ans[i+2]-ans[i] for i in range(len(ans)-2))"}, {"source": "mbpp-sanitized", "id": 131, "function_name": "reverse_vowels", "code": "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string", "distractor_code": "def differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n+1) if i % m != 0) - sum(i for i in range(1, n+1) if i % m == 0)\n\ndef max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        c1, c2 = s[left], s[right]\n        if c1 != c2:\n            s[left] = min(c1, c2)\n            s[right] = s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string"}, {"source": "mbpp-sanitized", "id": 132, "function_name": "tup_string", "code": "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str", "distractor_code": "def distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n\ndef tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\n\ndef smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)"}, {"source": "mbpp-sanitized", "id": 133, "function_name": "sum_negativenum", "code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)", "distractor_code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum"}, {"source": "mbpp-sanitized", "id": 135, "function_name": "hexagonal_num", "code": "def hexagonal_num(n): \n\treturn n*(2*n - 1) ", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) \n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    f = [0] * (n + 1)\n    t = 0\n    for x, y, z in sorted(offers, key=lambda it: it[1]):\n        x += 1\n        y += 1\n        while t < y:\n            f[t + 1] = f[t]\n            t += 1\n        f[y] = max(f[x - 1] + z, f[y])\n\n    return max(f)"}, {"source": "mbpp-sanitized", "id": 138, "function_name": "is_Sum_Of_Powers_Of_Two", "code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]\n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\n\ndef is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True"}, {"source": "mbpp-sanitized", "id": 141, "function_name": "pancake_sort", "code": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    p=0\n    cnt=0\n    for c in moves:\n        if c==\"L\":\n            p-=1\n        elif c==\"R\":\n            p+=1\n        else:\n            cnt+=1\n    return abs(p)+cnt\n\ndef findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef maxSum(nums: List[int]) -> int:\n    \n    ans = -1\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if max(str(nums[i]))==max(str(nums[j])):\n                ans = max(ans,nums[i]+nums[j])\n    return ans\n\ndef pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums"}, {"source": "mbpp-sanitized", "id": 142, "function_name": "count_samepair", "code": "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result", "distractor_code": "def minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1\n\ndef minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1\n\ndef count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)"}, {"source": "mbpp-sanitized", "id": 143, "function_name": "find_lists", "code": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) ", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\nfrom typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum\n\ndef word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n\ndef is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n\ndef find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \n\ndef maxSum(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if max(w for w in str(nums[i])) == max(w for w in str(nums[j])):\n                cur = nums[i]+nums[j]\n                if cur > ans:\n                    ans = cur\n    return ans"}, {"source": "mbpp-sanitized", "id": 145, "function_name": "max_Abs_Diff", "code": "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) ", "distractor_code": "def maximumOddBinaryNumber(s: str) -> str:\n    a = s.count('1')\n    b = s.count('0')\n    \n    res = '1'*(a-1) + '0'*(b) + '1'\n    return res\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum\n\nimport heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)"}, {"source": "mbpp-sanitized", "id": 160, "function_name": "find_solution", "code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    kq = deque()\n    S = 0\n    while nums:\n        while kq and kq[0][0] - k + 1 >= len(nums):\n            r, t = kq.popleft()\n            S -= t\n        nums[-1] -= S\n        if nums[-1] < 0:\n            return False\n        elif nums[-1] > 0:\n            if len(nums) < k:\n                return False\n            kq.append((len(nums) - 1, nums[-1]))\n            S += kq[-1][1]\n        nums.pop()\n    return True\n\ndef continuousSubarrays(a: List[int]) -> int:\n    h = Counter()\n    mo = deque([])\n    ans = 0\n    for i in a:\n        mo.append(i)\n        h[i] += 1\n        while h[i-2]+h[i-1]+h[i]+h[i+1]+h[i+2] != len(mo):\n            h[mo.popleft()] -= 1\n        ans += len(mo)\n    return ans\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None"}, {"source": "mbpp-sanitized", "id": 161, "function_name": "remove_elements", "code": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n\ndef is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \n\ndef frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count "}, {"source": "mbpp-sanitized", "id": 162, "function_name": "sum_series", "code": "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n\ndef centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1"}, {"source": "mbpp-sanitized", "id": 164, "function_name": "are_equivalent", "code": "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); ", "distractor_code": "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans"}, {"source": "mbpp-sanitized", "id": 165, "function_name": "count_char_position", "code": "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars ", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n\ndef minLength(s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) > 1 and stack[-2] + stack[-1] in [\"AB\", \"CD\"]:\n            stack.pop()\n            stack.pop()\n            \n    return len(stack)\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    ans = [float(\"inf\")]*(n+1)\n    \n    for i in range(n):\n        if i==0:\n            cost = prices[i]\n        else:\n            cost = ans[i-1]+prices[i]\n            \n        for j in range(i,min(n,i+i+1+1)):\n            ans[j] = min(ans[j],cost)\n    # print(ans)\n    return ans[n-1]\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans"}, {"source": "mbpp-sanitized", "id": 166, "function_name": "find_even_pair", "code": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count"}, {"source": "mbpp-sanitized", "id": 167, "function_name": "next_power_of_2", "code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; ", "distractor_code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    cntr = Counter(nums[:k])\n    cursum = sum(nums[:k])\n    \n    maxres = 0\n    if len(cntr) >= m:\n        maxres += cursum\n                   \n    for out, inp in zip(nums, nums[k:]):\n        cursum -= out\n        cursum += inp\n        cntr[out] -= 1\n        if cntr[out] == 0:\n            del cntr[out]\n        cntr[inp] += 1\n        if len(cntr) >= m:\n            maxres = max(maxres, cursum)\n    \n    return maxres\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result"}, {"source": "mbpp-sanitized", "id": 168, "function_name": "frequency", "code": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count ", "distractor_code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    q = deque()\n    ans = 0\n    for x in nums:\n        q.append(x)\n        while q[0] < x - k - k:\n            q.popleft()\n        ans = max(ans, len(q))\n    return ans\n\ndef frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \n\ndef countSeniors(details: List[str]) -> int:\n    ans=0\n    for s in details:\n        if int(s[11:13])>60:\n            ans+=1\n    return ans"}, {"source": "mbpp-sanitized", "id": 170, "function_name": "sum_range_list", "code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   ", "distractor_code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += grid[i][j]\n        if t == n - 1:\n            return i\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 171, "function_name": "perimeter_pentagon", "code": "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter", "distractor_code": "def minimumOperations(num: str) -> int:\n    ends = ['00', '25', '50', '75']\n    \n    num = '00'+num\n    \n    ans = len(num)-2\n    n = len(num)\n    \n    for e in ends:\n        u, v = e[0], e[1]\n        \n        idx1 = n-1\n        while idx1 > 0 and num[idx1] != v:\n            idx1 -= 1\n        idx2 = idx1-1\n        while idx2 > 0 and num[idx2] != u:\n            idx2 -= 1\n        if idx1 > 0 and idx2 > 0:\n            ans = min(ans, n-2-idx2)\n        \n    return ans\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans\n\nimport math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter\n\nimport cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res"}, {"source": "mbpp-sanitized", "id": 172, "function_name": "count_occurance", "code": "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count", "distractor_code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0\n\ndef count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    o = -1\n    m = 0\n    for c in s:\n        if c == '1':\n            o += 1\n        else:\n            m += 1\n    \n    return '1' * o + '0' * m + '1'\n\ndef minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1"}, {"source": "mbpp-sanitized", "id": 222, "function_name": "check_type", "code": "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) ", "distractor_code": "def maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans\n\ndef finalString(s: str) -> str:\n    res = []\n    for c in s:\n        if c == 'i':\n            res = res[::-1]\n        else:\n            res.append(c)\n    return ''.join(res)\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    A = defaultdict(lambda:inf)\n    A[words[0][0]+words[0][-1]] = len(words[0]) \n    for w in words[1:]:\n        B = defaultdict(lambda:inf) \n        for a,x in A.items():\n            B[a[0]+w[-1]] = min(B[a[0]+w[-1]],x+len(w) - (a[-1]==w[0]) )\n            B[w[0]+a[-1]] = min(B[w[0]+a[-1]],x+len(w) - (w[-1]==a[0]) ) \n        A,B = B ,A \n    return min(A.values())"}, {"source": "mbpp-sanitized", "id": 223, "function_name": "is_majority", "code": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-i-1]))\n    if len(s) & 1:\n        ans = ans + [s[len(s) // 2]] + ans[::-1]\n    else:\n        ans = ans + ans[::-1]\n    return ''.join(ans)\n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)"}, {"source": "mbpp-sanitized", "id": 224, "function_name": "count_Set_Bits", "code": "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count ", "distractor_code": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n\ndef minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret"}, {"source": "mbpp-sanitized", "id": 226, "function_name": "odd_values_string", "code": "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result", "distractor_code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    ii = [0]\n    for i in range(n-1):\n        if s[i] == s[i+1]: ii.append(i+1)\n    if len(ii) < 3: return n\n    ii.append(n)\n    ans = 0\n    for l, r in zip(ii, ii[2:]): ans = max(ans, r-l)\n    return ans\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    res = []\n    arr = [0]*n\n    \n    curr = 0\n    \n    for i,v in queries:\n        pv = arr[i]\n        \n        if i+1 <n and arr[i+1]==v:\n            curr += 1\n        if i-1>=0 and arr[i-1] == v:\n            curr += 1\n        if i+1 <n and arr[i+1]==pv and pv:\n            curr -= 1\n        if i-1>=0 and arr[i-1] == pv and pv:\n            curr -= 1\n        arr[i] = v\n        \n        res += [curr]\n    return res\n\ndef minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l\n\ndef odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result"}, {"source": "mbpp-sanitized", "id": 227, "function_name": "min_of_three", "code": "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest ", "distractor_code": "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res\n\ndef minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))\n\ndef min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res"}, {"source": "mbpp-sanitized", "id": 228, "function_name": "all_Bits_Set_In_The_Given_Range", "code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\ndef solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + i\n    return dp\n    \n\ndef minimumCost(s: str) -> int:\n    l = solve(s)\n    r = solve(s[::-1])\n    n = len(s)\n    ans = min(l[i] + r[n - 1 - i] for i in range(n))\n    return ans\n\ndef isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef minimumIndex(nums: List[int]) -> int:\n    c = Counter(nums)\n    d = max((v, k) for k, v in c.items())[1]\n    n = len(nums)\n    l = 0\n    r = c[d] - (n - c[d])\n    \n    for i, num in enumerate(nums):\n        if num == d:\n            l += 1\n            r -= 1\n        else:\n            l -= 1\n            r += 1\n        if l > 0 and r > 0: return i\n    return -1"}, {"source": "mbpp-sanitized", "id": 229, "function_name": "re_arrange_array", "code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr", "distractor_code": "def ascii_value(k):\n  ch=k\n  return ord(ch)\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) \n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res"}, {"source": "mbpp-sanitized", "id": 230, "function_name": "replace_blank", "code": "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2", "distractor_code": "def sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    res = 0\n    vowels = \"aeiou\"\n    n = len(s)\n    for i in range(n):\n        numVowels, numCons = 0, 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                numVowels += 1\n            else:\n                numCons += 1\n            if numVowels == numCons and (numVowels * numCons) % k == 0:\n                res += 1\n    return res\n\ndef isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True"}, {"source": "mbpp-sanitized", "id": 234, "function_name": "volume_cube", "code": "def volume_cube(l):\n  volume = l * l * l\n  return volume", "distractor_code": "def volume_cube(l):\n  volume = l * l * l\n  return volume\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\ndef group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \n\ndef max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct"}, {"source": "mbpp-sanitized", "id": 235, "function_name": "even_bit_set_number", "code": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ", "distractor_code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])\n\ndef count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2\n\ndef even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \n\ndef minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)"}, {"source": "mbpp-sanitized", "id": 237, "function_name": "check_occurences", "code": "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) ", "distractor_code": "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    cnt = {}\n    s = 0\n    cnt[0]=1\n    ans = 0\n    for c in nums:\n        if c%modulo==k:\n            s+=1\n            s%=modulo\n        ns = s-k\n        if ns<0:\n            ns+=modulo\n        if ns in cnt:\n            ans+=cnt[ns]\n        if s not in cnt:\n            cnt[s]=0\n        cnt[s]+=1\n    return ans\n\ndef odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \n\ndef checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)"}, {"source": "mbpp-sanitized", "id": 238, "function_name": "number_of_substrings", "code": "def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); ", "distractor_code": "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres"}, {"source": "mbpp-sanitized", "id": 239, "function_name": "get_total_number_of_sequences", "code": "def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]"}, {"source": "mbpp-sanitized", "id": 240, "function_name": "replace_list", "code": "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n", "distractor_code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    cnt=0\n    ans=0\n    last=-1\n    c=Counter([0])\n    for x in nums:\n        if x%m==k:\n            cnt+=1\n        ans+=c[(cnt-k)%m]\n\n        \n        c[cnt%m]+=1\n\n        \n            # last=i\n        \n        \n    return ans\n\ndef isGood(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums) - 1\n    \n    res = True\n    for i in range(n):\n        if nums[i] != i+1: return False\n    \n    return nums[-1] == n\n\ndef replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    \n    nums.sort()\n    n = len(nums)\n    \n    ans = float('inf')\n    \n    for i in range(1,n):\n        gap = nums[i] - nums[i-1]\n        \n        ans = min(ans, gap)\n    \n    return ans"}, {"source": "mbpp-sanitized", "id": 242, "function_name": "count_charac", "code": "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total", "distractor_code": "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\n\ndef removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num\n\ndef count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\n\ndef maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res"}, {"source": "mbpp-sanitized", "id": 244, "function_name": "next_Perfect_Square", "code": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN ", "distractor_code": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \n\ndef convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\""}, {"source": "mbpp-sanitized", "id": 245, "function_name": "max_sum", "code": "def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum", "distractor_code": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef is_lower(string):\n  return (string.lower())\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    c = 0\n    for i in range(len(s)):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i]) - 1)\n            c = 1\n        else:\n            if c:\n                break\n    if not c:\n        s[-1] = 'z'\n    return \"\".join(s)\n\ndef max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum"}, {"source": "mbpp-sanitized", "id": 247, "function_name": "lps", "code": "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]", "distractor_code": "def isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans\n\ndef maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res\n\ndef remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2"}, {"source": "mbpp-sanitized", "id": 249, "function_name": "intersection_array", "code": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result", "distractor_code": "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result\n\ndef get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count \n\ndef intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\n\ndef removeTrailingZeros(num: str) -> str:\n    while num[-1] == '0':\n        num = num[:-1]\n    return num"}, {"source": "mbpp-sanitized", "id": 250, "function_name": "count_X", "code": "def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count ", "distractor_code": "from collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans\n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \n\nimport math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \n\ndef distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans"}, {"source": "mbpp-sanitized", "id": 251, "function_name": "insert_element", "code": "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list", "distractor_code": "def vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)\n\ndef insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\n\ndef minimumOperations(num: str) -> int:\n    n = len(num)\n    ans = n - num.count(\"0\")\n    \n    a = [\"00\", \"25\", \"75\", \"50\"]\n    \n    for x in a:\n        \n        i = 1\n        j = n-1\n        while j >= 0 and i >= 0:\n            if j >= 0 and num[j] == x[i]:\n                i -= 1\n                j -= 1\n            else:\n                j -= 1\n        if i >= 0: continue\n        ans = min(ans, n - (j+3))\n    return ans\n\ndef next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0"}, {"source": "mbpp-sanitized", "id": 252, "function_name": "convert", "code": "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) ", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")\n\ndef minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans\n\nimport cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) "}, {"source": "mbpp-sanitized", "id": 253, "function_name": "count_integer", "code": "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans\n\ndef minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr"}, {"source": "mbpp-sanitized", "id": 255, "function_name": "combinations_colors", "code": "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n", "distractor_code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1\n\nfrom itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    \n    maxres = 0\n    right = 0\n    for left in range(n):\n        while right < n and nums[right] <= nums[left] + 2*k:\n            right += 1\n            maxres = max(maxres, right - left)\n    return maxres\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans"}, {"source": "mbpp-sanitized", "id": 256, "function_name": "count_Primes_nums", "code": "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]\n\ndef count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr"}, {"source": "mbpp-sanitized", "id": 257, "function_name": "swap_numbers", "code": "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans\n\ndef swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\n\ndef odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result"}, {"source": "mbpp-sanitized", "id": 259, "function_name": "maximize_elements", "code": "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3\n\ndef list_split(S, step):\n    return [S[i::step] for i in range(step)]\n\ndef minimumSum(n: int, k: int) -> int:\n    seen = set()\n    x = 0\n    while len(seen) < n:\n        x += 1\n        if k-x not in seen:\n            seen.add(x)\n    \n    return sum(seen)\n\ndef sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) "}, {"source": "mbpp-sanitized", "id": 260, "function_name": "newman_prime", "code": "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)", "distractor_code": "def minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans\n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\nfrom typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum\n\ndef newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)"}, {"source": "mbpp-sanitized", "id": 261, "function_name": "division_elements", "code": "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n\ndef division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "}, {"source": "mbpp-sanitized", "id": 262, "function_name": "split_two_parts", "code": "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]", "distractor_code": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef split_two_parts(list1, L):\n    return list1[:L], list1[L:]\n\ndef minimumSum(nums: List[int]) -> int:\n    p = list(accumulate(nums, min))\n    s = list(accumulate(nums[::-1], min))[::-1]\n    m = inf\n    for i in range(1, len(nums)-1):\n        if p[i-1] < nums[i] and s[i+1] < nums[i]:\n            m = min(m, p[i-1] + nums[i] + s[i+1])\n    return -1 if m == inf else m\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 264, "function_name": "dog_age", "code": "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\"\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    f = [0] * (n + 1)\n    t = 0\n    for x, y, z in sorted(offers, key=lambda it: it[1]):\n        x += 1\n        y += 1\n        while t < y:\n            f[t + 1] = f[t]\n            t += 1\n        f[y] = max(f[x - 1] + z, f[y])\n\n    return max(f)\n\ndef dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\n\ndef max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) \n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True"}, {"source": "mbpp-sanitized", "id": 265, "function_name": "list_split", "code": "def list_split(S, step):\n    return [S[i::step] for i in range(step)]", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef list_split(S, step):\n    return [S[i::step] for i in range(step)]\n\ndef highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res "}, {"source": "mbpp-sanitized", "id": 266, "function_name": "lateralsurface_cube", "code": "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n    res = 0\n    m = max(nums[0], nums[1])\n    c = max(0, nums[0] - nums[1])\n    for i in range(2, len(nums)):\n        res = max(res, nums[i] * c)\n        c = max(c, m - nums[i])\n        m = max(m, nums[i])\n    return res\n\ndef longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans\n\ndef lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res"}, {"source": "mbpp-sanitized", "id": 267, "function_name": "square_Sum", "code": "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) ", "distractor_code": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)\n\ndef square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans"}, {"source": "mbpp-sanitized", "id": 268, "function_name": "find_star_num", "code": "def find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) ", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans\n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) "}, {"source": "mbpp-sanitized", "id": 269, "function_name": "ascii_value", "code": "def ascii_value(k):\n  ch=k\n  return ord(ch)", "distractor_code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    dp=[0]*105\n    for l,r in nums:\n        for i in range(l,r+1):dp[i]=1\n    return sum(dp)\n\ndef ascii_value(k):\n  ch=k\n  return ord(ch)\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = math.inf\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if nums[i] < nums[j] and nums[k] < nums[j]:\n                    ans = min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=math.inf else -1"}, {"source": "mbpp-sanitized", "id": 270, "function_name": "sum_even_and_even_index", "code": "def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum", "distractor_code": "def minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx\n\ndef sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans"}, {"source": "mbpp-sanitized", "id": 271, "function_name": "even_Power_Sum", "code": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; ", "distractor_code": "def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\n\ndef even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans\n\nfrom typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False\n\ndef finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans"}, {"source": "mbpp-sanitized", "id": 272, "function_name": "rear_extract", "code": "def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) ", "distractor_code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\nimport math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \n\ndef rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) "}, {"source": "mbpp-sanitized", "id": 273, "function_name": "substract_elements", "code": "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) ", "distractor_code": "import heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans\n\nfrom collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\n\ndef substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) "}, {"source": "mbpp-sanitized", "id": 274, "function_name": "even_binomial_Coeff_Sum", "code": "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) ", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet\n\nimport math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)"}, {"source": "mbpp-sanitized", "id": 277, "function_name": "dict_filter", "code": "def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result", "distractor_code": "def continuousSubarrays(A: List[int]) -> int:\n    count = Counter()\n    ans = i = 0\n    for j, x in enumerate(A):\n        count[x] += 1\n        while len(count) > 3 or max(count) - min(count) > 2:\n            y = A[i]\n            count[y] -= 1\n            if count[y] == 0:\n                del count[y]\n            i += 1\n        ans += j - i +1\n    return ans\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\ndef dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result"}, {"source": "mbpp-sanitized", "id": 278, "function_name": "count_first_elements", "code": "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) ", "distractor_code": "from typing import List\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    if sum(prices[:2]) <= money:\n        return money - sum(prices[:2])\n    else:\n        return money\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans\n\ndef count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) "}, {"source": "mbpp-sanitized", "id": 279, "function_name": "is_num_decagonal", "code": "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n ", "distractor_code": "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\n\ndef is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n\ndef minimumOperations(s: str) -> int:\n    # 删空\n    ans = len(s)\n    # 留 1\n    if s.count('0'):\n        ans = len(s) - 1\n    st = {'00', '25', '50', '75'}\n    for i, x in enumerate(s):\n        for y in s[i + 1:]:\n            # 00 25 50 75\n            if x + y in st:\n                ans = min(ans, len(s) - i - 2)\n    return ans\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False"}, {"source": "mbpp-sanitized", "id": 280, "function_name": "sequential_search", "code": "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos", "distractor_code": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n\ndef string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)"}, {"source": "mbpp-sanitized", "id": 281, "function_name": "all_unique", "code": "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True", "distractor_code": "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\ndef countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer"}, {"source": "mbpp-sanitized", "id": 282, "function_name": "sub_list", "code": "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)", "distractor_code": "def finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)"}, {"source": "mbpp-sanitized", "id": 283, "function_name": "validate", "code": "def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True", "distractor_code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list \n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2\n\ndef validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    a = s.count('1')\n    b = s.count('0')\n    \n    res = '1'*(a-1) + '0'*(b) + '1'\n    return res\n\ndef is_lower(string):\n  return (string.lower())"}, {"source": "mbpp-sanitized", "id": 284, "function_name": "check_element", "code": "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element", "distractor_code": "def smallestString(s: str) -> str:\n    n = len(s) \n    s = list(s)\n    i = 0 \n    while i < n and s[i] == 'a':\n        i += 1 \n    if i == n: \n        s[-1] = 'z'\n        return ''.join(s) \n    for i in range(i,n):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i])-1) \n        else : break \n    return ''.join(s)\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t\n\ndef get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]"}, {"source": "mbpp-sanitized", "id": 285, "function_name": "text_match_two_three", "code": "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False", "distractor_code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct\n\nimport re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))"}, {"source": "mbpp-sanitized", "id": 286, "function_name": "max_sub_array_sum_repeated", "code": "def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    ans = [float(\"inf\")]*(n+1)\n    \n    for i in range(n):\n        if i==0:\n            cost = prices[i]\n        else:\n            cost = ans[i-1]+prices[i]\n            \n        for j in range(i,min(n,i+i+1+1)):\n            ans[j] = min(ans[j],cost)\n    # print(ans)\n    return ans[n-1]\n\ndef comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums"}, {"source": "mbpp-sanitized", "id": 287, "function_name": "square_Sum", "code": "def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)", "distractor_code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)\n\ndef minimumIndex(nums: List[int]) -> int:\n    c = Counter(nums)\n    d = max((v, k) for k, v in c.items())[1]\n    n = len(nums)\n    l = 0\n    r = c[d] - (n - c[d])\n    \n    for i, num in enumerate(nums):\n        if num == d:\n            l += 1\n            r -= 1\n        else:\n            l -= 1\n            r += 1\n        if l > 0 and r > 0: return i\n    return -1\n\ndef countPairs(nums: List[int], t: int) -> int:\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<t:\n                res+=1\n    return res\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\n\ndef square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)"}, {"source": "mbpp-sanitized", "id": 290, "function_name": "max_length", "code": "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)", "distractor_code": "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    cntr = Counter(nums[:k])\n    cursum = sum(nums[:k])\n    \n    maxres = 0\n    if len(cntr) >= m:\n        maxres += cursum\n                   \n    for out, inp in zip(nums, nums[k:]):\n        cursum -= out\n        cursum += inp\n        cntr[out] -= 1\n        if cntr[out] == 0:\n            del cntr[out]\n        cntr[inp] += 1\n        if len(cntr) >= m:\n            maxres = max(maxres, cursum)\n    \n    return maxres"}, {"source": "mbpp-sanitized", "id": 291, "function_name": "count_no_of_ways", "code": "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    loc = set(nums)  # 初始有石块的位置\n    for i, j in zip(moveFrom, moveTo):\n        loc.remove(i)  # i不再是有石块的位置\n        loc.add(j)  # 不管之前有没有石块，j成为有石块的位置\n    return sorted(loc)\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef closest_num(N):\n  return (N - 1)\n\ndef validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans"}, {"source": "mbpp-sanitized", "id": 292, "function_name": "find", "code": "def find(n,m):  \n    q = n//m \n    return (q)", "distractor_code": "def find(n,m):  \n    q = n//m \n    return (q)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer"}, {"source": "mbpp-sanitized", "id": 293, "function_name": "otherside_rightangle", "code": "import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n\ndef dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans\n\nimport math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True"}, {"source": "mbpp-sanitized", "id": 294, "function_name": "max_val", "code": "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)", "distractor_code": "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n\ndef minAbsoluteDifference(nums: List[int], x: int) -> int:\n    st = []\n    ans = float('inf')\n    for i,c in enumerate(nums):\n        if i>=x:\n            bisect.insort(st,nums[i-x])\n            p = bisect.bisect_left(st,c) \n            if p>0:\n                ans = min(ans,c-st[p-1])\n            if p<len(st):\n                ans = min(ans,st[p]-c)\n    return ans\n\ndef max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) "}, {"source": "mbpp-sanitized", "id": 295, "function_name": "sum_div", "code": "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)", "distractor_code": "def minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]\n\ndef finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)\n\ndef sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)"}, {"source": "mbpp-sanitized", "id": 296, "function_name": "get_Inv_Count", "code": "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count ", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count \n\nfrom typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = [s1[0], s1[2]]\n    b = [s2[0], s2[2]]\n    a.sort()\n    b.sort()\n    if a != b:\n        return False\n    a = [s1[1], s1[3]]\n    b = [s2[1], s2[3]]\n    a.sort()\n    b.sort()\n    return a == b"}, {"source": "mbpp-sanitized", "id": 297, "function_name": "flatten_list", "code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list ", "distractor_code": "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list \n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(str(nums[i])[0])\n            b = int(str(nums[j])[-1])\n            if gcd(a, b) == 1:\n                ans += 1\n    return ans\n\ndef lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)"}, {"source": "mbpp-sanitized", "id": 299, "function_name": "max_aggregate", "code": "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\nfrom collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)"}, {"source": "mbpp-sanitized", "id": 301, "function_name": "dict_depth", "code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0", "distractor_code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n\ndef canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\nimport collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    f = [0] * (n + 1)\n    t = 0\n    for x, y, z in sorted(offers, key=lambda it: it[1]):\n        x += 1\n        y += 1\n        while t < y:\n            f[t + 1] = f[t]\n            t += 1\n        f[y] = max(f[x - 1] + z, f[y])\n\n    return max(f)\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a = nums.index(1)\n    b = nums.index(n)\n    \n    if a < b:\n        return a + n - 1 - b\n    else:\n        return a + n - 1 - b - 1"}, {"source": "mbpp-sanitized", "id": 304, "function_name": "find_Element", "code": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] ", "distractor_code": "def buyChoco(prices: List[int], money: int) -> int:\n    s = sum(sorted(prices)[:2])\n    return money-s if s<=money else money\n\ndef find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)"}, {"source": "mbpp-sanitized", "id": 305, "function_name": "start_withp", "code": "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()", "distractor_code": "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()\n\ndef rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans"}, {"source": "mbpp-sanitized", "id": 306, "function_name": "max_sum_increasing_subseq", "code": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res\n\ndef max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    @cache\n    def dp(idx):\n        if idx == n - 1:\n            return 0\n        res = -1\n        for i in range(idx + 1, n):\n            if abs(nums[i] - nums[idx]) <= target and dp(i) != -1:\n                res = max(res, 1 + dp(i))\n        return res\n    return dp(0)"}, {"source": "mbpp-sanitized", "id": 307, "function_name": "colon_tuplex", "code": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon", "distractor_code": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\n\ndef isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9\n\nfrom copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon"}, {"source": "mbpp-sanitized", "id": 308, "function_name": "large_product", "code": "def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result", "distractor_code": "def sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)\n\ndef large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n\ndef max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\n\ndef continuousSubarrays(A: List[int]) -> int:\n    count = Counter()\n    ans = i = 0\n    for j, x in enumerate(A):\n        count[x] += 1\n        while len(count) > 3 or max(count) - min(count) > 2:\n            y = A[i]\n            count[y] -= 1\n            if count[y] == 0:\n                del count[y]\n            i += 1\n        ans += j - i +1\n    return ans"}, {"source": "mbpp-sanitized", "id": 309, "function_name": "maximum", "code": "def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b ", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \n\nimport re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans"}, {"source": "mbpp-sanitized", "id": 310, "function_name": "string_to_tuple", "code": "def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]\n\ndef string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\n\ndef subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans"}, {"source": "mbpp-sanitized", "id": 311, "function_name": "set_left_most_unset_bit", "code": "def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) ", "distractor_code": "def beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\nfrom collections import Counter\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ctr = Counter(moves)\n    return abs(ctr['L'] - ctr['R']) + ctr['_']\n\ndef count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \n\ndef set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \n\ndef check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False"}, {"source": "mbpp-sanitized", "id": 388, "function_name": "highest_Power_of_2", "code": "def highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res ", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    n = len(s1)\n    m = len(s2)\n    k = len(s3)\n    ans = inf\n    for i in range(1, n+1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            x1 = n-i\n            x2 = m-i\n            x3 = k-i\n            cur = x1+x2+x3\n            if cur < ans:\n                ans = cur\n    return ans if ans < inf else -1\n\ndef count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr\n\ndef sortVowels(s: str) -> str:\n    ss = \"aeiouAEIOU\"\n    ans = []\n    qs = [c for c in s if c in ss]\n    qs.sort()\n    pos = 0\n    for c in s:\n        if c in ss:\n            ans.append(qs[pos])\n            pos += 1\n        else:\n            ans.append(c)\n    return \"\".join(ans)\n\ndef highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res "}, {"source": "mbpp-sanitized", "id": 389, "function_name": "find_lucas", "code": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ", "distractor_code": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\ndef find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\ndef sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum"}, {"source": "mbpp-sanitized", "id": 390, "function_name": "add_string", "code": "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    res = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx\n\ndef add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) "}, {"source": "mbpp-sanitized", "id": 391, "function_name": "convert_list_dictionary", "code": "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\ndef convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ans = 0 \n    \n    while mainTank >= 5:\n        mainTank -= 5 \n        if additionalTank:\n            additionalTank -=1 \n            mainTank += 1\n        ans += 5 \n    ans += mainTank\n    return 10 * ans\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i"}, {"source": "mbpp-sanitized", "id": 392, "function_name": "get_max_sum", "code": "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]", "distractor_code": "def minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)\n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]"}, {"source": "mbpp-sanitized", "id": 393, "function_name": "max_length_list", "code": "def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)", "distractor_code": "def longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    i = 1\n    arr = {1}\n    while len(arr) < n:\n        i += 1\n        if target - i not in arr:\n            arr.add(i)\n    return sum(arr)\n\nimport numpy\n\ndef countSubMultisets(nums: List[int], l: int, r: int) -> int:\n    record = numpy.zeros(r+1)\n    record[0] = 1\n    count = collections.Counter(nums)\n\n\n    for i in count:\n\n        tmp = numpy.copy(record)\n        if i != 0:\n            for k in range(1,count[i]+1):\n                tmp[i*k:] += record[:-i*k]\n        else:\n            tmp *= (count[i] + 1)\n\n        record = tmp\n        \n        record %= int(1e9+7)\n\n\n\n    return int(numpy.sum(record[l:r+1]) % int (1e9+7))\n\nfrom collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \n\ndef max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1"}, {"source": "mbpp-sanitized", "id": 394, "function_name": "check_distinct", "code": "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res ", "distractor_code": "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr"}, {"source": "mbpp-sanitized", "id": 395, "function_name": "first_non_repeating_character", "code": "def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None", "distractor_code": "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    d = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == d\n    return ans\n\ndef first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None"}, {"source": "mbpp-sanitized", "id": 396, "function_name": "check_char", "code": "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" ", "distractor_code": "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]\n\ndef rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \n\ndef sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans\n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums) \n    C = Counter(nums)\n    m = max(C.values()) \n\n    if n >= m * 2: return -1\n    x = 0\n    for t in C: \n        if C[t] == m: x = t \n    print(n,m,x)\n    c = 0 \n    for i,y in enumerate(nums):\n        c += y == x \n        if c * 2 > i + 1:\n            if (C[x]-c) * 2 > n - (i+1):\n                return i \n    return -1"}, {"source": "mbpp-sanitized", "id": 397, "function_name": "median_numbers", "code": "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median", "distractor_code": "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median\n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \n\nimport math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1"}, {"source": "mbpp-sanitized", "id": 398, "function_name": "sum_of_digits", "code": "def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())", "distractor_code": "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    N = len(s)\n    \n    left = 0\n    best = 1\n    count = 0\n    \n    for right in range(1, N):\n        if s[right] == s[right - 1]:\n            count += 1\n        while count > 1:\n            if s[left] == s[left + 1]:\n                count -= 1\n            left += 1\n            \n        best = max(best, right - left + 1)\n    return best\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)\n\ndef sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())"}, {"source": "mbpp-sanitized", "id": 399, "function_name": "bitwise_xor", "code": "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n\ndef bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            ans += min(i, len(s) - i)\n    return ans"}, {"source": "mbpp-sanitized", "id": 400, "function_name": "extract_freq", "code": "def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans"}, {"source": "mbpp-sanitized", "id": 401, "function_name": "add_nested_tuples", "code": "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\ndef add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef Find_Min(lst): \n    return min(lst, key=len) "}, {"source": "mbpp-sanitized", "id": 404, "function_name": "minimum", "code": "def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b ", "distractor_code": "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([x for x in hours if x >= target])\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    diff = [0]*(len(nums)+1)\n    curr = 0\n    for i in range(len(nums)):\n        curr += diff[i]\n        if curr > nums[i]:\n            return False\n        if nums[i] > curr:\n            if i+k >= len(nums)+1:\n                return False\n            diff[i+k] -= nums[i]-curr\n            curr = nums[i]\n    return True\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)"}, {"source": "mbpp-sanitized", "id": 405, "function_name": "check_tuplex", "code": "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False", "distractor_code": "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\ndef add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) \n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)"}, {"source": "mbpp-sanitized", "id": 406, "function_name": "find_Parity", "code": "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    a = [0 for _ in range(n + 1)]\n    def zero():\n        return 0\n    \n    for i in range(n):\n        if nums[i] % m == k:\n            a[i + 1] = 1\n    \n    for i in range(1, n + 1):\n        a[i] += a[i - 1] \n        \n    cnt_m = collections.defaultdict(zero)\n    ans = 0\n    for i in range(n + 1):\n        ans += cnt_m[(a[i] - k + m) % m]\n        cnt_m[a[i] % m] += 1\n    return ans\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\n\ndef minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1\n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            ans += min(i, len(s) - i)\n    return ans\n\ndef countPairs(nums: List[int], t: int) -> int:\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<t:\n                res+=1\n    return res"}, {"source": "mbpp-sanitized", "id": 407, "function_name": "rearrange_bigger", "code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False", "distractor_code": "def smallestString(s: str) -> str:\n    if s == \"a\"*len(s):\n        return \"a\"*(len(s)-1)+\"z\"\n    r = \"\"\n    p = 0\n    for i in s:\n        if p == 1:\n            if i == \"a\":\n                p = 2\n                r += i\n            else:\n                r += chr(ord(i)-1)\n        elif p == 0:\n            if i == \"a\":\n                r += i\n            else:\n                p = 1\n                r += chr(ord(i)-1)\n        else:\n            r += i\n    return r\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d = defaultdict(lambda : 0)\n    d[0] = 0\n    for i, v in enumerate(nums):\n        if v > target:\n            continue\n        tmp = defaultdict(lambda : 0)\n        tmp[0] = 0\n        for s in d:\n            if s + v > target:\n                continue\n            tmp[s + v] = max(tmp[s + v], d[s] + 1)\n        for s in tmp:\n            d[s] = max(d[s], tmp[s])\n    return d[target] if target in d else -1\n\ndef rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False"}, {"source": "mbpp-sanitized", "id": 408, "function_name": "k_smallest_pairs", "code": "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs", "distractor_code": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    st = []\n    ans = float('inf')\n    for i,c in enumerate(nums):\n        if i>=x:\n            bisect.insort(st,nums[i-x])\n            p = bisect.bisect_left(st,c) \n            if p>0:\n                ans = min(ans,c-st[p-1])\n            if p<len(st):\n                ans = min(ans,st[p]-c)\n    return ans\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\n\ndef accountBalanceAfterPurchase(p: int) -> int:\n    a, b = divmod(p, 10)\n    if b < 5:\n        return 100 - a * 10\n    else:\n        return 90 - a * 10\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))"}, {"source": "mbpp-sanitized", "id": 409, "function_name": "min_product_tuple", "code": "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min", "distractor_code": "def minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef minCost(A: List[int], x: int) -> int:\n    n = len(A)\n    mns = list(range(0, n * x, x))\n    for i in range(n):\n        mn = A[i]\n        for j in range(n):\n            mn = min(mn, A[(i+j)%n])\n            mns[j] += mn\n    return min(mns)"}, {"source": "mbpp-sanitized", "id": 410, "function_name": "min_val", "code": "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val", "distractor_code": "from typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a\n\ndef countSeniors(details: List[str]) -> int:\n    ans=0\n    for s in details:\n        if int(s[11:13])>60:\n            ans+=1\n    return ans\n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)\n\ndef all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val"}, {"source": "mbpp-sanitized", "id": 411, "function_name": "snake_to_camel", "code": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))", "distractor_code": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1\n\ndef is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) "}, {"source": "mbpp-sanitized", "id": 412, "function_name": "remove_odd", "code": "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l", "distractor_code": "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))"}, {"source": "mbpp-sanitized", "id": 413, "function_name": "extract_nth_element", "code": "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result", "distractor_code": "def longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\n\ndef extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result"}, {"source": "mbpp-sanitized", "id": 414, "function_name": "overlapping", "code": "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False", "distractor_code": "def minimumOperations(num: str) -> int:\n    min_ops = len(num)\n    for rem in map(list, ('00', '25', '50', '75')):\n        copy = list(num)\n        ops = 0\n        while copy and copy[-1] != rem[-1]:\n            copy.pop(-1)\n            ops += 1\n        while len(copy) >= 2 and copy[-2] != rem[-2]:\n            copy.pop(-2)\n            ops += 1\n        if copy[-2:] == rem:\n            min_ops = min(min_ops, ops)\n    if '0' in num:\n        min_ops = min(min_ops, len(num) - 1)\n    return min_ops\n\ndef odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\n\nimport cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n\ndef overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res"}, {"source": "mbpp-sanitized", "id": 415, "function_name": "max_Product", "code": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    ", "distractor_code": "def checkArray(nums: List[int], k: int) -> bool:\n    queue = deque()\n    for i in range(k):\n        queue.append(nums[i])\n        \n    curr = 0\n    for i in range(k, len(nums)):\n        if curr > queue[0]:\n            return False\n        \n        curr = queue.popleft()\n        queue.append(curr + nums[i])\n    \n    n = len(set(queue))\n    return n == 1\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    @cache\n    def dp(idx):\n        if idx == n - 1:\n            return 0\n        res = -1\n        for i in range(idx + 1, n):\n            if abs(nums[i] - nums[idx]) <= target and dp(i) != -1:\n                res = max(res, 1 + dp(i))\n        return res\n    return dp(0)\n\ndef max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\ndef check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1"}, {"source": "mbpp-sanitized", "id": 417, "function_name": "group_tuples", "code": "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] ", "distractor_code": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]\n\ndef group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct\n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1"}, {"source": "mbpp-sanitized", "id": 418, "function_name": "Find_Max", "code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) \n\ndef Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps"}, {"source": "mbpp-sanitized", "id": 419, "function_name": "round_and_sum", "code": "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum", "distractor_code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set(words)\n    ans = 0\n    for word in words:\n        if word != word[::-1] and word[::-1] in s:\n            ans += 1\n    return ans // 2\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    loc = set(nums)  # 初始有石块的位置\n    for i, j in zip(moveFrom, moveTo):\n        loc.remove(i)  # i不再是有石块的位置\n        loc.add(j)  # 不管之前有没有石块，j成为有石块的位置\n    return sorted(loc)\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set()\n    ans = 0\n    for w in words:\n        if w[::-1] in s:\n            ans += 1\n            s.remove(w[::-1])\n        else:\n            s.add(w)\n    return ans\n\ndef round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum"}, {"source": "mbpp-sanitized", "id": 420, "function_name": "cube_Sum", "code": "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum", "distractor_code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\ndef sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n\ndef maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet\n\ndef cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum"}, {"source": "mbpp-sanitized", "id": 421, "function_name": "concatenate_tuple", "code": "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) ", "distractor_code": "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef minimumIndex(nums: List[int]) -> int:\n    c = Counter(nums)\n    d = max((v, k) for k, v in c.items())[1]\n    n = len(nums)\n    l = 0\n    r = c[d] - (n - c[d])\n    \n    for i, num in enumerate(nums):\n        if num == d:\n            l += 1\n            r -= 1\n        else:\n            l -= 1\n            r += 1\n        if l > 0 and r > 0: return i\n    return -1\n\ndef isGood(nums: List[int]) -> bool:\n    if len(nums)==1:\n        return False\n    nums.sort()\n    n = len(nums)\n    if nums[-1] != nums[-2]:\n        return False\n    for i in range(n-1):\n        if nums[i] != i+1:\n            return False\n    return True"}, {"source": "mbpp-sanitized", "id": 422, "function_name": "find_Average_Of_Cube", "code": "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) ", "distractor_code": "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \n\ndef search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 424, "function_name": "extract_rear", "code": "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) ", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    answer = [None for i in range(n)]\n    vowels = []\n    v2 = []\n    for i in range(n):\n        if s[i] not in 'aeiouAEIOU':\n            answer[i] = s[i]\n        else:\n            vowels.append(s[i])\n            v2.append(i)\n    vowels = sorted(vowels, key=lambda a: ord(a))\n    m = len(vowels)\n    for i in range(m):\n        c, j = vowels[i], v2[i]\n        answer[j] = c\n    return ''.join(answer)\n\ndef extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) "}, {"source": "mbpp-sanitized", "id": 425, "function_name": "count_element_in_list", "code": "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for x in nums:\n        s.add(x)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(list(s))\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\n\ndef isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr"}, {"source": "mbpp-sanitized", "id": 426, "function_name": "filter_oddnumbers", "code": "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\n\ndef intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result"}, {"source": "mbpp-sanitized", "id": 427, "function_name": "change_date_format", "code": "import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\nimport re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)"}, {"source": "mbpp-sanitized", "id": 428, "function_name": "shell_sort", "code": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list", "distractor_code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    p = [[] for _ in range(n)]\n    for l, r, w in offers:\n        p[r].append((l, w))\n    dp = [0] * n\n    for i in range(n):\n        if i:\n            dp[i] = max(dp[i], dp[i - 1])\n        for l, w in p[i]:\n            dp[i] = max(dp[i], (dp[l - 1] if l else 0) + w)\n    return dp[-1]\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    d = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == d\n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False"}, {"source": "mbpp-sanitized", "id": 429, "function_name": "and_tuples", "code": "def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]\n\ndef even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) \n\ndef and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "}, {"source": "mbpp-sanitized", "id": 430, "function_name": "parabola_directrix", "code": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)\n\ndef large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\n\ndef minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef minimumSeconds(nums: List[int]) -> int:\n    d=defaultdict(list)\n    for i,el in enumerate(nums):\n        d[el].append(i)\n    ans=float(\"inf\")\n    def check(el):\n        t=d[el][:]\n        g=[t[0]+len(nums)-1-t[-1]]\n        for a,b in zip(t,t[1:]):\n            g.append(b-a-1)\n        # print(g,el)\n        p=max(g)\n        return (p+1)//2\n    for el in d:\n        ans=min(ans,check(el))\n    return ans"}, {"source": "mbpp-sanitized", "id": 431, "function_name": "common_element", "code": "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result", "distractor_code": "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited"}, {"source": "mbpp-sanitized", "id": 432, "function_name": "median_trapezium", "code": "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median", "distractor_code": "def continuousSubarrays(A: List[int]) -> int:\n    count = Counter()\n    ans = i = 0\n    for j, x in enumerate(A):\n        count[x] += 1\n        while len(count) > 3 or max(count) - min(count) > 2:\n            y = A[i]\n            count[y] -= 1\n            if count[y] == 0:\n                del count[y]\n            i += 1\n        ans += j - i +1\n    return ans\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans"}, {"source": "mbpp-sanitized", "id": 433, "function_name": "check_greater", "code": "def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]", "distractor_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\ndef check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef maxIncreasingGroups(x: List[int]) -> int:\n    x.sort()\n    n = len(x)\n    vals = list(accumulate(x))\n    ans = 0\n    for v in vals:\n        if (ans + 1) * (ans + 2) // 2 <= v:\n            ans += 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 434, "function_name": "text_match_one", "code": "import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n", "distractor_code": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\nimport re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); "}, {"source": "mbpp-sanitized", "id": 435, "function_name": "last_Digit", "code": "def last_Digit(n) :\n    return (n % 10) ", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef last_Digit(n) :\n    return (n % 10) \n\ndef validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True"}, {"source": "mbpp-sanitized", "id": 436, "function_name": "neg_nos", "code": "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out ", "distractor_code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]\n\ndef neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \n\ndef maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result"}, {"source": "mbpp-sanitized", "id": 437, "function_name": "remove_odd", "code": "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\ndef remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2"}, {"source": "mbpp-sanitized", "id": 438, "function_name": "count_bidirectional", "code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res", "distractor_code": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    a = s.count('1')\n    b = s.count('0')\n    \n    res = '1'*(a-1) + '0'*(b) + '1'\n    return res\n\ndef finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    i = 0\n    while nums[i] != 1:\n        i += 1\n    while i > 0:\n        nums[i - 1], nums[i] = nums[i], nums[i - 1]\n        i -= 1\n        ans += 1\n    assert nums[0] == 1\n    i = 0\n    while nums[i] != n:\n        i += 1\n    while i + 1 < n:\n        nums[i + 1], nums[i] = nums[i], nums[i + 1]\n        i += 1\n        ans += 1\n    assert nums[n - 1] == n\n    return ans\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1"}, {"source": "mbpp-sanitized", "id": 439, "function_name": "multiple_to_single", "code": "def multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x", "distractor_code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    beauty = \"\"\n    n = len(s)\n    min_len = None\n    for ln in range(k, n+1):\n        for i in range(n-ln+1):\n            ss = s[i:i+ln]\n            if len([c for c in ss if c == '1']) == k:\n                min_len = ln\n                if not beauty or ss < beauty:\n                    beauty = ss\n        if min_len:\n            break\n    return beauty\n\ndef check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x"}, {"source": "mbpp-sanitized", "id": 440, "function_name": "find_adverb_position", "code": "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))", "distractor_code": "def minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            ans += min(i, len(s) - i)\n    return ans\n\nimport math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None\n\nimport re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))"}, {"source": "mbpp-sanitized", "id": 441, "function_name": "surfacearea_cube", "code": "def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea", "distractor_code": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n\ndef minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea"}, {"source": "mbpp-sanitized", "id": 442, "function_name": "positive_count", "code": "from array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)", "distractor_code": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    le = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i,n):\n            s.add(nums[j])\n            if len(s) == le:\n                ans += n - j\n                break\n    return ans\n\nfrom array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans\n\nfrom typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False"}, {"source": "mbpp-sanitized", "id": 443, "function_name": "largest_neg", "code": "def largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max", "distractor_code": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n\nfrom operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)"}, {"source": "mbpp-sanitized", "id": 444, "function_name": "trim_tuple", "code": "def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) ", "distractor_code": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\n\ndef minLength(s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) > 1 and stack[-2] + stack[-1] in [\"AB\", \"CD\"]:\n            stack.pop()\n            stack.pop()\n            \n    return len(stack)\n\ndef canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0\n\ndef is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) \n\ndef trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) \n\nNO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) "}, {"source": "mbpp-sanitized", "id": 445, "function_name": "index_multiplication", "code": "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    res = float('inf')\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n        res = min(res, nums[i + 1] - nums[i])\n    return res\n\ndef sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\n\ndef index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; "}, {"source": "mbpp-sanitized", "id": 446, "function_name": "count_Occurrence", "code": "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  ", "distractor_code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    \n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    n1z = 0\n    n2z = 0\n    for num in nums1:\n        n1z += num == 0\n    for num in nums2:\n        n2z += num == 0\n    \n    if n2z == 0 and s1 + n1z > s2:\n        return -1\n    if n1z == 0 and s2 + n2z > s1:\n        return -1\n    \n    \n    return max(s1+n1z,s2+n2z)\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  "}, {"source": "mbpp-sanitized", "id": 447, "function_name": "cube_nums", "code": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums", "distractor_code": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum\n\nfrom collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])"}, {"source": "mbpp-sanitized", "id": 448, "function_name": "cal_sum", "code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum", "distractor_code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans\n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dp(i, first, last):\n        if i == n:\n            return 0\n        ans1 = dp(i + 1, first, words[i][-1]) - int(last == words[i][0])\n        ans2 = dp(i + 1, words[i][0], last) - int(words[i][-1] == first)\n        if ans1 > ans2:\n            return ans2 + len(words[i])\n        return ans1 + len(words[i])\n    return dp(1, words[0][0], words[0][-1]) + len(words[0])"}, {"source": "mbpp-sanitized", "id": 450, "function_name": "extract_string", "code": "def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result", "distractor_code": "def buyChoco(prices: List[int], money: int) -> int:\n    s = sum(sorted(prices)[:2])\n    return money-s if s<=money else money\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\ndef extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result"}, {"source": "mbpp-sanitized", "id": 451, "function_name": "remove_whitespaces", "code": "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\nimport sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    setn = len(set(nums))\n    to_ret = 0\n    for i in range(len(nums)) :\n        set_t = set()\n        for j in range(i, len(nums)) :\n            set_t.add(nums[j])\n            if len(set_t) == setn :\n                to_ret += 1\n    return to_ret\n\nimport re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1"}, {"source": "mbpp-sanitized", "id": 452, "function_name": "loss_amount", "code": "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0", "distractor_code": "def minimumRightShifts(nums: List[int]) -> int:\n    s = sorted(nums)\n    n = len(nums)\n    for i in range(n + 10):\n        t = [nums[-1]] + nums[:-1][:]\n        if s == t:\n            return (i + 1) % n\n        nums = t[:]\n        # print('t', t, nums)\n    else:\n        return -1\n\ndef loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\n\ndef maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)\n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count "}, {"source": "mbpp-sanitized", "id": 453, "function_name": "sumofFactors", "code": "import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res", "distractor_code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\nimport math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l"}, {"source": "mbpp-sanitized", "id": 455, "function_name": "check_monthnumb_number", "code": "def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False", "distractor_code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    \n    res = 1  # select all\n    \n    if nums.count(0) == 0:  # select none\n        res += 1\n    \n    for i,(x,y) in enumerate(zip(nums, nums[1:]), start=1):\n        if x < i < y:\n            # print(x,i,y)\n            res += 1\n            \n    # print()\n    \n    return res\n\ndef check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\n\ndef long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n\ndef is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True"}, {"source": "mbpp-sanitized", "id": 456, "function_name": "reverse_string_list", "code": "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result", "distractor_code": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1\n\ndef reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result"}, {"source": "mbpp-sanitized", "id": 457, "function_name": "Find_Min", "code": "def Find_Min(lst): \n    return min(lst, key=len) ", "distractor_code": "def smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1\n\ndef Find_Min(lst): \n    return min(lst, key=len) \n\ndef is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix"}, {"source": "mbpp-sanitized", "id": 458, "function_name": "rectangle_area", "code": "def rectangle_area(l,b):\n  area=l*b\n  return area", "distractor_code": "def minimumOperations(num: str) -> int:\n    min_ops = len(num)\n    for rem in map(list, ('00', '25', '50', '75')):\n        copy = list(num)\n        ops = 0\n        while copy and copy[-1] != rem[-1]:\n            copy.pop(-1)\n            ops += 1\n        while len(copy) >= 2 and copy[-2] != rem[-2]:\n            copy.pop(-2)\n            ops += 1\n        if copy[-2:] == rem:\n            min_ops = min(min_ops, ops)\n    if '0' in num:\n        min_ops = min(min_ops, len(num) - 1)\n    return min_ops\n\nimport math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) \n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)\n\ndef rectangle_area(l,b):\n  area=l*b\n  return area\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)"}, {"source": "mbpp-sanitized", "id": 459, "function_name": "remove_uppercase", "code": "import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)\n\ndef removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)\n\nimport re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)\n\ndef minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res"}, {"source": "mbpp-sanitized", "id": 460, "function_name": "Extract", "code": "def Extract(lst): \n    return [item[0] for item in lst] ", "distractor_code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\n\ndef Extract(lst): \n    return [item[0] for item in lst] \n\ndef find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count"}, {"source": "mbpp-sanitized", "id": 461, "function_name": "upper_ctr", "code": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr", "distractor_code": "def minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\ndef upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr"}, {"source": "mbpp-sanitized", "id": 462, "function_name": "combinations_list", "code": "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result", "distractor_code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans\n\ndef search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result"}, {"source": "mbpp-sanitized", "id": 463, "function_name": "max_subarray_product", "code": "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far", "distractor_code": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list \n\ndef countPairs(nums: List[int], target: int) -> int:\n    res = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far"}, {"source": "mbpp-sanitized", "id": 464, "function_name": "check_value", "code": "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result", "distractor_code": "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\n\ndef tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\n\ndef count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) "}, {"source": "mbpp-sanitized", "id": 465, "function_name": "drop_empty", "code": "def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\nimport collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\n\ndef minimumSeconds(nums: List[int]) -> int:\n    idxs, res = defaultdict(list), (len(nums))//2\n    for i, n in enumerate(nums): idxs[n].append(i)\n    for n in idxs:\n        idx = idxs[n]\n        if len(idx) != 1:\n            cur = (idx[0]+(len(nums)-idx[-1]))//2\n            for i in range(len(idx)-1): cur = max(cur, (idx[i+1]-idx[i])//2)\n            res = min(res, cur)\n    return res\n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2"}, {"source": "mbpp-sanitized", "id": 468, "function_name": "max_product", "code": "def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([t for t in hours if t >= target])\n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans"}, {"source": "mbpp-sanitized", "id": 470, "function_name": "add_pairwise", "code": "def add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ", "distractor_code": "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    \n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    n1z = 0\n    n2z = 0\n    for num in nums1:\n        n1z += num == 0\n    for num in nums2:\n        n2z += num == 0\n    \n    if n2z == 0 and s1 + n1z > s2:\n        return -1\n    if n1z == 0 and s2 + n2z > s1:\n        return -1\n    \n    \n    return max(s1+n1z,s2+n2z)\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) "}, {"source": "mbpp-sanitized", "id": 471, "function_name": "find_remainder", "code": "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)\n\ndef find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n "}, {"source": "mbpp-sanitized", "id": 472, "function_name": "check_Consecutive", "code": "def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) ", "distractor_code": "def smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) "}, {"source": "mbpp-sanitized", "id": 473, "function_name": "tuple_intersection", "code": "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)", "distractor_code": "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)"}, {"source": "mbpp-sanitized", "id": 474, "function_name": "replace_char", "code": "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2", "distractor_code": "def distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res\n\nfrom collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\n\ndef isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot"}, {"source": "mbpp-sanitized", "id": 475, "function_name": "sort_counter", "code": "from collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter", "distractor_code": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1\n\nimport re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\n\ndef max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)"}, {"source": "mbpp-sanitized", "id": 476, "function_name": "big_sum", "code": "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n =len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n\n    return ans\n\ndef isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            \n            if nums[j] != nums[i] + ((j - i) & 1):\n                break\n            \n            ans = max(ans, j - i + 1)\n    return ans\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum"}, {"source": "mbpp-sanitized", "id": 477, "function_name": "is_lower", "code": "def is_lower(string):\n  return (string.lower())", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss\n\ndef is_lower(string):\n  return (string.lower())"}, {"source": "mbpp-sanitized", "id": 478, "function_name": "remove_lowercase", "code": "import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans\n\ndef dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result\n\nimport heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans\n\nimport re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)"}, {"source": "mbpp-sanitized", "id": 479, "function_name": "first_Digit", "code": "def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) ", "distractor_code": "def isGood(a: List[int]) -> bool:\n    \n    n = len(a) - 1\n    for i in range(1, n):\n        if a.count(i) != 1:\n            return False\n    \n    return a.count(n) == 2\n\ndef first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) \n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res"}, {"source": "livecodebench-execution", "id": "sample_0", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]", "distractor_code": "def distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]\n\ndef minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans\n\nimport math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) "}, {"source": "livecodebench-execution", "id": "sample_1", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans", "distractor_code": "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" \n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) "}, {"source": "livecodebench-execution", "id": "sample_2", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1\n\ndef neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]"}, {"source": "livecodebench-execution", "id": "sample_3", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans", "distractor_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            ans += chk(nums[j], nums[i])\n    return ans\n\ndef chk(n1, n2):\n    return int(gcd(int(str(n1)[0]), int(str(n2)[-1])) == 1)\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False\n\ndef maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_4", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans\n\nimport heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    cnt = defaultdict(int)\n    ans = 0\n    c = 0\n    s = 0\n    for r,x in enumerate(nums):\n        cnt[x] += 1\n        if cnt[x] == 1: c += 1\n        s += x\n        if r >= k:\n            y = nums[r-k]\n            cnt[y] -= 1\n            if cnt[y] == 0: c -= 1\n            s -= y\n        if c >= m: ans = max(ans,s)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_5", "function_name": "distinctDifferenceArray", "code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:(i + 1)])) - len(set(nums[(i + 1):])) for i in range(len(nums))]", "distractor_code": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count \n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:(i + 1)])) - len(set(nums[(i + 1):])) for i in range(len(nums))]"}, {"source": "livecodebench-execution", "id": "sample_6", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    res = []\n    arr = [0]*n\n    \n    curr = 0\n    \n    for i,v in queries:\n        pv = arr[i]\n        \n        if i+1 <n and arr[i+1]==v:\n            curr += 1\n        if i-1>=0 and arr[i-1] == v:\n            curr += 1\n        if i+1 <n and arr[i+1]==pv and pv:\n            curr -= 1\n        if i-1>=0 and arr[i-1] == pv and pv:\n            curr -= 1\n        arr[i] = v\n        \n        res += [curr]\n    return res", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    res = []\n    arr = [0]*n\n    \n    curr = 0\n    \n    for i,v in queries:\n        pv = arr[i]\n        \n        if i+1 <n and arr[i+1]==v:\n            curr += 1\n        if i-1>=0 and arr[i-1] == v:\n            curr += 1\n        if i+1 <n and arr[i+1]==pv and pv:\n            curr -= 1\n        if i-1>=0 and arr[i-1] == pv and pv:\n            curr -= 1\n        arr[i] = v\n        \n        res += [curr]\n    return res\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])"}, {"source": "livecodebench-execution", "id": "sample_7", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    ret = 0\n    a = [0] * n\n    ans = []\n    for x, y in queries:\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret -= 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret -= 1\n        a[x] = y\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret += 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret += 1\n        ans.append(ret)\n    return ans", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    ret = 0\n    a = [0] * n\n    ans = []\n    for x, y in queries:\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret -= 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret -= 1\n        a[x] = y\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret += 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret += 1\n        ans.append(ret)\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]\n\ndef minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)\n\ndef distributeCandies(n: int, limit: int) -> int:\n    res = comb(n + 2, 2)\n    if n >= limit + 1:\n        res -= 3 * comb(n - limit + 1, 2)\n    if n >= 2 * limit + 2:\n        res += 3 * comb(n - 2 * limit, 2)\n    if n >= 3 * (limit + 1):\n        res -= comb(n - 3 * limit - 1, 2)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_8", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans", "distractor_code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = math.inf\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if nums[i] < nums[j] and nums[k] < nums[j]:\n                    ans = min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=math.inf else -1\n\ndef longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_9", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res", "distractor_code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    res = 0\n    deq = deque()\n    for n in nums:\n        deq.append(n)\n        while deq[0] < n - 2 * k:\n            deq.popleft()\n        res = max(res, len(deq))\n    return res\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    mod = 1000000007\n    n = len(nums)\n    last = -1\n    ans = 1\n    for i in range(n):\n        if nums[i]:\n            if last != -1:\n                ans = ans * (i - last) % mod\n            last = i\n    return ans if last != -1 else 0\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_10", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    mod = 1000000007\n    n = len(nums)\n    last = -1\n    ans = 1\n    for i in range(n):\n        if nums[i]:\n            if last != -1:\n                ans = ans * (i - last) % mod\n            last = i\n    return ans if last != -1 else 0\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    ret = 0\n    a = [0] * n\n    ans = []\n    for x, y in queries:\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret -= 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret -= 1\n        a[x] = y\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret += 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret += 1\n        ans.append(ret)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_11", "function_name": "colorTheArray", "code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    color = [0] * (n + 1)\n    ans = 0\n    out = []\n    for i, x in queries:\n        if color[i] == color[i-1] and color[i] != 0:\n            ans -= 1\n        if color[i] == color[i+1] and color[i] != 0:\n            ans -= 1\n        \n        color[i] = x\n        \n        if color[i] == color[i-1]:\n            ans += 1\n        if color[i] == color[i+1]:\n            ans += 1\n            \n        out.append(ans)\n    return out", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    color = [0] * (n + 1)\n    ans = 0\n    out = []\n    for i, x in queries:\n        if color[i] == color[i-1] and color[i] != 0:\n            ans -= 1\n        if color[i] == color[i+1] and color[i] != 0:\n            ans -= 1\n        \n        color[i] = x\n        \n        if color[i] == color[i-1]:\n            ans += 1\n        if color[i] == color[i+1]:\n            ans += 1\n            \n        out.append(ans)\n    return out\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s"}, {"source": "livecodebench-execution", "id": "sample_12", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False", "distractor_code": "def continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1"}, {"source": "livecodebench-execution", "id": "sample_13", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]", "distractor_code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    n =len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n\n    return ans\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)\n\nfrom typing import *\n\nfrom math import *\n\n\ndef makeTheIntegerZero(a: int, b: int) -> int:\n    for i in range(1, 1000):\n        a -= b\n        if a >= i and bin(a)[2:].count('1') <= i:\n            return i\n    return -1\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if s1 == s2 == s3:\n        return 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i] != s2[i] or s1[i] != s3[i]:\n            break\n    else:\n        i += 1\n    if i < 1:\n        return -1\n    else:\n        return len(s1) - i + (len(s2) - i) + (len(s3) - i)"}, {"source": "livecodebench-execution", "id": "sample_14", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False", "distractor_code": "from collections import defaultdict\ndef minimumIndex(nums: List[int]) -> int:\n    dct = defaultdict(int)\n    for i in nums:\n        dct[i] += 1\n        if dct[i]*2>len(nums):dom = i\n    other = defaultdict(int)\n    upto = 0\n    for i in nums[:-1]:\n        other[i] += 1\n        dct[i] -= 1\n        upto += 1\n        la = len(nums)-upto\n        if other[dom]*2>upto and dct[dom]*2>la:return upto-1\n    return -1\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False\n\ndef Find_Min(lst): \n    return min(lst, key=len) "}, {"source": "livecodebench-execution", "id": "sample_15", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False", "distractor_code": "def minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)"}, {"source": "livecodebench-execution", "id": "sample_16", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1\n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = []\n    s = 0\n    cur = 1\n    st = set()\n    while len(ans)<n:\n        while k-cur in st:\n            cur+=1\n        ans.append(cur)\n        st.add(cur)\n        s+=cur\n        cur+=1\n    return s\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )"}, {"source": "livecodebench-execution", "id": "sample_17", "function_name": "doesValidArrayExist", "code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    if n == 1:\n        return derived[0] == 0\n    ans = 0\n    for i in range(n - 1):\n        ans ^= derived[i]\n    return ans == derived[-1]", "distractor_code": "from typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    if n == 1:\n        return derived[0] == 0\n    ans = 0\n    for i in range(n - 1):\n        ans ^= derived[i]\n    return ans == derived[-1]\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_18", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)", "distractor_code": "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\n\ndef minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]"}, {"source": "livecodebench-execution", "id": "sample_19", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    while 'AB' in s or 'CD' in s:\n        s = s.replace('AB', '').replace('CD', '')\n    return len(s)", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res\n\nfrom collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\ndef minLength(s: str) -> int:\n    while 'AB' in s or 'CD' in s:\n        s = s.replace('AB', '').replace('CD', '')\n    return len(s)"}, {"source": "livecodebench-execution", "id": "sample_20", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    \n    while 1:\n        n = len(s)\n        if n < 2:\n            break\n        for i in range(n - 1):\n            if s[i:i + 2] == \"AB\" or s[i:i + 2] == \"CD\":\n                s = s[:i] + s[i + 2:]\n                break\n        else:\n            break\n    \n    return len(s)", "distractor_code": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) \n\ndef count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef minLength(s: str) -> int:\n    \n    while 1:\n        n = len(s)\n        if n < 2:\n            break\n        for i in range(n - 1):\n            if s[i:i + 2] == \"AB\" or s[i:i + 2] == \"CD\":\n                s = s[:i] + s[i + 2:]\n                break\n        else:\n            break\n    \n    return len(s)"}, {"source": "livecodebench-execution", "id": "sample_21", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans\n\ndef minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if s1 == s2 == s3:\n        return 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i] != s2[i] or s1[i] != s3[i]:\n            break\n    else:\n        i += 1\n    if i < 1:\n        return -1\n    else:\n        return len(s1) - i + (len(s2) - i) + (len(s3) - i)\n\nfrom copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_22", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) > 1 and stack[-2] + stack[-1] in [\"AB\", \"CD\"]:\n            stack.pop()\n            stack.pop()\n            \n    return len(stack)", "distractor_code": "def sortVowels(s: str) -> str:\n    ss = \"aeiouAEIOU\"\n    ans = []\n    qs = [c for c in s if c in ss]\n    qs.sort()\n    pos = 0\n    for c in s:\n        if c in ss:\n            ans.append(qs[pos])\n            pos += 1\n        else:\n            ans.append(c)\n    return \"\".join(ans)\n\ndef maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans\n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef minOperations(a: List[int], b: List[int]) -> int:\n    def f():\n        ret = 0\n        aa, bb = a[:], b[:]\n        for i in range(len(a)):\n            if a[i] > a[-1] or b[i] > b[-1]:\n                a[i], b[i] = b[i], a[i]\n                ret += 1\n            if a[i] > a[-1] or b[i] > b[-1]:\n                return inf\n        a[:] = aa\n        b[:] = bb\n        return ret\n    \n    ans = f()\n    a[-1], b[-1] = b[-1], a[-1]\n    ans = min(ans, f() + 1)\n    return -1 if ans > len(a) else ans\n\ndef minLength(s: str) -> int:\n    stack = []\n    for c in s:\n        stack.append(c)\n        if len(stack) > 1 and stack[-2] + stack[-1] in [\"AB\", \"CD\"]:\n            stack.pop()\n            stack.pop()\n            \n    return len(stack)"}, {"source": "livecodebench-execution", "id": "sample_23", "function_name": "minLength", "code": "def minLength(s: str) -> int:\n    while True:\n        t=s.replace(\"AB\",\"\").replace(\"CD\",\"\")\n        if t==s:\n            return len(t)\n        else:\n            s=t", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n\ndef minLength(s: str) -> int:\n    while True:\n        t=s.replace(\"AB\",\"\").replace(\"CD\",\"\")\n        if t==s:\n            return len(t)\n        else:\n            s=t\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_24", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-i-1]))\n    if len(s) & 1:\n        ans = ans + [s[len(s) // 2]] + ans[::-1]\n    else:\n        ans = ans + ans[::-1]\n    return ''.join(ans)", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    d = defaultdict(int)\n    for x in nums:\n        d[x] += 1\n    for x,y in zip(moveFrom,moveTo):\n        tmp = d[x]\n        d[x]-=tmp\n        d[y]+=tmp\n    return [x for x in sorted(d) if d[x]>0]\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-i-1]))\n    if len(s) & 1:\n        ans = ans + [s[len(s) // 2]] + ans[::-1]\n    else:\n        ans = ans + ans[::-1]\n    return ''.join(ans)"}, {"source": "livecodebench-execution", "id": "sample_25", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        c1, c2 = s[left], s[right]\n        if c1 != c2:\n            s[left] = min(c1, c2)\n            s[right] = s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\nimport collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        c1, c2 = s[left], s[right]\n        if c1 != c2:\n            s[left] = min(c1, c2)\n            s[right] = s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]"}, {"source": "livecodebench-execution", "id": "sample_26", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res\n\ndef string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l\n\ndef maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret"}, {"source": "livecodebench-execution", "id": "sample_27", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)", "distractor_code": "def minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\ndef cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\n\ndef makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)\n\nfrom typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2"}, {"source": "livecodebench-execution", "id": "sample_28", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n\ndef countSeniors(details: List[str]) -> int:\n    ans=0\n    for s in details:\n        if int(s[11:13])>60:\n            ans+=1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    n = len(nums)\n    ans = 0\n    # 都选\n    ans += n > nums[0]\n    \n    # 都不选\n    ans += 0 < nums[-1]\n    \n    for i in range(n - 1):\n        # 前面都不选，后面都选\n        v = n - 1 - i\n        ans += v < nums[i] and v > nums[i + 1]\n    \n    return ans\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0"}, {"source": "livecodebench-execution", "id": "sample_29", "function_name": "makeSmallestPalindrome", "code": "def makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_30", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num", "distractor_code": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\ndef removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num\n\ndef minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base"}, {"source": "livecodebench-execution", "id": "sample_31", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)", "distractor_code": "def minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result\n\ndef even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)\n\ndef buyChoco(a: List[int], money: int) -> int:\n    a.sort()\n    if a[0] + a[1] > money:\n        return money\n    return money - a[0] - a[1]"}, {"source": "livecodebench-execution", "id": "sample_32", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(num: str) -> str:\n    while num[-1] == '0':\n        num = num[:-1]\n    return num", "distractor_code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n\ndef smallestString(s: str) -> str:\n    n = len(s) \n    s = list(s)\n    i = 0 \n    while i < n and s[i] == 'a':\n        i += 1 \n    if i == n: \n        s[-1] = 'z'\n        return ''.join(s) \n    for i in range(i,n):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i])-1) \n        else : break \n    return ''.join(s)\n\ndef removeTrailingZeros(num: str) -> str:\n    while num[-1] == '0':\n        num = num[:-1]\n    return num\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer"}, {"source": "livecodebench-execution", "id": "sample_33", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"", "distractor_code": "def matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea\n\ndef solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + i\n    return dp\n    \n\ndef minimumCost(s: str) -> int:\n    l = solve(s)\n    r = solve(s[::-1])\n    n = len(s)\n    ans = min(l[i] + r[n - 1 - i] for i in range(n))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_34", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]", "distractor_code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\ndef sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans\n\nimport heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)"}, {"source": "livecodebench-execution", "id": "sample_35", "function_name": "removeTrailingZeros", "code": "def removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")", "distractor_code": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN \n\ndef removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_36", "function_name": "minimumCost", "code": "def minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i - 1] != s[i]:\n            ans += min(i, len(s) - i)\n    \n    return ans", "distractor_code": "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]\n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i - 1] != s[i]:\n            ans += min(i, len(s) - i)\n    \n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]"}, {"source": "livecodebench-execution", "id": "sample_37", "function_name": "minimumCost", "code": "def solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + i\n    return dp\n    \n\ndef minimumCost(s: str) -> int:\n    l = solve(s)\n    r = solve(s[::-1])\n    n = len(s)\n    ans = min(l[i] + r[n - 1 - i] for i in range(n))\n    return ans", "distractor_code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\nfrom collections import Counter\n\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    for k, v in Counter(nums).items():\n        if v == 1:\n            return -1\n        r = v % 3\n        if r == 0:\n            ans += v // 3\n        elif r == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef minOperations(nums: List[int]) -> int:\n  c = {}\n  for x in nums:\n    c[x] = c.get(x, 0) + 1\n  ret = 0\n  for x in c.values():\n    if x < 2:\n      return -1\n    if x % 3 == 0:\n      ret += x // 3\n    elif x % 3 == 1:\n      ret += 2 + (x - 4) // 3\n    else:\n      ret += 1 + (x - 2) // 3\n  return ret\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\n\ndef solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + i\n    return dp\n    \n\ndef minimumCost(s: str) -> int:\n    l = solve(s)\n    r = solve(s[::-1])\n    n = len(s)\n    ans = min(l[i] + r[n - 1 - i] for i in range(n))\n    return ans\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    if (s1.count('1') + s2.count('1')) % 2 == 1:\n        return -1\n    \n    mask = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]\n    \n    @lru_cache\n    def dp(down):\n        if not down:\n            return 0\n        if len(down) == 1:\n            return x\n        \n        return min(2 * (down[1] - down[0]) + dp(tuple(down[2:])), x + dp(tuple(down[1:])))\n        \n    # print(mask, dp(tuple(mask)))\n    return dp(tuple(mask)) // 2"}, {"source": "livecodebench-execution", "id": "sample_38", "function_name": "minimumCost", "code": "def minimumCost(s: str) -> int:\n    n = len(s)\n    left = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        left[i] = tmp\n    s = s[::-1]\n    right = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        right[i] = tmp\n    right.reverse()\n    return min(x + y for x, y in zip(left, right))", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    left = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        left[i] = tmp\n    s = s[::-1]\n    right = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        right[i] = tmp\n    right.reverse()\n    return min(x + y for x, y in zip(left, right))\n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_39", "function_name": "minimumCost", "code": "def minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            ans += min(i, len(s) - i)\n    return ans", "distractor_code": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    d = defaultdict(list)\n    for i, a in enumerate(nums):\n        d[a].append(i)\n    for l in d.values():\n        cnt = 0\n        j = 0\n        for i in range(len(l)):\n            if i:\n                cnt += l[i] - l[i-1] - 1\n            while cnt > k:\n                cnt -= l[j+1] - l[j] - 1\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result\n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            ans += min(i, len(s) - i)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_40", "function_name": "minimumCost", "code": "def minimumCost(s: str) -> int:\n    ans = 0\n    n = len(s)\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            ans += min(i, n - i)\n    return ans", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)\n\ndef findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans\n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    n = len(s)\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            ans += min(i, n - i)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_41", "function_name": "minimumCost", "code": "def minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r", "distractor_code": "def buyChoco(a: List[int], money: int) -> int:\n    a.sort()\n    if a[0] + a[1] > money:\n        return money\n    return money - a[0] - a[1]\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    n = len(nums)\n    A = sorted(list(Counter(nums).values()))\n    \n    x = A[0]\n    @lru_cache(None)\n    def dp(y,x):\n        if y == 0:\n            return 0\n        if y < x:\n            return math.inf\n        if y==x or y == x+1:\n            return 1\n        return 1+min(dp(y-x,x),dp(y-x-1,x))\n    \n    while x:\n        ans = sum(dp(y,x) for y in A)\n        if ans < math.inf:\n            return ans\n        x=x-1\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far"}, {"source": "livecodebench-execution", "id": "sample_42", "function_name": "minimizedStringLength", "code": "def minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)", "distractor_code": "def minLength(s: str) -> int:\n    while True:\n        t=s.replace(\"AB\",\"\").replace(\"CD\",\"\")\n        if t==s:\n            return len(t)\n        else:\n            s=t\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_43", "function_name": "minimizedStringLength", "code": "def minimizedStringLength(s: str) -> int:\n    graph = collections.defaultdict(int)\n    \n    for char in s:\n        graph[char] += 1\n    \n    return len(graph)", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef minimizedStringLength(s: str) -> int:\n    graph = collections.defaultdict(int)\n    \n    for char in s:\n        graph[char] += 1\n    \n    return len(graph)"}, {"source": "livecodebench-execution", "id": "sample_44", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a, b = -1, -1\n    for i, v in enumerate(nums):\n        if v == 1: a = i \n        if v == n: b = i\n    delta = 0\n    if a > b:\n        delta = 1\n    return a+n-1-b-delta", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a, b = -1, -1\n    for i, v in enumerate(nums):\n        if v == 1: a = i \n        if v == n: b = i\n    delta = 0\n    if a > b:\n        delta = 1\n    return a+n-1-b-delta\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s"}, {"source": "livecodebench-execution", "id": "sample_45", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a,b = nums.index(1),nums.index(len(nums))\n    if a<b:return a+(n-b-1)\n    else:return a+(n-b-1)-1\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    if (s1.count('1') + s2.count('1')) % 2 == 1:\n        return -1\n    \n    mask = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]\n    \n    @lru_cache\n    def dp(down):\n        if not down:\n            return 0\n        if len(down) == 1:\n            return x\n        \n        return min(2 * (down[1] - down[0]) + dp(tuple(down[2:])), x + dp(tuple(down[1:])))\n        \n    # print(mask, dp(tuple(mask)))\n    return dp(tuple(mask)) // 2"}, {"source": "livecodebench-execution", "id": "sample_46", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a = nums.index(1)\n    b = nums.index(n)\n    \n    if a < b:\n        return a + n - 1 - b\n    else:\n        return a + n - 1 - b - 1", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    dp=[0]*105\n    for l,r in nums:\n        for i in range(l,r+1):dp[i]=1\n    return sum(dp)\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a = nums.index(1)\n    b = nums.index(n)\n    \n    if a < b:\n        return a + n - 1 - b\n    else:\n        return a + n - 1 - b - 1\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]"}, {"source": "livecodebench-execution", "id": "sample_47", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2\n\ndef maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r"}, {"source": "livecodebench-execution", "id": "sample_48", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    i = 0\n    while nums[i] != 1:\n        i += 1\n    while i > 0:\n        nums[i - 1], nums[i] = nums[i], nums[i - 1]\n        i -= 1\n        ans += 1\n    assert nums[0] == 1\n    i = 0\n    while nums[i] != n:\n        i += 1\n    while i + 1 < n:\n        nums[i + 1], nums[i] = nums[i], nums[i + 1]\n        i += 1\n        ans += 1\n    assert nums[n - 1] == n\n    return ans", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    i = 0\n    while nums[i] != 1:\n        i += 1\n    while i > 0:\n        nums[i - 1], nums[i] = nums[i], nums[i - 1]\n        i -= 1\n        ans += 1\n    assert nums[0] == 1\n    i = 0\n    while nums[i] != n:\n        i += 1\n    while i + 1 < n:\n        nums[i + 1], nums[i] = nums[i], nums[i + 1]\n        i += 1\n        ans += 1\n    assert nums[n - 1] == n\n    return ans\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_49", "function_name": "semiOrderedPermutation", "code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans", "distractor_code": "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)\n\ndef upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_50", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    if s == \"a\"*len(s):\n        return \"a\"*(len(s)-1)+\"z\"\n    r = \"\"\n    p = 0\n    for i in s:\n        if p == 1:\n            if i == \"a\":\n                p = 2\n                r += i\n            else:\n                r += chr(ord(i)-1)\n        elif p == 0:\n            if i == \"a\":\n                r += i\n            else:\n                p = 1\n                r += chr(ord(i)-1)\n        else:\n            r += i\n    return r", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres\n\nfrom typing import *\n\nfrom math import *\n\n\ndef isFascinating(n: int) -> bool:\n    x = str(n) + str(2 * n) + str(3 * n)\n    return len(set(x)) == 9 and len(x) == 9 and '0' not in x\n\ndef longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans\n\ndef findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\ndef smallestString(s: str) -> str:\n    if s == \"a\"*len(s):\n        return \"a\"*(len(s)-1)+\"z\"\n    r = \"\"\n    p = 0\n    for i in s:\n        if p == 1:\n            if i == \"a\":\n                p = 2\n                r += i\n            else:\n                r += chr(ord(i)-1)\n        elif p == 0:\n            if i == \"a\":\n                r += i\n            else:\n                p = 1\n                r += chr(ord(i)-1)\n        else:\n            r += i\n    return r"}, {"source": "livecodebench-execution", "id": "sample_51", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    if s == 'a': return 'z'\n    t = list(s)\n    l = r = -1\n    for i, c in enumerate(s):\n        if c != 'a':\n            if l == -1:\n                l = i\n            r = i\n        elif l != -1:\n            break\n    if l != -1:\n        for i in range(l, r + 1):\n            t[i] = chr(ord(t[i]) - 1)\n    else:\n        t[-1] = 'z'\n    return ''.join(t)", "distractor_code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set(words)\n    ans = 0\n    for word in words:\n        if word != word[::-1] and word[::-1] in s:\n            ans += 1\n    return ans // 2\n\ndef smallestString(s: str) -> str:\n    if s == 'a': return 'z'\n    t = list(s)\n    l = r = -1\n    for i, c in enumerate(s):\n        if c != 'a':\n            if l == -1:\n                l = i\n            r = i\n        elif l != -1:\n            break\n    if l != -1:\n        for i in range(l, r + 1):\n            t[i] = chr(ord(t[i]) - 1)\n    else:\n        t[-1] = 'z'\n    return ''.join(t)\n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\ndef newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())"}, {"source": "livecodebench-execution", "id": "sample_52", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)", "distractor_code": "def minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans\n\ndef smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    a = [0 for _ in range(n + 1)]\n    def zero():\n        return 0\n    \n    for i in range(n):\n        if nums[i] % m == k:\n            a[i + 1] = 1\n    \n    for i in range(1, n + 1):\n        a[i] += a[i - 1] \n        \n    cnt_m = collections.defaultdict(zero)\n    ans = 0\n    for i in range(n + 1):\n        ans += cnt_m[(a[i] - k + m) % m]\n        cnt_m[a[i] % m] += 1\n    return ans\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_53", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)", "distractor_code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for l, r in nums:\n        s |= set(range(l, r + 1))\n        \n    return (len(s))\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)\n\ndef list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    def check(m1, m2):\n        ans = 0\n        for x1, x2 in zip(nums1, nums2):\n            if x1 > m1 or x2 > m2:\n                if x2 > m1 or x1 > m2:\n                    return inf\n                ans += 1\n        return ans\n    m1 = nums1[-1]\n    m2 = nums2[-1]\n    ans = min(check(m1, m2), check(m2, m1))\n    return -1 if ans == inf else ans"}, {"source": "livecodebench-execution", "id": "sample_54", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    n = len(s) \n    s = list(s)\n    i = 0 \n    while i < n and s[i] == 'a':\n        i += 1 \n    if i == n: \n        s[-1] = 'z'\n        return ''.join(s) \n    for i in range(i,n):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i])-1) \n        else : break \n    return ''.join(s)", "distractor_code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\n\ndef minLength(s: str) -> int:\n    \n    while 1:\n        n = len(s)\n        if n < 2:\n            break\n        for i in range(n - 1):\n            if s[i:i + 2] == \"AB\" or s[i:i + 2] == \"CD\":\n                s = s[:i] + s[i + 2:]\n                break\n        else:\n            break\n    \n    return len(s)\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = ''\n    for w in words:\n        t += w[0]\n    return t == s\n\ndef smallestString(s: str) -> str:\n    n = len(s) \n    s = list(s)\n    i = 0 \n    while i < n and s[i] == 'a':\n        i += 1 \n    if i == n: \n        s[-1] = 'z'\n        return ''.join(s) \n    for i in range(i,n):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i])-1) \n        else : break \n    return ''.join(s)\n\nfrom typing import *\n\nfrom math import *\n\n\ndef makeTheIntegerZero(a: int, b: int) -> int:\n    for i in range(1, 1000):\n        a -= b\n        if a >= i and bin(a)[2:].count('1') <= i:\n            return i\n    return -1\n\ndef minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_55", "function_name": "smallestString", "code": "def smallestString(s: str) -> str:\n    s = list(s)\n    c = 0\n    for i in range(len(s)):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i]) - 1)\n            c = 1\n        else:\n            if c:\n                break\n    if not c:\n        s[-1] = 'z'\n    return \"\".join(s)", "distractor_code": "from typing import List\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    if sum(prices[:2]) <= money:\n        return money - sum(prices[:2])\n    else:\n        return money\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    c = 0\n    for i in range(len(s)):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i]) - 1)\n            c = 1\n        else:\n            if c:\n                break\n    if not c:\n        s[-1] = 'z'\n    return \"\".join(s)\n\ndef find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]"}, {"source": "livecodebench-execution", "id": "sample_56", "function_name": "minCost", "code": "def minCost(A: List[int], x: int) -> int:\n    n = len(A)\n    mns = list(range(0, n * x, x))\n    for i in range(n):\n        mn = A[i]\n        for j in range(n):\n            mn = min(mn, A[(i+j)%n])\n            mns[j] += mn\n    return min(mns)", "distractor_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef minCost(A: List[int], x: int) -> int:\n    n = len(A)\n    mns = list(range(0, n * x, x))\n    for i in range(n):\n        mn = A[i]\n        for j in range(n):\n            mn = min(mn, A[(i+j)%n])\n            mns[j] += mn\n    return min(mns)\n\ndef square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_57", "function_name": "distanceTraveled", "code": "def distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp=[-1]*(target+1)\n    dp[0]=0\n    for a in nums:\n        for i in range(target-a,-1,-1):\n            if dp[i]==-1:continue\n            dp[i+a]=max(dp[i+a],dp[i]+1)\n    return dp[-1]\n\ndef distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res"}, {"source": "livecodebench-execution", "id": "sample_58", "function_name": "distanceTraveled", "code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10", "distractor_code": "def maxSum(nums: List[int]) -> int:\n    dc = defaultdict(list)\n    for v in nums:\n        dc[max([int(c) for c in str(v)])].append(v)\n    res = -1\n    for d in range(10):\n        lst = dc[d]\n        if len(lst) >= 2:\n            res = max(res, sum(sorted(lst)[-2:]))\n    return res\n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) \n\ndef matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10"}, {"source": "livecodebench-execution", "id": "sample_59", "function_name": "distanceTraveled", "code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    res = 0\n    while mainTank > 0:\n        if mainTank >= 5:\n            mainTank -= 5\n            res += 50\n            if additionalTank:\n                additionalTank -= 1\n                mainTank += 1            \n        else:\n            res += mainTank * 10\n            mainTank = 0\n    return res", "distractor_code": "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    res = 0\n    while mainTank > 0:\n        if mainTank >= 5:\n            mainTank -= 5\n            res += 50\n            if additionalTank:\n                additionalTank -= 1\n                mainTank += 1            \n        else:\n            res += mainTank * 10\n            mainTank = 0\n    return res\n\ndef findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_60", "function_name": "distanceTraveled", "code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ex = min ((mainTank - 1) // 4, additionalTank)\n    \n    return (ex + mainTank) * 10", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ex = min ((mainTank - 1) // 4, additionalTank)\n    \n    return (ex + mainTank) * 10\n\ndef find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_61", "function_name": "distanceTraveled", "code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ans = 0 \n    \n    while mainTank >= 5:\n        mainTank -= 5 \n        if additionalTank:\n            additionalTank -=1 \n            mainTank += 1\n        ans += 5 \n    ans += mainTank\n    return 10 * ans", "distractor_code": "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ans = 0 \n    \n    while mainTank >= 5:\n        mainTank -= 5 \n        if additionalTank:\n            additionalTank -=1 \n            mainTank += 1\n        ans += 5 \n    ans += mainTank\n    return 10 * ans\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    res = []\n    arr = [0]*n\n    \n    curr = 0\n    \n    for i,v in queries:\n        pv = arr[i]\n        \n        if i+1 <n and arr[i+1]==v:\n            curr += 1\n        if i-1>=0 and arr[i-1] == v:\n            curr += 1\n        if i+1 <n and arr[i+1]==pv and pv:\n            curr -= 1\n        if i-1>=0 and arr[i-1] == pv and pv:\n            curr -= 1\n        arr[i] = v\n        \n        res += [curr]\n    return res"}, {"source": "livecodebench-execution", "id": "sample_62", "function_name": "distanceTraveled", "code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res", "distractor_code": "def vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    dp=[0]*105\n    for l,r in nums:\n        for i in range(l,r+1):dp[i]=1\n    return sum(dp)\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res"}, {"source": "livecodebench-execution", "id": "sample_63", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    \n    return min(y - x for x, y in zip(nums, nums[1:]))", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    \n    return min(y - x for x, y in zip(nums, nums[1:]))\n\ndef kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n\nfrom collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans\n\ndef minimumSum(n: int, k: int) -> int:\n    arr = []\n    st = set()\n    now = 1\n    while len(arr) < n:\n        if (k - now) not in st:\n            st.add(now)\n            arr.append(now)\n        \n        now += 1\n    return sum(arr)"}, {"source": "livecodebench-execution", "id": "sample_64", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(nums: List[int]) -> int:\n    \n    nums.sort()\n    n = len(nums)\n    \n    ans = float('inf')\n    \n    for i in range(1,n):\n        gap = nums[i] - nums[i-1]\n        \n        ans = min(ans, gap)\n    \n    return ans", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    \n    nums.sort()\n    n = len(nums)\n    \n    ans = float('inf')\n    \n    for i in range(1,n):\n        gap = nums[i] - nums[i-1]\n        \n        ans = min(ans, gap)\n    \n    return ans\n\ndef max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n\n    def is_champ(i):\n        for j in range(n):\n            if j == i:\n                continue\n            if grid[i][j] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        if is_champ(i):\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_65", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans", "distractor_code": "def findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans\n\ndef vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)"}, {"source": "livecodebench-execution", "id": "sample_66", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    res = 10 ** 10\n    # 枚举最大的\n    for i in range(len(nums) - 1, 0, -1):\n        # 最大的是 nums[i]\n        # 最小的是 nums[i-1]\n        res = min(res, nums[i] - nums[i - 1])\n    return res", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef isGood(nums: List[int]) -> bool:\n    if len(nums)==1:\n        return False\n    nums.sort()\n    n = len(nums)\n    if nums[-1] != nums[-2]:\n        return False\n    for i in range(n-1):\n        if nums[i] != i+1:\n            return False\n    return True\n\ndef sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    ans = [-1]\n    for i in range(len(s)-1):\n        if s[i+1] == s[i]: ans.append(i)\n    ans.append(len(s)-1)\n    if len(ans) == 2: return len(s)\n    return max(ans[i+2]-ans[i] for i in range(len(ans)-2))\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    res = 10 ** 10\n    # 枚举最大的\n    for i in range(len(nums) - 1, 0, -1):\n        # 最大的是 nums[i]\n        # 最小的是 nums[i-1]\n        res = min(res, nums[i] - nums[i - 1])\n    return res"}, {"source": "livecodebench-execution", "id": "sample_67", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret", "distractor_code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret"}, {"source": "livecodebench-execution", "id": "sample_68", "function_name": "findValueOfPartition", "code": "def findValueOfPartition(nums: List[int]) -> int:\n    res = float('inf')\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n        res = min(res, nums[i + 1] - nums[i])\n    return res", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    res = float('inf')\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n        res = min(res, nums[i + 1] - nums[i])\n    return res\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)\n\nfrom copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    p = [[] for _ in range(n)]\n    for l, r, w in offers:\n        p[r].append((l, w))\n    dp = [0] * n\n    for i in range(n):\n        if i:\n            dp[i] = max(dp[i], dp[i - 1])\n        for l, w in p[i]:\n            dp[i] = max(dp[i], (dp[l - 1] if l else 0) + w)\n    return dp[-1]"}, {"source": "livecodebench-execution", "id": "sample_69", "function_name": "countBeautifulPairs", "code": "from math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct", "distractor_code": "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) \n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct"}, {"source": "livecodebench-execution", "id": "sample_70", "function_name": "countBeautifulPairs", "code": "def countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            ans += chk(nums[j], nums[i])\n    return ans\n\ndef chk(n1, n2):\n    return int(gcd(int(str(n1)[0]), int(str(n2)[-1])) == 1)\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    ans = [-1]\n    for i in range(len(s)-1):\n        if s[i+1] == s[i]: ans.append(i)\n    ans.append(len(s)-1)\n    if len(ans) == 2: return len(s)\n    return max(ans[i+2]-ans[i] for i in range(len(ans)-2))\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            ans += chk(nums[j], nums[i])\n    return ans\n\ndef chk(n1, n2):\n    return int(gcd(int(str(n1)[0]), int(str(n2)[-1])) == 1)\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)\n\ndef countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far"}, {"source": "livecodebench-execution", "id": "sample_71", "function_name": "countBeautifulPairs", "code": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(str(nums[i])[0])\n            b = int(str(nums[j])[-1])\n            if gcd(a, b) == 1:\n                ans += 1\n    return ans", "distractor_code": "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(str(nums[i])[0])\n            b = int(str(nums[j])[-1])\n            if gcd(a, b) == 1:\n                ans += 1\n    return ans\n\ndef odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count \n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res"}, {"source": "livecodebench-execution", "id": "sample_72", "function_name": "countBeautifulPairs", "code": "def countBeautifulPairs(nums: List[int]) -> int:\n    res=0\n    n=len(nums)\n    for i in range(n):\n        for j in range(i+1,n):\n            a=int(str(nums[i])[0])\n            b=int(str(nums[j])[-1])\n            if gcd(a,b)==1:\n                res+=1\n    return res", "distractor_code": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    res=0\n    n=len(nums)\n    for i in range(n):\n        for j in range(i+1,n):\n            a=int(str(nums[i])[0])\n            b=int(str(nums[j])[-1])\n            if gcd(a,b)==1:\n                res+=1\n    return res\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] != -1 and abs(nums[j] - nums[i]) <= target:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[n - 1]"}, {"source": "livecodebench-execution", "id": "sample_73", "function_name": "countBeautifulPairs", "code": "def countBeautifulPairs(nums: List[int]) -> int:\n    a = []\n    b = []\n    for x in nums:\n        s = str(x)\n        a.append(int(s[0]))\n        b.append(int(s[-1]))\n    n = len(a)\n    return sum(gcd(a[i], b[j]) == 1 for i in range(n) for j in range(i+1, n))", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\ndef square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    a = []\n    b = []\n    for x in nums:\n        s = str(x)\n        a.append(int(s[0]))\n        b.append(int(s[-1]))\n    n = len(a)\n    return sum(gcd(a[i], b[j]) == 1 for i in range(n) for j in range(i+1, n))\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''"}, {"source": "livecodebench-execution", "id": "sample_74", "function_name": "countBeautifulPairs", "code": "def countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if gcd(int(str(nums[i])[0]), int(str(nums[j])[-1])) == 1:\n                ans += 1\n    return ans", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\nfrom typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if gcd(int(str(nums[i])[0]), int(str(nums[j])[-1])) == 1:\n                ans += 1\n    return ans\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    o = s.count('1')\n    z = len(s)-o\n    return '1'*(o-1)+'0'*z+'1'"}, {"source": "livecodebench-execution", "id": "sample_75", "function_name": "makeTheIntegerZero", "code": "from typing import *\n\nfrom math import *\n\n\ndef makeTheIntegerZero(a: int, b: int) -> int:\n    for i in range(1, 1000):\n        a -= b\n        if a >= i and bin(a)[2:].count('1') <= i:\n            return i\n    return -1", "distractor_code": "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    o = s.count('1')\n    z = len(s)-o\n    return '1'*(o-1)+'0'*z+'1'\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    n=len(nums)\n    d=0\n    for i in range(n):\n        if nums[i]%2!=0 or nums[i]>t: continue\n        d=max(d,1)\n        for j in range(i+1,n):\n            if nums[j]>t: break\n            if nums[j]%2==nums[j-1]%2: break\n            d=max(d,j-i+1)\n    return d\n\nfrom typing import *\n\nfrom math import *\n\n\ndef makeTheIntegerZero(a: int, b: int) -> int:\n    for i in range(1, 1000):\n        a -= b\n        if a >= i and bin(a)[2:].count('1') <= i:\n            return i\n    return -1\n\ndef maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet"}, {"source": "livecodebench-execution", "id": "sample_76", "function_name": "makeTheIntegerZero", "code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False\n\ndef recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total\n\ndef makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_77", "function_name": "makeTheIntegerZero", "code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]\n\ndef finalString(s: str) -> str:\n    res = []\n    for c in s:\n        if c == 'i':\n            res = res[::-1]\n        else:\n            res.append(c)\n    return ''.join(res)\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter"}, {"source": "livecodebench-execution", "id": "sample_78", "function_name": "makeTheIntegerZero", "code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    def check(x):\n        num = num1 - x * num2\n        if num <= 0:\n            return False\n        k = 0\n        while num:\n            if num & 1:\n                k += 1\n            num >>= 1\n        # print(num, x, k)\n        return x >= k and num1 - x * num2 >= x\n    \n    for i in range(1, 100):\n        if check(i):\n            return i\n    return -1", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    def check(x):\n        num = num1 - x * num2\n        if num <= 0:\n            return False\n        k = 0\n        while num:\n            if num & 1:\n                k += 1\n            num >>= 1\n        # print(num, x, k)\n        return x >= k and num1 - x * num2 >= x\n    \n    for i in range(1, 100):\n        if check(i):\n            return i\n    return -1\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans\n\ndef minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])\n\ndef minOperations(nums: List[int], k: int) -> int:\n    have = set()\n    for i, n in enumerate(reversed(nums)): \n        if n <= k: have.add(n)\n        if len(have) == k: return i+1"}, {"source": "livecodebench-execution", "id": "sample_79", "function_name": "makeTheIntegerZero", "code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1", "distractor_code": "def minOperations(nums: List[int], k: int) -> int:\n    have = set()\n    for i, n in enumerate(reversed(nums)): \n        if n <= k: have.add(n)\n        if len(have) == k: return i+1\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot\n\ndef amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1\n\ndef find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) "}, {"source": "livecodebench-execution", "id": "sample_80", "function_name": "makeTheIntegerZero", "code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1\n\ndef sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        check = True\n        for j in range(n - i + 1, n * 2 - i):\n            if nums[j % n] < nums[(j - 1) % n]:\n                check = False\n                break\n        if check: return i\n    return -1\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum"}, {"source": "livecodebench-execution", "id": "sample_81", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res", "distractor_code": "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    setn = len(set(nums))\n    to_ret = 0\n    for i in range(len(nums)) :\n        set_t = set()\n        for j in range(i, len(nums)) :\n            set_t.add(nums[j])\n            if len(set_t) == setn :\n                to_ret += 1\n    return to_ret\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        curr = set()\n        for j in range(i, n):\n            curr.add(nums[j])\n            k = len(curr)\n            ans += k * k\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_82", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    indexs = []\n    Mod = 10**9 + 7\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            indexs.append(i)\n    if len(indexs) == 0:\n        return 0\n    ans = 1\n    for i in range(1,len(indexs)):\n        ans *= (indexs[i] - indexs[i-1])\n        ans %= Mod\n    return ans", "distractor_code": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    indexs = []\n    Mod = 10**9 + 7\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            indexs.append(i)\n    if len(indexs) == 0:\n        return 0\n    ans = 1\n    for i in range(1,len(indexs)):\n        ans *= (indexs[i] - indexs[i-1])\n        ans %= Mod\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\nfrom collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n\ndef countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_83", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans", "distractor_code": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_84", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base\n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums) \n    C = Counter(nums)\n    m = max(C.values()) \n\n    if n >= m * 2: return -1\n    x = 0\n    for t in C: \n        if C[t] == m: x = t \n    print(n,m,x)\n    c = 0 \n    for i,y in enumerate(nums):\n        c += y == x \n        if c * 2 > i + 1:\n            if (C[x]-c) * 2 > n - (i+1):\n                return i \n    return -1\n\ndef removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef isAcronym(words: List[str], s: str) -> bool:\n    \n    return s == \"\".join([w[0] for w in words])"}, {"source": "livecodebench-execution", "id": "sample_85", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if 1 not in nums:\n        return 0\n    \n    MOD = 10 ** 9 + 7\n    ans = 1\n    ones = [i for i in range(len(nums)) if nums[i] == 1]\n    \n    for i in range(1, len(ones)):\n        ans = (ans * (ones[i] - ones[i - 1])) % MOD\n    \n    return ans", "distractor_code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef distributeCandies(n: int, limit: int) -> int:\n  c = 0\n  for i in range(limit + 1):\n    for j in range(limit + 1):\n      for k in range(limit + 1):\n        if i + j + k == n:\n          c += 1\n  return c\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if 1 not in nums:\n        return 0\n    \n    MOD = 10 ** 9 + 7\n    ans = 1\n    ones = [i for i in range(len(nums)) if nums[i] == 1]\n    \n    for i in range(1, len(ones)):\n        ans = (ans * (ones[i] - ones[i - 1])) % MOD\n    \n    return ans\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret"}, {"source": "livecodebench-execution", "id": "sample_86", "function_name": "numberOfGoodSubarraySplits", "code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    mod = 1000000007\n    n = len(nums)\n    last = -1\n    ans = 1\n    for i in range(n):\n        if nums[i]:\n            if last != -1:\n                ans = ans * (i - last) % mod\n            last = i\n    return ans if last != -1 else 0", "distractor_code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    ans = n = len(nums)\n    i, j = n // 2 - 1, n - 1\n    while i >= 0:\n        while i >= 0 and nums[i] == nums[j]:\n            i -= 1\n        if i >= 0:\n            ans -= 2\n            j -= 1\n            i -= 1\n    return ans\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    mod = 1000000007\n    n = len(nums)\n    last = -1\n    ans = 1\n    for i in range(n):\n        if nums[i]:\n            if last != -1:\n                ans = ans * (i - last) % mod\n            last = i\n    return ans if last != -1 else 0\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\"\n\ndef finalString(s: str) -> str:\n    stk = []\n    for i in s:\n        if i =='i':\n            stk.reverse()\n        else:\n            stk.append(i)\n    return \"\".join(stk)"}, {"source": "livecodebench-execution", "id": "sample_87", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    n=len(nums)\n    d=0\n    for i in range(n):\n        if nums[i]%2!=0 or nums[i]>t: continue\n        d=max(d,1)\n        for j in range(i+1,n):\n            if nums[j]>t: break\n            if nums[j]%2==nums[j-1]%2: break\n            d=max(d,j-i+1)\n    return d", "distractor_code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans\n\ndef decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    n=len(nums)\n    d=0\n    for i in range(n):\n        if nums[i]%2!=0 or nums[i]>t: continue\n        d=max(d,1)\n        for j in range(i+1,n):\n            if nums[j]>t: break\n            if nums[j]%2==nums[j-1]%2: break\n            d=max(d,j-i+1)\n    return d\n\nfrom collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) "}, {"source": "livecodebench-execution", "id": "sample_88", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n  c = 0\n  for i in range(limit + 1):\n    for j in range(limit + 1):\n      for k in range(limit + 1):\n        if i + j + k == n:\n          c += 1\n  return c\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_89", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx", "distractor_code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx\n\ndef isGood(a: List[int]) -> bool:\n    \n    n = len(a) - 1\n    for i in range(1, n):\n        if a.count(i) != 1:\n            return False\n    \n    return a.count(n) == 2\n\ndef cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums"}, {"source": "livecodebench-execution", "id": "sample_90", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0", "distractor_code": "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    res = 10 ** 10\n    # 枚举最大的\n    for i in range(len(nums) - 1, 0, -1):\n        # 最大的是 nums[i]\n        # 最小的是 nums[i-1]\n        res = min(res, nums[i] - nums[i - 1])\n    return res\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0"}, {"source": "livecodebench-execution", "id": "sample_91", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans", "distractor_code": "def matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))\n\ndef max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_92", "function_name": "longestAlternatingSubarray", "code": "def longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)", "distractor_code": "def longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n\ndef is_lower(string):\n  return (string.lower())\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)\n\ndef minimumSeconds(nums: List[int]) -> int:\n    idxs, res = defaultdict(list), (len(nums))//2\n    for i, n in enumerate(nums): idxs[n].append(i)\n    for n in idxs:\n        idx = idxs[n]\n        if len(idx) != 1:\n            cur = (idx[0]+(len(nums)-idx[-1]))//2\n            for i in range(len(idx)-1): cur = max(cur, (idx[i+1]-idx[i])//2)\n            res = min(res, cur)\n    return res\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    \n    def cal(i):\n        if i=='z':\n            return 'a'\n        return chr(ord(i)+1)\n    \n    n1 = len(str1)\n    n2 = len(str2)\n    \n    i = 0\n    j = 0\n    \n    while i<n1 and j<n2:\n        if str1[i]==str2[j] or cal(str1[i])==str2[j]:\n            i+=1\n            j+=1\n        else:\n            i+=1\n    \n    return j>=n2"}, {"source": "livecodebench-execution", "id": "sample_93", "function_name": "continuousSubarrays", "code": "def continuousSubarrays(A: List[int]) -> int:\n    res = i = 0\n    n = len(A)\n    count = Counter()\n    for j in range(n):\n        count[A[j]] += 1\n        while max(count) - min(count) > 2:\n            count[A[i]] -= 1\n            if count[A[i]] == 0:\n                del count[A[i]]\n            i += 1\n        res += j - i + 1\n    return res", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for i in words:\n        for j in i.split(separator):\n            if j:\n                ans.append(j)\n    return ans\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])\n\ndef continuousSubarrays(A: List[int]) -> int:\n    res = i = 0\n    n = len(A)\n    count = Counter()\n    for j in range(n):\n        count[A[j]] += 1\n        while max(count) - min(count) > 2:\n            count[A[i]] -= 1\n            if count[A[i]] == 0:\n                del count[A[i]]\n            i += 1\n        res += j - i + 1\n    return res\n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_94", "function_name": "continuousSubarrays", "code": "def continuousSubarrays(a: List[int]) -> int:\n    h = Counter()\n    mo = deque([])\n    ans = 0\n    for i in a:\n        mo.append(i)\n        h[i] += 1\n        while h[i-2]+h[i-1]+h[i]+h[i+1]+h[i+2] != len(mo):\n            h[mo.popleft()] -= 1\n        ans += len(mo)\n    return ans", "distractor_code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef continuousSubarrays(a: List[int]) -> int:\n    h = Counter()\n    mo = deque([])\n    ans = 0\n    for i in a:\n        mo.append(i)\n        h[i] += 1\n        while h[i-2]+h[i-1]+h[i]+h[i+1]+h[i+2] != len(mo):\n            h[mo.popleft()] -= 1\n        ans += len(mo)\n    return ans\n\ndef sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   "}, {"source": "livecodebench-execution", "id": "sample_95", "function_name": "continuousSubarrays", "code": "def continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans", "distractor_code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr"}, {"source": "livecodebench-execution", "id": "sample_96", "function_name": "continuousSubarrays", "code": "def continuousSubarrays(A: List[int]) -> int:\n    count = Counter()\n    ans = i = 0\n    for j, x in enumerate(A):\n        count[x] += 1\n        while len(count) > 3 or max(count) - min(count) > 2:\n            y = A[i]\n            count[y] -= 1\n            if count[y] == 0:\n                del count[y]\n            i += 1\n        ans += j - i +1\n    return ans", "distractor_code": "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n\ndef filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums)<target:return -1\n    cnt=[0]*32\n    for a in nums:\n        l=a.bit_length()-1\n        cnt[l]+=1\n    ans=0\n    for k in range(31):\n        if target>>k&1:\n            i=k\n            while cnt[i]==0:i+=1\n            while i>k:\n                cnt[i]-=1\n                cnt[i-1]+=2\n                ans+=1\n                i-=1\n            cnt[k]-=1\n        cnt[k+1]+=cnt[k]//2\n    return ans\n\ndef continuousSubarrays(A: List[int]) -> int:\n    count = Counter()\n    ans = i = 0\n    for j, x in enumerate(A):\n        count[x] += 1\n        while len(count) > 3 or max(count) - min(count) > 2:\n            y = A[i]\n            count[y] -= 1\n            if count[y] == 0:\n                del count[y]\n            i += 1\n        ans += j - i +1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_97", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    dp = [-1]*len(nums)\n    dp[0] = 0\n    for i in range(1,len(nums)):\n        for j in range(i):\n            if dp[j] > -1 and -target <= nums[j]-nums[i] <= target:\n                dp[i] = dp[i] if dp[i] >= dp[j]+1 else dp[j]+1\n    return dp[-1]\n\ndef is_Diff(n): \n    return (n % 11 == 0) \n\ndef min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest "}, {"source": "livecodebench-execution", "id": "sample_98", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]", "distractor_code": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <3:\n        return True\n    for i,v in enumerate(nums):\n        if i+1 >= len(nums):\n            continue\n        if v + nums[i+1] >= m:\n            return True\n    return False\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_99", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    res = comb(n + 2, 2)\n    if n >= limit + 1:\n        res -= 3 * comb(n - limit + 1, 2)\n    if n >= 2 * limit + 2:\n        res += 3 * comb(n - 2 * limit, 2)\n    if n >= 3 * (limit + 1):\n        res -= comb(n - 3 * limit - 1, 2)\n    return res\n\ndef find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\nfrom typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a"}, {"source": "livecodebench-execution", "id": "sample_100", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] != -1 and abs(nums[j] - nums[i]) <= target:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[n - 1]", "distractor_code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    x = Counter(nums).values()\n    m = inf\n    for n in range(1, min(x) + 1):\n        y = 0\n        for v in x:\n            if v // n < (v + n) // (n + 1):\n                break\n            y += (v + n) // (n + 1)\n        else:\n            m = min(m, y)\n            \n    return m\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if dp[j] != -1 and abs(nums[j] - nums[i]) <= target:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[n - 1]\n\ndef find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n\ndef long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b "}, {"source": "livecodebench-execution", "id": "sample_101", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    @cache\n    def dp(idx):\n        if idx == n - 1:\n            return 0\n        res = -1\n        for i in range(idx + 1, n):\n            if abs(nums[i] - nums[idx]) <= target and dp(i) != -1:\n                res = max(res, 1 + dp(i))\n        return res\n    return dp(0)", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    if n == 1:\n        return derived[0] == 0\n    ans = 0\n    for i in range(n - 1):\n        ans ^= derived[i]\n    return ans == derived[-1]\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    @cache\n    def dp(idx):\n        if idx == n - 1:\n            return 0\n        res = -1\n        for i in range(idx + 1, n):\n            if abs(nums[i] - nums[idx]) <= target and dp(i) != -1:\n                res = max(res, 1 + dp(i))\n        return res\n    return dp(0)\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_102", "function_name": "maximumJumps", "code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-1] * n\n    f[0] = 0\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= target:\n                    f[j] = max(f[i] + 1, f[j])\n    return f[-1]", "distractor_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            a = int(str(nums[i])[0])\n            b = int(str(nums[j])[-1])\n            if gcd(a, b) == 1:\n                ans += 1\n    return ans\n\ndef test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-1] * n\n    f[0] = 0\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= target:\n                    f[j] = max(f[i] + 1, f[j])\n    return f[-1]\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = ''\n    for w in words:\n        t += w[0]\n    return t == s"}, {"source": "livecodebench-execution", "id": "sample_103", "function_name": "maxNonDecreasingLength", "code": "def maxNonDecreasingLength(nums1: List[int], nums2: List[int]) -> int:\n    a = b = y = 1\n    for i in range(1, len(nums1)):\n        a, b = (\n            max(a + 1 if nums1[i] >= nums1[i - 1] else 1,\n                b + 1 if nums1[i] >= nums2[i - 1] else 1),\n            max(a + 1 if nums2[i] >= nums1[i - 1] else 1,\n                b + 1 if nums2[i] >= nums2[i - 1] else 1),\n        )\n        y = max(y, a, b)\n    return y", "distractor_code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)\n\ndef minOperations(nums: List[int]) -> int:\n  c = {}\n  for x in nums:\n    c[x] = c.get(x, 0) + 1\n  ret = 0\n  for x in c.values():\n    if x < 2:\n      return -1\n    if x % 3 == 0:\n      ret += x // 3\n    elif x % 3 == 1:\n      ret += 2 + (x - 4) // 3\n    else:\n      ret += 1 + (x - 2) // 3\n  return ret\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-1] * n\n    f[0] = 0\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= target:\n                    f[j] = max(f[i] + 1, f[j])\n    return f[-1]\n\ndef maxNonDecreasingLength(nums1: List[int], nums2: List[int]) -> int:\n    a = b = y = 1\n    for i in range(1, len(nums1)):\n        a, b = (\n            max(a + 1 if nums1[i] >= nums1[i - 1] else 1,\n                b + 1 if nums1[i] >= nums2[i - 1] else 1),\n            max(a + 1 if nums2[i] >= nums1[i - 1] else 1,\n                b + 1 if nums2[i] >= nums2[i - 1] else 1),\n        )\n        y = max(y, a, b)\n    return y"}, {"source": "livecodebench-execution", "id": "sample_104", "function_name": "maxNonDecreasingLength", "code": "def maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans", "distractor_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    tmp = []\n    for idx,v in enumerate(nums):\n        if v==1:\n            tmp.append(idx)\n    # print(tmp)\n    if len(tmp)==0:return 0\n    if len(tmp)==1:return 1\n    res = 1\n    mod = 10**9+7\n    for a,b in pairwise(tmp):\n        res = res*(b-a)% mod\n    return res\n\ndef maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_105", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    kq = deque()\n    S = 0\n    while nums:\n        while kq and kq[0][0] - k + 1 >= len(nums):\n            r, t = kq.popleft()\n            S -= t\n        nums[-1] -= S\n        if nums[-1] < 0:\n            return False\n        elif nums[-1] > 0:\n            if len(nums) < k:\n                return False\n            kq.append((len(nums) - 1, nums[-1]))\n            S += kq[-1][1]\n        nums.pop()\n    return True", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    kq = deque()\n    S = 0\n    while nums:\n        while kq and kq[0][0] - k + 1 >= len(nums):\n            r, t = kq.popleft()\n            S -= t\n        nums[-1] -= S\n        if nums[-1] < 0:\n            return False\n        elif nums[-1] > 0:\n            if len(nums) < k:\n                return False\n            kq.append((len(nums) - 1, nums[-1]))\n            S += kq[-1][1]\n        nums.pop()\n    return True\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef continuousSubarrays(A: List[int]) -> int:\n    res = i = 0\n    n = len(A)\n    count = Counter()\n    for j in range(n):\n        count[A[j]] += 1\n        while max(count) - min(count) > 2:\n            count[A[i]] -= 1\n            if count[A[i]] == 0:\n                del count[A[i]]\n            i += 1\n        res += j - i + 1\n    return res\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_106", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True", "distractor_code": "def isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d=[0]*(target+1)\n    t=[el for el in nums if el<=target]\n    if len(t)==0:\n        return -1\n    d[t[0]]=1\n    for el in t[1:]:\n        for j in range(target,0,-1):\n            if j-el>=0 and (j-el==0 or d[j-el]>0):\n                d[j]=max(d[j],d[j-el]+1)\n    if d[target]==0:\n        return -1\n    return d[target]\n\ndef word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True"}, {"source": "livecodebench-execution", "id": "sample_107", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    queue = deque()\n    for i in range(k):\n        queue.append(nums[i])\n        \n    curr = 0\n    for i in range(k, len(nums)):\n        if curr > queue[0]:\n            return False\n        \n        curr = queue.popleft()\n        queue.append(curr + nums[i])\n    \n    n = len(set(queue))\n    return n == 1", "distractor_code": "def checkArray(nums: List[int], k: int) -> bool:\n    queue = deque()\n    for i in range(k):\n        queue.append(nums[i])\n        \n    curr = 0\n    for i in range(k, len(nums)):\n        if curr > queue[0]:\n            return False\n        \n        curr = queue.popleft()\n        queue.append(curr + nums[i])\n    \n    n = len(set(queue))\n    return n == 1\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) \n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    p = [[] for _ in range(n)]\n    for l, r, w in offers:\n        p[r].append((l, w))\n    dp = [0] * n\n    for i in range(n):\n        if i:\n            dp[i] = max(dp[i], dp[i - 1])\n        for l, w in p[i]:\n            dp[i] = max(dp[i], (dp[l - 1] if l else 0) + w)\n    return dp[-1]"}, {"source": "livecodebench-execution", "id": "sample_108", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef finalString(s: str) -> str:\n    stk = []\n    for i in s:\n        if i =='i':\n            stk.reverse()\n        else:\n            stk.append(i)\n    return \"\".join(stk)\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)"}, {"source": "livecodebench-execution", "id": "sample_109", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    diff = [0]*(len(nums)+1)\n    curr = 0\n    for i in range(len(nums)):\n        curr += diff[i]\n        if curr > nums[i]:\n            return False\n        if nums[i] > curr:\n            if i+k >= len(nums)+1:\n                return False\n            diff[i+k] -= nums[i]-curr\n            curr = nums[i]\n    return True", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += grid[i][j]\n        if t == n - 1:\n            return i\n\ndef buyChoco(a: List[int], money: int) -> int:\n    a.sort()\n    if a[0] + a[1] > money:\n        return money\n    return money - a[0] - a[1]\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    diff = [0]*(len(nums)+1)\n    curr = 0\n    for i in range(len(nums)):\n        curr += diff[i]\n        if curr > nums[i]:\n            return False\n        if nums[i] > curr:\n            if i+k >= len(nums)+1:\n                return False\n            diff[i+k] -= nums[i]-curr\n            curr = nums[i]\n    return True\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[-4:-2]) > 60:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_110", "function_name": "checkArray", "code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0", "distractor_code": "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    p1 = p2 = 0\n    def nxt(c):\n        if c == 'z':\n            return 'a' \n        else:\n            return chr(ord(c) + 1)\n    while p1 < len(str1) and p2 < len(str2):\n        if str2[p2] == str1[p1] or str2[p2] == nxt(str1[p1]):\n            p2 += 1\n        p1 += 1\n    return p2 == len(str2)\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1\n\ndef kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0"}, {"source": "livecodebench-execution", "id": "sample_111", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans", "distractor_code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans\n\ndef opposite_Signs(x,y): \n    return ((x ^ y) < 0); \n\ndef replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n"}, {"source": "livecodebench-execution", "id": "sample_112", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    le = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i,n):\n            s.add(nums[j])\n            if len(s) == le:\n                ans += n - j\n                break\n    return ans\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for l, r in nums:\n        s |= set(range(l, r + 1))\n        \n    return (len(s))\n\ndef maxSum(nums: List[int]) -> int:\n    ans = -1\n    d = defaultdict(list)\n    for x in nums:\n        d[max(map(int,str(x)))].append(x)\n    for i in range(10):\n        if len(d[i]) < 2:\n            continue\n        d[i].sort()\n        ans = max(ans, d[i][-1] + d[i][-2])\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_113", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    res = 0\n    deq = deque()\n    for n in nums:\n        deq.append(n)\n        while deq[0] < n - 2 * k:\n            deq.popleft()\n        res = max(res, len(deq))\n    return res", "distractor_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]\n\ndef insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    res = 0\n    deq = deque()\n    for n in nums:\n        deq.append(n)\n        while deq[0] < n - 2 * k:\n            deq.popleft()\n        res = max(res, len(deq))\n    return res\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res"}, {"source": "livecodebench-execution", "id": "sample_114", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer", "distractor_code": "def makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1\n\ndef countWays(nums: List[int]) -> int:\n    n = len(nums)\n    nums.sort()\n    c = 0\n    for g in range(n+1):\n        l = (g == 0) or g > nums[g-1]\n        r = (g == n) or g < nums[g]\n        c += l and r\n    return int(c)\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans\n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer"}, {"source": "livecodebench-execution", "id": "sample_115", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    q = deque()\n    ans = 0\n    for x in nums:\n        q.append(x)\n        while q[0] < x - k - k:\n            q.popleft()\n        ans = max(ans, len(q))\n    return ans", "distractor_code": "def countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    q = deque()\n    ans = 0\n    for x in nums:\n        q.append(x)\n        while q[0] < x - k - k:\n            q.popleft()\n        ans = max(ans, len(q))\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)"}, {"source": "livecodebench-execution", "id": "sample_116", "function_name": "maximumBeauty", "code": "def maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    \n    maxres = 0\n    right = 0\n    for left in range(n):\n        while right < n and nums[right] <= nums[left] + 2*k:\n            right += 1\n            maxres = max(maxres, right - left)\n    return maxres", "distractor_code": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    \n    maxres = 0\n    right = 0\n    for left in range(n):\n        while right < n and nums[right] <= nums[left] + 2*k:\n            right += 1\n            maxres = max(maxres, right - left)\n    return maxres"}, {"source": "livecodebench-execution", "id": "sample_117", "function_name": "minimumIndex", "code": "def minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_118", "function_name": "minimumIndex", "code": "def minimumIndex(nums: List[int]) -> int:\n    x, c = 0, 0\n    for i in nums:\n        if i == x:\n            c += 1\n        else:\n            c -= 1\n            if c < 0:\n                x = i\n                c = 1\n    m = nums.count(x)\n    p = 0\n    for i in range(len(nums)):\n        p += nums[i] == x\n        if p * 2 > i + 1 and (m - p) * 2 > len(nums) - i - 1:\n            return i\n    return -1", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\"\n\ndef minimumIndex(nums: List[int]) -> int:\n    x, c = 0, 0\n    for i in nums:\n        if i == x:\n            c += 1\n        else:\n            c -= 1\n            if c < 0:\n                x = i\n                c = 1\n    m = nums.count(x)\n    p = 0\n    for i in range(len(nums)):\n        p += nums[i] == x\n        if p * 2 > i + 1 and (m - p) * 2 > len(nums) - i - 1:\n            return i\n    return -1\n\nimport re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))"}, {"source": "livecodebench-execution", "id": "sample_119", "function_name": "minimumIndex", "code": "def minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1", "distractor_code": "def minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef is_lower(string):\n  return (string.lower())\n\ndef count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\n\ndef find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) \n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_120", "function_name": "minimumIndex", "code": "def minimumIndex(nums: List[int]) -> int:\n    c = Counter(nums)\n    d = max((v, k) for k, v in c.items())[1]\n    n = len(nums)\n    l = 0\n    r = c[d] - (n - c[d])\n    \n    for i, num in enumerate(nums):\n        if num == d:\n            l += 1\n            r -= 1\n        else:\n            l -= 1\n            r += 1\n        if l > 0 and r > 0: return i\n    return -1", "distractor_code": "def minimumIndex(nums: List[int]) -> int:\n    c = Counter(nums)\n    d = max((v, k) for k, v in c.items())[1]\n    n = len(nums)\n    l = 0\n    r = c[d] - (n - c[d])\n    \n    for i, num in enumerate(nums):\n        if num == d:\n            l += 1\n            r -= 1\n        else:\n            l -= 1\n            r += 1\n        if l > 0 and r > 0: return i\n    return -1\n\ndef square_perimeter(a):\n  perimeter=4*a\n  return perimeter\n\ndef reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum"}, {"source": "livecodebench-execution", "id": "sample_121", "function_name": "minimumIndex", "code": "from collections import defaultdict\ndef minimumIndex(nums: List[int]) -> int:\n    dct = defaultdict(int)\n    for i in nums:\n        dct[i] += 1\n        if dct[i]*2>len(nums):dom = i\n    other = defaultdict(int)\n    upto = 0\n    for i in nums[:-1]:\n        other[i] += 1\n        dct[i] -= 1\n        upto += 1\n        la = len(nums)-upto\n        if other[dom]*2>upto and dct[dom]*2>la:return upto-1\n    return -1", "distractor_code": "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out \n\ndef continuousSubarrays(A: List[int]) -> int:\n    res = i = 0\n    n = len(A)\n    count = Counter()\n    for j in range(n):\n        count[A[j]] += 1\n        while max(count) - min(count) > 2:\n            count[A[i]] -= 1\n            if count[A[i]] == 0:\n                del count[A[i]]\n            i += 1\n        res += j - i + 1\n    return res\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\nfrom collections import defaultdict\ndef minimumIndex(nums: List[int]) -> int:\n    dct = defaultdict(int)\n    for i in nums:\n        dct[i] += 1\n        if dct[i]*2>len(nums):dom = i\n    other = defaultdict(int)\n    upto = 0\n    for i in nums[:-1]:\n        other[i] += 1\n        dct[i] -= 1\n        upto += 1\n        la = len(nums)-upto\n        if other[dom]*2>upto and dct[dom]*2>la:return upto-1\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_122", "function_name": "minimumIndex", "code": "def minimumIndex(nums: List[int]) -> int:\n    n = len(nums) \n    C = Counter(nums)\n    m = max(C.values()) \n\n    if n >= m * 2: return -1\n    x = 0\n    for t in C: \n        if C[t] == m: x = t \n    print(n,m,x)\n    c = 0 \n    for i,y in enumerate(nums):\n        c += y == x \n        if c * 2 > i + 1:\n            if (C[x]-c) * 2 > n - (i+1):\n                return i \n    return -1", "distractor_code": "def minimumIndex(nums: List[int]) -> int:\n    n = len(nums) \n    C = Counter(nums)\n    m = max(C.values()) \n\n    if n >= m * 2: return -1\n    x = 0\n    for t in C: \n        if C[t] == m: x = t \n    print(n,m,x)\n    c = 0 \n    for i,y in enumerate(nums):\n        c += y == x \n        if c * 2 > i + 1:\n            if (C[x]-c) * 2 > n - (i+1):\n                return i \n    return -1\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_123", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer", "distractor_code": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    \n    nums.sort()\n    n = len(nums)\n    \n    ans = float('inf')\n    \n    for i in range(1,n):\n        gap = nums[i] - nums[i-1]\n        \n        ans = min(ans, gap)\n    \n    return ans\n\ndef min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_124", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for i in words:\n        for j in i.split(separator):\n            if j:\n                ans.append(j)\n    return ans", "distractor_code": "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    res=0\n    n=len(nums)\n    for i in range(n):\n        for j in range(i+1,n):\n            a=int(str(nums[i])[0])\n            b=int(str(nums[j])[-1])\n            if gcd(a,b)==1:\n                res+=1\n    return res\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for i in words:\n        for j in i.split(separator):\n            if j:\n                ans.append(j)\n    return ans\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) "}, {"source": "livecodebench-execution", "id": "sample_125", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend(w.split(separator))\n        \n    return [s for s in ans if s]", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret\n\ndef find(n,m):  \n    q = n//m \n    return (q)\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend(w.split(separator))\n        \n    return [s for s in ans if s]\n\ndef sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_126", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]", "distractor_code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans\n\ndef max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    c = 0\n    for i in range(len(s)):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i]) - 1)\n            c = 1\n        else:\n            if c:\n                break\n    if not c:\n        s[-1] = 'z'\n    return \"\".join(s)"}, {"source": "livecodebench-execution", "id": "sample_127", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend([x for x in w.split(separator) if x])\n    return ans", "distractor_code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend([x for x in w.split(separator) if x])\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_128", "function_name": "splitWordsBySeparator", "code": "def splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res", "distractor_code": "import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))\n\ndef splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_129", "function_name": "maxIncreasingGroups", "code": "def maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n", "distractor_code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set()\n    ans = 0\n    for w in words:\n        if w[::-1] in s:\n            ans += 1\n            s.remove(w[::-1])\n        else:\n            s.add(w)\n    return ans\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n\ndef minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)"}, {"source": "livecodebench-execution", "id": "sample_130", "function_name": "maxIncreasingGroups", "code": "def maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res", "distractor_code": "def matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    c = 0\n    for i in range(len(s)):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i]) - 1)\n            c = 1\n        else:\n            if c:\n                break\n    if not c:\n        s[-1] = 'z'\n    return \"\".join(s)\n\ndef check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_131", "function_name": "maxIncreasingGroups", "code": "def maxIncreasingGroups(x: List[int]) -> int:\n    x.sort()\n    n = len(x)\n    vals = list(accumulate(x))\n    ans = 0\n    for v in vals:\n        if (ans + 1) * (ans + 2) // 2 <= v:\n            ans += 1\n    return ans", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            \n            if nums[j] != nums[i] + ((j - i) & 1):\n                break\n            \n            ans = max(ans, j - i + 1)\n    return ans\n\ndef maxIncreasingGroups(x: List[int]) -> int:\n    x.sort()\n    n = len(x)\n    vals = list(accumulate(x))\n    ans = 0\n    for v in vals:\n        if (ans + 1) * (ans + 2) // 2 <= v:\n            ans += 1\n    return ans\n\ndef split_two_parts(list1, L):\n    return list1[:L], list1[L:]"}, {"source": "livecodebench-execution", "id": "sample_132", "function_name": "maxIncreasingGroups", "code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort(reverse=True)\n    left, right = 1, len(usageLimits)\n    while left < right:\n        m = (left + right + 1) // 2\n        if test(usageLimits, m):\n            left = m\n        else:\n            right = m - 1\n    return left\n\ndef test(count: List[int], group: int) -> bool:\n    d = 0\n    for i, x in enumerate(count):\n        y = max(group - i, 0)\n        d = min(d + x - y, 0)\n    return d == 0", "distractor_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort(reverse=True)\n    left, right = 1, len(usageLimits)\n    while left < right:\n        m = (left + right + 1) // 2\n        if test(usageLimits, m):\n            left = m\n        else:\n            right = m - 1\n    return left\n\ndef test(count: List[int], group: int) -> bool:\n    d = 0\n    for i, x in enumerate(count):\n        y = max(group - i, 0)\n        d = min(d + x - y, 0)\n    return d == 0\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    cnt = {}\n    s = 0\n    cnt[0]=1\n    ans = 0\n    for c in nums:\n        if c%modulo==k:\n            s+=1\n            s%=modulo\n        ns = s-k\n        if ns<0:\n            ns+=modulo\n        if ns in cnt:\n            ans+=cnt[ns]\n        if s not in cnt:\n            cnt[s]=0\n        cnt[s]+=1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_133", "function_name": "maxIncreasingGroups", "code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans", "distractor_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]"}, {"source": "livecodebench-execution", "id": "sample_134", "function_name": "numberOfEmployeesWhoMetTarget", "code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \n\nfrom collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    \n    maxres = 0\n    right = 0\n    for left in range(n):\n        while right < n and nums[right] <= nums[left] + 2*k:\n            right += 1\n            maxres = max(maxres, right - left)\n    return maxres"}, {"source": "livecodebench-execution", "id": "sample_135", "function_name": "numberOfEmployeesWhoMetTarget", "code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([t for t in hours if t >= target])", "distractor_code": "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([t for t in hours if t >= target])\n\ndef canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0\n\nimport math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s"}, {"source": "livecodebench-execution", "id": "sample_136", "function_name": "numberOfEmployeesWhoMetTarget", "code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)", "distractor_code": "def sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)\n\ndef check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False"}, {"source": "livecodebench-execution", "id": "sample_137", "function_name": "numberOfEmployeesWhoMetTarget", "code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]\n\ndef square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)"}, {"source": "livecodebench-execution", "id": "sample_138", "function_name": "numberOfEmployeesWhoMetTarget", "code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([x for x in hours if x >= target])", "distractor_code": "def findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([x for x in hours if x >= target])\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element"}, {"source": "livecodebench-execution", "id": "sample_139", "function_name": "numberOfEmployeesWhoMetTarget", "code": "from typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])", "distractor_code": "def minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result\n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans\n\ndef maxSum(nums: List[int]) -> int:\n    dc = defaultdict(list)\n    for v in nums:\n        dc[max([int(c) for c in str(v)])].append(v)\n    res = -1\n    for d in range(10):\n        lst = dc[d]\n        if len(lst) >= 2:\n            res = max(res, sum(sorted(lst)[-2:]))\n    return res"}, {"source": "livecodebench-execution", "id": "sample_140", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans\n\ndef remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n\ndef volume_cube(l):\n  volume = l * l * l\n  return volume\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_141", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    d = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == d\n    return ans", "distractor_code": "def volume_cube(l):\n  volume = l * l * l\n  return volume\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for i in nums:\n        s.add(i)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(s)\n\ndef find_Volume(l,b,h) : \n    return ((l * b * h) / 2) \n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    d = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == d\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_142", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    setn = len(set(nums))\n    to_ret = 0\n    for i in range(len(nums)) :\n        set_t = set()\n        for j in range(i, len(nums)) :\n            set_t.add(nums[j])\n            if len(set_t) == setn :\n                to_ret += 1\n    return to_ret", "distractor_code": "def minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    setn = len(set(nums))\n    to_ret = 0\n    for i in range(len(nums)) :\n        set_t = set()\n        for j in range(i, len(nums)) :\n            set_t.add(nums[j])\n            if len(set_t) == setn :\n                to_ret += 1\n    return to_ret\n\ndef loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    def count(unit):\n        res = 0\n        for value in counter.values():\n            d, r = divmod(value, unit)\n            if r > d:\n                return -1\n            res += -(-value // (unit + 1))\n        return res\n        \n    counter, n = Counter(nums), len(nums)\n    for unit in range(min(counter.values()), 0, -1):\n        res = count(unit)\n        if res != -1:\n            return res"}, {"source": "livecodebench-execution", "id": "sample_143", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    le = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i,n):\n            s.add(nums[j])\n            if len(s) == le:\n                ans += n - j\n                break\n    return ans", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\nfrom typing import List\nfrom itertools import combinations\nfrom functools import reduce\nimport operator\n\ndef maxStrength(nums: List[int]) -> int:\n    n = len(nums)\n    max_strength = float('-inf')\n    \n    for r in range(1, n + 1):\n        for combination in combinations(nums, r):\n            product = reduce(operator.mul, combination, 1)\n            max_strength = max(max_strength, product)\n\n    return max_strength\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    le = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i,n):\n            s.add(nums[j])\n            if len(s) == le:\n                ans += n - j\n                break\n    return ans\n\ndef sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_144", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret\n\ndef count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_145", "function_name": "countCompleteSubarrays", "code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans\n\ndef get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    cnt = {}\n    s = 0\n    cnt[0]=1\n    ans = 0\n    for c in nums:\n        if c%modulo==k:\n            s+=1\n            s%=modulo\n        ns = s-k\n        if ns<0:\n            ns+=modulo\n        if ns in cnt:\n            ans+=cnt[ns]\n        if s not in cnt:\n            cnt[s]=0\n        cnt[s]+=1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_146", "function_name": "finalString", "code": "def finalString(s: str) -> str:\n    stk = []\n    for i in s:\n        if i =='i':\n            stk.reverse()\n        else:\n            stk.append(i)\n    return \"\".join(stk)", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for a, b in cnt.items():\n        if b == 1:\n            return -1\n        if b % 3 == 0:\n            ans += b // 3\n        if b % 3 == 1:\n            ans += (b - 4) // 3 + 2\n        if b % 3 == 2:\n            ans += (b - 2) // 3 + 1\n    return ans\n\ndef finalString(s: str) -> str:\n    stk = []\n    for i in s:\n        if i =='i':\n            stk.reverse()\n        else:\n            stk.append(i)\n    return \"\".join(stk)\n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct\n\nfrom array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\n\ndef distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_147", "function_name": "finalString", "code": "def finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    c = 0\n    for w in words:\n        if w == \"prev\":\n            c += 1\n            if len(stk) < c:\n                ans.append(-1)\n            else:\n                ans.append(stk[-c])\n        else:\n            stk.append(int(w))\n            c = 0\n    return ans\n\ndef finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)\n\ndef sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_148", "function_name": "finalString", "code": "def finalString(s: str) -> str:\n    res = []\n    for c in s:\n        if c == 'i':\n            res = res[::-1]\n        else:\n            res.append(c)\n    return ''.join(res)", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef finalString(s: str) -> str:\n    res = []\n    for c in s:\n        if c == 'i':\n            res = res[::-1]\n        else:\n            res.append(c)\n    return ''.join(res)\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum"}, {"source": "livecodebench-execution", "id": "sample_149", "function_name": "finalString", "code": "from typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a", "distractor_code": "def sortVowels(s: str) -> str:\n    ss = \"aeiouAEIOU\"\n    ans = []\n    qs = [c for c in s if c in ss]\n    qs.sort()\n    pos = 0\n    for c in s:\n        if c in ss:\n            ans.append(qs[pos])\n            pos += 1\n        else:\n            ans.append(c)\n    return \"\".join(ans)\n\ndef check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element\n\ndef minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); \n\ndef find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n \n\nfrom typing import *\n\nfrom math import *\n\ndef finalString(s: str) -> str:\n    a = \"\"\n    for i in s:\n        if i == 'i':\n            a = a[::-1]\n        else:\n            a += i\n    return a"}, {"source": "livecodebench-execution", "id": "sample_150", "function_name": "finalString", "code": "def finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans", "distractor_code": "def finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    a, b, c = 0, 0, 0\n    a = moves.count('L')\n    b = moves.count('R')\n    c = moves.count('_')\n    return max([a + c - b, b + c - a])"}, {"source": "livecodebench-execution", "id": "sample_151", "function_name": "finalString", "code": "def finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2"}, {"source": "livecodebench-execution", "id": "sample_152", "function_name": "canSplitArray", "code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(h>=target for h in hours)"}, {"source": "livecodebench-execution", "id": "sample_153", "function_name": "canSplitArray", "code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))", "distractor_code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list \n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\nimport re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) "}, {"source": "livecodebench-execution", "id": "sample_154", "function_name": "canSplitArray", "code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <3:\n        return True\n    for i,v in enumerate(nums):\n        if i+1 >= len(nums):\n            continue\n        if v + nums[i+1] >= m:\n            return True\n    return False", "distractor_code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <3:\n        return True\n    for i,v in enumerate(nums):\n        if i+1 >= len(nums):\n            continue\n        if v + nums[i+1] >= m:\n            return True\n    return False\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    s = sorted(nums)\n    n = len(nums)\n    for i in range(n + 10):\n        t = [nums[-1]] + nums[:-1][:]\n        if s == t:\n            return (i + 1) % n\n        nums = t[:]\n        # print('t', t, nums)\n    else:\n        return -1\n\ndef minimumIndex(nums: List[int]) -> int:\n    n = len(nums)\n    cnt = {}\n    for num in nums:\n        cnt[num] = cnt.get(num, 0) + 1\n    mx = 0\n    for num in cnt:\n        if cnt[num] > mx:\n            mx = cnt[num]\n            x = num\n    cx = 0\n    for i in range(n):\n        cx += int(nums[i] == x)\n        if cx * 2 > i + 1 and (cnt[x] - cx) * 2 > (n - i - 1):\n            return i\n    return -1\n\ndef check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False\n\ndef string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]"}, {"source": "livecodebench-execution", "id": "sample_155", "function_name": "canSplitArray", "code": "from typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False", "distractor_code": "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \n\nfrom typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False\n\ndef isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    sums = [0]\n    for i in nums:\n        sums.append(sums[-1]+i)\n    @lru_cache(None)\n    def dp(i,j):\n        if j-i==1:\n            return True\n        for k in range(i+1,j):\n            if k!=j-1 and sums[j]-sums[k]<m:\n                continue\n            if k!=i+1 and sums[k]-sums[i]<m:\n                continue\n            if dp(i,k) and dp(k,j):return True\n        return False\n    return dp(0,len(nums))"}, {"source": "livecodebench-execution", "id": "sample_156", "function_name": "canSplitArray", "code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False", "distractor_code": "def minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct\n\ndef minimizedStringLength(s: str) -> int:\n    graph = collections.defaultdict(int)\n    \n    for char in s:\n        graph[char] += 1\n    \n    return len(graph)\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]"}, {"source": "livecodebench-execution", "id": "sample_157", "function_name": "canSplitArray", "code": "def canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    res = float('inf')\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n        res = min(res, nums[i + 1] - nums[i])\n    return res\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_158", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res", "distractor_code": "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    def count(unit):\n        res = 0\n        for value in counter.values():\n            d, r = divmod(value, unit)\n            if r > d:\n                return -1\n            res += -(-value // (unit + 1))\n        return res\n        \n    counter, n = Counter(nums), len(nums)\n    for unit in range(min(counter.values()), 0, -1):\n        res = count(unit)\n        if res != -1:\n            return res\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:(i + 1)])) - len(set(nums[(i + 1):])) for i in range(len(nums))]"}, {"source": "livecodebench-execution", "id": "sample_159", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    \n    ans = -1\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if max(str(nums[i]))==max(str(nums[j])):\n                ans = max(ans,nums[i]+nums[j])\n    return ans", "distractor_code": "def maxSum(nums: List[int]) -> int:\n    \n    ans = -1\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if max(str(nums[i]))==max(str(nums[j])):\n                ans = max(ans,nums[i]+nums[j])\n    return ans\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n"}, {"source": "livecodebench-execution", "id": "sample_160", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    d = defaultdict(list)\n    for x in nums:\n        d[max(map(int,str(x)))].append(x)\n    for i in range(10):\n        if len(d[i]) < 2:\n            continue\n        d[i].sort()\n        ans = max(ans, d[i][-1] + d[i][-2])\n    return ans", "distractor_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp=[-1]*(target+1)\n    dp[0]=0\n    for a in nums:\n        for i in range(target-a,-1,-1):\n            if dp[i]==-1:continue\n            dp[i+a]=max(dp[i+a],dp[i]+1)\n    return dp[-1]\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t\n\ndef min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres\n\ndef maxSum(nums: List[int]) -> int:\n    ans = -1\n    d = defaultdict(list)\n    for x in nums:\n        d[max(map(int,str(x)))].append(x)\n    for i in range(10):\n        if len(d[i]) < 2:\n            continue\n        d[i].sort()\n        ans = max(ans, d[i][-1] + d[i][-2])\n    return ans\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )"}, {"source": "livecodebench-execution", "id": "sample_161", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(str(nums[i])) == max(str(nums[j])):\n                ans = max(ans, nums[i] + nums[j])\n    return ans", "distractor_code": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(str(nums[i])) == max(str(nums[j])):\n                ans = max(ans, nums[i] + nums[j])\n    return ans\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss"}, {"source": "livecodebench-execution", "id": "sample_162", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    dc = defaultdict(list)\n    for v in nums:\n        dc[max([int(c) for c in str(v)])].append(v)\n    res = -1\n    for d in range(10):\n        lst = dc[d]\n        if len(lst) >= 2:\n            res = max(res, sum(sorted(lst)[-2:]))\n    return res", "distractor_code": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n\ndef findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res\n\ndef minimumSum(n: int, k: int) -> int:\n    arr = []\n    st = set()\n    now = 1\n    while len(arr) < n:\n        if (k - now) not in st:\n            st.add(now)\n            arr.append(now)\n        \n        now += 1\n    return sum(arr)\n\ndef maxSum(nums: List[int]) -> int:\n    dc = defaultdict(list)\n    for v in nums:\n        dc[max([int(c) for c in str(v)])].append(v)\n    res = -1\n    for d in range(10):\n        lst = dc[d]\n        if len(lst) >= 2:\n            res = max(res, sum(sorted(lst)[-2:]))\n    return res\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    for l in nums:\n        l.sort()\n        \n    out = 0\n    while nums[0]:\n        top = 0\n        for l in nums:\n            top = max(top, l.pop())\n        out += top\n    return out"}, {"source": "livecodebench-execution", "id": "sample_163", "function_name": "maxSum", "code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if max(w for w in str(nums[i])) == max(w for w in str(nums[j])):\n                cur = nums[i]+nums[j]\n                if cur > ans:\n                    ans = cur\n    return ans", "distractor_code": "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max\n\ndef maxSum(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        for j in range(i+1, n):\n            if max(w for w in str(nums[i])) == max(w for w in str(nums[j])):\n                cur = nums[i]+nums[j]\n                if cur > ans:\n                    ans = cur\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_164", "function_name": "minAbsoluteDifference", "code": "def minAbsoluteDifference(nums: List[int], x: int) -> int:\n    st = []\n    ans = float('inf')\n    for i,c in enumerate(nums):\n        if i>=x:\n            bisect.insort(st,nums[i-x])\n            p = bisect.bisect_left(st,c) \n            if p>0:\n                ans = min(ans,c-st[p-1])\n            if p<len(st):\n                ans = min(ans,st[p]-c)\n    return ans", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans\n\ndef max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n\ndef minAbsoluteDifference(nums: List[int], x: int) -> int:\n    st = []\n    ans = float('inf')\n    for i,c in enumerate(nums):\n        if i>=x:\n            bisect.insort(st,nums[i-x])\n            p = bisect.bisect_left(st,c) \n            if p>0:\n                ans = min(ans,c-st[p-1])\n            if p<len(st):\n                ans = min(ans,st[p]-c)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)\n\ndef minimumOperations(num: str) -> int:\n    min_ops = len(num)\n    for rem in map(list, ('00', '25', '50', '75')):\n        copy = list(num)\n        ops = 0\n        while copy and copy[-1] != rem[-1]:\n            copy.pop(-1)\n            ops += 1\n        while len(copy) >= 2 and copy[-2] != rem[-2]:\n            copy.pop(-2)\n            ops += 1\n        if copy[-2:] == rem:\n            min_ops = min(min_ops, ops)\n    if '0' in num:\n        min_ops = min(min_ops, len(num) - 1)\n    return min_ops"}, {"source": "livecodebench-execution", "id": "sample_165", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    t = ''\n    for w in words:\n        t += w[0]\n    return t == s", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        curr = set()\n        for j in range(i, n):\n            curr.add(nums[j])\n            k = len(curr)\n            ans += k * k\n    return ans\n\ndef list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef countPairs(nums: List[int], target: int) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            ans += nums[i] + nums[j] < target\n    return ans\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = ''\n    for w in words:\n        t += w[0]\n    return t == s"}, {"source": "livecodebench-execution", "id": "sample_166", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    \n    return s == \"\".join([w[0] for w in words])", "distractor_code": "def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    \n    return s == \"\".join([w[0] for w in words])\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    if nums1.count(0) == 0 and nums2.count(0) == 0:\n        return -1 if sum(nums1) != sum(nums2) else sum(nums1)\n    if nums1.count(0) == 0:\n        ot = sum(nums2) + nums2.count(0)\n        if ot > sum(nums1):\n            return -1\n        \n        return sum(nums1)\n                    \n    if nums2.count(0) == 0:\n        return Solution().minSum(nums2, nums1)\n    \n    return max(nums1.count(0) + sum(nums1), nums2.count(0) + sum(nums2))"}, {"source": "livecodebench-execution", "id": "sample_167", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")\n\ndef count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) \n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_168", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    res = ''\n    for w in words:\n        res += w[0]\n    \n    return res == s", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    left = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        left[i] = tmp\n    s = s[::-1]\n    right = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        right[i] = tmp\n    right.reverse()\n    return min(x + y for x, y in zip(left, right))\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    res = ''\n    for w in words:\n        res += w[0]\n    \n    return res == s"}, {"source": "livecodebench-execution", "id": "sample_169", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)", "distractor_code": "def isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)\n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    \n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    n1z = 0\n    n2z = 0\n    for num in nums1:\n        n1z += num == 0\n    for num in nums2:\n        n2z += num == 0\n    \n    if n2z == 0 and s1 + n1z > s2:\n        return -1\n    if n1z == 0 and s2 + n2z > s1:\n        return -1\n    \n    \n    return max(s1+n1z,s2+n2z)"}, {"source": "livecodebench-execution", "id": "sample_170", "function_name": "isAcronym", "code": "def isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s", "distractor_code": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)"}, {"source": "livecodebench-execution", "id": "sample_171", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    arr = []\n    st = set()\n    now = 1\n    while len(arr) < n:\n        if (k - now) not in st:\n            st.add(now)\n            arr.append(now)\n        \n        now += 1\n    return sum(arr)", "distractor_code": "def minimumSum(n: int, k: int) -> int:\n    arr = []\n    st = set()\n    now = 1\n    while len(arr) < n:\n        if (k - now) not in st:\n            st.add(now)\n            arr.append(now)\n        \n        now += 1\n    return sum(arr)\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    colors = [0] * n\n    ans = []\n    res = 0\n    for i, c in queries:\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res -= 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res -= 1\n        colors[i] = c\n        if i and colors[i] == colors[i-1] and colors[i] > 0: res += 1\n        if i < n - 1 and colors[i] == colors[i+1] and colors[i] > 0: res += 1\n        ans.append(res)\n    return ans\n\nfrom collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count"}, {"source": "livecodebench-execution", "id": "sample_172", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    ans = []\n    s = 0\n    cur = 1\n    st = set()\n    while len(ans)<n:\n        while k-cur in st:\n            cur+=1\n        ans.append(cur)\n        st.add(cur)\n        s+=cur\n        cur+=1\n    return s", "distractor_code": "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] \n\ndef large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = []\n    s = 0\n    cur = 1\n    st = set()\n    while len(ans)<n:\n        while k-cur in st:\n            cur+=1\n        ans.append(cur)\n        st.add(cur)\n        s+=cur\n        cur+=1\n    return s"}, {"source": "livecodebench-execution", "id": "sample_173", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    seen = set()\n    x = 0\n    while len(seen) < n:\n        x += 1\n        if k-x not in seen:\n            seen.add(x)\n    \n    return sum(seen)", "distractor_code": "def minimumSum(n: int, k: int) -> int:\n    seen = set()\n    x = 0\n    while len(seen) < n:\n        x += 1\n        if k-x not in seen:\n            seen.add(x)\n    \n    return sum(seen)\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    n=len(nums)\n    d=0\n    for i in range(n):\n        if nums[i]%2!=0 or nums[i]>t: continue\n        d=max(d,1)\n        for j in range(i+1,n):\n            if nums[j]>t: break\n            if nums[j]%2==nums[j-1]%2: break\n            d=max(d,j-i+1)\n    return d\n\ndef solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + i\n    return dp\n    \n\ndef minimumCost(s: str) -> int:\n    l = solve(s)\n    r = solve(s[::-1])\n    n = len(s)\n    ans = min(l[i] + r[n - 1 - i] for i in range(n))\n    return ans\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_174", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))", "distractor_code": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_175", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)", "distractor_code": "def minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_176", "function_name": "minimumSum", "code": "def minimumSum(n: int, k: int) -> int:\n    ans = set()\n    i = 1\n    while len(ans) < n:\n        if k - i not in ans:\n            ans.add(i)\n        i += 1\n    return sum(ans)", "distractor_code": "def countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans\n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = set()\n    i = 1\n    while len(ans) < n:\n        if k - i not in ans:\n            ans.add(i)\n        i += 1\n    return sum(ans)\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False\n\ndef continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_177", "function_name": "maximizeTheProfit", "code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    f = [0] * (n + 1)\n    t = 0\n    for x, y, z in sorted(offers, key=lambda it: it[1]):\n        x += 1\n        y += 1\n        while t < y:\n            f[t + 1] = f[t]\n            t += 1\n        f[y] = max(f[x - 1] + z, f[y])\n\n    return max(f)", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    a = [0] * n\n    y = 0\n    ans = []\n    for i, c in queries:\n        y -= a[i] and (i > 0 and a[i] == a[i - 1]) + (i < n - 1 and a[i] == a[i + 1])\n        y += (i > 0 and c == a[i - 1]) + (i < n - 1 and c == a[i + 1])\n        a[i] = c\n        ans.append(y)\n    return ans\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'\n\nfrom typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    f = [0] * (n + 1)\n    t = 0\n    for x, y, z in sorted(offers, key=lambda it: it[1]):\n        x += 1\n        y += 1\n        while t < y:\n            f[t + 1] = f[t]\n            t += 1\n        f[y] = max(f[x - 1] + z, f[y])\n\n    return max(f)"}, {"source": "livecodebench-execution", "id": "sample_178", "function_name": "maximizeTheProfit", "code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    p = [[] for _ in range(n)]\n    for l, r, w in offers:\n        p[r].append((l, w))\n    dp = [0] * n\n    for i in range(n):\n        if i:\n            dp[i] = max(dp[i], dp[i - 1])\n        for l, w in p[i]:\n            dp[i] = max(dp[i], (dp[l - 1] if l else 0) + w)\n    return dp[-1]", "distractor_code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     \n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    p = [[] for _ in range(n)]\n    for l, r, w in offers:\n        p[r].append((l, w))\n    dp = [0] * n\n    for i in range(n):\n        if i:\n            dp[i] = max(dp[i], dp[i - 1])\n        for l, w in p[i]:\n            dp[i] = max(dp[i], (dp[l - 1] if l else 0) + w)\n    return dp[-1]\n\ndef is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True\n\nimport heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_179", "function_name": "maximizeTheProfit", "code": "import heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans", "distractor_code": "def maxNonDecreasingLength(nums1: List[int], nums2: List[int]) -> int:\n    a = b = y = 1\n    for i in range(1, len(nums1)):\n        a, b = (\n            max(a + 1 if nums1[i] >= nums1[i - 1] else 1,\n                b + 1 if nums1[i] >= nums2[i - 1] else 1),\n            max(a + 1 if nums2[i] >= nums1[i - 1] else 1,\n                b + 1 if nums2[i] >= nums2[i - 1] else 1),\n        )\n        y = max(y, a, b)\n    return y\n\ndef sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result\n\nimport heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_180", "function_name": "maximizeTheProfit", "code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]", "distractor_code": "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans\n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count \n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_181", "function_name": "maximizeTheProfit", "code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]", "distractor_code": "def maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]\n\ndef volume_cube(l):\n  volume = l * l * l\n  return volume\n\nimport sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef is_lower(string):\n  return (string.lower())\n\ndef minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_182", "function_name": "maximizeTheProfit", "code": "def maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i\n\nimport re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\ndef maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]"}, {"source": "livecodebench-execution", "id": "sample_183", "function_name": "longestEqualSubarray", "code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])"}, {"source": "livecodebench-execution", "id": "sample_184", "function_name": "longestEqualSubarray", "code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    return [len(set(nums[:i + 1])) - len(set(nums[i + 1:])) for i in range(len(nums))]\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\ndef makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)"}, {"source": "livecodebench-execution", "id": "sample_185", "function_name": "longestEqualSubarray", "code": "def longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans", "distractor_code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)\n\ndef first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) \n\ndef longestEqualSubarray(A: List[int], K: int) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = 0\n    for row in locs.values():\n        i = 0\n        for j, jx in enumerate(row):\n            while row[j] - row[i] - (j - i) > K:\n                i += 1\n            ans = max(ans, j-i + 1)\n    return ans\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    left = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        left[i] = tmp\n    s = s[::-1]\n    right = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        right[i] = tmp\n    right.reverse()\n    return min(x + y for x, y in zip(left, right))"}, {"source": "livecodebench-execution", "id": "sample_186", "function_name": "longestEqualSubarray", "code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans", "distractor_code": "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_187", "function_name": "longestEqualSubarray", "code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    d = defaultdict(list)\n    for i, a in enumerate(nums):\n        d[a].append(i)\n    for l in d.values():\n        cnt = 0\n        j = 0\n        for i in range(len(l)):\n            if i:\n                cnt += l[i] - l[i-1] - 1\n            while cnt > k:\n                cnt -= l[j+1] - l[j] - 1\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    d = defaultdict(list)\n    for i, a in enumerate(nums):\n        d[a].append(i)\n    for l in d.values():\n        cnt = 0\n        j = 0\n        for i in range(len(l)):\n            if i:\n                cnt += l[i] - l[i-1] - 1\n            while cnt > k:\n                cnt -= l[j+1] - l[j] - 1\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res"}, {"source": "livecodebench-execution", "id": "sample_188", "function_name": "furthestDistanceFromOrigin", "code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    n = len(s)\n    num_1s = s.count('1')\n    st = '1' * (num_1s - 1)\n    st += '0' * (n - num_1s)\n    st += '1'\n    return st\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef ascii_value(k):\n  ch=k\n  return ord(ch)\n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)"}, {"source": "livecodebench-execution", "id": "sample_189", "function_name": "furthestDistanceFromOrigin", "code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    p=0\n    cnt=0\n    for c in moves:\n        if c==\"L\":\n            p-=1\n        elif c==\"R\":\n            p+=1\n        else:\n            cnt+=1\n    return abs(p)+cnt", "distractor_code": "def continuousSubarrays(nums: List[int]) -> int:\n    l, r = 0, 0\n    n = len(nums)\n    cnt = Counter()\n    ans = 0\n    while l < n:\n        while r < n and (len(cnt) == 0 or (nums[r] - min(cnt) <= 2 and max(cnt) - nums[r] <= 2)):\n            cnt[nums[r]] += 1\n            r += 1\n        ans += r - l\n        cnt[nums[l]] -= 1\n        if cnt[nums[l]] == 0: del cnt[nums[l]]\n        l += 1\n    return ans\n\ndef re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    p=0\n    cnt=0\n    for c in moves:\n        if c==\"L\":\n            p-=1\n        elif c==\"R\":\n            p+=1\n        else:\n            cnt+=1\n    return abs(p)+cnt\n\ndef max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]"}, {"source": "livecodebench-execution", "id": "sample_190", "function_name": "furthestDistanceFromOrigin", "code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    res = 10 ** 10\n    # 枚举最大的\n    for i in range(len(nums) - 1, 0, -1):\n        # 最大的是 nums[i]\n        # 最小的是 nums[i-1]\n        res = min(res, nums[i] - nums[i - 1])\n    return res"}, {"source": "livecodebench-execution", "id": "sample_191", "function_name": "furthestDistanceFromOrigin", "code": "from collections import Counter\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ctr = Counter(moves)\n    return abs(ctr['L'] - ctr['R']) + ctr['_']", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)\n\ndef minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))\n\nfrom collections import Counter\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ctr = Counter(moves)\n    return abs(ctr['L'] - ctr['R']) + ctr['_']"}, {"source": "livecodebench-execution", "id": "sample_192", "function_name": "furthestDistanceFromOrigin", "code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    a, b, c = 0, 0, 0\n    a = moves.count('L')\n    b = moves.count('R')\n    c = moves.count('_')\n    return max([a + c - b, b + c - a])", "distractor_code": "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    a, b, c = 0, 0, 0\n    a = moves.count('L')\n    b = moves.count('R')\n    c = moves.count('_')\n    return max([a + c - b, b + c - a])\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    c = 0\n    for x in s:\n        if x == '1':\n            c += 1\n    n = len(s)\n    return (c-1)*'1'+(n-c)*'0'+'1'"}, {"source": "livecodebench-execution", "id": "sample_193", "function_name": "furthestDistanceFromOrigin", "code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff", "distractor_code": "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)"}, {"source": "livecodebench-execution", "id": "sample_194", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    k = target // 2\n    m = min(k, n)\n    ans = (1 + m) * m // 2\n    t = n - m\n    ans += (target + target + t - 1) * t // 2\n    return ans", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    d = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == d\n    return ans\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        check = True\n        for j in range(n - i + 1, n * 2 - i):\n            if nums[j % n] < nums[(j - 1) % n]:\n                check = False\n                break\n        if check: return i\n    return -1\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    k = target // 2\n    m = min(k, n)\n    ans = (1 + m) * m // 2\n    t = n - m\n    ans += (target + target + t - 1) * t // 2\n    return ans\n\ndef count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count"}, {"source": "livecodebench-execution", "id": "sample_195", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n and i <= target//2:\n        a.append(i)\n        i += 1\n    i = target\n    while len(a) < n:\n        a.append(i)\n        i += 1\n    return sum(a)", "distractor_code": "def minimumPossibleSum(n: int, target: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n and i <= target//2:\n        a.append(i)\n        i += 1\n    i = target\n    while len(a) < n:\n        a.append(i)\n        i += 1\n    return sum(a)\n\ndef remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i"}, {"source": "livecodebench-execution", "id": "sample_196", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    if target in [1, 2] :\n        return (1+n) * n // 2\n    if n - 1 + n < target : \n        return (1+n) * n // 2\n    \n    not_used = list(range(target//2+1, target))\n    l = n + len(not_used)\n    to_ret = (1+l) * l // 2\n    to_ret -= (not_used[0] + not_used[-1]) * len(not_used) // 2\n    return to_ret", "distractor_code": "def minimumPossibleSum(n: int, target: int) -> int:\n    if target in [1, 2] :\n        return (1+n) * n // 2\n    if n - 1 + n < target : \n        return (1+n) * n // 2\n    \n    not_used = list(range(target//2+1, target))\n    l = n + len(not_used)\n    to_ret = (1+l) * l // 2\n    to_ret -= (not_used[0] + not_used[-1]) * len(not_used) // 2\n    return to_ret\n\ndef rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) \n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res"}, {"source": "livecodebench-execution", "id": "sample_197", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    i = 1\n    arr = {1}\n    while len(arr) < n:\n        i += 1\n        if target - i not in arr:\n            arr.add(i)\n    return sum(arr)", "distractor_code": "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    i = 1\n    arr = {1}\n    while len(arr) < n:\n        i += 1\n        if target - i not in arr:\n            arr.add(i)\n    return sum(arr)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_198", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    arr = []\n    for i in range(1, target // 2 + 1):\n        arr.append(i)\n        if len(arr) == n:\n            return sum(arr)\n    \n    counter = target\n    while len(arr) < n:\n        arr.append(counter)\n        counter += 1\n    \n    return sum(arr)", "distractor_code": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    arr = []\n    for i in range(1, target // 2 + 1):\n        arr.append(i)\n        if len(arr) == n:\n            return sum(arr)\n    \n    counter = target\n    while len(arr) < n:\n        arr.append(counter)\n        counter += 1\n    \n    return sum(arr)\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    if target in [1, 2] :\n        return (1+n) * n // 2\n    if n - 1 + n < target : \n        return (1+n) * n // 2\n    \n    not_used = list(range(target//2+1, target))\n    l = n + len(not_used)\n    to_ret = (1+l) * l // 2\n    to_ret -= (not_used[0] + not_used[-1]) * len(not_used) // 2\n    return to_ret\n\ndef min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp=[-1]*(target+1)\n    dp[0]=0\n    for a in nums:\n        for i in range(target-a,-1,-1):\n            if dp[i]==-1:continue\n            dp[i+a]=max(dp[i+a],dp[i]+1)\n    return dp[-1]"}, {"source": "livecodebench-execution", "id": "sample_199", "function_name": "minimumPossibleSum", "code": "def minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum", "distractor_code": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    s3 = s1[0] + s1[3] + s1[2] + s1[1]\n    s4 = s1[2] + s1[3] + s1[0] + s1[1]\n    s5 = s1[2] + s1[1] + s1[0] + s1[3]\n    return s2 == s1 or s2 == s3 or s2 == s4 or s2 == s5\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    curr_sum = 0\n    banned = set()\n    for x in range(1,2*10**5 + 10):\n        if x not in banned:\n            curr_sum += x\n            n -= 1\n            banned.add(target-x)\n        if n == 0:\n            break\n    return curr_sum\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = [s1[0], s1[2]]\n    b = [s2[0], s2[2]]\n    a.sort()\n    b.sort()\n    if a != b:\n        return False\n    a = [s1[1], s1[3]]\n    b = [s2[1], s2[3]]\n    a.sort()\n    b.sort()\n    return a == b\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    \n    def cal(i):\n        if i=='z':\n            return 'a'\n        return chr(ord(i)+1)\n    \n    n1 = len(str1)\n    n2 = len(str2)\n    \n    i = 0\n    j = 0\n    \n    while i<n1 and j<n2:\n        if str1[i]==str2[j] or cal(str1[i])==str2[j]:\n            i+=1\n            j+=1\n        else:\n            i+=1\n    \n    return j>=n2\n\ndef len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max"}, {"source": "livecodebench-execution", "id": "sample_200", "function_name": "minOperations", "code": "def minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)", "distractor_code": "def minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a = nums.index(1)\n    b = nums.index(n)\n    \n    if a < b:\n        return a + n - 1 - b\n    else:\n        return a + n - 1 - b - 1"}, {"source": "livecodebench-execution", "id": "sample_201", "function_name": "minOperations", "code": "def minOperations(nums: List[int], target: int) -> int:\n    if sum(nums)<target:return -1\n    cnt=[0]*32\n    for a in nums:\n        l=a.bit_length()-1\n        cnt[l]+=1\n    ans=0\n    for k in range(31):\n        if target>>k&1:\n            i=k\n            while cnt[i]==0:i+=1\n            while i>k:\n                cnt[i]-=1\n                cnt[i-1]+=2\n                ans+=1\n                i-=1\n            cnt[k]-=1\n        cnt[k+1]+=cnt[k]//2\n    return ans", "distractor_code": "def minOperations(nums: List[int], target: int) -> int:\n    if sum(nums)<target:return -1\n    cnt=[0]*32\n    for a in nums:\n        l=a.bit_length()-1\n        cnt[l]+=1\n    ans=0\n    for k in range(31):\n        if target>>k&1:\n            i=k\n            while cnt[i]==0:i+=1\n            while i>k:\n                cnt[i]-=1\n                cnt[i-1]+=2\n                ans+=1\n                i-=1\n            cnt[k]-=1\n        cnt[k+1]+=cnt[k]//2\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        check = True\n        for j in range(n - i + 1, n * 2 - i):\n            if nums[j % n] < nums[(j - 1) % n]:\n                check = False\n                break\n        if check: return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_202", "function_name": "minimumOperations", "code": "def minimumOperations(num: str) -> int:\n    n = len(num)\n    ans = n - num.count(\"0\")\n    \n    a = [\"00\", \"25\", \"75\", \"50\"]\n    \n    for x in a:\n        \n        i = 1\n        j = n-1\n        while j >= 0 and i >= 0:\n            if j >= 0 and num[j] == x[i]:\n                i -= 1\n                j -= 1\n            else:\n                j -= 1\n        if i >= 0: continue\n        ans = min(ans, n - (j+3))\n    return ans", "distractor_code": "def minimumSum(nums: List[int]) -> int:\n    p = list(accumulate(nums, min))\n    s = list(accumulate(nums[::-1], min))[::-1]\n    m = inf\n    for i in range(1, len(nums)-1):\n        if p[i-1] < nums[i] and s[i+1] < nums[i]:\n            m = min(m, p[i-1] + nums[i] + s[i+1])\n    return -1 if m == inf else m\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    s = sum(sorted(prices)[:2])\n    return money-s if s<=money else money\n\ndef minimumOperations(num: str) -> int:\n    n = len(num)\n    ans = n - num.count(\"0\")\n    \n    a = [\"00\", \"25\", \"75\", \"50\"]\n    \n    for x in a:\n        \n        i = 1\n        j = n-1\n        while j >= 0 and i >= 0:\n            if j >= 0 and num[j] == x[i]:\n                i -= 1\n                j -= 1\n            else:\n                j -= 1\n        if i >= 0: continue\n        ans = min(ans, n - (j+3))\n    return ans\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_203", "function_name": "minimumOperations", "code": "def minimumOperations(num: str) -> int:\n    ends = ['00', '25', '50', '75']\n    \n    num = '00'+num\n    \n    ans = len(num)-2\n    n = len(num)\n    \n    for e in ends:\n        u, v = e[0], e[1]\n        \n        idx1 = n-1\n        while idx1 > 0 and num[idx1] != v:\n            idx1 -= 1\n        idx2 = idx1-1\n        while idx2 > 0 and num[idx2] != u:\n            idx2 -= 1\n        if idx1 > 0 and idx2 > 0:\n            ans = min(ans, n-2-idx2)\n        \n    return ans", "distractor_code": "def minimumOperations(num: str) -> int:\n    ends = ['00', '25', '50', '75']\n    \n    num = '00'+num\n    \n    ans = len(num)-2\n    n = len(num)\n    \n    for e in ends:\n        u, v = e[0], e[1]\n        \n        idx1 = n-1\n        while idx1 > 0 and num[idx1] != v:\n            idx1 -= 1\n        idx2 = idx1-1\n        while idx2 > 0 and num[idx2] != u:\n            idx2 -= 1\n        if idx1 > 0 and idx2 > 0:\n            ans = min(ans, n-2-idx2)\n        \n    return ans\n\ndef upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n\ndef sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)"}, {"source": "livecodebench-execution", "id": "sample_204", "function_name": "minimumOperations", "code": "def minimumOperations(s: str) -> int:\n    # 删空\n    ans = len(s)\n    # 留 1\n    if s.count('0'):\n        ans = len(s) - 1\n    st = {'00', '25', '50', '75'}\n    for i, x in enumerate(s):\n        for y in s[i + 1:]:\n            # 00 25 50 75\n            if x + y in st:\n                ans = min(ans, len(s) - i - 2)\n    return ans", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res \n\ndef minimumOperations(s: str) -> int:\n    # 删空\n    ans = len(s)\n    # 留 1\n    if s.count('0'):\n        ans = len(s) - 1\n    st = {'00', '25', '50', '75'}\n    for i, x in enumerate(s):\n        for y in s[i + 1:]:\n            # 00 25 50 75\n            if x + y in st:\n                ans = min(ans, len(s) - i - 2)\n    return ans\n\nimport math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN "}, {"source": "livecodebench-execution", "id": "sample_205", "function_name": "minimumOperations", "code": "def minimumOperations(num: str) -> int:\n    ans = len(num) - 1 if \"0\" in num else len(num)\n    modes = [\"00\", \"25\", \"50\", \"75\"]\n    for mode in modes:\n        i, j = len(num) - 1, len(mode) - 1\n        cur = 0\n        while i >= 0:\n            if num[i] == mode[j]:\n                i -= 1\n                j -= 1\n                if j == -1:\n                    ans = min(ans, cur)\n                    break\n            else:\n                i -= 1\n                cur += 1\n    return ans", "distractor_code": "def minimumOperations(num: str) -> int:\n    ans = len(num) - 1 if \"0\" in num else len(num)\n    modes = [\"00\", \"25\", \"50\", \"75\"]\n    for mode in modes:\n        i, j = len(num) - 1, len(mode) - 1\n        cur = 0\n        while i >= 0:\n            if num[i] == mode[j]:\n                i -= 1\n                j -= 1\n                if j == -1:\n                    ans = min(ans, cur)\n                    break\n            else:\n                i -= 1\n                cur += 1\n    return ans\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_206", "function_name": "minimumOperations", "code": "def minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1", "distractor_code": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6\n\ndef minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)\n\ndef minimumOperations(num: str) -> int:\n    l = [list(x) for x in ['00', '25', '50', '75']]\n    \n    for i, c in enumerate(('00'+num)[::-1]):\n        for x in l:\n            if c == x[-1]:\n                x.pop()\n            if not x:\n                return i-1\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend([x for x in w.split(separator) if x])\n    return ans\n\ndef isGood(nums: List[int]) -> bool:\n    if len(nums)==1:\n        return False\n    nums.sort()\n    n = len(nums)\n    if nums[-1] != nums[-2]:\n        return False\n    for i in range(n-1):\n        if nums[i] != i+1:\n            return False\n    return True"}, {"source": "livecodebench-execution", "id": "sample_207", "function_name": "minimumOperations", "code": "def minimumOperations(num: str) -> int:\n    min_ops = len(num)\n    for rem in map(list, ('00', '25', '50', '75')):\n        copy = list(num)\n        ops = 0\n        while copy and copy[-1] != rem[-1]:\n            copy.pop(-1)\n            ops += 1\n        while len(copy) >= 2 and copy[-2] != rem[-2]:\n            copy.pop(-2)\n            ops += 1\n        if copy[-2:] == rem:\n            min_ops = min(min_ops, ops)\n    if '0' in num:\n        min_ops = min(min_ops, len(num) - 1)\n    return min_ops", "distractor_code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef minimumOperations(num: str) -> int:\n    min_ops = len(num)\n    for rem in map(list, ('00', '25', '50', '75')):\n        copy = list(num)\n        ops = 0\n        while copy and copy[-1] != rem[-1]:\n            copy.pop(-1)\n            ops += 1\n        while len(copy) >= 2 and copy[-2] != rem[-2]:\n            copy.pop(-2)\n            ops += 1\n        if copy[-2:] == rem:\n            min_ops = min(min_ops, ops)\n    if '0' in num:\n        min_ops = min(min_ops, len(num) - 1)\n    return min_ops\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot"}, {"source": "livecodebench-execution", "id": "sample_208", "function_name": "countInterestingSubarrays", "code": "def countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans", "distractor_code": "def countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    ans = None\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            t = s[i:j+1]\n            if t.count('1') == k and (ans is None or len(t) < len(ans) or (len(t) == len(ans) and t < ans)):\n                ans = t\n    return \"\" if ans is None else ans\n\nfrom collections import defaultdict\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    aa=[]\n    for c in s:\n        if c in \"aiueo\":\n            aa.append(1)\n        else:\n            aa.append(-1)\n    a2i=defaultdict(list)\n    a2i[0].append(0)\n    ans=s=0\n    for i,a in enumerate(aa):\n        s+=a\n        for j in a2i[s]:\n            if (((i+1-j)//2)**2)%k==0:\n                ans+=1\n        a2i[s].append(i+1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_209", "function_name": "countInterestingSubarrays", "code": "from collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans", "distractor_code": "def checkArray(nums: List[int], k: int) -> bool:\n    a = [0] * (len(nums) + 1)\n    s = 0\n    for i in range(len(nums)):\n        s += a[i]\n        nums[i] -= s\n        if nums[i] < 0:\n            return False\n        if i <= len(nums) - k:\n            s += nums[i]\n            a[i + k] -= nums[i]\n            nums[i] = 0\n    return not any(nums)\n\nfrom collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans\n\ndef sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\n\ndef overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_210", "function_name": "countInterestingSubarrays", "code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res", "distractor_code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\ndef get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count \n\ntmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) "}, {"source": "livecodebench-execution", "id": "sample_211", "function_name": "countInterestingSubarrays", "code": "def countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    cnt = {}\n    s = 0\n    cnt[0]=1\n    ans = 0\n    for c in nums:\n        if c%modulo==k:\n            s+=1\n            s%=modulo\n        ns = s-k\n        if ns<0:\n            ns+=modulo\n        if ns in cnt:\n            ans+=cnt[ns]\n        if s not in cnt:\n            cnt[s]=0\n        cnt[s]+=1\n    return ans", "distractor_code": "tmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0\n\ndef maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans\n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    cnt = {}\n    s = 0\n    cnt[0]=1\n    ans = 0\n    for c in nums:\n        if c%modulo==k:\n            s+=1\n            s%=modulo\n        ns = s-k\n        if ns<0:\n            ns+=modulo\n        if ns in cnt:\n            ans+=cnt[ns]\n        if s not in cnt:\n            cnt[s]=0\n        cnt[s]+=1\n    return ans\n\ndef max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum"}, {"source": "livecodebench-execution", "id": "sample_212", "function_name": "countInterestingSubarrays", "code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    a = [0 for _ in range(n + 1)]\n    def zero():\n        return 0\n    \n    for i in range(n):\n        if nums[i] % m == k:\n            a[i + 1] = 1\n    \n    for i in range(1, n + 1):\n        a[i] += a[i - 1] \n        \n    cnt_m = collections.defaultdict(zero)\n    ans = 0\n    for i in range(n + 1):\n        ans += cnt_m[(a[i] - k + m) % m]\n        cnt_m[a[i] % m] += 1\n    return ans", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    \n    def cal(i):\n        if i=='z':\n            return 'a'\n        return chr(ord(i)+1)\n    \n    n1 = len(str1)\n    n2 = len(str2)\n    \n    i = 0\n    j = 0\n    \n    while i<n1 and j<n2:\n        if str1[i]==str2[j] or cal(str1[i])==str2[j]:\n            i+=1\n            j+=1\n        else:\n            i+=1\n    \n    return j>=n2\n\nimport re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    a = [0 for _ in range(n + 1)]\n    def zero():\n        return 0\n    \n    for i in range(n):\n        if nums[i] % m == k:\n            a[i + 1] = 1\n    \n    for i in range(1, n + 1):\n        a[i] += a[i - 1] \n        \n    cnt_m = collections.defaultdict(zero)\n    ans = 0\n    for i in range(n + 1):\n        ans += cnt_m[(a[i] - k + m) % m]\n        cnt_m[a[i] % m] += 1\n    return ans\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_213", "function_name": "countInterestingSubarrays", "code": "def countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    cnt=0\n    ans=0\n    last=-1\n    c=Counter([0])\n    for x in nums:\n        if x%m==k:\n            cnt+=1\n        ans+=c[(cnt-k)%m]\n\n        \n        c[cnt%m]+=1\n\n        \n            # last=i\n        \n        \n    return ans", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans\n\ndef overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ans = 0 \n    \n    while mainTank >= 5:\n        mainTank -= 5 \n        if additionalTank:\n            additionalTank -=1 \n            mainTank += 1\n        ans += 5 \n    ans += mainTank\n    return 10 * ans\n\ndef is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n \n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if gcd(int(str(nums[i])[0]), int(str(nums[j])[-1])) == 1:\n                ans += 1\n    return ans\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    cnt=0\n    ans=0\n    last=-1\n    c=Counter([0])\n    for x in nums:\n        if x%m==k:\n            cnt+=1\n        ans+=c[(cnt-k)%m]\n\n        \n        c[cnt%m]+=1\n\n        \n            # last=i\n        \n        \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_214", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)", "distractor_code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if 1 not in nums:\n        return 0\n    \n    MOD = 10 ** 9 + 7\n    ans = 1\n    ones = [i for i in range(len(nums)) if nums[i] == 1]\n    \n    for i in range(1, len(ones)):\n        ans = (ans * (ones[i] - ones[i - 1])) % MOD\n    \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_215", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    cnt = [0] * (101)\n    for l,r in nums:\n        for j in range(l, r + 1):\n            cnt[j] = 1\n    return sum(cnt)", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    q = deque()\n    ans = 0\n    for x in nums:\n        q.append(x)\n        while q[0] < x - k - k:\n            q.popleft()\n        ans = max(ans, len(q))\n    return ans\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    cnt = [0] * (101)\n    for l,r in nums:\n        for j in range(l, r + 1):\n            cnt[j] = 1\n    return sum(cnt)\n\ndef sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\nimport math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); "}, {"source": "livecodebench-execution", "id": "sample_216", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for l, r in nums:\n        s |= set(range(l, r + 1))\n        \n    return (len(s))", "distractor_code": "def removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for l, r in nums:\n        s |= set(range(l, r + 1))\n        \n    return (len(s))\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result\n\ndef is_octagonal(n): \n\treturn 3 * n * n - 2 * n "}, {"source": "livecodebench-execution", "id": "sample_217", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    dp=[0]*105\n    for l,r in nums:\n        for i in range(l,r+1):dp[i]=1\n    return sum(dp)", "distractor_code": "from typing import *\n\nfrom math import *\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <=2:\n        return True\n    for i in range(len(nums)-1):\n        if sum(nums[i:i+2]) >= m:\n            return True\n    return False\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    dp=[0]*105\n    for l,r in nums:\n        for i in range(l,r+1):dp[i]=1\n    return sum(dp)"}, {"source": "livecodebench-execution", "id": "sample_218", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    c = set()\n    for start, end in nums:\n        for i in range(start, end + 1):\n            c.add(i)\n    return len(c)", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    x = Counter(nums).values()\n    m = inf\n    for n in range(1, min(x) + 1):\n        y = 0\n        for v in x:\n            if v // n < (v + n) // (n + 1):\n                break\n            y += (v + n) // (n + 1)\n        else:\n            m = min(m, y)\n            \n    return m\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    c = set()\n    for start, end in nums:\n        for i in range(start, end + 1):\n            c.add(i)\n    return len(c)\n\ndef finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)"}, {"source": "livecodebench-execution", "id": "sample_219", "function_name": "numberOfPoints", "code": "def numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)"}, {"source": "livecodebench-execution", "id": "sample_220", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef closest_num(N):\n  return (N - 1)"}, {"source": "livecodebench-execution", "id": "sample_221", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0\n\ndef max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False"}, {"source": "livecodebench-execution", "id": "sample_222", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)", "distractor_code": "def checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    answer = [None for i in range(n)]\n    vowels = []\n    v2 = []\n    for i in range(n):\n        if s[i] not in 'aeiouAEIOU':\n            answer[i] = s[i]\n        else:\n            vowels.append(s[i])\n            v2.append(i)\n    vowels = sorted(vowels, key=lambda a: ord(a))\n    m = len(vowels)\n    for i in range(m):\n        c, j = vowels[i], v2[i]\n        answer[j] = c\n    return ''.join(answer)\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)"}, {"source": "livecodebench-execution", "id": "sample_223", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)\n\ndef maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums)<target:return -1\n    cnt=[0]*32\n    for a in nums:\n        l=a.bit_length()-1\n        cnt[l]+=1\n    ans=0\n    for k in range(31):\n        if target>>k&1:\n            i=k\n            while cnt[i]==0:i+=1\n            while i>k:\n                cnt[i]-=1\n                cnt[i-1]+=2\n                ans+=1\n                i-=1\n            cnt[k]-=1\n        cnt[k+1]+=cnt[k]//2\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_224", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\ndef empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit\n\ndef max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum"}, {"source": "livecodebench-execution", "id": "sample_225", "function_name": "sumIndicesWithKSetBits", "code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    \n    nums.sort()\n    n = len(nums)\n    \n    ans = float('inf')\n    \n    for i in range(1,n):\n        gap = nums[i] - nums[i-1]\n        \n        ans = min(ans, gap)\n    \n    return ans\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    i = 0\n    while nums[i] != 1:\n        i += 1\n    while i > 0:\n        nums[i - 1], nums[i] = nums[i], nums[i - 1]\n        i -= 1\n        ans += 1\n    assert nums[0] == 1\n    i = 0\n    while nums[i] != n:\n        i += 1\n    while i + 1 < n:\n        nums[i + 1], nums[i] = nums[i], nums[i + 1]\n        i += 1\n        ans += 1\n    assert nums[n - 1] == n\n    return ans\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    num = []\n    cnt = 0\n    ans = []\n    for word in words:\n        if word == \"prev\":\n            cnt += 1\n            if cnt <= len(num):\n                ans.append(num[- cnt])\n            else:\n                ans.append(-1)\n        else:\n            cnt = 0\n            num.append(int(word))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_226", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    n = len(nums)\n    nums.sort()\n    c = 0\n    for g in range(n+1):\n        l = (g == 0) or g > nums[g-1]\n        r = (g == n) or g < nums[g]\n        c += l and r\n    return int(c)", "distractor_code": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\n\ndef countWays(nums: List[int]) -> int:\n    n = len(nums)\n    nums.sort()\n    c = 0\n    for g in range(n+1):\n        l = (g == 0) or g > nums[g-1]\n        r = (g == n) or g < nums[g]\n        c += l and r\n    return int(c)"}, {"source": "livecodebench-execution", "id": "sample_227", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans", "distractor_code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False\n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x\n\ndef is_Diff(n): \n    return (n % 11 == 0) \n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_228", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    \n    res = 1  # select all\n    \n    if nums.count(0) == 0:  # select none\n        res += 1\n    \n    for i,(x,y) in enumerate(zip(nums, nums[1:]), start=1):\n        if x < i < y:\n            # print(x,i,y)\n            res += 1\n            \n    # print()\n    \n    return res", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    num = []\n    cnt = 0\n    ans = []\n    for word in words:\n        if word == \"prev\":\n            cnt += 1\n            if cnt <= len(num):\n                ans.append(num[- cnt])\n            else:\n                ans.append(-1)\n        else:\n            cnt = 0\n            num.append(int(word))\n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    \n    res = 1  # select all\n    \n    if nums.count(0) == 0:  # select none\n        res += 1\n    \n    for i,(x,y) in enumerate(zip(nums, nums[1:]), start=1):\n        if x < i < y:\n            # print(x,i,y)\n            res += 1\n            \n    # print()\n    \n    return res\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss\n\ndef minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1"}, {"source": "livecodebench-execution", "id": "sample_229", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans", "distractor_code": "def numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([x for x in hours if x >= target])\n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans\n\ndef finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_230", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    n = len(nums)\n    ans = 0\n    # 都选\n    ans += n > nums[0]\n    \n    # 都不选\n    ans += 0 < nums[-1]\n    \n    for i in range(n - 1):\n        # 前面都不选，后面都选\n        v = n - 1 - i\n        ans += v < nums[i] and v > nums[i + 1]\n    \n    return ans", "distractor_code": "def maximumOddBinaryNumber(s: str) -> str:\n    o = -1\n    m = 0\n    for c in s:\n        if c == '1':\n            o += 1\n        else:\n            m += 1\n    \n    return '1' * o + '0' * m + '1'\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    n = len(nums)\n    ans = 0\n    # 都选\n    ans += n > nums[0]\n    \n    # 都不选\n    ans += 0 < nums[-1]\n    \n    for i in range(n - 1):\n        # 前面都不选，后面都选\n        v = n - 1 - i\n        ans += v < nums[i] and v > nums[i + 1]\n    \n    return ans\n\ndef find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n \n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    n = len(nums)\n    for i in range(n):\n        nums[i] = 1 if (nums[i] % m) == k else 0\n    res = 0\n    h = Counter()\n    h[0] = 1\n    s = 0\n    # (s - x + m) % m = k\n    for i in nums:\n        s = (s + i) % m\n        x = (s - k + m) % m\n        if x < 0:\n            x += m\n        res += h[x]\n        h[s] += 1\n    return res\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)"}, {"source": "livecodebench-execution", "id": "sample_231", "function_name": "countWays", "code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_232", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    a = s.count('1')\n    b = s.count('0')\n    \n    res = '1'*(a-1) + '0'*(b) + '1'\n    return res", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False\n\ndef sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    a = s.count('1')\n    b = s.count('0')\n    \n    res = '1'*(a-1) + '0'*(b) + '1'\n    return res"}, {"source": "livecodebench-execution", "id": "sample_233", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    c = 0\n    for x in s:\n        if x == '1':\n            c += 1\n    n = len(s)\n    return (c-1)*'1'+(n-c)*'0'+'1'", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    res = 10 ** 10\n    # 枚举最大的\n    for i in range(len(nums) - 1, 0, -1):\n        # 最大的是 nums[i]\n        # 最小的是 nums[i-1]\n        res = min(res, nums[i] - nums[i - 1])\n    return res\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef maximumOddBinaryNumber(s: str) -> str:\n    c = 0\n    for x in s:\n        if x == '1':\n            c += 1\n    n = len(s)\n    return (c-1)*'1'+(n-c)*'0'+'1'"}, {"source": "livecodebench-execution", "id": "sample_234", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    n = len(s)\n    num_1s = s.count('1')\n    st = '1' * (num_1s - 1)\n    st += '0' * (n - num_1s)\n    st += '1'\n    return st", "distractor_code": "def maximumOddBinaryNumber(s: str) -> str:\n    n = len(s)\n    num_1s = s.count('1')\n    st = '1' * (num_1s - 1)\n    st += '0' * (n - num_1s)\n    st += '1'\n    return st\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n\ndef sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)"}, {"source": "livecodebench-execution", "id": "sample_235", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n\ndef maximumOddBinaryNumber(s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'"}, {"source": "livecodebench-execution", "id": "sample_236", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    o = -1\n    m = 0\n    for c in s:\n        if c == '1':\n            o += 1\n        else:\n            m += 1\n    \n    return '1' * o + '0' * m + '1'", "distractor_code": "def longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    n=len(nums)\n    d=0\n    for i in range(n):\n        if nums[i]%2!=0 or nums[i]>t: continue\n        d=max(d,1)\n        for j in range(i+1,n):\n            if nums[j]>t: break\n            if nums[j]%2==nums[j-1]%2: break\n            d=max(d,j-i+1)\n    return d\n\ndef tup_string(tup1):\n  str =  ''.join(tup1)\n  return str\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count \n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    o = -1\n    m = 0\n    for c in s:\n        if c == '1':\n            o += 1\n        else:\n            m += 1\n    \n    return '1' * o + '0' * m + '1'"}, {"source": "livecodebench-execution", "id": "sample_237", "function_name": "maximumOddBinaryNumber", "code": "def maximumOddBinaryNumber(s: str) -> str:\n    o = s.count('1')\n    z = len(s)-o\n    return '1'*(o-1)+'0'*z+'1'", "distractor_code": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans\n\ndef minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]\n\ndef maximumOddBinaryNumber(s: str) -> str:\n    o = s.count('1')\n    z = len(s)-o\n    return '1'*(o-1)+'0'*z+'1'"}, {"source": "livecodebench-execution", "id": "sample_238", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n    n =len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n\n    return ans", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2\n\ndef isGood(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums) - 1\n    \n    res = True\n    for i in range(n):\n        if nums[i] != i+1: return False\n    \n    return nums[-1] == n\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    n =len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n\n    return ans\n\ndef max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]"}, {"source": "livecodebench-execution", "id": "sample_239", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans", "distractor_code": "def matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num"}, {"source": "livecodebench-execution", "id": "sample_240", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet\n\ndef min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)"}, {"source": "livecodebench-execution", "id": "sample_241", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    x = 0 # max(ai - aj)\n    mx = 0\n    for y in nums:\n        ans = max(ans, x * y)\n        x = max(x, mx - y)\n        mx = max(mx, y)\n    return ans\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = ''\n    for w in words:\n        t += w[0]\n    return t == s\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l\n\nfrom operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) "}, {"source": "livecodebench-execution", "id": "sample_242", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres", "distractor_code": "def semiOrderedPermutation(nums: List[int]) -> int:\n    a, b = nums.index(1), nums.index(len(nums))\n    if a < b:\n        return a + len(nums) - b - 1\n    else:\n        return a + len(nums) - b - 2\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    def check(x):\n        num = num1 - x * num2\n        if num <= 0:\n            return False\n        k = 0\n        while num:\n            if num & 1:\n                k += 1\n            num >>= 1\n        # print(num, x, k)\n        return x >= k and num1 - x * num2 >= x\n    \n    for i in range(1, 100):\n        if check(i):\n            return i\n    return -1\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i):\n            ans += chk(nums[j], nums[i])\n    return ans\n\ndef chk(n1, n2):\n    return int(gcd(int(str(n1)[0]), int(str(n2)[-1])) == 1)\n\ndef gcd(x, y):\n    if x % y == 0:\n        return y\n    return gcd(y, x % y)"}, {"source": "livecodebench-execution", "id": "sample_243", "function_name": "maximumTripletValue", "code": "def maximumTripletValue(nums: List[int]) -> int:\n    res = 0\n    m = max(nums[0], nums[1])\n    c = max(0, nums[0] - nums[1])\n    for i in range(2, len(nums)):\n        res = max(res, nums[i] * c)\n        c = max(c, m - nums[i])\n        m = max(m, nums[i])\n    return res", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    \n    n = len(nums)\n    can = n-k\n    \n    table = defaultdict(list)        \n    for j in range(len(nums)):\n        table[nums[j]].append(j)\n    ans = 0    \n    \n    for ke in table:\n        lst = table[ke]\n        n1 = len(lst)\n        l = 0\n        for r in range(n1):\n            while lst[r]-lst[l]>=(r-l+1)+k:\n                l+=1\n            ans = max(ans,r-l+1)\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    res = 0\n    m = max(nums[0], nums[1])\n    c = max(0, nums[0] - nums[1])\n    for i in range(2, len(nums)):\n        res = max(res, nums[i] * c)\n        c = max(c, m - nums[i])\n        m = max(m, nums[i])\n    return res\n\ndef minimumSeconds(nums: List[int]) -> int:\n    idxs, res = defaultdict(list), (len(nums))//2\n    for i, n in enumerate(nums): idxs[n].append(i)\n    for n in idxs:\n        idx = idxs[n]\n        if len(idx) != 1:\n            cur = (idx[0]+(len(nums)-idx[-1]))//2\n            for i in range(len(idx)-1): cur = max(cur, (idx[i+1]-idx[i])//2)\n            res = min(res, cur)\n    return res\n\ndef removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_244", "function_name": "differenceOfSums", "code": "def differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    setn = len(set(nums))\n    to_ret = 0\n    for i in range(len(nums)) :\n        set_t = set()\n        for j in range(i, len(nums)) :\n            set_t.add(nums[j])\n            if len(set_t) == setn :\n                to_ret += 1\n    return to_ret\n\ndef max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if s1 == s2 == s3:\n        return 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i] != s2[i] or s1[i] != s3[i]:\n            break\n    else:\n        i += 1\n    if i < 1:\n        return -1\n    else:\n        return len(s1) - i + (len(s2) - i) + (len(s3) - i)\n\ndef string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_245", "function_name": "differenceOfSums", "code": "def differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n + 1) if i % m != 0) - sum(i for i in range(1, n + 1) if i % m == 0)", "distractor_code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n + 1) if i % m != 0) - sum(i for i in range(1, n + 1) if i % m == 0)\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\nimport re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))"}, {"source": "livecodebench-execution", "id": "sample_246", "function_name": "differenceOfSums", "code": "def differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n+1) if i % m != 0) - sum(i for i in range(1, n+1) if i % m == 0)", "distractor_code": "def maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n+1) if i % m != 0) - sum(i for i in range(1, n+1) if i % m == 0)\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res"}, {"source": "livecodebench-execution", "id": "sample_247", "function_name": "minOperations", "code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1", "distractor_code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    \n    return s == \"\".join([w[0] for w in words])\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i"}, {"source": "livecodebench-execution", "id": "sample_248", "function_name": "minOperations", "code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    if (s1.count('1') + s2.count('1')) % 2 == 1:\n        return -1\n    \n    mask = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]\n    \n    @lru_cache\n    def dp(down):\n        if not down:\n            return 0\n        if len(down) == 1:\n            return x\n        \n        return min(2 * (down[1] - down[0]) + dp(tuple(down[2:])), x + dp(tuple(down[1:])))\n        \n    # print(mask, dp(tuple(mask)))\n    return dp(tuple(mask)) // 2", "distractor_code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    if (s1.count('1') + s2.count('1')) % 2 == 1:\n        return -1\n    \n    mask = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]\n    \n    @lru_cache\n    def dp(down):\n        if not down:\n            return 0\n        if len(down) == 1:\n            return x\n        \n        return min(2 * (down[1] - down[0]) + dp(tuple(down[2:])), x + dp(tuple(down[1:])))\n        \n    # print(mask, dp(tuple(mask)))\n    return dp(tuple(mask)) // 2\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n + 1) if i % m != 0) - sum(i for i in range(1, n + 1) if i % m == 0)\n\ntmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True"}, {"source": "livecodebench-execution", "id": "sample_249", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    ans = None\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            t = s[i:j+1]\n            if t.count('1') == k and (ans is None or len(t) < len(ans) or (len(t) == len(ans) and t < ans)):\n                ans = t\n    return \"\" if ans is None else ans", "distractor_code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef smallestString(s: str) -> str:\n    if s == 'a': return 'z'\n    t = list(s)\n    l = r = -1\n    for i, c in enumerate(s):\n        if c != 'a':\n            if l == -1:\n                l = i\n            r = i\n        elif l != -1:\n            break\n    if l != -1:\n        for i in range(l, r + 1):\n            t[i] = chr(ord(t[i]) - 1)\n    else:\n        t[-1] = 'z'\n    return ''.join(t)\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    ans = None\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            t = s[i:j+1]\n            if t.count('1') == k and (ans is None or len(t) < len(ans) or (len(t) == len(ans) and t < ans)):\n                ans = t\n    return \"\" if ans is None else ans\n\ndef distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans\n\ndef tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6"}, {"source": "livecodebench-execution", "id": "sample_250", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''", "distractor_code": "def minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) "}, {"source": "livecodebench-execution", "id": "sample_251", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    N = len(s)\n    min_len = inf\n    ans = 'z' * 101\n\n    for right in range(N + 1):\n        for left in range(right):\n            ss = s[left:right]\n            if ss.count('1') == k:\n                if len(ss) < min_len or (len(ss) == min_len and ss < ans):\n                    min_len = len(ss)\n                    ans = ss\n\n    return \"\" if min_len == inf else ans", "distractor_code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    N = len(s)\n    min_len = inf\n    ans = 'z' * 101\n\n    for right in range(N + 1):\n        for left in range(right):\n            ss = s[left:right]\n            if ss.count('1') == k:\n                if len(ss) < min_len or (len(ss) == min_len and ss < ans):\n                    min_len = len(ss)\n                    ans = ss\n\n    return \"\" if min_len == inf else ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d=[0]*(target+1)\n    t=[el for el in nums if el<=target]\n    if len(t)==0:\n        return -1\n    d[t[0]]=1\n    for el in t[1:]:\n        for j in range(target,0,-1):\n            if j-el>=0 and (j-el==0 or d[j-el]>0):\n                d[j]=max(d[j],d[j-el]+1)\n    if d[target]==0:\n        return -1\n    return d[target]\n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num "}, {"source": "livecodebench-execution", "id": "sample_252", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    beauty = \"\"\n    n = len(s)\n    min_len = None\n    for ln in range(k, n+1):\n        for i in range(n-ln+1):\n            ss = s[i:i+ln]\n            if len([c for c in ss if c == '1']) == k:\n                min_len = ln\n                if not beauty or ss < beauty:\n                    beauty = ss\n        if min_len:\n            break\n    return beauty", "distractor_code": "def minimumSeconds(nums: List[int]) -> int:\n    ref = defaultdict(list)\n    for i in range(len(nums)):\n        ref[nums[i]].append(i)\n    ans = inf\n    for i in ref:\n        k = 0\n        for j in range(len(ref[i])):\n            x = ref[i][j]\n            y = ref[i][j - 1]\n            if x > y:\n                k = max(k, x - y - 1)\n            else:\n                k = max(k, len(nums) - y + x - 1)\n        if k % 2== 1:\n            k += 1\n        ans = min(ans, k // 2)\n    return ans\n\ndef rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    beauty = \"\"\n    n = len(s)\n    min_len = None\n    for ln in range(k, n+1):\n        for i in range(n-ln+1):\n            ss = s[i:i+ln]\n            if len([c for c in ss if c == '1']) == k:\n                min_len = ln\n                if not beauty or ss < beauty:\n                    beauty = ss\n        if min_len:\n            break\n    return beauty\n\ndef max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)"}, {"source": "livecodebench-execution", "id": "sample_253", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    res = (float('inf'), \"\")\n    for i in range(n):\n        ctr = 0\n        for j in range(i, n):\n            ctr += int(s[j])\n            if ctr == k:\n                res = min(res, (j - i + 1, s[i : j + 1]))\n    return res[1]", "distractor_code": "def furthestDistanceFromOrigin(moves: str) -> int:\n    ret = moves.count('_')\n    diff = abs(moves.count('L') - moves.count('R'))\n    return ret + diff\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    res = (float('inf'), \"\")\n    for i in range(n):\n        ctr = 0\n        for j in range(i, n):\n            ctr += int(s[j])\n            if ctr == k:\n                res = min(res, (j - i + 1, s[i : j + 1]))\n    return res[1]\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    n = len(nums)\n    ans = 0\n    # 都选\n    ans += n > nums[0]\n    \n    # 都不选\n    ans += 0 < nums[-1]\n    \n    for i in range(n - 1):\n        # 前面都不选，后面都选\n        v = n - 1 - i\n        ans += v < nums[i] and v > nums[i + 1]\n    \n    return ans\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans\n\ndef minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1"}, {"source": "livecodebench-execution", "id": "sample_254", "function_name": "shortestBeautifulSubstring", "code": "def shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]\n\ndef lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited\n\ndef is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False"}, {"source": "livecodebench-execution", "id": "sample_255", "function_name": "minimumSum", "code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = math.inf\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if nums[i] < nums[j] and nums[k] < nums[j]:\n                    ans = min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=math.inf else -1", "distractor_code": "def maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)\n\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = math.inf\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if nums[i] < nums[j] and nums[k] < nums[j]:\n                    ans = min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=math.inf else -1\n\ndef minimizedStringLength(s: str) -> int:\n    graph = collections.defaultdict(int)\n    \n    for char in s:\n        graph[char] += 1\n    \n    return len(graph)"}, {"source": "livecodebench-execution", "id": "sample_256", "function_name": "minimumSum", "code": "def minimumSum(nums: List[int]) -> int:\n    p = list(accumulate(nums, min))\n    s = list(accumulate(nums[::-1], min))[::-1]\n    m = inf\n    for i in range(1, len(nums)-1):\n        if p[i-1] < nums[i] and s[i+1] < nums[i]:\n            m = min(m, p[i-1] + nums[i] + s[i+1])\n    return -1 if m == inf else m", "distractor_code": "def minimumSeconds(nums: List[int]) -> int:\n    d = defaultdict(list)\n    for i, j in enumerate(nums):\n        d[j].append(i)\n    n = len(nums)\n    ret = n // 2\n    for l in d.values():\n        r = 0\n        q = len(l)\n        for i, j in enumerate(l):\n            if i < q - 1:\n                k = l[i + 1]\n            else:\n                k = l[0] + n\n            r = max(r, (k - j) // 2)\n        ret = min(ret, r)\n    return ret\n\ndef search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)\n\ndef minimumSum(nums: List[int]) -> int:\n    p = list(accumulate(nums, min))\n    s = list(accumulate(nums[::-1], min))[::-1]\n    m = inf\n    for i in range(1, len(nums)-1):\n        if p[i-1] < nums[i] and s[i+1] < nums[i]:\n            m = min(m, p[i-1] + nums[i] + s[i+1])\n    return -1 if m == inf else m\n\ndef minimumSum(n: int, k: int) -> int:\n    seen = set()\n    x = 0\n    while len(seen) < n:\n        x += 1\n        if k-x not in seen:\n            seen.add(x)\n    \n    return sum(seen)"}, {"source": "livecodebench-execution", "id": "sample_257", "function_name": "minimumSum", "code": "def minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)"}, {"source": "livecodebench-execution", "id": "sample_258", "function_name": "minimumSum", "code": "def minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[j] > max(nums[i], nums[k]):\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans < inf else -1", "distractor_code": "def minimumSum(n: int, k: int) -> int:\n    s = set()\n    current = 1\n    \n    while len(s) < n:\n        if k - current not in s:\n            s.add(current)\n        current += 1\n    return sum(list(s))\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[j] > max(nums[i], nums[k]):\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans < inf else -1\n\ndef find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_259", "function_name": "minimumSum", "code": "def minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1", "distractor_code": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False\n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1"}, {"source": "livecodebench-execution", "id": "sample_260", "function_name": "minimumSum", "code": "def minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1", "distractor_code": "def minimumSum(nums: list[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] < nums[j] and nums[j] > nums[k]:\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans != inf else -1\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp = [0]*(target + 1)\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] or not i:\n                dp[i + x] = max(dp[i + x], dp[i] + 1)\n    \n    return dp[-1] if dp[-1] else -1\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-i-1]))\n    if len(s) & 1:\n        ans = ans + [s[len(s) // 2]] + ans[::-1]\n    else:\n        ans = ans + ans[::-1]\n    return ''.join(ans)\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx"}, {"source": "livecodebench-execution", "id": "sample_261", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_262", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])", "distractor_code": "def canBeEqual(s1: str, s2: str) -> bool:\n    def sign(s):\n        return sorted(s[::2]), sorted(s[1::2])\n        \n    return sign(s1) == sign(s2)\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    d = collections.Counter(nums)\n    s = [d[i] for i in  d]\n    s.sort()\n\n    def f(x,n):\n        b = x//(n-1)\n        if x%(n-1)==0: return True\n        a = x - (n-1) * b\n        if a <= b:return True\n    for i in range(s[0]+1,1,-1):\n\n        if all(f(j,i) for j in s):\n\n            return  sum([j//i+(j%i !=0)  for j in s])\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    n = len(nums)\n    for k,v in c.items():\n        if v >= n - v:\n            return v - (n - v)\n    return n % 2\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for x in nums:\n        s.add(x)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(list(s))\n\ndef empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit"}, {"source": "livecodebench-execution", "id": "sample_263", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans\n\ndef tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result\n\ndef maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b \n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)\n\ndef findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_264", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    x = Counter(nums).values()\n    m = inf\n    for n in range(1, min(x) + 1):\n        y = 0\n        for v in x:\n            if v // n < (v + n) // (n + 1):\n                break\n            y += (v + n) // (n + 1)\n        else:\n            m = min(m, y)\n            \n    return m", "distractor_code": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; \n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans\n\ndef Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    x = Counter(nums).values()\n    m = inf\n    for n in range(1, min(x) + 1):\n        y = 0\n        for v in x:\n            if v // n < (v + n) // (n + 1):\n                break\n            y += (v + n) // (n + 1)\n        else:\n            m = min(m, y)\n            \n    return m"}, {"source": "livecodebench-execution", "id": "sample_265", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    n = len(nums)\n    A = sorted(list(Counter(nums).values()))\n    \n    x = A[0]\n    @lru_cache(None)\n    def dp(y,x):\n        if y == 0:\n            return 0\n        if y < x:\n            return math.inf\n        if y==x or y == x+1:\n            return 1\n        return 1+min(dp(y-x,x),dp(y-x-1,x))\n    \n    while x:\n        ans = sum(dp(y,x) for y in A)\n        if ans < math.inf:\n            return ans\n        x=x-1", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    n = len(nums)\n    A = sorted(list(Counter(nums).values()))\n    \n    x = A[0]\n    @lru_cache(None)\n    def dp(y,x):\n        if y == 0:\n            return 0\n        if y < x:\n            return math.inf\n        if y==x or y == x+1:\n            return 1\n        return 1+min(dp(y-x,x),dp(y-x-1,x))\n    \n    while x:\n        ans = sum(dp(y,x) for y in A)\n        if ans < math.inf:\n            return ans\n        x=x-1\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    n = len(nums)\n    for k,v in c.items():\n        if v >= n - v:\n            return v - (n - v)\n    return n % 2\n\ndef max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n\ndef square_perimeter(a):\n  perimeter=4*a\n  return perimeter"}, {"source": "livecodebench-execution", "id": "sample_266", "function_name": "minGroupsForValidAssignment", "code": "def minGroupsForValidAssignment(nums: List[int]) -> int:\n    def count(unit):\n        res = 0\n        for value in counter.values():\n            d, r = divmod(value, unit)\n            if r > d:\n                return -1\n            res += -(-value // (unit + 1))\n        return res\n        \n    counter, n = Counter(nums), len(nums)\n    for unit in range(min(counter.values()), 0, -1):\n        res = count(unit)\n        if res != -1:\n            return res", "distractor_code": "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False\n\ndef all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    def count(unit):\n        res = 0\n        for value in counter.values():\n            d, r = divmod(value, unit)\n            if r > d:\n                return -1\n            res += -(-value // (unit + 1))\n        return res\n        \n    counter, n = Counter(nums), len(nums)\n    for unit in range(min(counter.values()), 0, -1):\n        res = count(unit)\n        if res != -1:\n            return res\n\ndef minimumOperations(s: str) -> int:\n    # 删空\n    ans = len(s)\n    # 留 1\n    if s.count('0'):\n        ans = len(s) - 1\n    st = {'00', '25', '50', '75'}\n    for i, x in enumerate(s):\n        for y in s[i + 1:]:\n            # 00 25 50 75\n            if x + y in st:\n                ans = min(ans, len(s) - i - 2)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_267", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    def f(nums):\n        return sum(max(1, x) for x in nums)\n    a = f(nums1)\n    b = f(nums2)\n    if a > b:\n        a, b = b, a\n        nums1, nums2 = nums2, nums1\n    if a != b and 0 not in nums1:\n        return -1\n    return max(a, b)", "distractor_code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    def f(nums):\n        return sum(max(1, x) for x in nums)\n    a = f(nums1)\n    b = f(nums2)\n    if a > b:\n        a, b = b, a\n        nums1, nums2 = nums2, nums1\n    if a != b and 0 not in nums1:\n        return -1\n    return max(a, b)\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)"}, {"source": "livecodebench-execution", "id": "sample_268", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    if nums1.count(0) == 0 and nums2.count(0) == 0:\n        return -1 if sum(nums1) != sum(nums2) else sum(nums1)\n    if nums1.count(0) == 0:\n        ot = sum(nums2) + nums2.count(0)\n        if ot > sum(nums1):\n            return -1\n        \n        return sum(nums1)\n                    \n    if nums2.count(0) == 0:\n        return Solution().minSum(nums2, nums1)\n    \n    return max(nums1.count(0) + sum(nums1), nums2.count(0) + sum(nums2))", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    if nums1.count(0) == 0 and nums2.count(0) == 0:\n        return -1 if sum(nums1) != sum(nums2) else sum(nums1)\n    if nums1.count(0) == 0:\n        ot = sum(nums2) + nums2.count(0)\n        if ot > sum(nums1):\n            return -1\n        \n        return sum(nums1)\n                    \n    if nums2.count(0) == 0:\n        return Solution().minSum(nums2, nums1)\n    \n    return max(nums1.count(0) + sum(nums1), nums2.count(0) + sum(nums2))\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx"}, {"source": "livecodebench-execution", "id": "sample_269", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)", "distractor_code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_270", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)", "distractor_code": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n\n    def is_champ(i):\n        for j in range(n):\n            if j == i:\n                continue\n            if grid[i][j] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        if is_champ(i):\n            return i\n    return -1\n\ndef all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(1, n):\n        if nums[i - 1] + nums[i] >= m:\n            return True\n    return False\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)"}, {"source": "livecodebench-execution", "id": "sample_271", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    \n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    n1z = 0\n    n2z = 0\n    for num in nums1:\n        n1z += num == 0\n    for num in nums2:\n        n2z += num == 0\n    \n    if n2z == 0 and s1 + n1z > s2:\n        return -1\n    if n1z == 0 and s2 + n2z > s1:\n        return -1\n    \n    \n    return max(s1+n1z,s2+n2z)", "distractor_code": "def findValueOfPartition(a: List[int]) -> int:\n    a.sort()\n    ans = a[-1] - a[0]\n    for i in range(len(a) - 1):\n        ans = min(ans, a[i + 1] - a[i])\n    return ans\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    \n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    n1z = 0\n    n2z = 0\n    for num in nums1:\n        n1z += num == 0\n    for num in nums2:\n        n2z += num == 0\n    \n    if n2z == 0 and s1 + n1z > s2:\n        return -1\n    if n1z == 0 and s2 + n2z > s1:\n        return -1\n    \n    \n    return max(s1+n1z,s2+n2z)\n\ndef distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res"}, {"source": "livecodebench-execution", "id": "sample_272", "function_name": "minSum", "code": "def minSum(nums1: List[int], nums2: List[int]) -> int:\n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    empty1 = sum((x == 0) for x in nums1)\n    empty2 = sum((x == 0) for x in nums2)\n    mins1 = s1 + empty1\n    mins2 = s2 + empty2\n    if empty1 == 0 and s1 < mins2:\n        return -1\n    if empty2 == 0 and s2 < mins1:\n        return -1\n    return max(mins1, mins2)", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend([x for x in w.split(separator) if x])\n    return ans\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0\n\ndef distributeCandies(n: int, limit: int) -> int:\n    limit = min(limit, n)\n    ans = 0\n    for i in range(limit+1):\n        if n-i > limit * 2:\n            continue\n        ans += (min(limit, n-i) - max(0, n-i-limit) + 1)\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    s1 = sum(nums1)\n    s2 = sum(nums2)\n    empty1 = sum((x == 0) for x in nums1)\n    empty2 = sum((x == 0) for x in nums2)\n    mins1 = s1 + empty1\n    mins2 = s2 + empty2\n    if empty1 == 0 and s1 < mins2:\n        return -1\n    if empty2 == 0 and s2 < mins1:\n        return -1\n    return max(mins1, mins2)\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far"}, {"source": "livecodebench-execution", "id": "sample_273", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n  n = len(grid)\n  for j in range(n):\n    if all(grid[i][j] == 0 for i in range(n)):\n      return j", "distractor_code": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums\n\ndef findChampion(grid: List[List[int]]) -> int:\n  n = len(grid)\n  for j in range(n):\n    if all(grid[i][j] == 0 for i in range(n)):\n      return j\n\ndef validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True\n\ndef loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0"}, {"source": "livecodebench-execution", "id": "sample_274", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res"}, {"source": "livecodebench-execution", "id": "sample_275", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n\n    def is_champ(i):\n        for j in range(n):\n            if j == i:\n                continue\n            if grid[i][j] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        if is_champ(i):\n            return i\n    return -1", "distractor_code": "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n\n    def is_champ(i):\n        for j in range(n):\n            if j == i:\n                continue\n            if grid[i][j] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        if is_champ(i):\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_276", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1", "distractor_code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1\n\ndef list_split(S, step):\n    return [S[i::step] for i in range(step)]"}, {"source": "livecodebench-execution", "id": "sample_277", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i", "distractor_code": "def differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n + 1) if i % m != 0) - sum(i for i in range(1, n + 1) if i % m == 0)\n\ndef minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\ndef substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) \n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i\n\nfrom typing import List\nfrom itertools import combinations\nfrom functools import reduce\nimport operator\n\ndef maxStrength(nums: List[int]) -> int:\n    n = len(nums)\n    max_strength = float('-inf')\n    \n    for r in range(1, n + 1):\n        for combination in combinations(nums, r):\n            product = reduce(operator.mul, combination, 1)\n            max_strength = max(max_strength, product)\n\n    return max_strength"}, {"source": "livecodebench-execution", "id": "sample_278", "function_name": "findChampion", "code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += grid[i][j]\n        if t == n - 1:\n            return i", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += grid[i][j]\n        if t == n - 1:\n            return i\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited\n\ndef minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_279", "function_name": "minOperations", "code": "# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef square_Sum(n):  \n    return int(n*(4*n*n-1)/3) \n\n# output should be -1..\n\ndef min_swaps(nums1, nums2, max1, max2):\n    total = 0\n    for a, b in zip(nums1, nums2):\n        if max1 >= a and max2 >= b:\n            pass\n        elif max2 >= a and max1 >= b:\n            total += 1\n        else:\n            return -1\n    return total\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    return min(min_swaps(nums1, nums2, nums1[-1], nums2[-1]),\n        min_swaps(nums1, nums2, nums2[-1], nums1[-1]))\n\ndef insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list"}, {"source": "livecodebench-execution", "id": "sample_280", "function_name": "minOperations", "code": "def minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1", "distractor_code": "def minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1\n\nimport heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    n = len(s)\n    tmp = set('aeiou')\n    s = [1 if c in tmp else 0 for c in s]\n    ans = 0\n    for i in range(n):\n        c1, c2 = 0, 0\n        for j in range(i, n):\n            c1 += s[j]\n            c2 += 1 - s[j]\n            if c1 == c2 and c1 * c2 % k == 0:\n                ans += 1\n    return ans\n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]"}, {"source": "livecodebench-execution", "id": "sample_281", "function_name": "minOperations", "code": "def minOperations(a: List[int], b: List[int]) -> int:\n    def f():\n        ret = 0\n        aa, bb = a[:], b[:]\n        for i in range(len(a)):\n            if a[i] > a[-1] or b[i] > b[-1]:\n                a[i], b[i] = b[i], a[i]\n                ret += 1\n            if a[i] > a[-1] or b[i] > b[-1]:\n                return inf\n        a[:] = aa\n        b[:] = bb\n        return ret\n    \n    ans = f()\n    a[-1], b[-1] = b[-1], a[-1]\n    ans = min(ans, f() + 1)\n    return -1 if ans > len(a) else ans", "distractor_code": "def minOperations(a: List[int], b: List[int]) -> int:\n    def f():\n        ret = 0\n        aa, bb = a[:], b[:]\n        for i in range(len(a)):\n            if a[i] > a[-1] or b[i] > b[-1]:\n                a[i], b[i] = b[i], a[i]\n                ret += 1\n            if a[i] > a[-1] or b[i] > b[-1]:\n                return inf\n        a[:] = aa\n        b[:] = bb\n        return ret\n    \n    ans = f()\n    a[-1], b[-1] = b[-1], a[-1]\n    ans = min(ans, f() + 1)\n    return -1 if ans > len(a) else ans\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]\n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0 \n    for i in range(limit+1):\n        for j in range(limit+1):\n            k = n-i-j\n            if 0 <= k <= limit:\n                answer+=1\n    return answer\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    beauty = \"\"\n    n = len(s)\n    min_len = None\n    for ln in range(k, n+1):\n        for i in range(n-ln+1):\n            ss = s[i:i+ln]\n            if len([c for c in ss if c == '1']) == k:\n                min_len = ln\n                if not beauty or ss < beauty:\n                    beauty = ss\n        if min_len:\n            break\n    return beauty"}, {"source": "livecodebench-execution", "id": "sample_282", "function_name": "minOperations", "code": "def minOperations(nums1: List[int], nums2: List[int]) -> int:\n    def check(m1, m2):\n        ans = 0\n        for x1, x2 in zip(nums1, nums2):\n            if x1 > m1 or x2 > m2:\n                if x2 > m1 or x1 > m2:\n                    return inf\n                ans += 1\n        return ans\n    m1 = nums1[-1]\n    m2 = nums2[-1]\n    ans = min(check(m1, m2), check(m2, m1))\n    return -1 if ans == inf else ans", "distractor_code": "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    def check(m1, m2):\n        ans = 0\n        for x1, x2 in zip(nums1, nums2):\n            if x1 > m1 or x2 > m2:\n                if x2 > m1 or x1 > m2:\n                    return inf\n                ans += 1\n        return ans\n    m1 = nums1[-1]\n    m2 = nums2[-1]\n    ans = min(check(m1, m2), check(m2, m1))\n    return -1 if ans == inf else ans"}, {"source": "livecodebench-execution", "id": "sample_283", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1", "distractor_code": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1"}, {"source": "livecodebench-execution", "id": "sample_284", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    ans = len(s1 + s2 + s3)\n    for i in range(len(s1), 0, -1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            return ans - i * 3\n    return -1", "distractor_code": "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    ans = len(s1 + s2 + s3)\n    for i in range(len(s1), 0, -1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            return ans - i * 3\n    return -1\n\ndef minOperations(nums: List[int], k: int) -> int:\n    nums = nums[::-1]\n    s = set()\n    for i,c in enumerate(nums):\n        if c>k:\n            continue\n        s.add(c)\n        if len(s)==k:\n            return i+1;\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums.sort()\n    \n    return min(y - x for x, y in zip(nums, nums[1:]))\n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_285", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    n = len(s1)\n    m = len(s2)\n    k = len(s3)\n    ans = inf\n    for i in range(1, n+1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            x1 = n-i\n            x2 = m-i\n            x3 = k-i\n            cur = x1+x2+x3\n            if cur < ans:\n                ans = cur\n    return ans if ans < inf else -1", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    n = len(s1)\n    m = len(s2)\n    k = len(s3)\n    ans = inf\n    for i in range(1, n+1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            x1 = n-i\n            x2 = m-i\n            x3 = k-i\n            cur = x1+x2+x3\n            if cur < ans:\n                ans = cur\n    return ans if ans < inf else -1\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res\n\ndef splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_286", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3", "distractor_code": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3\n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))"}, {"source": "livecodebench-execution", "id": "sample_287", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if s1 == s2 == s3:\n        return 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i] != s2[i] or s1[i] != s3[i]:\n            break\n    else:\n        i += 1\n    if i < 1:\n        return -1\n    else:\n        return len(s1) - i + (len(s2) - i) + (len(s3) - i)", "distractor_code": "def removeTrailingZeros(a: str) -> str:\n    n = len(a)\n    while n - 1 >= 0 and a[n-1]=='0':\n        n -= 1\n    return a[:n]\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if s1 == s2 == s3:\n        return 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i] != s2[i] or s1[i] != s3[i]:\n            break\n    else:\n        i += 1\n    if i < 1:\n        return -1\n    else:\n        return len(s1) - i + (len(s2) - i) + (len(s3) - i)\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    def cut(s):\n        return (sorted(s[::2]), sorted(s[1::2]))\n    \n    return cut(s1) == cut(s2)\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]"}, {"source": "livecodebench-execution", "id": "sample_288", "function_name": "findMinimumOperations", "code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1", "distractor_code": "def isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)"}, {"source": "livecodebench-execution", "id": "sample_289", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret", "distractor_code": "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\nfrom collections import Counter\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    ctr = Counter(moves)\n    return abs(ctr['L'] - ctr['R']) + ctr['_']\n\ndef minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans\n\ndef minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    ans = None\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            t = s[i:j+1]\n            if t.count('1') == k and (ans is None or len(t) < len(ans) or (len(t) == len(ans) and t < ans)):\n                ans = t\n    return \"\" if ans is None else ans\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES"}, {"source": "livecodebench-execution", "id": "sample_290", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    ans = min(x, y) * 2\n    if x != y:\n        ans += 1\n    return (ans  + z) * 2\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums)==list(range(1,len(nums)))+[len(nums)-1]\n\ndef minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d = defaultdict(lambda : 0)\n    d[0] = 0\n    for i, v in enumerate(nums):\n        if v > target:\n            continue\n        tmp = defaultdict(lambda : 0)\n        tmp[0] = 0\n        for s in d:\n            if s + v > target:\n                continue\n            tmp[s + v] = max(tmp[s + v], d[s] + 1)\n        for s in tmp:\n            d[s] = max(d[s], tmp[s])\n    return d[target] if target in d else -1\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]"}, {"source": "livecodebench-execution", "id": "sample_291", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res", "distractor_code": "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ones = []\n    for i in range(n):\n        if s[i]=='1':\n            ones.append(i)\n    if len(ones) < k:\n        return ''\n    answer = [float('inf'), ''.join(['1' for i in range(n+1)])]\n    for i in range(k-1, len(ones)):\n        i1 = ones[i-k+1]\n        i2 = ones[i]\n        answer =  min(answer, [i2-i1, s[i1:i2+1]])\n    return answer[1]\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res"}, {"source": "livecodebench-execution", "id": "sample_292", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans", "distractor_code": "def minimumSteps(s: str) -> int:\n    ans = c1 = 0\n    for x in s:\n        if x == '1':\n            c1 += 1\n        else:\n            ans += c1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n  n = len(s)\n  result = list(s)\n  \n  for i in range(n // 2):\n    i2 = n - 1 - i\n    if result[i] == result[i2]:\n      continue\n    if result[i] < result[i2]:\n      result[i2] = result[i]\n    else:\n      result[i] = result[i2]\n  \n  return ''.join(result)\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res, target = 0, nums[0]\n    for n in nums[1:]: target &= n\n    if target != 0: return 1\n    cur = -1\n    for n in nums:\n        if cur == -1: cur = n\n        cur &= n\n        if cur == target:\n            cur = -1\n            res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_293", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    n = len(s)\n    idx = [i for i, c in enumerate(s) if c == '0']\n    m = len(idx)\n    \n    return sum(idx) - m * (m - 1) // 2", "distractor_code": "def minimumSteps(s: str) -> int:\n    cnt = 0\n    res = 0\n    for c in s:\n        if c == '1':\n            cnt += 1\n        else:\n            res += cnt\n    return res\n\ndef minimumSteps(s: str) -> int:\n    n = len(s)\n    idx = [i for i, c in enumerate(s) if c == '0']\n    m = len(idx)\n    \n    return sum(idx) - m * (m - 1) // 2\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    tag = [0] * (n + 1)\n    sh = 0\n    for i in range(n):\n        sh += tag[i]\n        if nums[i] - sh < 0:\n            return False\n        x = nums[i] - sh\n        if x:\n            if i + k > n:\n                return False\n            sh += x\n            tag[i + k] -= x\n    return True\n\ndef sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_294", "function_name": "minimumSteps", "code": "def minimumSteps(s: str) -> int:\n    b = 0\n    re = 0\n    for i in s:\n        if i == '1': b += 1\n        else: re += b;\n    return re", "distractor_code": "def minimumSteps(s: str) -> int:\n    b = 0\n    re = 0\n    for i in s:\n        if i == '1': b += 1\n        else: re += b;\n    return re\n\ndef minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    if len(nums) <3:\n        return True\n    for i,v in enumerate(nums):\n        if i+1 >= len(nums):\n            continue\n        if v + nums[i+1] >= m:\n            return True\n    return False\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_295", "function_name": "beautifulSubstrings", "code": "def beautifulSubstrings(s: str, k: int) -> int:\n    n = len(s)\n    tmp = set('aeiou')\n    s = [1 if c in tmp else 0 for c in s]\n    ans = 0\n    for i in range(n):\n        c1, c2 = 0, 0\n        for j in range(i, n):\n            c1 += s[j]\n            c2 += 1 - s[j]\n            if c1 == c2 and c1 * c2 % k == 0:\n                ans += 1\n    return ans", "distractor_code": "def beautifulSubstrings(s: str, k: int) -> int:\n    n = len(s)\n    tmp = set('aeiou')\n    s = [1 if c in tmp else 0 for c in s]\n    ans = 0\n    for i in range(n):\n        c1, c2 = 0, 0\n        for j in range(i, n):\n            c1 += s[j]\n            c2 += 1 - s[j]\n            if c1 == c2 and c1 * c2 % k == 0:\n                ans += 1\n    return ans\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    def f(nums):\n        return sum(max(1, x) for x in nums)\n    a = f(nums1)\n    b = f(nums2)\n    if a > b:\n        a, b = b, a\n        nums1, nums2 = nums2, nums1\n    if a != b and 0 not in nums1:\n        return -1\n    return max(a, b)\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans\n\ndef find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None\n\ndef extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)"}, {"source": "livecodebench-execution", "id": "sample_296", "function_name": "beautifulSubstrings", "code": "def beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans", "distractor_code": "def beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars \n\ndef distinctDifferenceArray(a: List[int]) -> List[int]:\n    return [len(set(a[:i+1]))-len(set(a[i+1:]))for i in range(len(a))]\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = []\n    s = 0\n    cur = 1\n    st = set()\n    while len(ans)<n:\n        while k-cur in st:\n            cur+=1\n        ans.append(cur)\n        st.add(cur)\n        s+=cur\n        cur+=1\n    return s\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort(reverse=True)\n    n = len(nums)\n    ans = 0\n    # 都选\n    ans += n > nums[0]\n    \n    # 都不选\n    ans += 0 < nums[-1]\n    \n    for i in range(n - 1):\n        # 前面都不选，后面都选\n        v = n - 1 - i\n        ans += v < nums[i] and v > nums[i + 1]\n    \n    return ans\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    mark = [0] * 200\n    for s,t in nums:\n        for i in range(s, t+1):\n            mark[i] = 1\n    return sum(mark)"}, {"source": "livecodebench-execution", "id": "sample_297", "function_name": "beautifulSubstrings", "code": "def beautifulSubstrings(s: str, k: int) -> int:\n    res = 0\n    vowels = \"aeiou\"\n    n = len(s)\n    for i in range(n):\n        numVowels, numCons = 0, 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                numVowels += 1\n            else:\n                numCons += 1\n            if numVowels == numCons and (numVowels * numCons) % k == 0:\n                res += 1\n    return res", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    res = 0\n    vowels = \"aeiou\"\n    n = len(s)\n    for i in range(n):\n        numVowels, numCons = 0, 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                numVowels += 1\n            else:\n                numCons += 1\n            if numVowels == numCons and (numVowels * numCons) % k == 0:\n                res += 1\n    return res\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    sa = sum(nums1)\n    sb = sum(nums2)\n    a = nums1.count(0)\n    b = nums2.count(0)\n    if sa + a > sb and b == 0:\n        return -1\n    if sb + b > sa and a == 0:\n        return -1\n    return max(sa + a, sb + b)\n\ndef bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) "}, {"source": "livecodebench-execution", "id": "sample_298", "function_name": "beautifulSubstrings", "code": "def beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output", "distractor_code": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr\n\ndef minimumSeconds(A: List[int]) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = N = len(A)\n    for row in locs.values():\n        gaps = [row[i+1] - row[i] - 1 for i in range(len(row) - 1)]\n        gaps.append(row[0] + N - row[-1] - 1)\n        m = max(gaps)\n        m = (m + 1) // 2\n        ans = min(ans, m)\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output"}, {"source": "livecodebench-execution", "id": "sample_299", "function_name": "beautifulSubstrings", "code": "from collections import defaultdict\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    aa=[]\n    for c in s:\n        if c in \"aiueo\":\n            aa.append(1)\n        else:\n            aa.append(-1)\n    a2i=defaultdict(list)\n    a2i[0].append(0)\n    ans=s=0\n    for i,a in enumerate(aa):\n        s+=a\n        for j in a2i[s]:\n            if (((i+1-j)//2)**2)%k==0:\n                ans+=1\n        a2i[s].append(i+1)\n    return ans", "distractor_code": "from collections import defaultdict\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    aa=[]\n    for c in s:\n        if c in \"aiueo\":\n            aa.append(1)\n        else:\n            aa.append(-1)\n    a2i=defaultdict(list)\n    a2i[0].append(0)\n    ans=s=0\n    for i,a in enumerate(aa):\n        s+=a\n        for j in a2i[s]:\n            if (((i+1-j)//2)**2)%k==0:\n                ans+=1\n        a2i[s].append(i+1)\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res, target = 0, nums[0]\n    for n in nums[1:]: target &= n\n    if target != 0: return 1\n    cur = -1\n    for n in nums:\n        if cur == -1: cur = n\n        cur &= n\n        if cur == target:\n            cur = -1\n            res += 1\n    return res\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans\n\ndef countWays(nums: List[int]) -> int:\n    nums.append(-0x3f3f3f3f)\n    nums.append(0x3f3f3f3f)\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 1):\n        if i > nums[i] and i < nums[i + 1]:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_300", "function_name": "beautifulSubstrings", "code": "def beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())", "distractor_code": "def sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    l, r = 0, 0\n    cnt = 0\n    ans = 0\n    n = len(s)\n    while l < n:\n        while r < n and cnt + (s[r] == s[r-1] and r > 0) < 2:\n            cnt += (s[r] == s[r-1] and r > 0)\n            r += 1\n        ans = max(ans, r - l)\n        if l == n-1: break\n        cnt -= s[l] == s[l+1]\n        l += 1\n    return ans\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    p = defaultdict(int)\n    for i in range(2, k+1):\n        while k % i == 0:\n            p[i] += 1\n            k //= i\n    k = 2 * prod(x ** ((v + 1) // 2) for x, v in p.items())\n    a = [2 * (x in 'aeiou') - 1 for x in s]\n    m = defaultdict(int)\n    for i, x in enumerate((0, *accumulate(a))):\n        m[(x, i%k)] += 1\n    return sum(v * (v-1) // 2 for v in m.values())"}, {"source": "livecodebench-execution", "id": "sample_301", "function_name": "lexicographicallySmallestArray", "code": "def lexicographicallySmallestArray(nums: List[int], limit: int) -> List[int]:\n    n = len(nums)\n    \n    order = sorted(range(n), key = lambda x: nums[x])\n    \n    out = [-1] * n\n    \n    l = 0\n    for i in range(n):\n        if i == n - 1 or nums[order[i]] + limit < nums[order[i + 1]]:\n            ind = sorted(order[l: i + 1])\n            for j in range(i - l + 1):\n                out[ind[j]] = nums[order[l + j]]\n            l = i + 1\n    return out", "distractor_code": "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]\n\ndef get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]\n\ndef check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\n\ndef find_Volume(l,b,h) : \n    return ((l * b * h) / 2) \n\ndef lexicographicallySmallestArray(nums: List[int], limit: int) -> List[int]:\n    n = len(nums)\n    \n    order = sorted(range(n), key = lambda x: nums[x])\n    \n    out = [-1] * n\n    \n    l = 0\n    for i in range(n):\n        if i == n - 1 or nums[order[i]] + limit < nums[order[i + 1]]:\n            ind = sorted(order[l: i + 1])\n            for j in range(i - l + 1):\n                out[ind[j]] = nums[order[l + j]]\n            l = i + 1\n    return out\n\ndef maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_302", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[11:13]) > 60:\n            ans += 1\n    return ans\n\ndef snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "}, {"source": "livecodebench-execution", "id": "sample_303", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1,n):\n            if nums[i] + nums[j] < target:\n                ans += 1\n    return ans\n\ndef countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\nimport re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\n\ndef minLength(s: str) -> int:\n    \n    while 1:\n        n = len(s)\n        if n < 2:\n            break\n        for i in range(n - 1):\n            if s[i:i + 2] == \"AB\" or s[i:i + 2] == \"CD\":\n                s = s[:i] + s[i + 2:]\n                break\n        else:\n            break\n    \n    return len(s)\n\ndef last_Digit(n) :\n    return (n % 10) \n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr"}, {"source": "livecodebench-execution", "id": "sample_304", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    out = 0\n    for s in details:\n        if int(int(s[11:13]) > 60):\n            out += 1\n    return out", "distractor_code": "def minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))\n\ndef longestEqualSubarray(nums: List[int], k: int) -> int:\n    n = len(nums)\n    cs = [[] for _ in range(n+1)]\n    for i, c in enumerate(nums):\n        cs[c].append(i)\n    ans = 0\n    for i in range(1, n+1):\n        st = 0\n        m = len(cs[i])\n        for ed in range(m):\n            while st < ed and cs[i][ed]-cs[i][st]+1-(ed-st+1) > k:\n                st += 1\n            ans = max(ans, ed-st+1)\n    return ans\n\nfrom itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n\n\ndef countSeniors(details: List[str]) -> int:\n    out = 0\n    for s in details:\n        if int(int(s[11:13]) > 60):\n            out += 1\n    return out"}, {"source": "livecodebench-execution", "id": "sample_305", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    ans=0\n    for s in details:\n        if int(s[11:13])>60:\n            ans+=1\n    return ans", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    ans=0\n    for s in details:\n        if int(s[11:13])>60:\n            ans+=1\n    return ans\n\ndef square_perimeter(a):\n  perimeter=4*a\n  return perimeter\n\ndef countSeniors(details: List[str]) -> int:\n    answer = 0\n    for x in details:\n        age = x[-4:][:2]\n        age = int(age)\n        if age > 60:\n            answer+=1\n    return answer\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)"}, {"source": "livecodebench-execution", "id": "sample_306", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    d = defaultdict(int)\n    for x in nums:\n        d[x] += 1\n    for x,y in zip(moveFrom,moveTo):\n        tmp = d[x]\n        d[x]-=tmp\n        d[y]+=tmp\n    return [x for x in sorted(d) if d[x]>0]\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1\n\ndef overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_307", "function_name": "countSeniors", "code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[-4:-2]) > 60:\n            ans += 1\n    return ans", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[-4:-2]) > 60:\n            ans += 1\n    return ans\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    left = 0\n    right = 0\n    a = 0\n    ret = 0\n    for c in moves:\n        if c == 'L':\n            left += 1\n        elif c == 'R':\n            right += 1\n        else:\n            a += 1\n    ret = max(ret, abs(left-right)+a)\n    return ret\n\ndef countPairs(nums: List[int], target: int) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            ans += nums[i] + nums[j] < target\n    return ans\n\ndef minimumCost(s: str) -> int:\n    ans = 0\n    n = len(s)\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            ans += min(i, n - i)\n    return ans\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    ans = [0]*n\n    for x in [0, 1]:\n        ans = [0]*n\n        ans[-1] = x\n        for i in range(n-2, -1, -1):\n            ans[i] = ans[i+1]^derived[i]\n        if ans[n-1]^ans[0] == derived[n-1]:\n            return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_308", "function_name": "matrixSum", "code": "def matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res", "distractor_code": "def maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    n, m = len(nums), len(nums[0])\n    for i in range(n):\n        nums[i].sort(reverse=1)\n    res = 0\n    for k in range(m):\n        maxi = 0\n        for i in range(n):\n            maxi = max(maxi, nums[i][k])\n        res += maxi\n    return res\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    ans = [float(\"inf\")]*(n+1)\n    \n    for i in range(n):\n        if i==0:\n            cost = prices[i]\n        else:\n            cost = ans[i-1]+prices[i]\n            \n        for j in range(i,min(n,i+i+1+1)):\n            ans[j] = min(ans[j],cost)\n    # print(ans)\n    return ans[n-1]"}, {"source": "livecodebench-execution", "id": "sample_309", "function_name": "matrixSum", "code": "def matrixSum(nums: List[List[int]]) -> int:\n    for l in nums:\n        l.sort()\n        \n    out = 0\n    while nums[0]:\n        top = 0\n        for l in nums:\n            top = max(top, l.pop())\n        out += top\n    return out", "distractor_code": "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))\n\ndef extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    for l in nums:\n        l.sort()\n        \n    out = 0\n    while nums[0]:\n        top = 0\n        for l in nums:\n            top = max(top, l.pop())\n        out += top\n    return out\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    cnt = defaultdict(int)\n    ans = 0\n    c = 0\n    s = 0\n    for r,x in enumerate(nums):\n        cnt[x] += 1\n        if cnt[x] == 1: c += 1\n        s += x\n        if r >= k:\n            y = nums[r-k]\n            cnt[y] -= 1\n            if cnt[y] == 0: c -= 1\n            s -= y\n        if c >= m: ans = max(ans,s)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_310", "function_name": "matrixSum", "code": "def matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans", "distractor_code": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for a, b in cnt.items():\n        if b == 1:\n            return -1\n        if b % 3 == 0:\n            ans += b // 3\n        if b % 3 == 1:\n            ans += (b - 4) // 3 + 2\n        if b % 3 == 2:\n            ans += (b - 2) // 3 + 1\n    return ans\n\ndef matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n\n    def is_champ(i):\n        for j in range(n):\n            if j == i:\n                continue\n            if grid[i][j] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        if is_champ(i):\n            return i\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_311", "function_name": "matrixSum", "code": "def matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans", "distractor_code": "def matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    N = len(s)\n    min_len = inf\n    ans = 'z' * 101\n\n    for right in range(N + 1):\n        for left in range(right):\n            ss = s[left:right]\n            if ss.count('1') == k:\n                if len(ss) < min_len or (len(ss) == min_len and ss < ans):\n                    min_len = len(ss)\n                    ans = ss\n\n    return \"\" if min_len == inf else ans\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    tmp = set(nums)\n    for x, y in zip(moveFrom, moveTo):\n        tmp.remove(x)\n        tmp.add(y)\n    return sorted(tmp)\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dp(i, first, last):\n        if i == n:\n            return 0\n        ans1 = dp(i + 1, first, words[i][-1]) - int(last == words[i][0])\n        ans2 = dp(i + 1, words[i][0], last) - int(words[i][-1] == first)\n        if ans1 > ans2:\n            return ans2 + len(words[i])\n        return ans1 + len(words[i])\n    return dp(1, words[0][0], words[0][-1]) + len(words[0])"}, {"source": "livecodebench-execution", "id": "sample_312", "function_name": "matrixSum", "code": "def matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))", "distractor_code": "def finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"}, {"source": "livecodebench-execution", "id": "sample_313", "function_name": "matrixSum", "code": "def matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans", "distractor_code": "def matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x"}, {"source": "livecodebench-execution", "id": "sample_314", "function_name": "buyChoco", "code": "from typing import List\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    if sum(prices[:2]) <= money:\n        return money - sum(prices[:2])\n    else:\n        return money", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l\n\nfrom typing import List\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    if sum(prices[:2]) <= money:\n        return money - sum(prices[:2])\n    else:\n        return money\n\ndef find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n\ndef multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)"}, {"source": "livecodebench-execution", "id": "sample_315", "function_name": "buyChoco", "code": "def buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot", "distractor_code": "def minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res\n\ndef canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    tot = sum(prices[:2])\n    if tot > money: return money\n    return money - tot"}, {"source": "livecodebench-execution", "id": "sample_316", "function_name": "buyChoco", "code": "def buyChoco(a: List[int], money: int) -> int:\n    a.sort()\n    if a[0] + a[1] > money:\n        return money\n    return money - a[0] - a[1]", "distractor_code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    if not n: return 0\n    elif n == 1: return prices[0]\n    dp = [float(\"inf\")] * n\n    for j in range(2):\n        dp[j] = prices[0]\n    #print(dp)\n    for i in range(1, n):\n        price = dp[i - 1] + prices[i]\n        for j in range(i, min(n, (i + 1) * 2)):\n            dp[j] = min(dp[j], price)\n        #print(dp)\n    return dp[-1]\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    l = min(len(s1), len(s2), len(s3))\n    for i in range(l, 0, -1):\n        if s1[:i] == s2[:i] and s2[:i] == s3[:i]:\n            return len(s1) - i + len(s2) - i + len(s3) - i\n        \n    return -1\n\ndef smallestString(s: str) -> str:\n    n = len(s) \n    s = list(s)\n    i = 0 \n    while i < n and s[i] == 'a':\n        i += 1 \n    if i == n: \n        s[-1] = 'z'\n        return ''.join(s) \n    for i in range(i,n):\n        if s[i] != 'a':\n            s[i] = chr(ord(s[i])-1) \n        else : break \n    return ''.join(s)\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    n = len(nums)\n    ans = []\n    for i in range(1, n + 1):\n        pref = nums[:i]\n        suff = nums[i:]\n        ans.append(len(set(pref)) - len(set(suff)))\n    return ans\n\ndef buyChoco(a: List[int], money: int) -> int:\n    a.sort()\n    if a[0] + a[1] > money:\n        return money\n    return money - a[0] - a[1]"}, {"source": "livecodebench-execution", "id": "sample_317", "function_name": "buyChoco", "code": "def buyChoco(prices: List[int], money: int) -> int:\n    s = sum(sorted(prices)[:2])\n    return money-s if s<=money else money", "distractor_code": "def smallest_num(xs):\n  return min(xs)\n\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    s = sum(sorted(prices)[:2])\n    return money-s if s<=money else money\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\"\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    if n == 1:\n        return derived[0] == 0\n    ans = 0\n    for i in range(n - 1):\n        ans ^= derived[i]\n    return ans == derived[-1]\n\ndef tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result"}, {"source": "livecodebench-execution", "id": "sample_318", "function_name": "buyChoco", "code": "def buyChoco(prices: List[int], money: int) -> int:\n  x = -1\n  n = len(prices)\n  for i in range(n):\n    for j in range(i + 1, n):\n      x = max(x, money - prices[i] - prices[j])\n  return money if x < 0 else x", "distractor_code": "def buyChoco(prices: List[int], money: int) -> int:\n  x = -1\n  n = len(prices)\n  for i in range(n):\n    for j in range(i + 1, n):\n      x = max(x, money - prices[i] - prices[j])\n  return money if x < 0 else x\n\ndef check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ans = 0 \n    \n    while mainTank >= 5:\n        mainTank -= 5 \n        if additionalTank:\n            additionalTank -=1 \n            mainTank += 1\n        ans += 5 \n    ans += mainTank\n    return 10 * ans"}, {"source": "livecodebench-execution", "id": "sample_319", "function_name": "buyChoco", "code": "def buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t", "distractor_code": "def ascii_value(k):\n  ch=k\n  return ord(ch)\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    t = prices[0] + prices[1]\n    if t > money:\n        return money\n    else:\n        return money - t"}, {"source": "livecodebench-execution", "id": "sample_320", "function_name": "maxStrength", "code": "from typing import List\nfrom itertools import combinations\nfrom functools import reduce\nimport operator\n\ndef maxStrength(nums: List[int]) -> int:\n    n = len(nums)\n    max_strength = float('-inf')\n    \n    for r in range(1, n + 1):\n        for combination in combinations(nums, r):\n            product = reduce(operator.mul, combination, 1)\n            max_strength = max(max_strength, product)\n\n    return max_strength", "distractor_code": "def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None\n\ndef removeTrailingZeros(num: str) -> str:\n    while num and num[-1] == \"0\":\n        num = num[:-1]\n    \n    return num\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    N = len(s)\n    \n    left = 0\n    best = 1\n    count = 0\n    \n    for right in range(1, N):\n        if s[right] == s[right - 1]:\n            count += 1\n        while count > 1:\n            if s[left] == s[left + 1]:\n                count -= 1\n            left += 1\n            \n        best = max(best, right - left + 1)\n    return best\n\ndef sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)\n\nfrom typing import List\nfrom itertools import combinations\nfrom functools import reduce\nimport operator\n\ndef maxStrength(nums: List[int]) -> int:\n    n = len(nums)\n    max_strength = float('-inf')\n    \n    for r in range(1, n + 1):\n        for combination in combinations(nums, r):\n            product = reduce(operator.mul, combination, 1)\n            max_strength = max(max_strength, product)\n\n    return max_strength"}, {"source": "livecodebench-execution", "id": "sample_321", "function_name": "maxStrength", "code": "def maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax", "distractor_code": "def maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res \n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) "}, {"source": "livecodebench-execution", "id": "sample_322", "function_name": "isFascinating", "code": "from typing import *\n\nfrom math import *\n\n\ndef isFascinating(n: int) -> bool:\n    x = str(n) + str(2 * n) + str(3 * n)\n    return len(set(x)) == 9 and len(x) == 9 and '0' not in x", "distractor_code": "def beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\nfrom typing import *\n\nfrom math import *\n\n\ndef isFascinating(n: int) -> bool:\n    x = str(n) + str(2 * n) + str(3 * n)\n    return len(set(x)) == 9 and len(x) == 9 and '0' not in x\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if 1 not in nums:\n        return 0\n    \n    MOD = 10 ** 9 + 7\n    ans = 1\n    ones = [i for i in range(len(nums)) if nums[i] == 1]\n    \n    for i in range(1, len(ones)):\n        ans = (ans * (ones[i] - ones[i - 1])) % MOD\n    \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_323", "function_name": "isFascinating", "code": "def isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        ct = 0\n        for j in range(n):\n            ct += grid[j][i]\n        if ct == 0:\n            return i\n\ndef isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9\n\ndef check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res "}, {"source": "livecodebench-execution", "id": "sample_324", "function_name": "isFascinating", "code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True\n\ndef max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far\n\ndef minimumIndex(nums: List[int]) -> int:\n    counts = Counter(nums)\n    x = max(counts.keys(), key = lambda y: counts[y])\n    \n    curr = 0\n    for i in range(len(nums)):\n        if nums[i] == x:\n            curr += 1\n            counts[x] -= 1\n        \n        left = i + 1\n        right = len(nums) - i - 1\n        \n        if curr * 2 > left and counts[x] * 2 > right:\n            return i\n        \n    return -1"}, {"source": "livecodebench-execution", "id": "sample_325", "function_name": "isFascinating", "code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\"", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    ex = min ((mainTank - 1) // 4, additionalTank)\n    \n    return (ex + mainTank) * 10\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n\n\ndef Extract(lst): \n    return [item[0] for item in lst] \n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    \n    lst1 = [s1[0], s1[2]]\n    lst2 = [s2[0], s2[2]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    lst1 = [s1[1], s1[3]]\n    lst2 = [s2[1], s2[3]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    return True\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2*n) + str(3 * n)\n    s = [ch for ch in s]\n    s.sort()\n    return ''.join(s) == \"123456789\""}, {"source": "livecodebench-execution", "id": "sample_326", "function_name": "isFascinating", "code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    n = len(nums)\n    i0 = 0\n    answer = 1\n    for i in range(1, n):\n        while nums[i]-nums[i0] > 2*k:\n            i0+=1\n        answer = max(answer, i-i0+1)\n    return answer"}, {"source": "livecodebench-execution", "id": "sample_327", "function_name": "isFascinating", "code": "def isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9", "distractor_code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d=[0]*(target+1)\n    t=[el for el in nums if el<=target]\n    if len(t)==0:\n        return -1\n    d[t[0]]=1\n    for el in t[1:]:\n        for j in range(target,0,-1):\n            if j-el>=0 and (j-el==0 or d[j-el]>0):\n                d[j]=max(d[j],d[j-el]+1)\n    if d[target]==0:\n        return -1\n    return d[target]\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9"}, {"source": "livecodebench-execution", "id": "sample_328", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    ii = [0]\n    for i in range(n-1):\n        if s[i] == s[i+1]: ii.append(i+1)\n    if len(ii) < 3: return n\n    ii.append(n)\n    ans = 0\n    for l, r in zip(ii, ii[2:]): ans = max(ans, r-l)\n    return ans", "distractor_code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    ii = [0]\n    for i in range(n-1):\n        if s[i] == s[i+1]: ii.append(i+1)\n    if len(ii) < 3: return n\n    ii.append(n)\n    ans = 0\n    for l, r in zip(ii, ii[2:]): ans = max(ans, r-l)\n    return ans\n\ndef matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n=len(nums)\n    l=nums.index(1)\n    r=nums.index(n)\n    ans=l+n-1-r\n    if l>r:\n        ans-=1\n    return ans\n\ndef minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret\n\ndef find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"}, {"source": "livecodebench-execution", "id": "sample_329", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    N = len(s)\n    \n    left = 0\n    best = 1\n    count = 0\n    \n    for right in range(1, N):\n        if s[right] == s[right - 1]:\n            count += 1\n        while count > 1:\n            if s[left] == s[left + 1]:\n                count -= 1\n            left += 1\n            \n        best = max(best, right - left + 1)\n    return best", "distractor_code": "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i, n):\n            li = nums[i:j + 1]\n            if li[0]%2 == 0 and all(li[k]%2 != li[k - 1]%2 for k in range(1,len(li))) and all(li[k] <= threshold for k in range(len(li))):\n                ans = max(ans, len(li))\n    return ans\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    N = len(s)\n    \n    left = 0\n    best = 1\n    count = 0\n    \n    for right in range(1, N):\n        if s[right] == s[right - 1]:\n            count += 1\n        while count > 1:\n            if s[left] == s[left + 1]:\n                count -= 1\n            left += 1\n            \n        best = max(best, right - left + 1)\n    return best\n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_330", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    ans = [-1]\n    for i in range(len(s)-1):\n        if s[i+1] == s[i]: ans.append(i)\n    ans.append(len(s)-1)\n    if len(ans) == 2: return len(s)\n    return max(ans[i+2]-ans[i] for i in range(len(ans)-2))", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans\n\nimport re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    ans = [-1]\n    for i in range(len(s)-1):\n        if s[i+1] == s[i]: ans.append(i)\n    ans.append(len(s)-1)\n    if len(ans) == 2: return len(s)\n    return max(ans[i+2]-ans[i] for i in range(len(ans)-2))"}, {"source": "livecodebench-execution", "id": "sample_331", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res", "distractor_code": "def minimumOperations(num: str) -> int:\n    ans = len(num) - 1 if \"0\" in num else len(num)\n    modes = [\"00\", \"25\", \"50\", \"75\"]\n    for mode in modes:\n        i, j = len(num) - 1, len(mode) - 1\n        cur = 0\n        while i >= 0:\n            if num[i] == mode[j]:\n                i -= 1\n                j -= 1\n                if j == -1:\n                    ans = min(ans, cur)\n                    break\n            else:\n                i -= 1\n                cur += 1\n    return ans\n\ndef matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res\n\ndef index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count "}, {"source": "livecodebench-execution", "id": "sample_332", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx", "distractor_code": "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) \n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx\n\ndef count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count "}, {"source": "livecodebench-execution", "id": "sample_333", "function_name": "longestSemiRepetitiveSubstring", "code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    l, r = 0, 0\n    cnt = 0\n    ans = 0\n    n = len(s)\n    while l < n:\n        while r < n and cnt + (s[r] == s[r-1] and r > 0) < 2:\n            cnt += (s[r] == s[r-1] and r > 0)\n            r += 1\n        ans = max(ans, r - l)\n        if l == n-1: break\n        cnt -= s[l] == s[l+1]\n        l += 1\n    return ans", "distractor_code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    i = 0\n    t = 0\n    res = 0\n    for j in range(n):\n        if j and s[j - 1] == s[j]: t += 1\n        while t > 1:\n            i += 1\n            if s[i - 1] == s[i]: t -= 1\n        res = max(res, j - i + 1)\n    return res\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    l, r = 0, 0\n    cnt = 0\n    ans = 0\n    n = len(s)\n    while l < n:\n        while r < n and cnt + (s[r] == s[r-1] and r > 0) < 2:\n            cnt += (s[r] == s[r-1] and r > 0)\n            r += 1\n        ans = max(ans, r - l)\n        if l == n-1: break\n        cnt -= s[l] == s[l+1]\n        l += 1\n    return ans\n\ndef pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums\n\ndef tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_334", "function_name": "maximumNumberOfStringPairs", "code": "from typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    base = 10 ** 9 + 7\n    l = 0\n    while l < len(nums) and nums[l] == 0:\n        l += 1\n    if l == len(nums):\n        return 0\n    ans = 1\n    for i in range(l + 1, len(nums)):\n        if nums[i] == 1:\n            ans = (ans * (i - l)) % base\n            l = i\n    return ans\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count \n\nfrom typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef minimumOperations(num: str) -> int:\n    ends = ['00', '25', '50', '75']\n    \n    num = '00'+num\n    \n    ans = len(num)-2\n    n = len(num)\n    \n    for e in ends:\n        u, v = e[0], e[1]\n        \n        idx1 = n-1\n        while idx1 > 0 and num[idx1] != v:\n            idx1 -= 1\n        idx2 = idx1-1\n        while idx2 > 0 and num[idx2] != u:\n            idx2 -= 1\n        if idx1 > 0 and idx2 > 0:\n            ans = min(ans, n-2-idx2)\n        \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_335", "function_name": "maximumNumberOfStringPairs", "code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans", "distractor_code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]\n\ndef find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) "}, {"source": "livecodebench-execution", "id": "sample_336", "function_name": "maximumNumberOfStringPairs", "code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    c = Counter()\n    res = 0\n    for i in words:\n        si = \"\".join(i[::-1])\n        if c[si]:\n            c[si] -= 1\n            res += 1\n        else:\n            c[i] += 1\n    return res", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    c = Counter()\n    res = 0\n    for i in words:\n        si = \"\".join(i[::-1])\n        if c[si]:\n            c[si] -= 1\n            res += 1\n        else:\n            c[i] += 1\n    return res\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    res = float('inf')\n    nums.sort()\n    for i in range(0, len(nums) - 1):\n        res = min(res, nums[i + 1] - nums[i])\n    return res\n\ndef is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\n\ndef countPairs(nums: List[int], t: int) -> int:\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<t:\n                res+=1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_337", "function_name": "maximumNumberOfStringPairs", "code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set(words)\n    ans = 0\n    for word in words:\n        if word != word[::-1] and word[::-1] in s:\n            ans += 1\n    return ans // 2", "distractor_code": "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(i for i in range(1, n + 1) if i % m != 0) - sum(i for i in range(1, n + 1) if i % m == 0)\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set(words)\n    ans = 0\n    for word in words:\n        if word != word[::-1] and word[::-1] in s:\n            ans += 1\n    return ans // 2"}, {"source": "livecodebench-execution", "id": "sample_338", "function_name": "maximumNumberOfStringPairs", "code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set()\n    ans = 0\n    for w in words:\n        if w[::-1] in s:\n            ans += 1\n            s.remove(w[::-1])\n        else:\n            s.add(w)\n    return ans", "distractor_code": "def maxSum(nums: List[int]) -> int:\n    ans = -1\n    d = defaultdict(list)\n    for x in nums:\n        d[max(map(int,str(x)))].append(x)\n    for i in range(10):\n        if len(d[i]) < 2:\n            continue\n        d[i].sort()\n        ans = max(ans, d[i][-1] + d[i][-2])\n    return ans\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set()\n    ans = 0\n    for w in words:\n        if w[::-1] in s:\n            ans += 1\n            s.remove(w[::-1])\n        else:\n            s.add(w)\n    return ans\n\ndef buyChoco(prices: List[int], money: int) -> int:\n  x = -1\n  n = len(prices)\n  for i in range(n):\n    for j in range(i + 1, n):\n      x = max(x, money - prices[i] - prices[j])\n  return money if x < 0 else x"}, {"source": "livecodebench-execution", "id": "sample_339", "function_name": "maximumNumberOfStringPairs", "code": "def maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans", "distractor_code": "def longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    ii = [0]\n    for i in range(n-1):\n        if s[i] == s[i+1]: ii.append(i+1)\n    if len(ii) < 3: return n\n    ii.append(n)\n    ans = 0\n    for l, r in zip(ii, ii[2:]): ans = max(ans, r-l)\n    return ans\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(n * 2) + str(n * 3)\n    st = set(str(n) + str(n * 2) + str(n * 3))\n    if len(s) == 9 and len(st) == 9 and '0' not in st:\n        return True\n    return False"}, {"source": "livecodebench-execution", "id": "sample_340", "function_name": "longestString", "code": "def longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2", "distractor_code": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            \n            if nums[j] != nums[i] + ((j - i) & 1):\n                break\n            \n            ans = max(ans, j - i + 1)\n    return ans\n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2"}, {"source": "livecodebench-execution", "id": "sample_341", "function_name": "longestString", "code": "def longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)", "distractor_code": "def countBeautifulPairs(nums: List[int]) -> int:\n    res=0\n    n=len(nums)\n    for i in range(n):\n        for j in range(i+1,n):\n            a=int(str(nums[i])[0])\n            b=int(str(nums[j])[-1])\n            if gcd(a,b)==1:\n                res+=1\n    return res\n\nimport re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))\n\ndef longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)"}, {"source": "livecodebench-execution", "id": "sample_342", "function_name": "longestString", "code": "def longestString(x: int, y: int, z: int) -> int:\n    ans = min(x, y) * 2\n    if x != y:\n        ans += 1\n    return (ans  + z) * 2", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    ans = min(x, y) * 2\n    if x != y:\n        ans += 1\n    return (ans  + z) * 2\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    ans = len(s1 + s2 + s3)\n    for i in range(len(s1), 0, -1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            return ans - i * 3\n    return -1\n\ndef maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i"}, {"source": "livecodebench-execution", "id": "sample_343", "function_name": "minimizeConcatenatedLength", "code": "def minimizeConcatenatedLength(words: List[str]) -> int:\n    A = defaultdict(lambda:inf)\n    A[words[0][0]+words[0][-1]] = len(words[0]) \n    for w in words[1:]:\n        B = defaultdict(lambda:inf) \n        for a,x in A.items():\n            B[a[0]+w[-1]] = min(B[a[0]+w[-1]],x+len(w) - (a[-1]==w[0]) )\n            B[w[0]+a[-1]] = min(B[w[0]+a[-1]],x+len(w) - (w[-1]==a[0]) ) \n        A,B = B ,A \n    return min(A.values())", "distractor_code": "def minLength(s: str) -> int:\n    while \"AB\" in s or \"CD\" in s:\n        s = s.replace(\"AB\", \"\")\n        s = s.replace(\"CD\", \"\")\n    return len(s)\n\ndef check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    A = defaultdict(lambda:inf)\n    A[words[0][0]+words[0][-1]] = len(words[0]) \n    for w in words[1:]:\n        B = defaultdict(lambda:inf) \n        for a,x in A.items():\n            B[a[0]+w[-1]] = min(B[a[0]+w[-1]],x+len(w) - (a[-1]==w[0]) )\n            B[w[0]+a[-1]] = min(B[w[0]+a[-1]],x+len(w) - (w[-1]==a[0]) ) \n        A,B = B ,A \n    return min(A.values())\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    s3 = s1[0] + s1[3] + s1[2] + s1[1]\n    s4 = s1[2] + s1[3] + s1[0] + s1[1]\n    s5 = s1[2] + s1[1] + s1[0] + s1[3]\n    return s2 == s1 or s2 == s3 or s2 == s4 or s2 == s5"}, {"source": "livecodebench-execution", "id": "sample_344", "function_name": "minimizeConcatenatedLength", "code": "def minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dp(i, first, last):\n        if i == n:\n            return 0\n        ans1 = dp(i + 1, first, words[i][-1]) - int(last == words[i][0])\n        ans2 = dp(i + 1, words[i][0], last) - int(words[i][-1] == first)\n        if ans1 > ans2:\n            return ans2 + len(words[i])\n        return ans1 + len(words[i])\n    return dp(1, words[0][0], words[0][-1]) + len(words[0])", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans\n\nfrom typing import *\n\nfrom math import *\n\n\ndef isFascinating(n: int) -> bool:\n    x = str(n) + str(2 * n) + str(3 * n)\n    return len(set(x)) == 9 and len(x) == 9 and '0' not in x\n\ndef distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dp(i, first, last):\n        if i == n:\n            return 0\n        ans1 = dp(i + 1, first, words[i][-1]) - int(last == words[i][0])\n        ans2 = dp(i + 1, words[i][0], last) - int(words[i][-1] == first)\n        if ans1 > ans2:\n            return ans2 + len(words[i])\n        return ans1 + len(words[i])\n    return dp(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) \n\ndef minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct"}, {"source": "livecodebench-execution", "id": "sample_345", "function_name": "minimizeConcatenatedLength", "code": "def minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for w in words:\n        ans.extend(w.split(separator))\n        \n    return [s for s in ans if s]\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos"}, {"source": "livecodebench-execution", "id": "sample_346", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            \n            if nums[j] != nums[i] + ((j - i) & 1):\n                break\n            \n            ans = max(ans, j - i + 1)\n    return ans", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if 1 not in nums:\n        return 0\n    \n    MOD = 10 ** 9 + 7\n    ans = 1\n    ones = [i for i in range(len(nums)) if nums[i] == 1]\n    \n    for i in range(1, len(ones)):\n        ans = (ans * (ones[i] - ones[i - 1])) % MOD\n    \n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            \n            if nums[j] != nums[i] + ((j - i) & 1):\n                break\n            \n            ans = max(ans, j - i + 1)\n    return ans\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret"}, {"source": "livecodebench-execution", "id": "sample_347", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans\n\ndef longestString(x: int, y: int, z: int) -> int:\n    return z * 2 + (min(x, y + 1) + min(y, x + 1)) * 2\n\ndef maxIncreasingGroups(usageLimits: List[int]) -> int:\n    def f(x):\n        return (x + 1) * (x + 2) // 2\n    \n    usageLimits.sort()\n    prefix = [usageLimits[0]]\n    for i in range(1, len(usageLimits)):\n        prefix.append(prefix[-1] + usageLimits[i])\n        \n    ans = 0\n    \n    for num in prefix:\n        if f(ans) <= num:\n            ans += 1\n            \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_348", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    last = 0\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == last:\n        return True\n    last = 1\n    for i in range(n-1):\n        last = derived[i] ^ last\n    if derived[n-1] == (1 ^ last):\n        return True\n    return False\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for to_ret in range(1, 100) :\n        num1 -= num2\n        if num1 < to_ret :\n            return -1\n        s1 = len([c for c in bin(num1)[2:] if c == '1'])\n        # print(num1, s1)\n        if to_ret >= s1 :\n            return to_ret\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_349", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans", "distractor_code": "def splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    nums.sort()\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] > 0:\n                dp[i+x] = max(dp[i+x], 1 + dp[i])\n    return dp[-1] - 1\n\ndef max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    @cache\n    def dfs(i):\n        if i == len(nums) - 1:\n            return 0\n        r = -1\n        for j in range(i + 1, len(nums)):\n            if abs(nums[j] - nums[i]) <= target:\n                if dfs(j) > -1:\n                    r = max(r, 1 + dfs(j))\n        return r\n    res = dfs(0)\n    dfs.cache_clear()\n    return res"}, {"source": "livecodebench-execution", "id": "sample_350", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres", "distractor_code": "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True\n\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = inf\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if nums[j] > max(nums[i], nums[k]):\n                    ans = min(ans, nums[i] + nums[j] + nums[k])\n    return ans if ans < inf else -1\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres"}, {"source": "livecodebench-execution", "id": "sample_351", "function_name": "alternatingSubarray", "code": "def alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1", "distractor_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)"}, {"source": "livecodebench-execution", "id": "sample_352", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    d = defaultdict(int)\n    for x in nums:\n        d[x] += 1\n    for x,y in zip(moveFrom,moveTo):\n        tmp = d[x]\n        d[x]-=tmp\n        d[y]+=tmp\n    return [x for x in sorted(d) if d[x]>0]", "distractor_code": "import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums)==list(range(1,len(nums)))+[len(nums)-1]\n\ndef is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True\n\ndef isFascinating(n: int) -> bool:\n    s = str(n) + str(2 * n) + str(3 * n)\n    if len(s) != 9:\n        return False\n    tmp = set(s)\n    if len(tmp) != 9 or '0' in tmp:\n        return False\n    return True\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    d = defaultdict(int)\n    for x in nums:\n        d[x] += 1\n    for x,y in zip(moveFrom,moveTo):\n        tmp = d[x]\n        d[x]-=tmp\n        d[y]+=tmp\n    return [x for x in sorted(d) if d[x]>0]\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)"}, {"source": "livecodebench-execution", "id": "sample_353", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    loc = set(nums)  # 初始有石块的位置\n    for i, j in zip(moveFrom, moveTo):\n        loc.remove(i)  # i不再是有石块的位置\n        loc.add(j)  # 不管之前有没有石块，j成为有石块的位置\n    return sorted(loc)", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    loc = set(nums)  # 初始有石块的位置\n    for i, j in zip(moveFrom, moveTo):\n        loc.remove(i)  # i不再是有石块的位置\n        loc.add(j)  # 不管之前有没有石块，j成为有石块的位置\n    return sorted(loc)\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(str(nums[i])) == max(str(nums[j])):\n                ans = max(ans, nums[i] + nums[j])\n    return ans\n\ndef isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef distanceTraveled(a: int, b: int) -> int:\n    res = 0\n    while a:\n        if a >= 5:\n            res += 5 * 10\n            a -= 5\n            if b:\n                b -= 1\n                a += 1\n        else:\n            res += a * 10\n            a = 0\n    return res\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1"}, {"source": "livecodebench-execution", "id": "sample_354", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for x in nums:\n        s.add(x)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(list(s))", "distractor_code": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); \n\ndef maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort(reverse=True)\n    left, right = 1, len(usageLimits)\n    while left < right:\n        m = (left + right + 1) // 2\n        if test(usageLimits, m):\n            left = m\n        else:\n            right = m - 1\n    return left\n\ndef test(count: List[int], group: int) -> bool:\n    d = 0\n    for i, x in enumerate(count):\n        y = max(group - i, 0)\n        d = min(d + x - y, 0)\n    return d == 0\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for x in nums:\n        s.add(x)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(list(s))\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        curr = sum(grid[x][i] for x in range(n))\n        if curr == 0:\n            return i\n    return -1\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_355", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for i in nums:\n        s.add(i)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(s)", "distractor_code": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] \n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    seen = set()\n    ans = 0 \n    for w in words:\n        if w in seen:\n            ans += 1\n        else:\n            seen.add(w[::-1])\n            \n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res\n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    s = set()\n    for i in nums:\n        s.add(i)\n    for i in range(len(moveFrom)):\n        s.remove(moveFrom[i])\n        s.add(moveTo[i])\n    return sorted(s)"}, {"source": "livecodebench-execution", "id": "sample_356", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    tmp = set(nums)\n    for x, y in zip(moveFrom, moveTo):\n        tmp.remove(x)\n        tmp.add(y)\n    return sorted(tmp)", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    tmp = set(nums)\n    for x, y in zip(moveFrom, moveTo):\n        tmp.remove(x)\n        tmp.add(y)\n    return sorted(tmp)\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef is_lower(string):\n  return (string.lower())\n\ndef long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t"}, {"source": "livecodebench-execution", "id": "sample_357", "function_name": "relocateMarbles", "code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans\n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    \n    nums = sorted(list(set(nums)))\n    dd = {}\n    for item in nums:\n        dd[item] = 1\n    for a,b in zip(moveFrom, moveTo):\n        del dd[a]\n        dd[b] = 1\n    ll = dd.keys()\n    return sorted(ll)"}, {"source": "livecodebench-execution", "id": "sample_358", "function_name": "minimumBeautifulSubstrings", "code": "def minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ans = 0\n    n = len(nums)\n    for i in  range(n):\n        if bin(i).count(\"1\") == k:\n            ans += nums[i]\n    return ans\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]\n\ndef maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet\n\ndef eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))"}, {"source": "livecodebench-execution", "id": "sample_359", "function_name": "minimumBeautifulSubstrings", "code": "def minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    f = [-1] * (n + 1)\n    f[0] = 0\n    sp = set()\n    p = 1\n    while len(bin(p)[2:]) <= n:\n        sp.add(str(bin(p)[2:]))\n        p *= 5\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n + 1):\n                if s[i:j] in sp:\n                    if f[j] == -1 or f[j] > f[i] + 1:\n                        f[j] = f[i] + 1\n    return f[-1]", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    f = [-1] * (n + 1)\n    f[0] = 0\n    sp = set()\n    p = 1\n    while len(bin(p)[2:]) <= n:\n        sp.add(str(bin(p)[2:]))\n        p *= 5\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n + 1):\n                if s[i:j] in sp:\n                    if f[j] == -1 or f[j] > f[i] + 1:\n                        f[j] = f[i] + 1\n    return f[-1]\n\ndef finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)"}, {"source": "livecodebench-execution", "id": "sample_360", "function_name": "minimumBeautifulSubstrings", "code": "tmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    tot = len(set(nums))\n    ans = 0\n    for i in range(n):\n        s = set()\n        for x in nums[i:]:\n            s.add(x)\n            ans += int(len(s) == tot)\n    return ans\n\ndef minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)\n\ndef drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1\n\ntmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    for n in range(min(min(len(s1),len(s2)),len(s3)),0,-1):\n        if s1[:n] == s2[:n] and s1[:n] == s3[:n]:\n            return len(s1)+len(s2)+len(s3)-n*3\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_361", "function_name": "isGood", "code": "def isGood(a: List[int]) -> bool:\n    \n    n = len(a) - 1\n    for i in range(1, n):\n        if a.count(i) != 1:\n            return False\n    \n    return a.count(n) == 2", "distractor_code": "def isGood(a: List[int]) -> bool:\n    \n    n = len(a) - 1\n    for i in range(1, n):\n        if a.count(i) != 1:\n            return False\n    \n    return a.count(n) == 2\n\ndef findChampion(grid: List[List[int]]) -> int:\n  n = len(grid)\n  for j in range(n):\n    if all(grid[i][j] == 0 for i in range(n)):\n      return j\n\nimport math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s"}, {"source": "livecodebench-execution", "id": "sample_362", "function_name": "isGood", "code": "def isGood(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums) - 1\n    \n    res = True\n    for i in range(n):\n        if nums[i] != i+1: return False\n    \n    return nums[-1] == n", "distractor_code": "def findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    if len(set([s1[0], s2[0], s3[0]])) != 1:\n        return -1\n    ans = 0\n    for i in range(min(len(s1), len(s2), len(s3))):\n        if s1[i]==s2[i]==s3[i]:\n            ans += 1\n        else:\n            break\n    return len(s1)+len(s2)+len(s3)-ans*3\n\ndef isGood(nums: List[int]) -> bool:\n    nums.sort()\n    n = len(nums) - 1\n    \n    res = True\n    for i in range(n):\n        if nums[i] != i+1: return False\n    \n    return nums[-1] == n\n\ndef sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1"}, {"source": "livecodebench-execution", "id": "sample_363", "function_name": "isGood", "code": "def isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True", "distractor_code": "def maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\ndef isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps\n\ndef get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]"}, {"source": "livecodebench-execution", "id": "sample_364", "function_name": "isGood", "code": "def isGood(nums: List[int]) -> bool:\n    return sorted(nums)==list(range(1,len(nums)))+[len(nums)-1]", "distractor_code": "def maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    dp = [-1]*n\n    dp[0] = 0\n    for i in range(n):\n        if dp[i] == -1:\n            continue\n        for j in range(i+1, n):\n            if abs(nums[i] - nums[j]) <= target:\n                dp[j] = max(dp[j], dp[i]+1)\n    return dp[-1]\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums)==list(range(1,len(nums)))+[len(nums)-1]\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    res = (float('inf'), \"\")\n    for i in range(n):\n        ctr = 0\n        for j in range(i, n):\n            ctr += int(s[j])\n            if ctr == k:\n                res = min(res, (j - i + 1, s[i : j + 1]))\n    return res[1]\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    for i in range(n):\n        cnt = 0\n        min_j = -1\n        for j in range(i, n):\n            if s[j] == '1':\n                cnt += 1\n            if cnt == k:\n                min_j = j\n                break\n        if min_j > -1:\n            ans.append((min_j - i + 1, s[i:min_j + 1]))\n    ans.sort()\n    if ans:\n        return ans[0][1]\n    else:\n        return ''\n\ndef split_two_parts(list1, L):\n    return list1[:L], list1[L:]\n\ndef minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_365", "function_name": "isGood", "code": "def isGood(nums: List[int]) -> bool:\n    if len(nums)==1:\n        return False\n    nums.sort()\n    n = len(nums)\n    if nums[-1] != nums[-2]:\n        return False\n    for i in range(n-1):\n        if nums[i] != i+1:\n            return False\n    return True", "distractor_code": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef isGood(nums: List[int]) -> bool:\n    if len(nums)==1:\n        return False\n    nums.sort()\n    n = len(nums)\n    if nums[-1] != nums[-2]:\n        return False\n    for i in range(n-1):\n        if nums[i] != i+1:\n            return False\n    return True\n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res"}, {"source": "livecodebench-execution", "id": "sample_366", "function_name": "isGood", "code": "def isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])", "distractor_code": "def isGood(nums: List[int]) -> bool:\n    return sorted(nums) == ([i + 1 for i in range(len(nums) - 1)] + [len(nums) - 1])\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    ans = len(s1 + s2 + s3)\n    for i in range(len(s1), 0, -1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            return ans - i * 3\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_367", "function_name": "sortVowels", "code": "def sortVowels(s: str) -> str:\n    ss = \"aeiouAEIOU\"\n    ans = []\n    qs = [c for c in s if c in ss]\n    qs.sort()\n    pos = 0\n    for c in s:\n        if c in ss:\n            ans.append(qs[pos])\n            pos += 1\n        else:\n            ans.append(c)\n    return \"\".join(ans)", "distractor_code": "def accountBalanceAfterPurchase(p: int) -> int:\n    a, b = divmod(p, 10)\n    if b < 5:\n        return 100 - a * 10\n    else:\n        return 90 - a * 10\n\ndef minimumSteps(s: str) -> int:\n    r = len(s) - 1\n    ret = 0\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '1':\n            ret += r - i\n            r -= 1\n    \n    return ret\n\ndef minimumSum(n: int, k: int) -> int:\n    a = []\n    i = 1\n    while len(a) < n:\n        ok = True\n        for ai in a:\n            if i + ai == k:\n                ok = False\n        if ok:\n            a.append(i)\n        i += 1\n    return sum(a)\n\ndef Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef sortVowels(s: str) -> str:\n    ss = \"aeiouAEIOU\"\n    ans = []\n    qs = [c for c in s if c in ss]\n    qs.sort()\n    pos = 0\n    for c in s:\n        if c in ss:\n            ans.append(qs[pos])\n            pos += 1\n        else:\n            ans.append(c)\n    return \"\".join(ans)"}, {"source": "livecodebench-execution", "id": "sample_368", "function_name": "sortVowels", "code": "def sortVowels(s: str) -> str:\n    n = len(s)\n    answer = [None for i in range(n)]\n    vowels = []\n    v2 = []\n    for i in range(n):\n        if s[i] not in 'aeiouAEIOU':\n            answer[i] = s[i]\n        else:\n            vowels.append(s[i])\n            v2.append(i)\n    vowels = sorted(vowels, key=lambda a: ord(a))\n    m = len(vowels)\n    for i in range(m):\n        c, j = vowels[i], v2[i]\n        answer[j] = c\n    return ''.join(answer)", "distractor_code": "def rectangle_area(l,b):\n  area=l*b\n  return area\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for u, v in nums:\n        for i in range(u, v + 1):\n            s.add(i)\n    return len(s)\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    answer = [None for i in range(n)]\n    vowels = []\n    v2 = []\n    for i in range(n):\n        if s[i] not in 'aeiouAEIOU':\n            answer[i] = s[i]\n        else:\n            vowels.append(s[i])\n            v2.append(i)\n    vowels = sorted(vowels, key=lambda a: ord(a))\n    m = len(vowels)\n    for i in range(m):\n        c, j = vowels[i], v2[i]\n        answer[j] = c\n    return ''.join(answer)"}, {"source": "livecodebench-execution", "id": "sample_369", "function_name": "sortVowels", "code": "def sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    n = len(s)\n    \n    v = []\n    for i in range(n):\n        if s[i].lower() in ['a', 'e', 'i', 'o', 'u']:\n            v.append(i)\n    \n    vs = sorted(v, key=lambda i: s[i])\n    \n    ss = s[:]\n    \n    for i in range(len(v)):\n        s[v[i]] = ss[vs[i]]\n    \n    return ''.join(s)", "distractor_code": "def minimumSeconds(nums: List[int]) -> int:\n    ref = defaultdict(list)\n    for i in range(len(nums)):\n        ref[nums[i]].append(i)\n    ans = inf\n    for i in ref:\n        k = 0\n        for j in range(len(ref[i])):\n            x = ref[i][j]\n            y = ref[i][j - 1]\n            if x > y:\n                k = max(k, x - y - 1)\n            else:\n                k = max(k, len(nums) - y + x - 1)\n        if k % 2== 1:\n            k += 1\n        ans = min(ans, k // 2)\n    return ans\n\ndef sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    n = len(s)\n    \n    v = []\n    for i in range(n):\n        if s[i].lower() in ['a', 'e', 'i', 'o', 'u']:\n            v.append(i)\n    \n    vs = sorted(v, key=lambda i: s[i])\n    \n    ss = s[:]\n    \n    for i in range(len(v)):\n        s[v[i]] = ss[vs[i]]\n    \n    return ''.join(s)\n\ndef rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    dp = [0] * (n + 1)\n    offers.sort()\n    i = 0\n    for r in range(n + 1):\n        dp[r] = max(dp[r], dp[r - 1])\n        while i < len(offers) and offers[i][0] <= r:\n            dp[offers[i][1] + 1] = max(dp[offers[i][1] + 1], dp[offers[i][0]] + offers[i][2])\n            i += 1\n    return dp[-1]\n\ndef upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr\n\ndef flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list "}, {"source": "livecodebench-execution", "id": "sample_370", "function_name": "sortVowels", "code": "def sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)", "distractor_code": "def sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)\n\nfrom collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter\n\ndef isGood(nums: List[int]) -> bool:\n    return sorted(nums)==list(range(1,len(nums)))+[len(nums)-1]\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) \n\ndef finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)"}, {"source": "livecodebench-execution", "id": "sample_371", "function_name": "sortVowels", "code": "def sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1\n\ndef distributeCandies(n: int, limit: int) -> int:\n  c = 0\n  for i in range(limit + 1):\n    for j in range(limit + 1):\n      for k in range(limit + 1):\n        if i + j + k == n:\n          c += 1\n  return c\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    n = len(s)\n    tmp = set('aeiou')\n    s = [1 if c in tmp else 0 for c in s]\n    ans = 0\n    for i in range(n):\n        c1, c2 = 0, 0\n        for j in range(i, n):\n            c1 += s[j]\n            c2 += 1 - s[j]\n            if c1 == c2 and c1 * c2 % k == 0:\n                ans += 1\n    return ans\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)"}, {"source": "livecodebench-execution", "id": "sample_372", "function_name": "sortVowels", "code": "def vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False\n\ndef vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)\n\ndef minimumSeconds(nums: List[int]) -> int:\n    d = defaultdict(list)\n    for i, j in enumerate(nums):\n        d[j].append(i)\n    n = len(nums)\n    ret = n // 2\n    for l in d.values():\n        r = 0\n        q = len(l)\n        for i, j in enumerate(l):\n            if i < q - 1:\n                k = l[i + 1]\n            else:\n                k = l[0] + n\n            r = max(r, (k - j) // 2)\n        ret = min(ret, r)\n    return ret\n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1"}, {"source": "livecodebench-execution", "id": "sample_373", "function_name": "accountBalanceAfterPurchase", "code": "def accountBalanceAfterPurchase(p: int) -> int:\n    a, b = divmod(p, 10)\n    if b < 5:\n        return 100 - a * 10\n    else:\n        return 90 - a * 10", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res\n\ndef accountBalanceAfterPurchase(p: int) -> int:\n    a, b = divmod(p, 10)\n    if b < 5:\n        return 100 - a * 10\n    else:\n        return 90 - a * 10\n\ndef shortestBeautifulSubstring(s: str, k: int) -> str:\n    n = len(s)\n    res = (float('inf'), \"\")\n    for i in range(n):\n        ctr = 0\n        for j in range(i, n):\n            ctr += int(s[j])\n            if ctr == k:\n                res = min(res, (j - i + 1, s[i : j + 1]))\n    return res[1]"}, {"source": "livecodebench-execution", "id": "sample_374", "function_name": "minimumSeconds", "code": "def minimumSeconds(nums: List[int]) -> int:\n    d = defaultdict(list)\n    for i, j in enumerate(nums):\n        d[j].append(i)\n    n = len(nums)\n    ret = n // 2\n    for l in d.values():\n        r = 0\n        q = len(l)\n        for i, j in enumerate(l):\n            if i < q - 1:\n                k = l[i + 1]\n            else:\n                k = l[0] + n\n            r = max(r, (k - j) // 2)\n        ret = min(ret, r)\n    return ret", "distractor_code": "def minimumSteps(s: str) -> int:\n    b = 0\n    re = 0\n    for i in s:\n        if i == '1': b += 1\n        else: re += b;\n    return re\n\nfrom typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef minimumSeconds(nums: List[int]) -> int:\n    d = defaultdict(list)\n    for i, j in enumerate(nums):\n        d[j].append(i)\n    n = len(nums)\n    ret = n // 2\n    for l in d.values():\n        r = 0\n        q = len(l)\n        for i, j in enumerate(l):\n            if i < q - 1:\n                k = l[i + 1]\n            else:\n                k = l[0] + n\n            r = max(r, (k - j) // 2)\n        ret = min(ret, r)\n    return ret\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s\n\nimport sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i\n\ndef minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)"}, {"source": "livecodebench-execution", "id": "sample_375", "function_name": "minimumSeconds", "code": "def minimumSeconds(nums: List[int]) -> int:\n    ref = defaultdict(list)\n    for i in range(len(nums)):\n        ref[nums[i]].append(i)\n    ans = inf\n    for i in ref:\n        k = 0\n        for j in range(len(ref[i])):\n            x = ref[i][j]\n            y = ref[i][j - 1]\n            if x > y:\n                k = max(k, x - y - 1)\n            else:\n                k = max(k, len(nums) - y + x - 1)\n        if k % 2== 1:\n            k += 1\n        ans = min(ans, k // 2)\n    return ans", "distractor_code": "def isGood(nums: List[int]) -> bool:\n    \n    mx = max(nums)\n    \n    c = nums.count(mx)\n    \n    if len(nums) != mx + 1 or c != 2:\n        return False\n    \n    for i in range(1, mx):\n        if nums.count(i) != 1:\n            return False\n    \n    return True\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef minimumSeconds(nums: List[int]) -> int:\n    ref = defaultdict(list)\n    for i in range(len(nums)):\n        ref[nums[i]].append(i)\n    ans = inf\n    for i in ref:\n        k = 0\n        for j in range(len(ref[i])):\n            x = ref[i][j]\n            y = ref[i][j - 1]\n            if x > y:\n                k = max(k, x - y - 1)\n            else:\n                k = max(k, len(nums) - y + x - 1)\n        if k % 2== 1:\n            k += 1\n        ans = min(ans, k // 2)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)\n\ndef replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n"}, {"source": "livecodebench-execution", "id": "sample_376", "function_name": "minimumSeconds", "code": "def minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps", "distractor_code": "def vowel(ch): return ch.lower() in 'aeiou'\n\ndef sortVowels(s: str) -> str:\n    q = deque(sorted((ch for ch in s if vowel(ch))))\n    res = []\n    for ch in s:\n        if vowel(ch):\n            res.append(q.popleft())\n        else:\n            res.append(ch)\n    return ''.join(res)\n\nimport math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter\n\ndef smallestString(s: str) -> str:\n    if s == \"a\"*len(s):\n        return \"a\"*(len(s)-1)+\"z\"\n    r = \"\"\n    p = 0\n    for i in s:\n        if p == 1:\n            if i == \"a\":\n                p = 2\n                r += i\n            else:\n                r += chr(ord(i)-1)\n        elif p == 0:\n            if i == \"a\":\n                r += i\n            else:\n                p = 1\n                r += chr(ord(i)-1)\n        else:\n            r += i\n    return r\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps"}, {"source": "livecodebench-execution", "id": "sample_377", "function_name": "minimumSeconds", "code": "def minimumSeconds(nums: List[int]) -> int:\n    d=defaultdict(list)\n    for i,el in enumerate(nums):\n        d[el].append(i)\n    ans=float(\"inf\")\n    def check(el):\n        t=d[el][:]\n        g=[t[0]+len(nums)-1-t[-1]]\n        for a,b in zip(t,t[1:]):\n            g.append(b-a-1)\n        # print(g,el)\n        p=max(g)\n        return (p+1)//2\n    for el in d:\n        ans=min(ans,check(el))\n    return ans", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    res = 0\n    for i in range(len(nums)):\n        r = 1\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[j - 1] == -1 + 2 * ((j - i) & 1):\n                r += 1\n                res = max(res, r)\n            else:\n                break\n    return res if res > 0 else -1\n\ndef is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\n\ndef minimumSeconds(nums: List[int]) -> int:\n    d=defaultdict(list)\n    for i,el in enumerate(nums):\n        d[el].append(i)\n    ans=float(\"inf\")\n    def check(el):\n        t=d[el][:]\n        g=[t[0]+len(nums)-1-t[-1]]\n        for a,b in zip(t,t[1:]):\n            g.append(b-a-1)\n        # print(g,el)\n        p=max(g)\n        return (p+1)//2\n    for el in d:\n        ans=min(ans,check(el))\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_378", "function_name": "minimumSeconds", "code": "def minimumSeconds(A: List[int]) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = N = len(A)\n    for row in locs.values():\n        gaps = [row[i+1] - row[i] - 1 for i in range(len(row) - 1)]\n        gaps.append(row[0] + N - row[-1] - 1)\n        m = max(gaps)\n        m = (m + 1) // 2\n        ans = min(ans, m)\n    return ans", "distractor_code": "def minimumSeconds(A: List[int]) -> int:\n    locs = defaultdict(list)\n    for i,x in enumerate(A):\n        locs[x].append(i)\n    \n    ans = N = len(A)\n    for row in locs.values():\n        gaps = [row[i+1] - row[i] - 1 for i in range(len(row) - 1)]\n        gaps.append(row[0] + N - row[-1] - 1)\n        m = max(gaps)\n        m = (m + 1) // 2\n        ans = min(ans, m)\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res, target = 0, nums[0]\n    for n in nums[1:]: target &= n\n    if target != 0: return 1\n    cur = -1\n    for n in nums:\n        if cur == -1: cur = n\n        cur &= n\n        if cur == target:\n            cur = -1\n            res += 1\n    return res\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    s = len(set(nums))\n    n = len(nums)\n    ret = 0\n    for i in range(n):\n        a = set()\n        for j in range(i, n):\n            a.add(nums[j])\n            if len(a) == s:\n                ret += n - j\n                break\n    return ret"}, {"source": "livecodebench-execution", "id": "sample_379", "function_name": "minimumSeconds", "code": "def minimumSeconds(nums: List[int]) -> int:\n    idxs, res = defaultdict(list), (len(nums))//2\n    for i, n in enumerate(nums): idxs[n].append(i)\n    for n in idxs:\n        idx = idxs[n]\n        if len(idx) != 1:\n            cur = (idx[0]+(len(nums)-idx[-1]))//2\n            for i in range(len(idx)-1): cur = max(cur, (idx[i+1]-idx[i])//2)\n            res = min(res, cur)\n    return res", "distractor_code": "def maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\ndef count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\n\ndef minimumPossibleSum(n: int, target: int) -> int:\n    if target in [1, 2] :\n        return (1+n) * n // 2\n    if n - 1 + n < target : \n        return (1+n) * n // 2\n    \n    not_used = list(range(target//2+1, target))\n    l = n + len(not_used)\n    to_ret = (1+l) * l // 2\n    to_ret -= (not_used[0] + not_used[-1]) * len(not_used) // 2\n    return to_ret\n\ndef minimumSeconds(nums: List[int]) -> int:\n    idxs, res = defaultdict(list), (len(nums))//2\n    for i, n in enumerate(nums): idxs[n].append(i)\n    for n in idxs:\n        idx = idxs[n]\n        if len(idx) != 1:\n            cur = (idx[0]+(len(nums)-idx[-1]))//2\n            for i in range(len(idx)-1): cur = max(cur, (idx[i+1]-idx[i])//2)\n            res = min(res, cur)\n    return res\n\ndef find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_380", "function_name": "countPairs", "code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp = [0]*(target + 1)\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] or not i:\n                dp[i + x] = max(dp[i + x], dp[i] + 1)\n    \n    return dp[-1] if dp[-1] else -1\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    \n    return s == \"\".join([w[0] for w in words])\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)"}, {"source": "livecodebench-execution", "id": "sample_381", "function_name": "countPairs", "code": "def countPairs(nums: List[int], t: int) -> int:\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<t:\n                res+=1\n    return res", "distractor_code": "from typing import *\n\nfrom math import *\n\n\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([i for i in hours if i >= target])\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    n = len(s)\n    ii = [0]\n    for i in range(n-1):\n        if s[i] == s[i+1]: ii.append(i+1)\n    if len(ii) < 3: return n\n    ii.append(n)\n    ans = 0\n    for l, r in zip(ii, ii[2:]): ans = max(ans, r-l)\n    return ans\n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx\n\ndef countPairs(nums: List[int], t: int) -> int:\n    n=len(nums)\n    res=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<t:\n                res+=1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_382", "function_name": "countPairs", "code": "def countPairs(nums: List[int], target: int) -> int:\n    res = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    res = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ss = \"\"\n    for w in words:\n        ss+=w[0]\n    return s == ss\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res\n\ndef find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) \n\ndef find(n,m):  \n    q = n//m \n    return (q)"}, {"source": "livecodebench-execution", "id": "sample_383", "function_name": "countPairs", "code": "def countPairs(nums: List[int], target: int) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            ans += nums[i] + nums[j] < target\n    return ans", "distractor_code": "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result\n\ndef countPairs(nums: List[int], target: int) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            ans += nums[i] + nums[j] < target\n    return ans\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    @cache\n    def f(idx, a, b):\n        if idx == n-1:\n            return 0\n        if nums1[idx] <= a and nums2[idx] <= b:\n            return f(idx+1, a, b)\n        elif nums2[idx] <= a and nums1[idx] <= b:\n            return 1 + f(idx+1, a, b)\n        else:\n            return inf\n    ans = min(f(0, nums1[-1], nums2[-1]), 1 + f(0, nums2[-1], nums1[-1]))\n    return ans if ans < 10**9 else -1"}, {"source": "livecodebench-execution", "id": "sample_384", "function_name": "countPairs", "code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res", "distractor_code": "def maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    res = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(list(str(nums[i]))) == max(list(str(nums[j]))):\n                res = max(res, nums[i] + nums[j])\n    return res\n\ndef first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] < target:\n                res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_385", "function_name": "countPairs", "code": "def countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1,n):\n            if nums[i] + nums[j] < target:\n                ans += 1\n    return ans", "distractor_code": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    maxres = 0\n    for i,x in enumerate(nums):\n        for j,y in enumerate(nums[i+1:], start=i+1):\n            for k,z in enumerate(nums[j+1:], start=j+1):\n                val = (nums[i] - nums[j]) * nums[k]\n                maxres = max(maxres, val)\n    return maxres\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1,n):\n            if nums[i] + nums[j] < target:\n                ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_386", "function_name": "canMakeSubsequence", "code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    n1, n2 = len(str1), len(str2)\n    j = 0\n    for i in range(n1):\n        if str2[j] == 'a' and str1[i] == 'z':\n            j += 1\n        elif chr(ord(str2[j]) - 1) == str1[i] or str2[j] == str1[i]:\n            j += 1\n        if j == n2:\n            return True\n    return False\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True"}, {"source": "livecodebench-execution", "id": "sample_387", "function_name": "canMakeSubsequence", "code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    p1 = p2 = 0\n    def nxt(c):\n        if c == 'z':\n            return 'a' \n        else:\n            return chr(ord(c) + 1)\n    while p1 < len(str1) and p2 < len(str2):\n        if str2[p2] == str1[p1] or str2[p2] == nxt(str1[p1]):\n            p2 += 1\n        p1 += 1\n    return p2 == len(str2)", "distractor_code": "def countPairs(nums: List[int], target: int) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            ans += nums[i] + nums[j] < target\n    return ans\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    p1 = p2 = 0\n    def nxt(c):\n        if c == 'z':\n            return 'a' \n        else:\n            return chr(ord(c) + 1)\n    while p1 < len(str1) and p2 < len(str2):\n        if str2[p2] == str1[p1] or str2[p2] == nxt(str1[p1]):\n            p2 += 1\n        p1 += 1\n    return p2 == len(str2)"}, {"source": "livecodebench-execution", "id": "sample_388", "function_name": "canMakeSubsequence", "code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    \n    def cal(i):\n        if i=='z':\n            return 'a'\n        return chr(ord(i)+1)\n    \n    n1 = len(str1)\n    n2 = len(str2)\n    \n    i = 0\n    j = 0\n    \n    while i<n1 and j<n2:\n        if str1[i]==str2[j] or cal(str1[i])==str2[j]:\n            i+=1\n            j+=1\n        else:\n            i+=1\n    \n    return j>=n2", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    \n    def cal(i):\n        if i=='z':\n            return 'a'\n        return chr(ord(i)+1)\n    \n    n1 = len(str1)\n    n2 = len(str2)\n    \n    i = 0\n    j = 0\n    \n    while i<n1 and j<n2:\n        if str1[i]==str2[j] or cal(str1[i])==str2[j]:\n            i+=1\n            j+=1\n        else:\n            i+=1\n    \n    return j>=n2\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)\n\ndef minimumSteps(s: str) -> int:\n    n = len(s)\n    idx = [i for i, c in enumerate(s) if c == '0']\n    m = len(idx)\n    \n    return sum(idx) - m * (m - 1) // 2\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_389", "function_name": "canMakeSubsequence", "code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False", "distractor_code": "def minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans\n\ndef smallestString(s: str) -> str:\n    l = len(s)\n    i = 0\n    while i < l and s[i] == 'a': i += 1\n    if i == l: return s[:-1] + 'z'\n    s = list(s)\n    for j in range(i, l):\n        if s[j] == 'a': break\n        s[j] = chr(ord(s[j]) - 1)\n    return ''.join(s)\n\ndef maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    l1 = len(str1)\n    l2 = len(str2)\n    idx = 0\n    for c in str1:\n        if c == str2[idx] or ord(c) + 1 == ord(str2[idx]) or (c == 'z' and str2[idx] == 'a'):\n            idx += 1\n            if idx == l2:\n                return True\n    return False\n\ndef opposite_Signs(x,y): \n    return ((x ^ y) < 0); \n\ndef surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea"}, {"source": "livecodebench-execution", "id": "sample_390", "function_name": "canMakeSubsequence", "code": "def canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0", "distractor_code": "def distinctDifferenceArray(nums: List[int]) -> List[int]:\n    c = collections.Counter(nums)\n    suf = len(c)\n    ca = collections.Counter()\n    ans = []\n    for num in nums:\n        c[num] -= 1\n        if c[num] == 0:\n            suf -= 1\n        ca[num] += 1\n        ans.append(len(ca) - suf)\n    return ans\n\ndef splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res\n\ndef canMakeSubsequence(s1: str, s2: str) -> bool:\n    s1=list(s1)\n    s2=list(s2)\n    while s1 and s2:\n        c1=s1[-1]\n        c2=s2[-1]\n        if c1==c2 or (c1==\"z\" and c2==\"a\") or chr(ord(c1)+1)==c2:\n            s2.pop()\n            s1.pop()\n        else:\n            s1.pop()\n    return len(s2)==0"}, {"source": "livecodebench-execution", "id": "sample_391", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    s3 = s1[0] + s1[3] + s1[2] + s1[1]\n    s4 = s1[2] + s1[3] + s1[0] + s1[1]\n    s5 = s1[2] + s1[1] + s1[0] + s1[3]\n    return s2 == s1 or s2 == s3 or s2 == s4 or s2 == s5", "distractor_code": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    s3 = s1[0] + s1[3] + s1[2] + s1[1]\n    s4 = s1[2] + s1[3] + s1[0] + s1[1]\n    s5 = s1[2] + s1[1] + s1[0] + s1[3]\n    return s2 == s1 or s2 == s3 or s2 == s4 or s2 == s5\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)"}, {"source": "livecodebench-execution", "id": "sample_392", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)", "distractor_code": "def canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\nimport re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))\n\ndef subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\ndef minimumSteps(s: str) -> int:\n    a = []\n    for i in range(len(s)):\n        if s[i]=='0':\n            a.append(i)\n    ans = 0\n    for i in range(len(a)):\n        ans += abs(i-a[i])\n    return ans\n\ndef hexagonal_num(n): \n\treturn n*(2*n - 1) \n\ntmp = set()\nfor i in range(30):\n    x = bin(pow(5, i))[2:]\n    if len(x) > 15: break\n    tmp.add(x)\n\ndef minimumBeautifulSubstrings(s: str) -> int:\n    n = len(s)\n    @cache\n    def getRes(idx):\n        if idx == n: return 0\n        ans = inf\n        for j in range(idx+1, n+1):\n            if s[idx:j] in tmp:\n                ans = min(ans, getRes(j) + 1)\n        return ans\n    ans = getRes(0)\n    getRes.cache_clear()\n    return ans if ans < inf else -1"}, {"source": "livecodebench-execution", "id": "sample_393", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    \n    lst1 = [s1[0], s1[2]]\n    lst2 = [s2[0], s2[2]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    lst1 = [s1[1], s1[3]]\n    lst2 = [s2[1], s2[3]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    return True", "distractor_code": "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n \n\ndef minimizedStringLength(s: str) -> int:\n    graph = collections.defaultdict(int)\n    \n    for char in s:\n        graph[char] += 1\n    \n    return len(graph)\n\ndef countPairs(nums: List[int], target: int) -> int:\n    n = len(nums)\n    ans = 0\n    \n    for i in range(n):\n        for j in range(i+1,n):\n            if nums[i]+nums[j]<target:\n                ans+=1\n    \n    return ans\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    \n    lst1 = [s1[0], s1[2]]\n    lst2 = [s2[0], s2[2]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    lst1 = [s1[1], s1[3]]\n    lst2 = [s2[1], s2[3]]\n    if sorted(lst1) != sorted(lst2):\n        return False\n    return True\n\nimport re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n"}, {"source": "livecodebench-execution", "id": "sample_394", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    a = [s1[0], s1[2]]\n    b = [s2[0], s2[2]]\n    a.sort()\n    b.sort()\n    if a != b:\n        return False\n    a = [s1[1], s1[3]]\n    b = [s2[1], s2[3]]\n    a.sort()\n    b.sort()\n    return a == b", "distractor_code": "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\n\ndef minimumSum(n: int, k: int) -> int:\n    ans = set()\n    i = 1\n    while len(ans) < n:\n        if k - i not in ans:\n            ans.add(i)\n        i += 1\n    return sum(ans)\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i in range(n):\n        t = 0\n        for j in range(n):\n            t += grid[i][j]\n        if t == n - 1:\n            return i\n\ndef remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = [s1[0], s1[2]]\n    b = [s2[0], s2[2]]\n    a.sort()\n    b.sort()\n    if a != b:\n        return False\n    a = [s1[1], s1[3]]\n    b = [s2[1], s2[3]]\n    a.sort()\n    b.sort()\n    return a == b"}, {"source": "livecodebench-execution", "id": "sample_395", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    def sign(s):\n        return sorted(s[::2]), sorted(s[1::2])\n        \n    return sign(s1) == sign(s2)", "distractor_code": "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA\n\ndef findMinimumOperations(s1: str, s2: str, s3: str) -> int:\n    n = len(s1)\n    m = len(s2)\n    k = len(s3)\n    ans = inf\n    for i in range(1, n+1):\n        if s1[:i] == s2[:i] == s3[:i]:\n            x1 = n-i\n            x2 = m-i\n            x3 = k-i\n            cur = x1+x2+x3\n            if cur < ans:\n                ans = cur\n    return ans if ans < inf else -1\n\ndef matrixSum(a: List[List[int]]) -> int:\n    for i in range(len(a)):\n        a[i].sort()\n    ans = 0\n    for j in range(len(a[0])):\n        x = 0\n        for i in range(len(a)):\n            x = max(x, a[i][j])\n        ans += x\n    return ans\n\ndef minLength(s: str) -> int:\n    while True:\n        t=s.replace(\"AB\",\"\").replace(\"CD\",\"\")\n        if t==s:\n            return len(t)\n        else:\n            s=t\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    def sign(s):\n        return sorted(s[::2]), sorted(s[1::2])\n        \n    return sign(s1) == sign(s2)"}, {"source": "livecodebench-execution", "id": "sample_396", "function_name": "canBeEqual", "code": "def canBeEqual(s1: str, s2: str) -> bool:\n    def cut(s):\n        return (sorted(s[::2]), sorted(s[1::2]))\n    \n    return cut(s1) == cut(s2)", "distractor_code": "def colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    c = [0] * n\n    ans = 0\n    res = []\n    for i, x in queries:\n        if c[i]:\n            if i:\n                ans -= c[i] == c[i - 1]\n            if i + 1 < n:\n                ans -= c[i] == c[i + 1]\n        c[i] = x\n        if i:\n            ans += c[i] == c[i - 1]\n        if i + 1 < n:\n            ans += c[i] == c[i + 1]\n        res.append(ans)\n    return res\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    ans = 0\n    for i in range(n + 1):\n        if i and nums[i-1] >= i: continue\n        if i < n and nums[i] <= i: continue\n        ans += 1\n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = math.inf\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if nums[i] < nums[j] and nums[k] < nums[j]:\n                    ans = min(ans,nums[i]+nums[j]+nums[k])\n    return ans if ans!=math.inf else -1\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    c = Counter()\n    res = 0\n    for i in words:\n        si = \"\".join(i[::-1])\n        if c[si]:\n            c[si] -= 1\n            res += 1\n        else:\n            c[i] += 1\n    return res\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    queue = deque()\n    for i in range(k):\n        queue.append(nums[i])\n        \n    curr = 0\n    for i in range(k, len(nums)):\n        if curr > queue[0]:\n            return False\n        \n        curr = queue.popleft()\n        queue.append(curr + nums[i])\n    \n    n = len(set(queue))\n    return n == 1\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    def cut(s):\n        return (sorted(s[::2]), sorted(s[1::2]))\n    \n    return cut(s1) == cut(s2)"}, {"source": "livecodebench-execution", "id": "sample_397", "function_name": "maxSum", "code": "from typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum", "distractor_code": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)\n\ndef combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result\n\nfrom typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1\n\ndef finalString(s: str) -> str:\n    ans = ''\n    for c in s:\n        if c == 'i':\n            ans = ans[::-1]\n        else:\n            ans += c\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_398", "function_name": "maxSum", "code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    c = Counter()\n    ssum = 0\n    n = len(nums)\n    for i in range(k):\n        c[nums[i]] += 1\n        ssum += nums[i]\n    res = ssum if len(c) >= m else 0\n    for i in range(k, n):\n        c[nums[i]] += 1\n        c[nums[i-k]] -= 1\n        if not c[nums[i-k]]:\n            del c[nums[i-k]]\n        ssum += nums[i] - nums[i-k]\n        if len(c) >= m:\n            res = max(res, ssum)\n    return res", "distractor_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    c = Counter()\n    ssum = 0\n    n = len(nums)\n    for i in range(k):\n        c[nums[i]] += 1\n        ssum += nums[i]\n    res = ssum if len(c) >= m else 0\n    for i in range(k, n):\n        c[nums[i]] += 1\n        c[nums[i-k]] -= 1\n        if not c[nums[i-k]]:\n            del c[nums[i-k]]\n        ssum += nums[i] - nums[i-k]\n        if len(c) >= m:\n            res = max(res, ssum)\n    return res\n\ndef makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]"}, {"source": "livecodebench-execution", "id": "sample_399", "function_name": "maxSum", "code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    cnt = defaultdict(int)\n    ans = 0\n    c = 0\n    s = 0\n    for r,x in enumerate(nums):\n        cnt[x] += 1\n        if cnt[x] == 1: c += 1\n        s += x\n        if r >= k:\n            y = nums[r-k]\n            cnt[y] -= 1\n            if cnt[y] == 0: c -= 1\n            s -= y\n        if c >= m: ans = max(ans,s)\n    return ans", "distractor_code": "def isAcronym(words: List[str], s: str) -> bool:\n    res = ''\n    for w in words:\n        res += w[0]\n    \n    return res == s\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    cnt = defaultdict(int)\n    ans = 0\n    c = 0\n    s = 0\n    for r,x in enumerate(nums):\n        cnt[x] += 1\n        if cnt[x] == 1: c += 1\n        s += x\n        if r >= k:\n            y = nums[r-k]\n            cnt[y] -= 1\n            if cnt[y] == 0: c -= 1\n            s -= y\n        if c >= m: ans = max(ans,s)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_400", "function_name": "maxSum", "code": "def maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res", "distractor_code": "def isFascinating(n: int) -> bool:\n    s = str(n)+str(2*n)+str(3*n)\n    return set(s) == set(\"123456789\") and len(s) == 9\n\ndef maxSum(A: List[int], m: int, k: int) -> int:\n    count = Counter(A[:k])\n    res = 0\n    total = sum(A[:k])\n    if len(count) >= m:\n        res = total\n    for j in range(k, len(A)):\n        total += A[j] - A[j - k]\n        count[A[j]] += 1\n        count[A[j - k]] -= 1\n        if count[A[j - k]] == 0:\n            del count[A[j - k]]\n        if len(count) >= m:\n            res = max(res, total)\n    return res\n\ndef max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    "}, {"source": "livecodebench-execution", "id": "sample_401", "function_name": "maxSum", "code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans", "distractor_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    ans = 0\n    n = len(nums)\n    cur = 0\n    dic = Counter()\n    for i in range(k):\n        cur += nums[i]\n        dic[nums[i]] += 1\n    if len(dic) >= m:\n        ans = cur\n    for i in range(k, n):\n        cur += nums[i]\n        cur -= nums[i - k]\n        dic[nums[i]] += 1\n        dic[nums[i - k]] -= 1\n        if dic[nums[i - k]] == 0:\n            del dic[nums[i - k]]\n        if len(dic) >= m:\n            ans = max(ans, cur)\n    return ans\n\ndef Extract(lst): \n    return [item[0] for item in lst] \n\ndef removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")\n\ndef concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) \n\ndef alternatingSubarray(nums: List[int]) -> int:\n    ans = -1\n    n = len(nums)\n    for i in range(n):\n        delta = 1\n        for j in range(i + 1, n):\n            if nums[j] - nums[j - 1] == delta:\n                ans = max(ans, j - i + 1)\n                delta = -delta\n            else:\n                break\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_402", "function_name": "maxSum", "code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    cntr = Counter(nums[:k])\n    cursum = sum(nums[:k])\n    \n    maxres = 0\n    if len(cntr) >= m:\n        maxres += cursum\n                   \n    for out, inp in zip(nums, nums[k:]):\n        cursum -= out\n        cursum += inp\n        cntr[out] -= 1\n        if cntr[out] == 0:\n            del cntr[out]\n        cntr[inp] += 1\n        if len(cntr) >= m:\n            maxres = max(maxres, cursum)\n    \n    return maxres", "distractor_code": "def maxSum(nums: List[int], m: int, k: int) -> int:\n    cntr = Counter(nums[:k])\n    cursum = sum(nums[:k])\n    \n    maxres = 0\n    if len(cntr) >= m:\n        maxres += cursum\n                   \n    for out, inp in zip(nums, nums[k:]):\n        cursum -= out\n        cursum += inp\n        cntr[out] -= 1\n        if cntr[out] == 0:\n            del cntr[out]\n        cntr[inp] += 1\n        if len(cntr) >= m:\n            maxres = max(maxres, cursum)\n    \n    return maxres\n\nfrom collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  \n\ndef colorTheArray(n: int, queries: List[List[int]]) -> List[int]:\n    ret = 0\n    a = [0] * n\n    ans = []\n    for x, y in queries:\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret -= 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret -= 1\n        a[x] = y\n        if x > 0 and a[x-1] == a[x] and a[x] != 0:\n            ret += 1\n        if x < n-1 and a[x+1] == a[x] and a[x] != 0:\n            ret += 1\n        ans.append(ret)\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)"}, {"source": "livecodebench-execution", "id": "sample_403", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    s = sorted(nums)\n    n = len(nums)\n    for i in range(n + 10):\n        t = [nums[-1]] + nums[:-1][:]\n        if s == t:\n            return (i + 1) % n\n        nums = t[:]\n        # print('t', t, nums)\n    else:\n        return -1", "distractor_code": "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    s = sorted(nums)\n    n = len(nums)\n    for i in range(n + 10):\n        t = [nums[-1]] + nums[:-1][:]\n        if s == t:\n            return (i + 1) % n\n        nums = t[:]\n        # print('t', t, nums)\n    else:\n        return -1\n\ndef ascii_value(k):\n  ch=k\n  return ord(ch)\n\ndef add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n\ndef count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars "}, {"source": "livecodebench-execution", "id": "sample_404", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1", "distractor_code": "def countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (j - i) & 1:\n                if nums[j] != nums[i] + 1:\n                    break\n            else:\n                if nums[j] != nums[i]:\n                    break\n            ans = max(ans, j - i + 1)\n    return ans\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    def sign(s):\n        return sorted(s[::2]), sorted(s[1::2])\n        \n    return sign(s1) == sign(s2)\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    x = Counter(nums).values()\n    m = inf\n    for n in range(1, min(x) + 1):\n        y = 0\n        for v in x:\n            if v // n < (v + n) // (n + 1):\n                break\n            y += (v + n) // (n + 1)\n        else:\n            m = min(m, y)\n            \n    return m\n\ndef numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    indexs = []\n    Mod = 10**9 + 7\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            indexs.append(i)\n    if len(indexs) == 0:\n        return 0\n    ans = 1\n    for i in range(1,len(indexs)):\n        ans *= (indexs[i] - indexs[i-1])\n        ans %= Mod\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_405", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        check = True\n        for j in range(n - i + 1, n * 2 - i):\n            if nums[j % n] < nums[(j - 1) % n]:\n                check = False\n                break\n        if check: return i\n    return -1", "distractor_code": "def beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres\n\ndef sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos\n\ndef check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        check = True\n        for j in range(n - i + 1, n * 2 - i):\n            if nums[j % n] < nums[(j - 1) % n]:\n                check = False\n                break\n        if check: return i\n    return -1\n\ndef tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result"}, {"source": "livecodebench-execution", "id": "sample_406", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    b = sorted(nums)\n    ans = inf\n    n = len(nums)\n    for i in range(n):\n        a = nums[i:] + nums[:i]\n        if a == b:\n            ans = min(ans, (n - i) % n)\n    return -1 if ans == inf else ans", "distractor_code": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))\n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    b = sorted(nums)\n    ans = inf\n    n = len(nums)\n    for i in range(n):\n        a = nums[i:] + nums[:i]\n        if a == b:\n            ans = min(ans, (n - i) % n)\n    return -1 if ans == inf else ans\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    \n    res = 1  # select all\n    \n    if nums.count(0) == 0:  # select none\n        res += 1\n    \n    for i,(x,y) in enumerate(zip(nums, nums[1:]), start=1):\n        if x < i < y:\n            # print(x,i,y)\n            res += 1\n            \n    # print()\n    \n    return res\n\ndef sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)"}, {"source": "livecodebench-execution", "id": "sample_407", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    t = sorted(nums)\n    if t == nums:\n        return 0\n    for i in range(1, n+1):\n        nums = [nums[-1]] + nums[:-1]\n        if t == nums:\n            return i\n    return -1", "distractor_code": "def minimumRightShifts(nums: List[int]) -> int:\n    n = len(nums)\n    t = sorted(nums)\n    if t == nums:\n        return 0\n    for i in range(1, n+1):\n        nums = [nums[-1]] + nums[:-1]\n        if t == nums:\n            return i\n    return -1\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\nimport re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))"}, {"source": "livecodebench-execution", "id": "sample_408", "function_name": "minimumRightShifts", "code": "def minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1", "distractor_code": "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums\n\ndef canMakeSubsequence(str1: str, str2: str) -> bool:\n    p1 = p2 = 0\n    def nxt(c):\n        if c == 'z':\n            return 'a' \n        else:\n            return chr(ord(c) + 1)\n    while p1 < len(str1) and p2 < len(str2):\n        if str2[p2] == str1[p1] or str2[p2] == nxt(str1[p1]):\n            p2 += 1\n        p1 += 1\n    return p2 == len(str2)\n\ndef maxIncreasingGroups(A: List[int]) -> int:\n    A.sort()\n    n = len(A)\n\n    ii = 0\n    pre = 0\n    ceil = inf\n    k = 1\n    while k <= ceil:\n        while ii < n and A[ii] <= k:\n            pre += A[ii]\n            ii += 1\n        total = pre + k * (n - ii)\n\n        a = (total * 2 // k - k - 1) // 2\n        while ((a + 1) + (a + k)) * k // 2 <= total:\n            a += 1\n        ceil = min(ceil, a + k - 1)\n        if k <= ceil:\n            res = k\n        k += 1\n    return res\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        c1, c2 = s[left], s[right]\n        if c1 != c2:\n            s[left] = min(c1, c2)\n            s[right] = s[left]\n        left += 1\n        right -= 1\n    return ''.join(s)\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1"}, {"source": "livecodebench-execution", "id": "sample_409", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    n = len(nums)\n    for k,v in c.items():\n        if v >= n - v:\n            return v - (n - v)\n    return n % 2", "distractor_code": "def canMakeSubsequence(str1: str, str2: str) -> bool:\n    p1 = p2 = 0\n    def nxt(c):\n        if c == 'z':\n            return 'a' \n        else:\n            return chr(ord(c) + 1)\n    while p1 < len(str1) and p2 < len(str2):\n        if str2[p2] == str1[p1] or str2[p2] == nxt(str1[p1]):\n            p2 += 1\n        p1 += 1\n    return p2 == len(str2)\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    n = len(nums)\n    for k,v in c.items():\n        if v >= n - v:\n            return v - (n - v)\n    return n % 2\n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    ans = 1\n    n = len(nums)\n    l = 0\n    for r in range(n):\n        while nums[r] - nums[l] > 2 * k:\n            l += 1\n        ans = max(ans, r - l + 1)\n    return ans\n\ndef find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) "}, {"source": "livecodebench-execution", "id": "sample_410", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1", "distractor_code": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    t = \"\"\n    for c in words:\n        t += c[0]\n    return t == s\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef semiOrderedPermutation(nums: List[int]) -> int:\n    n = len(nums)\n    a = nums.index(1)\n    b = nums.index(n)\n    \n    if a < b:\n        return a + n - 1 - b\n    else:\n        return a + n - 1 - b - 1\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    mx = max(c.values())\n    n = len(nums)\n    \n    if mx > n - mx:\n        return 2 * mx - n\n    else:\n        return n & 1"}, {"source": "livecodebench-execution", "id": "sample_411", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    n = len(nums)\n    h = [-v for v in Counter(nums).values()]\n    heapify(h)\n    while len(h) >= 2:\n        x = -heappop(h)\n        y = -heappop(h)\n        x -= 1 \n        y -= 1 \n        if x:heappush(h,-x)\n        if y:heappush(h,-y)\n    return -sum(h)", "distractor_code": "def minimumCost(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s)):\n        if s[i - 1] != s[i]:\n            ans += min(i, len(s) - i)\n    \n    return ans\n\ndef distinctDifferenceArray(nums: List[int]) -> List[int]:\n    r = Counter(nums)\n    l = set()\n    ans = []\n    for x in nums:\n        r[x] -= 1\n        if not r[x]:\n            del r[x]\n        l.add(x)\n        ans.append(len(l) - len(r))\n    return ans\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    n = len(nums)\n    h = [-v for v in Counter(nums).values()]\n    heapify(h)\n    while len(h) >= 2:\n        x = -heappop(h)\n        y = -heappop(h)\n        x -= 1 \n        y -= 1 \n        if x:heappush(h,-x)\n        if y:heappush(h,-y)\n    return -sum(h)"}, {"source": "livecodebench-execution", "id": "sample_412", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    ans = n = len(nums)\n    i, j = n // 2 - 1, n - 1\n    while i >= 0:\n        while i >= 0 and nums[i] == nums[j]:\n            i -= 1\n        if i >= 0:\n            ans -= 2\n            j -= 1\n            i -= 1\n    return ans", "distractor_code": "def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    ans = n = len(nums)\n    i, j = n // 2 - 1, n - 1\n    while i >= 0:\n        while i >= 0 and nums[i] == nums[j]:\n            i -= 1\n        if i >= 0:\n            ans -= 2\n            j -= 1\n            i -= 1\n    return ans\n\ndef last_Digit(n) :\n    return (n % 10) \n\ndef find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num \n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)\n\ndef find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] "}, {"source": "livecodebench-execution", "id": "sample_413", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2", "distractor_code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    cnt = collections.Counter(words)\n    ans = 0\n    keys = list(cnt.keys())\n    vis = set()\n    for key in keys:\n        if key == key[::-1]:\n            ans += cnt[key] // 2\n        elif key not in vis:\n            vis.add(key)\n            vis.add(key[::-1])\n            ans += min(cnt[key], cnt[key[::-1]])\n    return ans\n\ndef sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1\n\ndef findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef longestString(x: int, y: int, z: int) -> int:\n    if x > y:\n        return 2 * (y + min(y + 1, x) + z)\n    else:\n        return 2 * (x + min(x + 1, y) + z)"}, {"source": "livecodebench-execution", "id": "sample_414", "function_name": "minLengthAfterRemovals", "code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1", "distractor_code": "def minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    s = 0\n    for i, v in enumerate(nums):\n        if bin(i).count('1') == k: s += v\n    return s\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1\n\ndef number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); "}, {"source": "livecodebench-execution", "id": "sample_415", "function_name": "countPairs", "code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res", "distractor_code": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; \n\ndef maximumBeauty(nums: List[int], k: int) -> int:\n    nums.sort()\n    j = 0\n    ans = 0\n    for i in range(len(nums)):\n        while j < len(nums) and nums[j] - nums[i] <= 2 * k:\n            j += 1\n        ans = max(ans, j - i)\n    return ans\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res\n\ndef is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set\n\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    \n    dp = [0]*(n+1)\n    offers.sort(key=lambda x:x[1])\n    m = len(offers)\n    po = 0\n    \n    for j in range(n):\n        dp[j]=max(dp[j],dp[j-1])\n        while po<m and offers[po][1]==j:\n            dp[j]=max(dp[j],dp[offers[po][0]-1]+offers[po][2])\n            po+=1\n    return dp[n-1]"}, {"source": "livecodebench-execution", "id": "sample_416", "function_name": "countPairs", "code": "def countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans", "distractor_code": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    answer = []\n    \n    for w in words:\n        answer.extend([c for c in w.split(separator) if c != ''])\n        \n    return answer\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef minOperations(nums1: List[int], nums2: List[int]) -> int:\n    def check(m1, m2):\n        ans = 0\n        for x1, x2 in zip(nums1, nums2):\n            if x1 > m1 or x2 > m2:\n                if x2 > m1 or x1 > m2:\n                    return inf\n                ans += 1\n        return ans\n    m1 = nums1[-1]\n    m2 = nums2[-1]\n    ans = min(check(m1, m2), check(m2, m1))\n    return -1 if ans == inf else ans"}, {"source": "livecodebench-execution", "id": "sample_417", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    have = set()\n    for i, n in enumerate(reversed(nums)): \n        if n <= k: have.add(n)\n        if len(have) == k: return i+1", "distractor_code": "def maximumOddBinaryNumber(s: str) -> str:\n    n = len(s)\n    num_1s = s.count('1')\n    st = '1' * (num_1s - 1)\n    st += '0' * (n - num_1s)\n    st += '1'\n    return st\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    b = sorted(nums)\n    ans = inf\n    n = len(nums)\n    for i in range(n):\n        a = nums[i:] + nums[:i]\n        if a == b:\n            ans = min(ans, (n - i) % n)\n    return -1 if ans == inf else ans\n\ndef minOperations(nums: List[int], k: int) -> int:\n    have = set()\n    for i, n in enumerate(reversed(nums)): \n        if n <= k: have.add(n)\n        if len(have) == k: return i+1\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n\ndef dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"}, {"source": "livecodebench-execution", "id": "sample_418", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1", "distractor_code": "def minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for j, n in enumerate(nums[::-1]):\n        s.add(n)\n        flag = True\n        for i in range(1, k + 1):\n            if i not in s:\n                flag = False\n        if flag: return j + 1\n\ndef find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count\n\nimport re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" "}, {"source": "livecodebench-execution", "id": "sample_419", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    nums = nums[::-1]\n    s = set()\n    for i,c in enumerate(nums):\n        if c>k:\n            continue\n        s.add(c)\n        if len(s)==k:\n            return i+1;", "distractor_code": "def numberOfGoodSubarraySplits(nums: List[int]) -> int:\n    if all([t==0 for t in nums]) :\n        return 0\n    ttt = 10**9+7\n    base = 1\n    tmp = -1\n    for c in nums :\n        if c == 1 :\n            if tmp > 0 :\n                base = (base * tmp) % ttt\n            tmp = 1\n        elif tmp >= 0 :\n            tmp += 1\n    return base\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    m, a = mainTank, additionalTank\n    res = 0\n    while m > 0:\n        if m < 5:\n            res += m\n            break\n        else:\n            m -= 5\n            if a > 0:\n                a -= 1\n                m += 1\n            res += 5\n    return res * 10\n\nfrom collections import Counter\n\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    for k, v in Counter(nums).items():\n        if v == 1:\n            return -1\n        r = v % 3\n        if r == 0:\n            ans += v // 3\n        elif r == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    arr = list(num)\n    while arr and arr[-1] == \"0\":\n        arr.pop()\n    if arr:\n        return \"\".join(arr)\n    else:\n        return \"0\"\n\ndef minOperations(nums: List[int], k: int) -> int:\n    nums = nums[::-1]\n    s = set()\n    for i,c in enumerate(nums):\n        if c>k:\n            continue\n        s.add(c)\n        if len(s)==k:\n            return i+1;"}, {"source": "livecodebench-execution", "id": "sample_420", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct", "distractor_code": "def longestEqualSubarray(nums: List[int], k: int) -> int:\n    ans = 0\n    mp = defaultdict(list)\n    for i, x in enumerate(nums):\n        mp[x].append(i)\n    for a in mp.values():\n        m = len(a)\n        j = 0\n        for i in range(m):\n            while a[i] - a[j] - (i - j) > k:\n                j += 1\n            ans = max(ans, i - j + 1)\n    return ans\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    ret = 0\n    for i, x in enumerate(nums):\n        if bin(i).count('1') == k:\n            ret += x\n    return ret\n\ndef isGood(a: List[int]) -> bool:\n    \n    n = len(a) - 1\n    for i in range(1, n):\n        if a.count(i) != 1:\n            return False\n    \n    return a.count(n) == 2\n\ndef minOperations(nums: List[int], k: int) -> int:\n    ct = 0\n    st = set()\n    for v in nums[::-1]:\n        ct += 1\n        if v <= k:\n            st.add(v)\n            if len(st) == k:\n                return ct\n\ndef minimumSteps(s: str) -> int:\n    n = len(s)\n    idx = [i for i, c in enumerate(s) if c == '0']\n    m = len(idx)\n    \n    return sum(idx) - m * (m - 1) // 2"}, {"source": "livecodebench-execution", "id": "sample_421", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    n = len(derived)\n    if n == 1:\n        return derived[0] == 0\n    ans = 0\n    for i in range(n - 1):\n        ans ^= derived[i]\n    return ans == derived[-1]\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_422", "function_name": "minOperations", "code": "def minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1", "distractor_code": "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) \n\ndef maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax\n\ndef magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True\n\ndef differenceOfSums(n: int, m: int) -> int:\n    return sum(x for x in range(1, n + 1) if x % m) - sum(x for x in range(1, n + 1) if x % m == 0)\n\ndef minOperations(nums: List[int], k: int) -> int:\n    s = set()\n    for i, num in enumerate(reversed(nums)):\n        \n        if 1 <= num <= k:\n            s.add(num)\n        if len(s) == k:\n            return i + 1\n\ndef intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result"}, {"source": "livecodebench-execution", "id": "sample_423", "function_name": "minOperations", "code": "def minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans", "distractor_code": "def canBeEqual(s1: str, s2: str) -> bool:\n    a = list(s1)\n    b = list(s2)\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n    if a[1] > a[3]:\n        a[1], a[3] = a[3], a[1]\n    if b[0] > b[2]:\n        b[0], b[2] = b[2], b[0]\n    if b[1] > b[3]:\n        b[1], b[3] = b[3], b[1]\n    return ''.join(a) == ''.join(b)\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for v in cnt.values():\n        if v == 1:\n            return -1\n        if v % 3 == 0:\n            ans += v // 3\n        elif v % 3 == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef makeSmallestPalindrome(s: str) -> str:\n    n = len(s)\n    s = list(s)\n    \n    for i in range(n // 2):\n        x = i\n        y = n - 1 - i\n        c = min(s[x], s[y])\n        s[x] = c\n        s[y] = c\n    return \"\".join(s)"}, {"source": "livecodebench-execution", "id": "sample_424", "function_name": "minOperations", "code": "def minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans", "distractor_code": "def smallestString(s: str) -> str:\n    if s == \"a\"*len(s):\n        return \"a\"*(len(s)-1)+\"z\"\n    r = \"\"\n    p = 0\n    for i in s:\n        if p == 1:\n            if i == \"a\":\n                p = 2\n                r += i\n            else:\n                r += chr(ord(i)-1)\n        elif p == 0:\n            if i == \"a\":\n                r += i\n            else:\n                p = 1\n                r += chr(ord(i)-1)\n        else:\n            r += i\n    return r\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    a = 0\n    x, y = num1, num2\n    while x > y:\n        x -= y\n        a += 1\n        b = x\n        c = 0\n        cc = 0\n        z = 1\n        while b:\n            c += (b%2 == 1)\n            cc += (b%2 == 1)*z\n            z *= 2\n            b //= 2\n        if c <= a and cc >= a:\n            return a\n    return -1\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    cnt=0\n    ans=0\n    last=-1\n    c=Counter([0])\n    for x in nums:\n        if x%m==k:\n            cnt+=1\n        ans+=c[(cnt-k)%m]\n\n        \n        c[cnt%m]+=1\n\n        \n            # last=i\n        \n        \n    return ans\n\ndef replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2\n\ndef minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_425", "function_name": "minOperations", "code": "def minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for a, b in cnt.items():\n        if b == 1:\n            return -1\n        if b % 3 == 0:\n            ans += b // 3\n        if b % 3 == 1:\n            ans += (b - 4) // 3 + 2\n        if b % 3 == 2:\n            ans += (b - 2) // 3 + 1\n    return ans", "distractor_code": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    cnt = Counter(nums)\n    for a, b in cnt.items():\n        if b == 1:\n            return -1\n        if b % 3 == 0:\n            ans += b // 3\n        if b % 3 == 1:\n            ans += (b - 4) // 3 + 2\n        if b % 3 == 2:\n            ans += (b - 2) // 3 + 1\n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans"}, {"source": "livecodebench-execution", "id": "sample_426", "function_name": "minOperations", "code": "def minOperations(nums: List[int]) -> int:\n  c = {}\n  for x in nums:\n    c[x] = c.get(x, 0) + 1\n  ret = 0\n  for x in c.values():\n    if x < 2:\n      return -1\n    if x % 3 == 0:\n      ret += x // 3\n    elif x % 3 == 1:\n      ret += 2 + (x - 4) // 3\n    else:\n      ret += 1 + (x - 2) // 3\n  return ret", "distractor_code": "def maximumTripletValue(nums: List[int]) -> int:\n    n =len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n\n    return ans\n\ndef maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    left = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        left[i] = tmp\n    s = s[::-1]\n    right = [0] * (n)\n    tmp = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i-1]:\n            tmp += i\n        right[i] = tmp\n    right.reverse()\n    return min(x + y for x, y in zip(left, right))\n\ndef minOperations(nums: List[int]) -> int:\n  c = {}\n  for x in nums:\n    c[x] = c.get(x, 0) + 1\n  ret = 0\n  for x in c.values():\n    if x < 2:\n      return -1\n    if x % 3 == 0:\n      ret += x // 3\n    elif x % 3 == 1:\n      ret += 2 + (x - 4) // 3\n    else:\n      ret += 1 + (x - 2) // 3\n  return ret\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    cnt = [0] * (101)\n    for l,r in nums:\n        for j in range(l, r + 1):\n            cnt[j] = 1\n    return sum(cnt)\n\ndef matrixSum(a: List[List[int]]) -> int:\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        a[i] = sorted(a[i])\n    ans = 0\n    for j in range(m):\n        tmp = 0\n        for i in range(n):\n            tmp = max(tmp, a[i][j])\n        ans += tmp\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_427", "function_name": "minOperations", "code": "def minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans", "distractor_code": "def minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    for x in range(1, 1000):\n        k = num1 - x * num2\n        if k <= 0:\n            break\n        if bin(k).count('1') <= x and k >= x:\n            return x\n    return -1\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    for i in range(1, k + 1):\n        if i * i % k == 0:\n            k = i * 2\n            break\n    cc = [Counter() for _ in range(k)]\n    cc[0][0] = 1\n    ans = cur = 0\n    for i, x in enumerate(s, 1):\n        cur += 1 if x in 'aeiou' else -1\n        ans += cc[i % k][cur]\n        cc[i % k][cur] += 1\n    return ans\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    mp = defaultdict(int)\n    for x, y in coordinates:\n        mp[(x, y)] += 1\n    \n    res = 0\n    for i in range(k + 1):\n        a, b = i, k - i\n        tmp = mp.copy()\n        for x, y in coordinates:\n            tmp[(x, y)] -= 1\n            if (a ^ x, b ^ y) in tmp:\n                res += tmp[(a ^ x, b ^ y)]\n    \n    return res\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1"}, {"source": "livecodebench-execution", "id": "sample_428", "function_name": "minOperations", "code": "from collections import Counter\n\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    for k, v in Counter(nums).items():\n        if v == 1:\n            return -1\n        r = v % 3\n        if r == 0:\n            ans += v // 3\n        elif r == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans", "distractor_code": "def maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]\n\nfrom collections import Counter\n\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    for k, v in Counter(nums).items():\n        if v == 1:\n            return -1\n        r = v % 3\n        if r == 0:\n            ans += v // 3\n        elif r == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    \n    return sum(i>=target for i in hours )\n\ndef makeSmallestPalindrome(s: str) -> str:\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        c = min(s[i], s[n - 1 - i])\n        s[i] = c\n        s[n - 1 - i] = c\n    return \"\".join(s)"}, {"source": "livecodebench-execution", "id": "sample_429", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r", "distractor_code": "def countSeniors(details: List[str]) -> int:\n    ans = 0\n    for s in details:\n        if int(s[-4:-2]) > 60:\n            ans += 1\n    return ans\n\ndef smallestString(s: str) -> str:\n    s = list(s)\n    for i in range(len(s)):\n        if s[i] != 'a':\n            while i < len(s) and s[i] != 'a':\n                s[i] = chr(ord(s[i]) - 1)\n                i += 1\n            break\n    else:\n        s[-1] = 'z'\n    return ''.join(s)\n\ndef maximumTripletValue(nums: List[int]) -> int:\n  maxNum = max(nums[0], nums[1])\n  maxDiff = nums[0] - nums[1]\n  maxTriplet = 0\n  \n  for num in islice(nums, 2, len(nums)):\n    maxTriplet = max(maxTriplet, maxDiff * num)\n    \n    maxDiff = max(maxDiff, maxNum - num)\n    \n    maxNum = max(maxNum, num)\n  \n  return maxTriplet\n\ndef maxSubarrays(nums: List[int]) -> int:\n    r = nums[0]\n    for n in nums:\n        r &= n\n    if r > 0:\n        return 1\n    r = 0\n    c = nums[0]\n    for i in range(len(nums)):\n        c &= nums[i]\n        if c == 0:\n            r += 1\n            if i == len(nums) - 1:\n                break\n            c = nums[i + 1]\n    return r\n\ndef rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  "}, {"source": "livecodebench-execution", "id": "sample_430", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    res, target = 0, nums[0]\n    for n in nums[1:]: target &= n\n    if target != 0: return 1\n    cur = -1\n    for n in nums:\n        if cur == -1: cur = n\n        cur &= n\n        if cur == target:\n            cur = -1\n            res += 1\n    return res", "distractor_code": "def distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    res = 0\n    while mainTank > 0:\n        if mainTank >= 5:\n            mainTank -= 5\n            res += 50\n            if additionalTank:\n                additionalTank -= 1\n                mainTank += 1            \n        else:\n            res += mainTank * 10\n            mainTank = 0\n    return res\n\ndef maxStrength(nums: List[int]) -> int:\n    ans = max(nums)\n    p = [num for num in nums if num > 0]\n    pmax = 1\n    if len(p) > 0:\n        pmax *= prod(p)\n    n = [num for num in nums if num < 0]\n    n.sort()\n    nmax = 1\n    if len(n) > 0:\n        m = len(n) - len(n) % 2\n        nmax *= prod(n[:m])\n    if len(p) == 0 and len(n) < 2:\n        return ans\n    return pmax * nmax\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res, target = 0, nums[0]\n    for n in nums[1:]: target &= n\n    if target != 0: return 1\n    cur = -1\n    for n in nums:\n        if cur == -1: cur = n\n        cur &= n\n        if cur == target:\n            cur = -1\n            res += 1\n    return res\n\ndef is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False\n\ndef sortVowels(s: str) -> str:\n    n = len(s)\n    t = []\n    p = []\n    for i in range(n):\n        if s[i] in \"aeiou\" or s[i] in \"AEIOU\":\n            t.append(s[i])\n            p.append(i)\n    t.sort()\n    res = list(s)\n    for i in range(len(t)):\n        res[p[i]] = t[i]\n    return \"\".join(res)\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum"}, {"source": "livecodebench-execution", "id": "sample_431", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans", "distractor_code": "def finalString(s: str) -> str:\n    res = []\n    for x in s: \n        if x == 'i': \n            res = res[::-1]\n        else: \n            res.append(x)\n    return ''.join(res)\n\ndef maxSum(nums: List[int]) -> int:\n    \n    ans = -1\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if max(str(nums[i]))==max(str(nums[j])):\n                ans = max(ans,nums[i]+nums[j])\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    res = nums[0]\n    for i in range(1, len(nums)):\n        res &= nums[i]\n    if res:\n        return 1\n    ans = 0\n    cur = nums[0]\n    for i in range(len(nums)):\n        cur &= nums[i]\n        if cur == 0:\n            ans += 1\n            if i + 1 < len(nums):\n                cur = nums[i + 1]\n    return ans\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    \n    v = 0\n    for c in derived:\n        v ^= c\n    if v == 0: return True\n    \n    v = 1\n    for c in derived:\n        v ^= c\n    if v == 1: return True\n    \n    return False\n\ndef minOperations(nums: List[int], k: int) -> int:\n    vis = [0] * (k + 1)\n    cnt = 0\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        if nums[i] <= k and not vis[nums[i]]:\n            vis[nums[i]] = 1\n            cnt += 1\n            if cnt == k:\n                return n - i\n\ndef sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())"}, {"source": "livecodebench-execution", "id": "sample_432", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)", "distractor_code": "def maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)\n\ndef countSeniors(details: List[str]) -> int:\n    out = 0\n    for s in details:\n        if int(int(s[11:13]) > 60):\n            out += 1\n    return out\n\ndef smallestString(s: str) -> str:\n    if s == 'a': return 'z'\n    t = list(s)\n    l = r = -1\n    for i, c in enumerate(s):\n        if c != 'a':\n            if l == -1:\n                l = i\n            r = i\n        elif l != -1:\n            break\n    if l != -1:\n        for i in range(l, r + 1):\n            t[i] = chr(ord(t[i]) - 1)\n    else:\n        t[-1] = 'z'\n    return ''.join(t)\n\ndef minOperations(nums: List[int]) -> int:\n    cs = collections.Counter(nums)\n    ans = 0\n    for k,v in cs.items():\n        if v==1:\n            return -1\n        ans += (v+2)//3\n    return ans\n\ndef removeTrailingZeros(num: str) -> str:\n    if num.count(\"0\") == len(num):\n        return \"\"\n    return num.rstrip(\"0\")"}, {"source": "livecodebench-execution", "id": "sample_433", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res", "distractor_code": "def minCost(A: List[int], x: int) -> int:\n    n = len(A)\n    mns = list(range(0, n * x, x))\n    for i in range(n):\n        mn = A[i]\n        for j in range(n):\n            mn = min(mn, A[(i+j)%n])\n            mns[j] += mn\n    return min(mns)\n\ndef maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) \n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    ans = n = len(nums)\n    i, j = n // 2 - 1, n - 1\n    while i >= 0:\n        while i >= 0 and nums[i] == nums[j]:\n            i -= 1\n        if i >= 0:\n            ans -= 2\n            j -= 1\n            i -= 1\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res"}, {"source": "livecodebench-execution", "id": "sample_434", "function_name": "maxSubarrays", "code": "def maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans", "distractor_code": "from typing import List\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    max_sum = 0\n    n = len(nums)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if len(set(subarray)) >= m:\n            max_sum = max(max_sum, sum(subarray))\n            \n    return max_sum\n\ndef maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans\n\nimport re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    c = Counter(nums)\n    a = list(sorted([v for _,v in c.items()]))\n    lim = a[0]\n    for sz in range(a[0]+1,1,-1):\n        good = True\n        cnt = 0\n        for n in a:\n            q,r = divmod(n,sz)\n            if r!=0:\n                q+=1\n                r=sz-r\n            if r>q:\n                good=False\n                break\n            cnt += q\n        if good:\n            return cnt\n    print(\"bad\")\n    return len(nums)"}, {"source": "livecodebench-execution", "id": "sample_435", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res", "distractor_code": "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    res = []\n    a = []\n    k = 0\n    for word in words:\n        if word == 'prev':\n            k += 1\n            n = len(a)\n            if n >= k:\n                res.append(a[n-k])\n            else:\n                res.append(-1)\n        else:\n            a.append(int(word))\n            k = 0\n    return res\n\ndef lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]"}, {"source": "livecodebench-execution", "id": "sample_436", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    num = []\n    cnt = 0\n    ans = []\n    for word in words:\n        if word == \"prev\":\n            cnt += 1\n            if cnt <= len(num):\n                ans.append(num[- cnt])\n            else:\n                ans.append(-1)\n        else:\n            cnt = 0\n            num.append(int(word))\n    return ans", "distractor_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  \n\nimport re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    num = []\n    cnt = 0\n    ans = []\n    for word in words:\n        if word == \"prev\":\n            cnt += 1\n            if cnt <= len(num):\n                ans.append(num[- cnt])\n            else:\n                ans.append(-1)\n        else:\n            cnt = 0\n            num.append(int(word))\n    return ans\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_437", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    i = 0\n    for x in words:\n        if x == 'prev':\n            i += 1\n            if i > len(stk):\n                ans.append(-1)\n            else:\n                ans.append(stk[-i])\n        else:\n            stk.append(int(x))\n            i = 0\n    return ans\n\ndef minSum(nums1: List[int], nums2: List[int]) -> int:\n    has0_1 = has0_2 = False\n    s1 = s2 = 0\n    for n in nums1:\n        if n == 0:\n            s1 += 1\n            has0_1 = True\n        else:\n            s1 += n\n    for n in nums2:\n        if n == 0:\n            s2 += 1\n            has0_2 = True\n        else:\n            s2 += n\n    \n    if s1 > s2 and (not has0_2):\n        return -1\n    if s1 < s2 and (not has0_1):\n        return -1\n    return max(s1, s2)\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    n = len(nums)\n    \n    end = [0] * (n * 2)\n    cr = 0\n    for i in range(n):\n        cr -= end[i]\n        \n        nums[i] -= cr\n        if nums[i] < 0:\n            return False\n        \n        if i + k <= n:\n            cr += nums[i]\n            end[i + k] = nums[i]\n            nums[i] = 0\n            \n    return max(nums) == 0\n\nimport re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)\n\ndef makeTheIntegerZero(num1: int, num2: int) -> int:\n    ops = 0\n    while num1 >= 0:\n        num_ones = bin(num1).count('1')\n        if num_ones <= ops and num1 >= ops:\n            return ops\n        num1 -= num2\n        ops += 1\n    return -1\n\ndef furthestDistanceFromOrigin(moves: str) -> int:\n    s = 0\n    bal = 0\n    for i in moves:\n        if i == 'L':\n            bal -= 1\n        if i == 'R':\n            bal += 1\n        if i == '_':\n            s += 1\n        \n    return abs(bal) + s"}, {"source": "livecodebench-execution", "id": "sample_438", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited", "distractor_code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n\n    current = []\n    reached = -1\n    visited = []\n\n    for x in words:\n        if x != \"prev\":\n            current.append(int(x))\n            reached = len(current) - 1\n        elif reached >= 0:\n            visited.append(current[reached])\n            reached -= 1\n        else:\n            visited.append(-1)\n\n    return visited\n\ndef removeTrailingZeros(num: str) -> str:\n    while num[-1] == '0':\n        num = num[:-1]\n    return num\n\ndef maxSum(nums: List[int]) -> int:\n    n = len(nums)\n    ans = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(str(nums[i])) == max(str(nums[j])):\n                ans = max(ans, nums[i] + nums[j])\n    return ans\n\ndef string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst"}, {"source": "livecodebench-execution", "id": "sample_439", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans", "distractor_code": "def doesValidArrayExist(derived: List[int]) -> bool:\n    curr = 0\n    for i in range(len(derived)):\n        if i == len(derived) - 1:\n            return curr == 0 if derived[i] == 0 else curr == 1\n        \n        if derived[i] == 1:\n            curr = 0 if curr == 1 else 1\n\ndef finalString(s: str) -> str:\n    ans = \"\"\n    for i in s:\n        if i != 'i':\n            ans += i\n        else:\n            ans = ans[::-1]\n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    nums = []\n    r = 0\n    for x in words:\n        if x[0] == 'p':\n            r -= 1\n            ans.append(-1 if abs(r) > len(nums) else nums[len(nums)+r])\n        else:\n            nums.append(int(x))\n            r = 0\n            \n    return ans\n\ndef common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result"}, {"source": "livecodebench-execution", "id": "sample_440", "function_name": "lastVisitedIntegers", "code": "def lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    c = 0\n    for w in words:\n        if w == \"prev\":\n            c += 1\n            if len(stk) < c:\n                ans.append(-1)\n            else:\n                ans.append(stk[-c])\n        else:\n            stk.append(int(w))\n            c = 0\n    return ans", "distractor_code": "def countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans\n\ndef closest_num(N):\n  return (N - 1)\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\ndef doesValidArrayExist(derived: List[int]) -> bool:\n    original = [True]\n    for i in derived:\n        if i == 0:\n            original.append(original[-1])\n        else:\n            original.append(not original[-1])\n    return original[0] == original[-1]\n\ndef countInterestingSubarrays(nums: List[int], m: int, k: int) -> int:\n    cnt=0\n    ans=0\n    last=-1\n    c=Counter([0])\n    for x in nums:\n        if x%m==k:\n            cnt+=1\n        ans+=c[(cnt-k)%m]\n\n        \n        c[cnt%m]+=1\n\n        \n            # last=i\n        \n        \n    return ans\n\ndef lastVisitedIntegers(words: List[str]) -> List[int]:\n    ans = []\n    stk = []\n    c = 0\n    for w in words:\n        if w == \"prev\":\n            c += 1\n            if len(stk) < c:\n                ans.append(-1)\n            else:\n                ans.append(stk[-c])\n        else:\n            stk.append(int(w))\n            c = 0\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_441", "function_name": "countSubMultisets", "code": "import numpy\n\ndef countSubMultisets(nums: List[int], l: int, r: int) -> int:\n    record = numpy.zeros(r+1)\n    record[0] = 1\n    count = collections.Counter(nums)\n\n\n    for i in count:\n\n        tmp = numpy.copy(record)\n        if i != 0:\n            for k in range(1,count[i]+1):\n                tmp[i*k:] += record[:-i*k]\n        else:\n            tmp *= (count[i] + 1)\n\n        record = tmp\n        \n        record %= int(1e9+7)\n\n\n\n    return int(numpy.sum(record[l:r+1]) % int (1e9+7))", "distractor_code": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") \n\ndef minimumRightShifts(nums: List[int]) -> int:\n    m = min(nums)\n    for i in range(len(nums)):\n        if m == nums[i]:\n            nums = nums[i:] + nums[:i]\n            for j in range(len(nums) - 1):\n                if nums[j] > nums[j + 1]:\n                    return -1\n            return len(nums) - i if i > 0 else 0\n    return -1\n\ndef max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0\n\nimport numpy\n\ndef countSubMultisets(nums: List[int], l: int, r: int) -> int:\n    record = numpy.zeros(r+1)\n    record[0] = 1\n    count = collections.Counter(nums)\n\n\n    for i in count:\n\n        tmp = numpy.copy(record)\n        if i != 0:\n            for k in range(1,count[i]+1):\n                tmp[i*k:] += record[:-i*k]\n        else:\n            tmp *= (count[i] + 1)\n\n        record = tmp\n        \n        record %= int(1e9+7)\n\n\n\n    return int(numpy.sum(record[l:r+1]) % int (1e9+7))"}, {"source": "livecodebench-execution", "id": "sample_442", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        curr = set()\n        for j in range(i, n):\n            curr.add(nums[j])\n            k = len(curr)\n            ans += k * k\n    return ans", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        curr = set()\n        for j in range(i, n):\n            curr.add(nums[j])\n            k = len(curr)\n            ans += k * k\n    return ans\n\ndef check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False\n\ndef count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res\n\ndef maxIncreasingGroups(u: List[int]) -> int:\n    u.sort()\n    n = len(u)\n    j, x = 0, 0\n    for i in range(1, n + 1):\n        while j < n and x + u[j] < i:\n            x += u[j]\n            j += 1\n        if j < n and x + u[j] >= i:\n            x = x + u[j] - i\n            j += 1\n        else:\n            return i - 1\n    return n"}, {"source": "livecodebench-execution", "id": "sample_443", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    counts = []\n    for i in range(len(nums)):\n        hset = set()\n        for j in range(i, len(nums)):\n            hset.add(nums[j])\n            counts.append(len(hset))\n    ans = 0\n    for n in counts:\n        ans += n * n\n    return ans", "distractor_code": "def minimumBeautifulSubstrings(s: str) -> int:\n    good = []\n    num = 1\n    n = len(s)\n    while True:\n        b = bin(num)[2:]\n        if len(b) > n:\n            break\n        good.append(b)\n        num *= 5\n    dp = [int(1e9)] * (n + 1)\n    dp[0] = 0\n    gs = set(good)\n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + 1] in gs:\n                dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n    return -1 if dp[n] == int(1e9) else dp[n]\n\ndef minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b \n\ndef sumCounts(nums: List[int]) -> int:\n    counts = []\n    for i in range(len(nums)):\n        hset = set()\n        for j in range(i, len(nums)):\n            hset.add(nums[j])\n            counts.append(len(hset))\n    ans = 0\n    for n in counts:\n        ans += n * n\n    return ans\n\ndef subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks\n\ndef minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)\n\ndef longestAlternatingSubarray(nums: List[int], t: int) -> int:\n    ans = 0 \n    n = len(nums)\n    f = [0]*n \n    if nums[0]%2==0 and nums[0] <= t:\n        f[0] = 1\n    for i in range(1,n):\n        if nums[i] > t:continue\n        v = nums[i]%2\n        if v == 0:\n            f[i] = 1\n        if v!= nums[i-1]%2 and f[i-1]:\n            f[i] = 1+f[i-1]\n    return max(f)"}, {"source": "livecodebench-execution", "id": "sample_444", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans", "distractor_code": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) \n\ndef min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest \n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0 \n    for i in range(limit+1):\n        for j in range(limit+1):\n            k = n-i-j\n            if 0 <= k <= limit:\n                answer+=1\n    return answer\n\ndef countCompleteSubarrays(nums: List[int]) -> int:\n    m = len(set(nums))\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        s = set()\n        for j in range(i, n):\n            s.add(nums[j])\n            ans += len(s) == m\n    return ans\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s = len(set(nums[i:j]))\n            ans += s * s\n    return ans\n\ndef sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    a = []\n    n = len(s)\n    \n    for i in range(n):\n        \n        if s[i] in \"aeiouAEIOU\":\n            a.append(s[i])\n    \n    a.sort(reverse=True)\n    \n    for i in range(n):\n        if s[i] in \"aeiouAEIOU\":\n            s[i] = a.pop()\n    \n    return \"\".join(s)"}, {"source": "livecodebench-execution", "id": "sample_445", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans", "distractor_code": "def splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    ans = []\n    for i in words:\n        for j in i.split(separator):\n            if j:\n                ans.append(j)\n    return ans\n\ndef find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0\n\ndef sumCounts(nums: List[int]) -> int:\n    ans=0\n    n=len(nums)\n    for i in range(n):\n        s=defaultdict(int)\n        for j in range(i,n):\n            s[nums[j]]+=1\n            ans+=len(s)*len(s)\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_446", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans", "distractor_code": "def sumCounts(nums: List[int]) -> int:\n    ans = 0\n    for i in range(len(nums)):\n        seen = set()\n        for j in range(i, len(nums)):\n            seen.add(nums[j])\n            ans += len(seen) * len(seen)\n    return ans\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result"}, {"source": "livecodebench-execution", "id": "sample_447", "function_name": "sumCounts", "code": "def sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans", "distractor_code": "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\nfrom collections import Counter\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    cnt = Counter()\n    cnt[0] = 1\n    ans = 0\n    s = 0\n    for a in nums:\n        s += a%modulo == k\n        s %= modulo\n        ans += cnt[(s-k)%modulo]\n        cnt[s] += 1\n    return ans\n\ndef sumCounts(nums: List[int]) -> int:\n    n = len(nums)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            l = len(set(nums[i:j + 1]))\n            ans += l * l\n    return ans\n\ndef find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1\n\ndef distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_448", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans", "distractor_code": "def minimumSum(nums: List[int]) -> int:\n    p = list(accumulate(nums, min))\n    s = list(accumulate(nums[::-1], min))[::-1]\n    m = inf\n    for i in range(1, len(nums)-1):\n        if p[i-1] < nums[i] and s[i+1] < nums[i]:\n            m = min(m, p[i-1] + nums[i] + s[i+1])\n    return -1 if m == inf else m\n\ndef minChanges(s: str) -> int:\n    \n    # for each 2 char, if not equal one needs to be changed\n    ans = i = 0\n    while i < len(s):\n        if s[i] != s[i+1]:\n            ans += 1\n        i += 2\n    return ans\n\ndef Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength \n\ndef longestSemiRepetitiveSubstring(s: str) -> int:\n    bak = [0]\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            bak.append(i)\n    bak.append(len(s))\n    if len(bak) <= 3:\n        return len(s)\n    mx = 0\n    for i in range(2, len(bak)):\n        mx = max(mx, bak[i]-bak[i-2])\n    return mx\n\ndef countInterestingSubarrays(nums: List[int], modulo: int, k: int) -> int:\n    n = len(nums)\n    h = []\n    for i in nums:\n        if i % modulo == k:\n            h.append(1)\n        else:\n            h.append(0)\n    d = defaultdict(int)\n    d[0] = 1\n    s = 0\n    ans = 0\n    for i in h:\n        s += i\n        s %= modulo\n        ans += d[(s - k) % modulo]\n        d[s] += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_449", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans", "distractor_code": "def accountBalanceAfterPurchase(p: int) -> int:\n    a, b = divmod(p, 10)\n    if b < 5:\n        return 100 - a * 10\n    else:\n        return 90 - a * 10\n\ndef minimumCost(s: str) -> int:\n    n = len(s)\n    r = 0\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            r += min(i+1, n-1-i)\n    return r\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(0,len(s),2):\n        if s[i]!=s[i+1]:ans+=1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_450", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans", "distractor_code": "def makeSmallestPalindrome(s: str) -> str:\n    ans = []\n    for i in range(len(s) // 2):\n        ans.append(min(s[i], s[-(i + 1)]))\n    \n    a = ans[::-1]\n    if len(s) % 2:\n        ans.append(s[len(s) // 2])\n        \n    ans.extend(a)\n    return \"\".join(ans)\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\nfrom typing import List\n\ndef buyChoco(prices: List[int], money: int) -> int:\n    prices.sort()\n    if sum(prices[:2]) <= money:\n        return money - sum(prices[:2])\n    else:\n        return money\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([t for t in hours if t >= target])\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    r = 0\n    for i, n in enumerate(nums):\n        s = bin(i)[2:]\n        if s.count('1') == k:\n            r += n\n    return r\n\ndef distanceTraveled(mainTank: int, additionalTank: int) -> int:\n    \n    res=0\n    \n    while mainTank:\n        if mainTank<5:\n            res+=mainTank*10\n            mainTank=0\n        \n        else:\n            res+=5*10\n            if additionalTank:\n                mainTank+=1\n                additionalTank-=1\n            mainTank-=5\n    return res"}, {"source": "livecodebench-execution", "id": "sample_451", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res", "distractor_code": "def maxIncreasingGroups(usageLimits: List[int]) -> int:\n    usageLimits.sort(reverse=True)\n    left, right = 1, len(usageLimits)\n    while left < right:\n        m = (left + right + 1) // 2\n        if test(usageLimits, m):\n            left = m\n        else:\n            right = m - 1\n    return left\n\ndef test(count: List[int], group: int) -> bool:\n    d = 0\n    for i, x in enumerate(count):\n        y = max(group - i, 0)\n        d = min(d + x - y, 0)\n    return d == 0\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    a = [s1[0], s1[2]]\n    b = [s2[0], s2[2]]\n    a.sort()\n    b.sort()\n    if a != b:\n        return False\n    a = [s1[1], s1[3]]\n    b = [s2[1], s2[3]]\n    a.sort()\n    b.sort()\n    return a == b\n\ndef minChanges(s: str) -> int:\n    res = 0\n    for i in range(0, len(s), 2):\n        if s[i] != s[i+1]:\n            res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_452", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result", "distractor_code": "def minChanges(s: str) -> int:\n    n = len(s)\n    result = 0\n    for i in range(0, n, 2):\n        if s[i] != s[i + 1]:\n            result += 1\n    return result\n\ndef long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    ans = 0\n    m, n = len(nums), len(nums[0])\n    for _ in range(n):\n        cur = 0\n        for i in range(m):\n            val = max(nums[i])\n            j = nums[i].index(val)\n            nums[i][j] = 0\n            cur = max(cur, val)\n        ans += cur\n    return ans\n\ndef canSplitArray(nums: List[int], m: int) -> bool:\n    n = len(nums)\n    if n <= 2:\n        return True\n    for i in range(n - 1):\n        if nums[i] + nums[i + 1] >= m:\n            return True\n    return False\n\ndef maxSubarrays(nums: List[int]) -> int:\n    n = len(nums)\n    mask = (1 << 20) - 1\n    a = mask\n    for i in range(n):\n        a &= nums[i]\n    if a != 0:\n        return 1\n    c = mask\n    ans = 0\n    for i in range(n):\n        c &= nums[i]\n        if c == 0:\n            ans += 1\n            c = mask\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_453", "function_name": "minChanges", "code": "def minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans", "distractor_code": "import heapq\ndef maximizeTheProfit(n: int, offers: List[List[int]]) -> int:\n    offers.sort()\n    q = []\n    ans = 0\n    for s, e, g in offers:\n        while len(q) > 0 and q[0][0] < s:\n            ans = max(ans, q[0][1])\n            heapq.heappop(q)\n        heapq.heappush(q, (e, ans + g))\n    while len(q) > 0:\n        _, v = heapq.heappop(q)\n        ans = max(ans, v)\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    maxx = 0\n    n = len(nums)\n    for i in range(n):\n        if nums[i] % 2 != 0:\n            continue\n        for j in range(i, n):\n            if nums[j] > threshold:\n                break\n            if j > i and nums[j] % 2 == nums[j - 1] % 2:\n                break\n            maxx = max(maxx, j - i + 1)\n    return maxx\n\ndef countPairs(coordinates: List[List[int]], k: int) -> int:\n    c = defaultdict(int)\n    for i, j in coordinates:\n        c[(i, j)] += 1\n    ans = 0\n    for i, j in coordinates:\n        c[(i, j)] -= 1\n        for r in range(k + 1):\n            x = r ^ i\n            y = (k - r) ^ j\n            ans += c[(x, y)]\n    return ans\n\ndef minChanges(s: str) -> int:\n    ans = 0\n    for i in range(1, len(s), 2):\n        if s[i] != s[i - 1]:\n            ans += 1\n    return ans\n\ndef longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    for L in range(n, 0, -1):\n        for i in range(n - L + 1):\n            tmp = nums[i:i+L]\n            if tmp[0] % 2 == 0 and all(tmp[j] % 2 != tmp[j+1] % 2 for j in range(len(tmp)-1)) and all(j <= threshold for j in tmp):\n                return L\n    return 0"}, {"source": "livecodebench-execution", "id": "sample_454", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d = defaultdict(lambda : 0)\n    d[0] = 0\n    for i, v in enumerate(nums):\n        if v > target:\n            continue\n        tmp = defaultdict(lambda : 0)\n        tmp[0] = 0\n        for s in d:\n            if s + v > target:\n                continue\n            tmp[s + v] = max(tmp[s + v], d[s] + 1)\n        for s in tmp:\n            d[s] = max(d[s], tmp[s])\n    return d[target] if target in d else -1", "distractor_code": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    \n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d = defaultdict(lambda : 0)\n    d[0] = 0\n    for i, v in enumerate(nums):\n        if v > target:\n            continue\n        tmp = defaultdict(lambda : 0)\n        tmp[0] = 0\n        for s in d:\n            if s + v > target:\n                continue\n            tmp[s + v] = max(tmp[s + v], d[s] + 1)\n        for s in tmp:\n            d[s] = max(d[s], tmp[s])\n    return d[target] if target in d else -1\n\ndef all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True"}, {"source": "livecodebench-execution", "id": "sample_455", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    nums.sort()\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] > 0:\n                dp[i+x] = max(dp[i+x], 1 + dp[i])\n    return dp[-1] - 1", "distractor_code": "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    nums.sort()\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] > 0:\n                dp[i+x] = max(dp[i+x], 1 + dp[i])\n    return dp[-1] - 1\n\ndef minimumSum(nums: List[int]) -> int:\n    left, right, ans = [inf], [inf], inf\n    for num in nums:\n        left.append(min(left[-1], num))\n    for num in nums[::-1]:\n        right.append(min(right[-1], num))\n    right.reverse()\n    for i, num in enumerate(nums):\n        if left[i] < num and right[i + 1] < num:\n            ans = min(ans, num + left[i] + right[i + 1])\n    return ans if ans < inf else -1"}, {"source": "livecodebench-execution", "id": "sample_456", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp = [0]*(target + 1)\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] or not i:\n                dp[i + x] = max(dp[i + x], dp[i] + 1)\n    \n    return dp[-1] if dp[-1] else -1", "distractor_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp = [0]*(target + 1)\n    for x in nums:\n        for i in range(target - x, -1, -1):\n            if dp[i] or not i:\n                dp[i + x] = max(dp[i + x], dp[i] + 1)\n    \n    return dp[-1] if dp[-1] else -1\n\ndef maxSum(nums: List[int], m: int, k: int) -> int:\n    c = Counter()\n    ssum = 0\n    n = len(nums)\n    for i in range(k):\n        c[nums[i]] += 1\n        ssum += nums[i]\n    res = ssum if len(c) >= m else 0\n    for i in range(k, n):\n        c[nums[i]] += 1\n        c[nums[i-k]] -= 1\n        if not c[nums[i-k]]:\n            del c[nums[i-k]]\n        ssum += nums[i] - nums[i-k]\n        if len(c) >= m:\n            res = max(res, ssum)\n    return res\n\ndef minGroupsForValidAssignment(nums: List[int]) -> int:\n    cnt = Counter(nums)\n    freq = Counter(cnt.values())\n    k = min(freq)\n    ans = inf\n    for i in range(1, k + 2):\n        res = 0\n        for x in freq:\n            v = (x + i - 1) // i\n            k1 = x - v * (i - 1)\n            k2 = v - k1\n            if k1 < 0 or k2 < 0: break\n            res += freq[x] * v\n        else: ans = min(ans, res)\n    return ans\n\ndef maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output\n\ndef findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]"}, {"source": "livecodebench-execution", "id": "sample_457", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]", "distractor_code": "def smallest_num(xs):\n  return min(xs)\n\n\ndef cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    max_len = [-1] * (target + 1)\n    max_len[0] = 0\n    for x in nums:\n        for new_sum in reversed(range(x, target + 1)):\n            if max_len[new_sum - x] != -1:\n                max_len[new_sum] = max(\n                    max_len[new_sum],\n                    max_len[new_sum - x] + 1\n                )\n    return max_len[target]"}, {"source": "livecodebench-execution", "id": "sample_458", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d=[0]*(target+1)\n    t=[el for el in nums if el<=target]\n    if len(t)==0:\n        return -1\n    d[t[0]]=1\n    for el in t[1:]:\n        for j in range(target,0,-1):\n            if j-el>=0 and (j-el==0 or d[j-el]>0):\n                d[j]=max(d[j],d[j-el]+1)\n    if d[target]==0:\n        return -1\n    return d[target]", "distractor_code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    d=[0]*(target+1)\n    t=[el for el in nums if el<=target]\n    if len(t)==0:\n        return -1\n    d[t[0]]=1\n    for el in t[1:]:\n        for j in range(target,0,-1):\n            if j-el>=0 and (j-el==0 or d[j-el]>0):\n                d[j]=max(d[j],d[j-el]+1)\n    if d[target]==0:\n        return -1\n    return d[target]\n\ndef minLengthAfterRemovals(nums: List[int]) -> int:\n    C = Counter(nums)\n    m = max(C.values())\n    if 2 * m >= len(nums):\n        return 2 * m - len(nums)\n    else:\n        return len(nums) & 1\n\ndef maximumTripletValue(nums: List[int]) -> int:\n    ans = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                ans = max(ans, (nums[i] - nums[j]) * nums[k])\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_459", "function_name": "lengthOfLongestSubsequence", "code": "def lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp=[-1]*(target+1)\n    dp[0]=0\n    for a in nums:\n        for i in range(target-a,-1,-1):\n            if dp[i]==-1:continue\n            dp[i+a]=max(dp[i+a],dp[i]+1)\n    return dp[-1]", "distractor_code": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max\n\ndef removeTrailingZeros(num: str) -> str:\n    while num[-1] == '0':\n        num = num[:-1]\n    return num\n\ndef lexicographicallySmallestArray(nums: List[int], limit: int) -> List[int]:\n    n = len(nums)\n    \n    order = sorted(range(n), key = lambda x: nums[x])\n    \n    out = [-1] * n\n    \n    l = 0\n    for i in range(n):\n        if i == n - 1 or nums[order[i]] + limit < nums[order[i + 1]]:\n            ind = sorted(order[l: i + 1])\n            for j in range(i - l + 1):\n                out[ind[j]] = nums[order[l + j]]\n            l = i + 1\n    return out\n\ndef canBeEqual(s1: str, s2: str) -> bool:\n    s3 = s1[0] + s1[3] + s1[2] + s1[1]\n    s4 = s1[2] + s1[3] + s1[0] + s1[1]\n    s5 = s1[2] + s1[1] + s1[0] + s1[3]\n    return s2 == s1 or s2 == s3 or s2 == s4 or s2 == s5\n\ndef lengthOfLongestSubsequence(nums: List[int], target: int) -> int:\n    dp=[-1]*(target+1)\n    dp[0]=0\n    for a in nums:\n        for i in range(target-a,-1,-1):\n            if dp[i]==-1:continue\n            dp[i+a]=max(dp[i+a],dp[i]+1)\n    return dp[-1]\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    ans = 0\n    for i in hours:\n        if i >= target:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_460", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n  c = 0\n  for i in range(limit + 1):\n    for j in range(limit + 1):\n      for k in range(limit + 1):\n        if i + j + k == n:\n          c += 1\n  return c", "distractor_code": "def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum\n\ndef big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum\n\ndef distributeCandies(n: int, limit: int) -> int:\n  c = 0\n  for i in range(limit + 1):\n    for j in range(limit + 1):\n      for k in range(limit + 1):\n        if i + j + k == n:\n          c += 1\n  return c"}, {"source": "livecodebench-execution", "id": "sample_461", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n    res = comb(n + 2, 2)\n    if n >= limit + 1:\n        res -= 3 * comb(n - limit + 1, 2)\n    if n >= 2 * limit + 2:\n        res += 3 * comb(n - 2 * limit, 2)\n    if n >= 3 * (limit + 1):\n        res -= comb(n - 3 * limit - 1, 2)\n    return res", "distractor_code": "def distributeCandies(n: int, limit: int) -> int:\n    res = comb(n + 2, 2)\n    if n >= limit + 1:\n        res -= 3 * comb(n - limit + 1, 2)\n    if n >= 2 * limit + 2:\n        res += 3 * comb(n - 2 * limit, 2)\n    if n >= 3 * (limit + 1):\n        res -= comb(n - 3 * limit - 1, 2)\n    return res\n\ndef median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median\n\ndef maxSubarrays(nums: List[int]) -> int:\n    m = reduce(int.__and__, nums)\n    \n    res = 0\n    running = -1\n    for num in nums:\n        running &= num\n        if running == 0:\n            running = -1\n            res += 1\n    return res + (1 if running == m else 0)\n\ndef beautifulSubstrings(s: str, k: int) -> int:\n    \n    vowels = set('aeiou')\n    \n    n = len(s)\n    output = 0\n    for i in range(n):\n        diff = 0\n        count = 0\n        for j in range(i, n):\n            if s[j] in vowels:\n                diff += 1\n                count += 1\n            else:\n                diff -= 1\n                \n            output += (diff == 0) and (count ** 2 % k == 0)\n            \n    return output"}, {"source": "livecodebench-execution", "id": "sample_462", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer", "distractor_code": "def minLengthAfterRemovals(nums: List[int]) -> int:\n    c = Counter(nums)\n    x = max(c.values())\n    if x > len(nums) // 2:\n        return 2 * x - len(nums)\n    else:\n        return len(nums) % 2\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres\n\ndef minChanges(s: str) -> int:\n    c=1\n    ans=0\n    for i in range(1,len(s)):\n        if s[i]==s[i-1]:\n            c+=1\n        else:\n            if c%2==1:\n                ans+=1\n                c+=1\n            else:\n                c=1\n    return ans\n\nimport cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) \n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0\n    for c3 in range(limit + 1):\n        c1_min = max(0, n - c3 - limit)\n        c1_max = min(limit, n - c3)\n        \n        # print(c3, c1_min, c1_max)\n        \n        answer += max(c1_max - c1_min + 1, 0)\n        \n    return answer\n\ndef splitWordsBySeparator(words: List[str], separator: str) -> List[str]:\n    A = separator.join(words).split(separator)\n    return [w for w in A if w]"}, {"source": "livecodebench-execution", "id": "sample_463", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n    limit = min(limit, n)\n    ans = 0\n    for i in range(limit+1):\n        if n-i > limit * 2:\n            continue\n        ans += (min(limit, n-i) - max(0, n-i-limit) + 1)\n    return ans", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1\n\ndef distributeCandies(n: int, limit: int) -> int:\n    limit = min(limit, n)\n    ans = 0\n    for i in range(limit+1):\n        if n-i > limit * 2:\n            continue\n        ans += (min(limit, n-i) - max(0, n-i-limit) + 1)\n    return ans\n\ndef checkArray(nums: List[int], k: int) -> bool:\n    kq = deque()\n    S = 0\n    while nums:\n        while kq and kq[0][0] - k + 1 >= len(nums):\n            r, t = kq.popleft()\n            S -= t\n        nums[-1] -= S\n        if nums[-1] < 0:\n            return False\n        elif nums[-1] > 0:\n            if len(nums) < k:\n                return False\n            kq.append((len(nums) - 1, nums[-1]))\n            S += kq[-1][1]\n        nums.pop()\n    return True\n\ndef maxSubarrays(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    mn = nums[0]\n    for num in nums:\n        mn &= num\n    \n    if mn:\n        return 1\n    \n    res, cur = 0, nums[0]\n    for i in range(1, n):\n        if cur == mn:\n            res += 1\n            cur = nums[i]\n        cur &= nums[i]\n    \n    if cur == mn:\n        res += 1\n    \n    return res\n\ndef get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]\n\ndef countSeniors(details: List[str]) -> int:\n    res = 0\n    for s in details:\n        age = int(s[11:13])\n        if age > 60:\n            res += 1\n    return res"}, {"source": "livecodebench-execution", "id": "sample_464", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n    answer = 0 \n    for i in range(limit+1):\n        for j in range(limit+1):\n            k = n-i-j\n            if 0 <= k <= limit:\n                answer+=1\n    return answer", "distractor_code": "def longestAlternatingSubarray(nums: List[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    for l in range(n):\n        if nums[l]%2 != 0:\n            continue\n        \n        if nums[l] > threshold:\n            continue\n        \n        good = True\n        r = l+1\n        while r<n and nums[r]<=threshold and nums[r]%2 != nums[r-1]%2:\n            r += 1\n        \n        case = r-l\n        ans = max(ans, case)\n    \n    return ans\n\ndef maximizeTheProfit(N: int, offers: List[List[int]]) -> int:\n    best = [0] * (N + 1)\n    \n    prev = collections.defaultdict(list)\n    \n    for a, b, w in offers:\n        prev[b].append((a - 1, w))\n        \n    for i in range(N):\n        best[i + 1] = max(best[i], best[i + 1])\n        for p, w in prev[i]:\n            best[i + 1] = max(best[i + 1], best[p + 1] + w)\n    # print(best)\n    return best[N]\n\ndef minOperations(nums: List[int], target: int) -> int:\n    if sum(nums) < target:\n        return -1\n    ans = 0\n    while True:\n        mn = None\n        y = target\n        nums.sort(reverse=True)\n        for x in nums:\n            if y >= x:\n                y -= x\n            elif mn is None or mn > x:\n                mn = x\n        if y == 0:\n            return ans\n        ans += 1\n        nums.remove(mn)\n        nums.append(mn // 2)\n        nums.append(mn // 2)\n\ndef minimumRightShifts(nums: List[int]) -> int:\n    def f(l):\n        for i in range(1, len(l)):\n            if l[i] < l[i - 1]:\n                return False\n        return True\n    \n    for i in range(len(nums)):\n        if f(nums):\n            return i\n        p = nums.pop()\n        nums = [p] + nums\n    return -1\n\ndef distributeCandies(n: int, limit: int) -> int:\n    answer = 0 \n    for i in range(limit+1):\n        for j in range(limit+1):\n            k = n-i-j\n            if 0 <= k <= limit:\n                answer+=1\n    return answer"}, {"source": "livecodebench-execution", "id": "sample_465", "function_name": "distributeCandies", "code": "def distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans", "distractor_code": "def splitWordsBySeparator(a: List[str], b: str) -> List[str]:\n    res = []\n    for x in a:\n        res.extend(w for w in x.split(b) if w)\n    return res\n\ndef distributeCandies(n: int, limit: int) -> int:\n    ans = 0\n    for a in range(limit+1):\n        for b in range(limit+1):\n            for c in range(limit+1):\n                if a+b+c == n: ans += 1\n    return ans\n\ndef minLength(s: str) -> int:\n    \n    while 1:\n        n = len(s)\n        if n < 2:\n            break\n        for i in range(n - 1):\n            if s[i:i + 2] == \"AB\" or s[i:i + 2] == \"CD\":\n                s = s[:i] + s[i + 2:]\n                break\n        else:\n            break\n    \n    return len(s)\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    c = set()\n    for start, end in nums:\n        for i in range(start, end + 1):\n            c.add(i)\n    return len(c)\n\ndef isFascinating(n: int) -> bool:\n    t = \"\"\n    for i in range(1, 4):\n        t += str(i * n)\n    c = collections.Counter(t)\n    return c[\"0\"] == 0 and len(c) == 9 and len(t) == 9\n\ndef sumIndicesWithKSetBits(nums: List[int], k: int) -> int:\n    return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)"}, {"source": "livecodebench-execution", "id": "sample_466", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES", "distractor_code": "def findValueOfPartition(nums: List[int]) -> int:\n    nums = sorted(nums)\n    to_ret = 1e99\n    for i in range(len(nums)-1) :\n        to_ret = min(to_ret, nums[i+1]-nums[i])\n    return to_ret\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\nfrom math import gcd\n\ndef countBeautifulPairs(nums: List[int]) -> int:\n\n    n = len(nums)\n    \n    ct = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            f = int(str(nums[i])[0])\n            s = int(str(nums[j])[-1])\n            \n            #print(f,s)\n            \n            if gcd(s, f) == 1:\n                ct += 1\n    return ct\n\ndef test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     "}, {"source": "livecodebench-execution", "id": "sample_467", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l", "distractor_code": "def minimizedStringLength(s: str) -> int:\n    ss = set()\n    for c in s:\n        ss.add(c)\n    return len(ss)\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    \n    l = []\n    for i in range(len(words)):\n        if x in words[i]:\n            l.append(i)\n    \n    return l"}, {"source": "livecodebench-execution", "id": "sample_468", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res", "distractor_code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)\n\ndef countWays(nums: List[int]) -> int:\n    nums.sort()\n    ans = 1\n    if nums[0] != 0:\n        ans += 1\n    for i in range(1, len(nums)):\n        if nums[i-1] < i and nums[i] > i:\n            ans += 1\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_469", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res", "distractor_code": "def relocateMarbles(nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n    tmp = set(nums)\n    for x, y in zip(moveFrom, moveTo):\n        tmp.remove(x)\n        tmp.add(y)\n    return sorted(tmp)\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i in range(len(words)):\n        try:\n            b = words[i].find(x)\n            if (b >= 0):\n                res.append(i)\n        except:\n            pass\n    return res\n\ndef removeTrailingZeros(num: str) -> str:\n    d = list(num)\n    while d and d[-1] == '0':\n        d.pop()\n    return ''.join(d)\n\ndef numberOfEmployeesWhoMetTarget(hours: List[int], target: int) -> int:\n    return len([t for t in hours if t >= target])"}, {"source": "livecodebench-execution", "id": "sample_470", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res", "distractor_code": "def longestString(x: int, y: int, z: int) -> int:\n    ans = min(x, y) * 2\n    if x != y:\n        ans += 1\n    return (ans  + z) * 2\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    res = []\n    for i, w in enumerate(words):\n        if x in w:\n            res.append(i)\n    return res\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    ans = []\n    for w in words:\n        ans.append(w[:1])\n    return s == ''.join(ans)\n\ndef replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2\n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dp(i, first, last):\n        if i == n:\n            return 0\n        ans1 = dp(i + 1, first, words[i][-1]) - int(last == words[i][0])\n        ans2 = dp(i + 1, words[i][0], last) - int(words[i][-1] == first)\n        if ans1 > ans2:\n            return ans2 + len(words[i])\n        return ans1 + len(words[i])\n    return dp(1, words[0][0], words[0][-1]) + len(words[0])"}, {"source": "livecodebench-execution", "id": "sample_471", "function_name": "findWordsContaining", "code": "def findWordsContaining(words: List[str], x: str) -> List[int]:\n    return [i for i, w in enumerate(words) if x in w]", "distractor_code": "def alternatingSubarray(nums: List[int]) -> int:\n    n = len(nums)\n    maxres = -1\n    for i,(a,b) in enumerate(zip(nums, nums[1:])):\n        if b-a == 1:\n            i += 2\n            count = 2\n            while i < n and nums[i] == nums[i-2]:\n                i += 1\n                count += 1\n            maxres = max(maxres, count)\n    return maxres\n\ndef minimumSum(nums: List[int]) -> int:\n    \n    n = len(nums)\n    A = deque()\n    rmin = math.inf\n    for i in range(n-1,-1,-1):\n        A.appendleft(rmin)\n        rmin = min(rmin,nums[i])\n    lmin = nums[0]\n    ans = math.inf\n    for i in range(1,n-1):\n        if lmin < nums[i] > A[i]:\n            ans = min(ans, lmin + nums[i] + A[i])\n        lmin = min(lmin, nums[i])\n    return ans if ans < math.inf else -1\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    return [i for i, w in enumerate(words) if x in w]\n\ndef min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val\n\ndef findWordsContaining(words: List[str], x: str) -> List[int]:\n    RES = []\n    for i, el in enumerate(words):\n        if x in el:\n            RES.append(i)\n    return RES\n\nfrom collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) "}, {"source": "livecodebench-execution", "id": "sample_472", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    if not n: return 0\n    elif n == 1: return prices[0]\n    dp = [float(\"inf\")] * n\n    for j in range(2):\n        dp[j] = prices[0]\n    #print(dp)\n    for i in range(1, n):\n        price = dp[i - 1] + prices[i]\n        for j in range(i, min(n, (i + 1) * 2)):\n            dp[j] = min(dp[j], price)\n        #print(dp)\n    return dp[-1]", "distractor_code": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    if not n: return 0\n    elif n == 1: return prices[0]\n    dp = [float(\"inf\")] * n\n    for j in range(2):\n        dp[j] = prices[0]\n    #print(dp)\n    for i in range(1, n):\n        price = dp[i - 1] + prices[i]\n        for j in range(i, min(n, (i + 1) * 2)):\n            dp[j] = min(dp[j], price)\n        #print(dp)\n    return dp[-1]\n\ndef maximumJumps(nums: List[int], target: int) -> int:\n    n = len(nums)\n    f = [-1] * n\n    f[0] = 0\n    for i in range(n):\n        if f[i] >= 0:\n            for j in range(i + 1, n):\n                if abs(nums[i] - nums[j]) <= target:\n                    f[j] = max(f[i] + 1, f[j])\n    return f[-1]"}, {"source": "livecodebench-execution", "id": "sample_473", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)", "distractor_code": "from collections import Counter\n\n\ndef minOperations(nums: List[int]) -> int:\n    ans = 0\n    for k, v in Counter(nums).items():\n        if v == 1:\n            return -1\n        r = v % 3\n        if r == 0:\n            ans += v // 3\n        elif r == 1:\n            ans += v // 3 + 1\n        else:\n            ans += v // 3 + 1\n    return ans\n\ndef is_octagonal(n): \n\treturn 3 * n * n - 2 * n \n\ndef check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) \n\ndef sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum\n\ndef minimumSeconds(nums: List[int]) -> int:\n    n = len(nums)\n    ni = defaultdict(list)\n    for i, v in enumerate(nums):\n        ni[v].append(i)\n    min_steps = n\n    for v, idxs in ni.items():\n        gap = n-idxs[-1] + idxs[0]\n        for i in range(len(idxs)-1):\n            gap = max(gap, idxs[i+1]-idxs[i])\n        min_steps = min(min_steps, gap//2)\n    return min_steps\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    @cache\n    def dp(i):\n        if i >= n:\n            return 0\n        min_cost = inf\n        for j in range(i + 1, i + i + 3):\n            min_cost = min(min_cost, dp(j))\n        return prices[i] + min_cost\n    return dp(0)"}, {"source": "livecodebench-execution", "id": "sample_474", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)", "distractor_code": "def continuousSubarrays(a: List[int]) -> int:\n    h = Counter()\n    mo = deque([])\n    ans = 0\n    for i in a:\n        mo.append(i)\n        h[i] += 1\n        while h[i-2]+h[i-1]+h[i]+h[i+1]+h[i+2] != len(mo):\n            h[mo.popleft()] -= 1\n        ans += len(mo)\n    return ans\n\ndef large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result\n\ndef matrixSum(nums: List[List[int]]) -> int:\n    matrix = [sorted(l) for l in nums]\n    mat = list(list(l) for l in zip(*matrix))\n    return sum(map(max,mat))\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    s = set()\n    ans = 0\n    for w in words:\n        if w[::-1] in s:\n            ans += 1\n            s.remove(w[::-1])\n        else:\n            s.add(w)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    \n    @cache\n    def dfs(i, free_until):\n        if i >= len(prices):\n            return 0\n        \n        res = prices[i] + dfs(i + 1, min(len(prices) - 1, i + i + 1))\n        \n        if free_until >= i:\n            res = min(res, dfs(i + 1, free_until))\n            \n        return res\n        \n    dfs.cache_clear()\n    return dfs(0, -1)"}, {"source": "livecodebench-execution", "id": "sample_475", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)", "distractor_code": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False\n\ndef numberOfPoints(nums: List[List[int]]) -> int:\n    s = set()\n    for l, r in nums:\n        s |= set(range(l, r + 1))\n        \n    return (len(s))\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    \n    @cache\n    def panda(i, fc):\n        if i >= n:\n            return 0\n        \n        c1 = float(inf)\n        if fc != 0:\n            c1 = panda(i + 1, fc - 1)\n            \n        c2 = prices[i] + panda(i + 1, min(n + 1, i + 1))\n        \n        return min(c1, c2)\n    \n    return panda(0, 0)\n\ndef alternatingSubarray(nums: List[int]) -> int:\n    \n    n = len(nums)\n    \n    ans = -1\n    \n    for i in range(n-1):\n        if nums[i+1]==nums[i]+1:\n            j = i+1\n            while j+1<n and nums[j+1]==nums[j-1]:\n                j+=1\n            ans=max(ans,j-i+1)\n    \n    return ans\n\ndef findChampion(grid: List[List[int]]) -> int:\n    n = len(grid)\n    for i, row in enumerate(grid):\n        if sum(row[j] for j in range(n) if j != i) == n - 1:\n            return i\n    return -1\n\ndef sortVowels(s: str) -> str:\n    \n    s = list(s)\n    \n    n = len(s)\n    \n    v = []\n    for i in range(n):\n        if s[i].lower() in ['a', 'e', 'i', 'o', 'u']:\n            v.append(i)\n    \n    vs = sorted(v, key=lambda i: s[i])\n    \n    ss = s[:]\n    \n    for i in range(len(v)):\n        s[v[i]] = ss[vs[i]]\n    \n    return ''.join(s)"}, {"source": "livecodebench-execution", "id": "sample_476", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    ans = [float(\"inf\")]*(n+1)\n    \n    for i in range(n):\n        if i==0:\n            cost = prices[i]\n        else:\n            cost = ans[i-1]+prices[i]\n            \n        for j in range(i,min(n,i+i+1+1)):\n            ans[j] = min(ans[j],cost)\n    # print(ans)\n    return ans[n-1]", "distractor_code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    ans = [float(\"inf\")]*(n+1)\n    \n    for i in range(n):\n        if i==0:\n            cost = prices[i]\n        else:\n            cost = ans[i-1]+prices[i]\n            \n        for j in range(i,min(n,i+i+1+1)):\n            ans[j] = min(ans[j],cost)\n    # print(ans)\n    return ans[n-1]\n\ndef sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   \n\ndef minOperations(s1: str, s2: str, x: int) -> int:\n    n = len(s1)\n    idx = [i for i in range(n) if s1[i] != s2[i]]\n    if len(idx) % 2 != 0: return -1\n    dp0, dp1 = 0, 0\n    for i in range(1, len(idx)):\n        dp0, dp1 = dp1, min(dp1, dp0 + (idx[i] - idx[i-1] - x))\n    return len(idx) // 2 * x + dp1\n\ndef maxNonDecreasingLength(a: List[int], b: List[int]) -> int:\n    p1 = p2 = 0\n    l1 = l2 = ans = 0\n    for x, y in zip(a, b):\n        t1 = t2 = 1\n        if x >= p1:\n            t1 = max(t1, l1 + 1)\n        if x >= p2:\n            t1 = max(t1, l2 + 1)\n        if y >= p1:\n            t2 = max(t2, l1 + 1)\n        if y >= p2:\n            t2 = max(t2, l2 + 1)\n        ans = max(ans, t1, t2)\n        p1, p2, l1, l2 = x, y, t1, t2\n    return ans"}, {"source": "livecodebench-execution", "id": "sample_477", "function_name": "minimumCoins", "code": "def minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]", "distractor_code": "def findChampion(grid: List[List[int]]) -> int:\n  n = len(grid)\n  for j in range(n):\n    if all(grid[i][j] == 0 for i in range(n)):\n      return j\n\ndef check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) \n\ndef minimumOperations(s: str) -> int:\n    # 删空\n    ans = len(s)\n    # 留 1\n    if s.count('0'):\n        ans = len(s) - 1\n    st = {'00', '25', '50', '75'}\n    for i, x in enumerate(s):\n        for y in s[i + 1:]:\n            # 00 25 50 75\n            if x + y in st:\n                ans = min(ans, len(s) - i - 2)\n    return ans\n\ndef minimumCoins(prices: List[int]) -> int:\n    n = len(prices)\n    # @cache\n    # def dp(i):\n    #     if i == n:\n    #         return 0\n    #     prices[i] + dp(min(2 * i + 2, n))\n    dp = [math.inf] * (n + 1)\n    dp[-1] = 0\n    for i in reversed(range(n)):\n        dp[i] = prices[i] + min(dp[j] for j in range(i + 1, min(2 * i + 2, n) + 1))\n    return dp[0]\n\ndef isAcronym(words: List[str], s: str) -> bool:\n    res = ''\n    for w in words:\n        res += w[0]\n    \n    return res == s"}, {"source": "livecodebench-execution", "id": "sample_478", "function_name": "findMaximumLength", "code": "def findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]", "distractor_code": "def last_Digit(n) :\n    return (n % 10) \n\ndef minimizeConcatenatedLength(words: List[str]) -> int:\n    n = len(words)\n    @cache\n    def dfs(i, l, r):\n        if i == n:\n            return 0\n        s = words[i]\n        nl = s[0]\n        nr = s[-1]\n        return len(s) + min(dfs(i + 1, l, nr) - (r == nl), dfs(i + 1, nl, r) - (l == nr))\n    return dfs(1, words[0][0], words[0][-1]) + len(words[0])\n\ndef minAbsoluteDifference(nums: List[int], x: int) -> int:\n    st = []\n    ans = float('inf')\n    for i,c in enumerate(nums):\n        if i>=x:\n            bisect.insort(st,nums[i-x])\n            p = bisect.bisect_left(st,c) \n            if p>0:\n                ans = min(ans,c-st[p-1])\n            if p<len(st):\n                ans = min(ans,st[p]-c)\n    return ans\n\ndef minOperations(nums: List[int]) -> int:\n    m = {}\n    for i in nums:\n        if i not in m:\n            m[i] = 0\n        m[i] += 1\n    ans = 0\n    for i in m:\n        if m[i] == 1:\n            return -1\n        while m[i] % 3 != 0:\n            m[i] -= 2\n            ans += 1\n        ans += m[i] // 3\n    return ans\n\ndef findMaximumLength(nums: List[int]) -> int:\n    nums+=[float('inf')]\n    presum=[0]+list(accumulate(nums))\n\n    n, dp, prev, cur = len(nums)-1, Counter(), Counter(),0\n\n    for i in range(n):\n        i+=1\n        cur=max(cur,prev[i])\n        dp[i]=(i-cur-1) + dp[cur]\n        idx=bisect.bisect_left(presum,2*presum[i]-presum[cur])   \n        prev[idx]=i\n    return n-dp[n]\n\nfrom typing import *\n\nfrom math import *\n\ndef maximumNumberOfStringPairs(words: List[str]) -> int:\n    a = 0\n    for i in words:\n        if i[::-1] in words and i != i[::-1]:\n            a+=1\n    return a//2"}]