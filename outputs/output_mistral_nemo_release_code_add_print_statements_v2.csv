index,generated,result,format_properties
0,"<ans>
'''input
9 4 8
6 8 5 1 8 1 1 2 1
9 2
8 4
5 3
9 7
'''
from sys import stdin
import math
from copy import deepcopy
from collections import defaultdict


def process_offer(offers):
	print(""offers: "", str(offers))
	aux = []
	for i in offers:
		temp = offers[i]
		temp.sort()
		aux.append([i, temp[-1]])
	print(""aux: "", str(aux))
	aux = sorted(aux, key = lambda x: x[0])
	print(""sorted aux: "", str(aux))
	return aux


def make(first, second):
	print(""first: "", str(first), ""second: "", str(second))
	return str(first) + ' ' + str(second)


def brute(arr, dp, offers, index, remain):
	print(""index: "", str(index), ""remain: "", str(remain))
	# base case:
	if remain == 0:
		return 0

	if make(index, remain) in dp:
		return dp[make(index, remain)]

	min_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)
	print(""min_cost: "", str(min_cost))
	for i in range(len(offers)):
		cost = 0
		if offers[i][0] <= remain:
			free = offers[i][1]
			for  j in range(index + free, index + offers[i][0]):
				cost += arr[j]
			cost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])
			min_cost = min(min_cost, cost)
		else:
			break
	dp[make(index, remain)] = min_cost
	return min_cost



# main starts
n, m, k = list(map(int, stdin.readline().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
arr = list(map(int, stdin.readline().split()))
print(""arr: "", str(arr))
arr.sort()
print(""sorted arr: "", str(arr))
offers = defaultdict(list)
for _ in range(m):
	x, y = list(map(int, stdin.readline().split()))
	print(""x: "", str(x), ""y: "", str(y))
	offers[x].append(y)

offers = process_offer(offers)
dp = dict()
print(brute(arr, dp, offers, 0, k))
#print(dp)


</ans>",0,{}
1,"<ans>
def PrimeDecomp(N, ConcFlag):
    if ConcFlag:
        if N <= 1:
            print(""N: "", str(N))
            return [1], 1
        else:
            I = 2
            PrimeDec = []
            DivCount = 1
            while I * I <= N:
                Cnt = 0
                while N % I == 0:
                    N //= I
                    PrimeDec.append(I)
                DivCount *= (Cnt + 1)
                I += 1
            if N >= 2:
                PrimeDec.append(N)
                DivCount *= 2
            print(""PrimeDec: "", str(PrimeDec))
            print(""DivCount: "", str(DivCount))
            return PrimeDec, DivCount
    else:
        if N <= 1:
            print(""N: "", str(N))
            return [1], [1], 1
        else:
            I = 2
            PrimeDec = []
            PrimeCnt = []
            DivCount = 1
            while I * I <= N:
                Cnt = 0
                while N % I == 0:
                    N //= I
                    Cnt += 1
                if Cnt >= 1:
                    PrimeDec.append(I)
                    PrimeCnt.append(Cnt)
                    DivCount *= (Cnt + 1)
                I += 1
            if N >= 2:
                PrimeDec.append(N)
                PrimeCnt.append(1)
                DivCount *= 2
            print(""PrimeDec: "", str(PrimeDec))
            print(""PrimeCnt: "", str(PrimeCnt))
            print(""DivCount: "", str(DivCount))
            return PrimeDec, PrimeCnt, DivCount

def DivisorFactorial(N, FactDec, FactCnt, MemoFlag, Mod, ModFlag):
    if MemoFlag:
        if N <= 1:
            print(""N: "", str(N))
            FDivCnt = 1
            return FactDec, FactCnt, FDivCnt
        else:
            PrimeDec, PrimeCnt, _ = PrimeDecomp(N, False)
            for TP in range(0, len(PrimeDec)):
                if PrimeDec[TP] in set(FactDec):
                    FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                else:
                    FactDec.append(PrimeDec[TP])
                    FactCnt.append(PrimeCnt[TP])
            print(""FactDec: "", str(FactDec))
            print(""FactCnt: "", str(FactCnt))
            FDivCnt = 1
            for TF in FactCnt:
                FDivCnt = [FDivCnt * (TF + 1), (FDivCnt * (TF + 1)) % Mod][ModFlag]
            print(""FDivCnt: "", str(FDivCnt))
            return FactDec, FactCnt, FDivCnt
    else:
        if N <= 1:
            print(""N: "", str(N))
            FDivCnt = 1
            return FactDec, FactCnt, FDivCnt
        else:
            for TN in range(2, N + 1):
                PrimeDec, PrimeCnt, _ = PrimeDecomp(TN, False)
                for TP in range(0, len(PrimeDec)):
                    if PrimeDec[TP] in set(FactDec):
                        FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                    else:
                        FactDec.append(PrimeDec[TP])
                        FactCnt.append(PrimeCnt[TP])
            print(""FactDec: "", str(FactDec))
            print(""FactCnt: "", str(FactCnt))
            FDivCnt = 1
            for TF in FactCnt:
                FDivCnt = [FDivCnt * (TF + 1), (FDivCnt * (TF + 1)) % Mod][ModFlag]
            print(""FDivCnt: "", str(FDivCnt))
            return FactDec, FactCnt, FDivCnt
FactDec, FactCnt, FDivCnt = DivisorFactorial(int(input()), [], [], False, 10**9+7, True)
print(FDivCnt)
</ans>",0,{}
2,"<ans>
from math import sqrt,gcd

def gen_primes():
    """""" Generate an infinite sequence of prime numbers.
    """"""
    #
    D = {}

    # The running integer that's checked for primeness
    q = 2

    while True:
        if q not in D:
            # q is a new prime.
            # Yield it and mark its first multiple that isn't
            # already marked in previous iterations
            #
            yield q
            print(""q: "", str(q))
            D[q * q] = [q]
        else:
            # q is composite. D[q] is the list of primes that
            # divide it. Since we've reached q, we no longer
            # need it in the map, but we'll mark the next
            # multiples of its witnesses to prepare for larger
            # numbers
            #
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
            del D[q]

        q += 1

def is_prime(n):
    if n<=1:
        return False
    if n == 2:
        return True
    if n % 2 ==0:
        return False
    return all(n%i for i in range(3,int(sqrt(n))+1))

def calculate_colors(n):
    primes = gen_primes()
    sqr_n = int(sqrt(n)) + 1
    if n == 1:
        return 1
    for p in primes:
        if n % p == 0:
            while n % p == 0:
                g= gcd(p,n)
                n = int(n//g)
            if n > 1:
                return 1
            else:
                return p
        if p > sqr_n:
            return n

n = int(input())
print(calculate_colors(n))
</ans>",0,{}
3,"<ans>
import numpy as np
mod = 998244353

def poly_mul(f, g):
    Lf = len(f)
    print(""Lf: "", str(Lf))
    Lg = len(g)
    print(""Lg: "", str(Lg))
    L = Lf + Lg - 1
    if Lf <= 16 or Lg <= 16:
        if Lf == 0 or Lg == 0:
            return np.zeros((0,), dtype=np.int64)
        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)
    fft = np.fft.rfft; ifft = np.fft.irfft
    fft_len = 1 << L.bit_length()
    fl = f & (1 << 15) - 1
    print(""fl: "", str(fl))
    fh = f >> 15
    print(""fh: "", str(fh))
    gl = g & (1 << 15) - 1
    print(""gl: "", str(gl))
    gh = g >> 15
    print(""gh: "", str(gh))
    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod
    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    return (x + ((y - x - z) << 15) + (z << 30)) % mod

def poly_inv(fps, n=None):
    assert fps[0] != 0
    if n is None:
        n = len(fps)
    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)
    res[0] = pow(int(fps[0]), mod-2, mod)
    i = 1
    while i < n:
        i <<= 1
        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod
    return res[:n]

def poly_div(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    if n1 < n2:
        return np.zeros((0,), dtype=np.int64)
    n = n1 - n2 + 1
    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]
    return res

def poly_mod(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    if n1 < n2:
        return fps1
    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]
    return res % mod

def multipoint_evaluation(fps, xs):
    threshold = 8
    n_xs = len(xs)
    bit = (n_xs-1).bit_length()
    if bit <= threshold:
        res = np.zeros_like(xs)
        xs_cumprod = np.ones_like(xs)
        for coef in fps:
            res += xs_cumprod * coef
            xs_cumprod *= xs
            xs_cumprod %= mod
        return res
    k = 1<<bit
    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)
    fpss[0, :n_xs] = -xs % mod
    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod
    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod
    for i in range(1, bit):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+step] = f[:-1]
    f = poly_mod(fps, f)
    fpss[-1, :len(f)] = f
    fpss[-1, len(f):] = 0
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f = fpss[i+1, j:j+step]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss[i, j:j+half] = poly_mod(f, f1)
            fpss[i, j+half:j+step] = poly_mod(f, f2)
    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)
    xs_cumprod = np.ones_like(xs)
    res = np.zeros_like(xs)
    for i in range(1<<threshold):
        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    return res.reshape(-1)[:n_xs] % mod

def poly_differential(fps):
    return fps[1:] * np.arange(1, len(fps)) % mod

def lagrange_interpolation(X, Y, mod):
    n = len(X)
    g = [0]*(n+1)
    g[0] = 1
    for i, x in enumerate(X):
        for j in range(i, -1, -1):
            g[j+1] += g[j] * (-x) % mod
    res = [0]*n
    for x, y in zip(X, Y):
        f = g[:]
        denom = 0
        v = 1
        pow_x = [1]  # x の idx 乗
        for _ in range(n-1):
            v = v * x % mod
            pow_x.append(v)
        pow_x.reverse()  # n-1 乗 ~ 0 乗
        for i, po in enumerate(pow_x):
            f_i = f[i]
            f[i+1] += f_i * x % mod  # f = g / (x - x_i) を組立除法で求める
            denom = (denom + f_i * po) % mod
        denom_inv = pow(denom, mod-2, mod)
        for i, f_i in enumerate(f[:n]):
            res[i] += (f_i * y * denom_inv) % mod  # mod が大きいと 64bit に収まらなくなるのでひとつずつ mod 取った方がいいか？
    return [v % mod for v in res]

def polynomial_interpolation(xs, ys):
    assert len(xs) == len(ys)
    threshold = 8
    as_strided = np.lib.stride_tricks.as_strided
    n = len(xs)
    if n==1:
        return ys.copy()
    bit = (n-1).bit_length()
    if bit <= threshold:
        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)
        return np.array(res[::-1], dtype=np.int64)
    k = 1<<bit
    fpss = np.zeros((bit+1, n+1), dtype=np.int64)
    fpss[0, :n] = -xs % mod
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, n, step):
            if j+half >= n:
                fpss[i+1, j:n] = fpss[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+len(f)-1] = f[:-1]
    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)
    fpss2[bit, :n] = poly_differential(f)
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, n, step):
            if j+half >= n:
                fpss2[i, j:n] = fpss2[i+1, j:n]
                continue
            f = fpss2[i+1, j:min(j+step, n)]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:min(j+step, n)+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i, j:j+half] = poly_mod(f, f1)
            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)
    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))
    xs_cumprod = np.ones_like(xs)
    f = np.zeros_like(xs)
    for i in range(1<<threshold):
        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    f = f.ravel()
    for j in range(n):
        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, k, step):
            if j+half >= n:
                fpss2[i+1, j:n] = fpss2[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i+1, j:min(j+step, n)] = (
                poly_mul(fpss2[i, j:j+half], f2)
                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)
            ) % mod
    return fpss2[bit, :n]

mod = int(input())
A = np.array(input().split(), dtype=np.int64)
X = np.arange(mod, dtype=np.int64)
Ans = polynomial_interpolation(X, A)
print(("" "".join(map(str, Ans.tolist()))))
</ans>",0,{}
4,"<ans>
import math
from collections import defaultdict
import sys
#input = sys.stdin.readline

def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    k = list(map(int, input().split()))
    print(""k: "", str(k))
    sales = [(0, 0)] * m
    for i in range(m):
        a, b = list(map(int, input().split()))
        sales[i] = (b, a)

    def check(days):
        last_sale = {}
        print(""last_sale: "", str(last_sale))
        for sale in sales:
            if sale[1] <= days:
                if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:
                    last_sale[sale[0]] = sale[1]

        date_last_sales = {}
        print(""date_last_sales: "", str(date_last_sales))
        for t, d in list(last_sale.items()):
            if d not in date_last_sales:
                date_last_sales[d] = [t]
            else:
                date_last_sales[d].append(t)

        balance = 0
        required = [0] + k.copy()
        print(""required: "", str(required))

        end = 0
        for d in range(1, days+1):
            balance += 1
            if d in date_last_sales:
                for t in date_last_sales[d]:
                    if required[t] > 0:
                        if required[t] > balance:
                            end += required[t] - balance
                        balance -= min(required[t], balance)
                        required[t] = 0
            if d == days:  # last day
                for r in required:
                    if r > 0:
                        end += r

        return 2*end <= balance

    total = sum(k)
    print(""total: "", str(total))
    hi = 2*total
    lo = 1
    print(""hi: "", str(hi), ""lo: "", str(lo))

    while lo + 1 < hi:
        mid = (lo + hi) // 2
        print(""mid: "", str(mid))
        if check(mid):
            hi = mid
        else:
            lo = mid

    if check(lo):
        print(lo)
    else:
        print(hi)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
5,"<ans>
import sys
from collections import deque
import heapq
input = sys.stdin.readline

N = int(input())
print(""N: "", str(N))
EDGE = [list(map(int, input().split())) for i in range(N - 1)]
print(""EDGE: "", str(EDGE))

EDGELIST = [[] for i in range(N + 1)]
print(""EDGELIST: "", str(EDGELIST))

for i, j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

REDG = [None for i in range(N + 1)]
print(""REDG: "", str(REDG))
QUE = deque([1])
check = [0] * (N + 1)
DEPTH = [None] * (N + 1)
i = 0
while QUE:
    NQUE = deque()
    i += 1

    while QUE:
        x = QUE.pop()
        DEPTH[x] = i
        check[x] = 1
        for to in EDGELIST[x]:
            if check[to] == 1:
                continue
            else:
                REDG[to] = x
                NQUE.append(to)
    QUE = NQUE

check = [0] * (N + 1)
check[1] = 1
LEAF = []
for i in range(2, N + 1):
    if len(EDGELIST[i]) == 1:
        LEAF.append((-DEPTH[i], i))

QUE = LEAF
heapq.heapify(QUE)
ANS = 0

while QUE:
    dep, x = heapq.heappop(QUE)
    if check[x] != 0 or dep >= -3:
        continue

    if check[REDG[x]] == 2:
        continue

    if check[x] == 0:
        check[x] = 1
    if check[REDG[REDG[x]]] == 0:
        check[REDG[REDG[x]]] = 1
    check[REDG[x]] = 2
    heapq.heappush(QUE, (-DEPTH[REDG[REDG[REDG[x]]]], REDG[REDG[REDG[x]]]))
    ANS += 1

print(ANS)

</ans>",0,{}
6,"<ans>
class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        print(""_parent: "", str(self._parent))
        self._size = [1] * N
        print(""_size: "", str(self._size))

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

    def calc_group_num(self):
        N = len(self._parent)
        ans = 0
        for i in range(N):
            if self.find_root(i) == i:
                ans += 1
        return ans

import sys

input=sys.stdin.readline

n,m=list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m))
t=list(map(int,input().split()))
print(""t: "", str(t))
t=[t[i]-1 for i in range(n)]
query=[]
for i in range(m-1):
    a,b=list(map(int,input().split()))
    print(""a: "", str(a), ""b: "", str(b))
    query.append((a-1,b-1))

tower=[[] for i in range(m)]
for i in range(n):
    id=t[i]
    if not tower[id]:
        tower[id].append((i+1,i+1))
    else:
        start,end=tower[id].pop()
        if end+1==i+1:
            tower[id].append((start,i+1))
        else:
            tower[id].append((start,end))
            tower[id].append((i+1,i+1))

#print(tower)
test=[]
for i in range(m):
    for start,end in tower[i]:
        if end!=n:
            test.append((t[start-1],t[end]))

#print(test)
start=[-1]*len(test)
end=[m-1]*len(test)
temp=[[] for i in range(m)]
for i in range(len(test)):
    T=(end[i]+start[i])//2
    temp[T].append(i)

def parabisect():
    uf=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=query[i]
        uf.unite(a,b)
        while temp[i]:
            j=temp[i].pop()
            id1,id2=test[j]
            if uf.is_same_group(id1,id2):
                end[j]=i
            else:
                start[j]=i
            if end[j]-start[j]>1:
                T=(end[j]+start[j])//2
                temp[T].append(j)

for i in range(20):
    parabisect()

res=[0]*m
for i in range(len(test)):
    res[end[i]+1]-=1

for i in range(1,m):
    res[i]+=res[i-1]

for i in range(m):
    print(""res: "", str(res[i]))
</ans>",0,{}
7,"<ans>
# from collections import deque
import io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # 神奇快读，无法运行调试
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

print(""BUFSIZE: "", str(BUFSIZE))

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        print(""_fd: "", str(self._fd))
        self.buffer = BytesIO()
        print(""buffer: "", str(self.buffer))
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        print(""writable: "", str(self.writable))
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        print(""buffer: "", str(self.buffer))
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        print(""writable: "", str(self.writable))
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")

n, m = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m))
inc = {
    # chr(97+i):0 for i in range(26)
}
print(""inc: "", str(inc))
l = [None for i in range(n*m)]
print(""l: "", str(l))

for i in range(n):
    t = int(input())
    print(""t: "", str(t))
    for j in range(m):
        ipt = input()
        print(""ipt: "", str(ipt))
        l[t*m+j] = ipt
        if len(inc)==26:continue
        for q in ipt:
            inc.setdefault(q, 0)
print(""inc: "", str(inc))

d = {}
print(""d: "", str(d))

f = l[0][0]

def ae(u, v):
    t = d.setdefault(u, set())
    print(""u: "", str(u), ""v: "", str(v), ""t: "", str(t))
    if v not in t:
        t.add(v)
        inc[v] = inc.get(v, 0) + 1
        print(""inc[v]: "", str(inc[v]))

for p, i in enumerate(l[1:]):
    for j in range(min(len(l[p]), len(i))):
        if l[p][j] != i[j]:
            # if len(l[p])-1 != j:
                # ae(l[p][j],i[j])
            ae(i[j], l[p][j])
            break
        if len(i)-1==j and len(l[p])-1 > j:
            print(""IMPOSSIBLE"")
            return

ans = []
dq = []
# dq = deque()
ptr = 0

ninc = {}

for k, v in inc.items():
    if v == 0:
        dq.append(k)
    else:
        ninc[k] = v
print(""ninc: "", str(ninc))

if len(inc):
    print(""IMPOSSIBLE"")
    return

print(*reversed(ans), sep='')

</ans>",0,{}
8,"<ans>
import sys
import math
import itertools
import functools
import collections

def ii(): return int(input())
print(""ii: "", str(ii))
def mi(): return list(map(int, input().split()))
print(""mi: "", str(mi))
def li(): return list(map(int, input().split()))
print(""li: "", str(li))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
print(""lcm: "", str(lcm))
def wr(arr): return ' '.join(map(str, arr))
print(""wr: "", str(wr))
def revn(n): return str(n)[::-1]
print(""revn: "", str(revn))
def dd(): return collections.defaultdict(int)
print(""dd: "", str(dd))
def ddl(): return collections.defaultdict(list)
print(""ddl: "", str(ddl))
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
print(""sieve: "", str(sieve))
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
print(""divs: "", str(divs))
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
print(""divn: "", str(divn))
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
print(""prime: "", str(prime))
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
print(""convn: "", str(convn))
def cdiv(n, k): return n // k + (n % k != 0)
print(""cdiv: "", str(cdiv))

t = ii()
print(""t: "", str(t))
for _ in range(t):
    r, g, b = sorted(mi())
    print(""r: "", str(r), ""g: "", str(g), ""b: "", str(b))
    if b > r + g + 1:
        print('No')
    else:
        print('Yes')

</ans>",0,{}
9,"<ans>
#!/usr/bin/env python
# 560B_art.py - Codeforces.com 560B Art program
#
# Copyright (C) 2015 Sergey

""""""
Gerald asks whether it is possible to place the paintings on the board,
or is the board he bought not large enough?
Input

The first line contains two space-separated numbers a1 and b1 the sides
of the board. Next two lines contain numbers a2 b2 a3 and b3 the sides
of the paintings. All numbers ai,?bi in the input are integers and fit into
the range from 1 to 1000.

Output

If the paintings can be placed on the wall, print ""YES"" (without the quotes),
and if they cannot, print ""NO"" (without the quotes).
""""""

# Standard modules
import unittest
import sys

# Additional modules


###############################################################################
# Art Class
###############################################################################


class Art:
    """""" Art representation """"""

    def __init__(self, args):
        """""" Default constructor """"""
        print(""args: "", str(args))
        self.numa, self.numb = args
        print(""numa: "", str(self.numa), ""numb: "", str(self.numb))

        self.r = self.rect(self.numa[0], self.numb[0])
        print(""r: "", str(self.r))
        self.rmax = self.rect(self.numa[1], self.numb[1])
        print(""rmax: "", str(self.rmax))
        self.rmin = self.rect(self.numa[2], self.numb[2])
        print(""rmin: "", str(self.rmin))
        if self.rmax[0] < self.rmax[1]:
            self.rmax, self.rmin = self.rmin, self.rmax
        print(""rmax after swap: "", str(self.rmax), ""rmin after swap: "", str(self.rmin))

        self.remain = []
        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))
        print(""remain after first condition: "", str(self.remain))
        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))
        print(""remain after second condition: "", str(self.remain))
        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))
        print(""remain after third condition: "", str(self.remain))
        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))
        print(""remain after fourth condition: "", str(self.remain))

    def rect(self, a, b):
        if a > b:
            return (a, b)
        else:
            return (b, a)

    def calculate(self):
        """""" Main calcualtion function of the class """"""
        for rec in self.remain:
            print(""rec: "", str(rec))
            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:
                return ""YES""
            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:
                return ""YES""
        return ""NO""


###############################################################################
# Helping classes
###############################################################################


###############################################################################
# Art Class testing wrapper code
###############################################################################


def get_inputs(test_inputs=None):

    it = iter(test_inputs.split(""\n"")) if test_inputs else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if it:
            return next(it)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    imax = 3
    numnums = list(map(int, "" "".join(uinput() for i in range(imax)).split()))

    # Splitting numnums into n arrays
    numa = []
    numb = []
    for i in range(0, 2*imax, 2):
        numa.append(numnums[i])
        numb.append(numnums[i+1])

    # Decoding inputs into a list
    return [numa, numb]


def calculate(test_inputs=None):
    """""" Base class calculate method wrapper """"""
    return Art(get_inputs(test_inputs)).calculate()


###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_Art_class__basic_functions(self):
        """""" Art class basic functions testing """"""

        # Constructor test
        d = Art([[3, 1, 2], [2, 3, 1]])
        self.assertEqual(d.numa[0], 3)

        self.assertEqual(d.r, (3, 2))
        self.assertEqual(d.rmax, (3, 1))
        self.assertEqual(d.rmin, (2, 1))

        self.assertEqual(d.remain, [(3, 1)])

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        test = ""3 2\n1 3\n2 1""
        self.assertEqual(calculate(test), ""YES"")
        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])
        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])

        # Sample test 2
        test = ""5 5\n3 3\n3 3""
        self.assertEqual(calculate(test), ""NO"")

        # Sample test 3
        test = ""4 2\n2 3\n1 2""
        self.assertEqual(calculate(test), ""YES"")

        # My test 4
        test = ""5 5\n1 5\n1 5""
        self.assertEqual(calculate(test), ""YES"")

    def test_time_limit_test(self):
        """""" Quiz time limit test """"""

        import random

        # Time limit test
        test = ""1000 1000""
        test += ""\n900 900""
        test += ""\n50 50""

        import timeit

        start = timeit.default_timer()
        args = get_inputs(test)

        init = timeit.default_timer()
        d = Art(args)

        calc = timeit.default_timer()
        d.calculate()

        stop = timeit.default_timer()
        print((
            ""\nTime Test: "" +
            ""{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)"".
            format(stop-start, init-start, calc-init, stop-calc)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(calculate())

__starting_point()
</ans>",0,{}
10,"<ans>
import sys
from collections import defaultdict

class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * n
        print(""self.n: "", str(self.n))
        print(""self.tree: "", str(self.tree))

    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        result = 0
        while r > 0:
            result += self.tree[r-1]
            r &= (r - 1)
        return result

    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)

    def add(self, i, value=1):
        while i < self.n:
            self.tree[i] += value
            i |= (i + 1)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
swaps = []
for _ in range(n):
    i, j = list(map(int, input().split()))
    swaps.append(i)
    swaps.append(j)

pos = defaultdict(list)
for i, val in enumerate(swaps):
    pos[val].append(i)

c = 0
prev = -1
compr = [0] * (2*n)
decompr = {}
for val in sorted(swaps):
    if prev == val: continue
    for j in pos[val]:
        compr[j] = c
    decompr[c] = val
    c += 1
    prev = val

arr = list(range(c))
for t in range(n):
    i, j = compr[t<<1], compr[t<<1|1]
    arr[i], arr[j] = arr[j], arr[i]

bit = BIT(c)
total_inv = 0
for i, val in enumerate(arr):
    total_inv += bit.get_sum(val+1, c)
    if i != val:
        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)
    bit.add(val)
print(total_inv)

</ans>",0,{}
11,"<ans>
from math import sqrt

eps = 1e-9

def mysqrt(x):
    if x <= 0:
        return 0
    return sqrt(x)

def good(R):
    nonlocal xs
    nonlocal ys
    nonlocal n

    left = -10**20
    right = 10**20

    for i in range(n):
        # (x - xi)**2 + (y - yi)**2 = R**2
        # y = R
        xi = xs[i]
        yi = abs(ys[i])

        D = 2 * R * yi - yi**2

        if D + eps < 0:
            return False

        sD = mysqrt(D)

        new_left = xi - sD
        new_right = xi + sD

        left = max(left, new_left)
        right = min(right, new_right)

        if left + eps > right:
            return False

    return True

def solve(lower, high, md):
    R = 0
    for _ in range(150):
        R = md(lower, high)

        if good(R):
            high = R
        else:
            lower = R

    return R

n = int(input())

xs = [0.0 for _ in range(n)]
ys = [0.0 for _ in range(n)]

for i in range(n):
    xs[i], ys[i] = list(map(float, input().split()))
    if i > 0:
        if ys[i] * ys[0] < 0:
            print(-1)
            return

R = None
if good(1):
    R = solve(0, 1, lambda x, y: (x + y) / 2)
else:
    R = solve(1, 1e16, lambda x, y: sqrt(x * y))

print('{:.16}'.format(R))
</ans>",0,{}
12,"<ans>
```
def bin_pow(num, degree , module):
    if degree == 0:
        return 1
    if degree == 1:
        return num % module

    if degree % 2 == 0:
        val = bin_pow(num, degree // 2, module)
        return (val * val) % module

    return (num * bin_pow(num , degree - 1, module)) % module

x, y = list(map(int,input().split()))
print(""x: "", str(x), ""y: "", str(y))

if y % x != 0:
    print(0)
    return

y //= x

divs = set()
to_gen = []

num = 2
val = y

while num * num <= val:
    degree = 0
    while y % num == 0:
        degree+=1
        y //= num
    if degree != 0:
        to_gen.append((num, degree))

    if num == 2:
        num += 1
    else:
        num += 2

if y != 1:
    to_gen.append((y, 1))

print(""to_gen: "", str(to_gen))

to_gen_len = len(to_gen)

def generate(ind):
    if ind == to_gen_len:
        yield 1
        return
    gen_val = to_gen[ind][0]

    for deg in range(1 + to_gen[ind][1]):
        for each in generate(ind  + 1):
            yield gen_val**deg * each

for each in generate(0):
    divs.add(each)

divs = list(divs)
divs.sort()
divs_answers = {}
mod = 10**9 + 7
ans = bin_pow(2, val - 1, mod)

for el in divs:
    if el == 1:
        divs_answers[el] = 1
        ans -= 1
    else:
        curr_val = bin_pow(2, el - 1 ,mod)
        for other_el in divs:
            if other_el >= el:
                break
            if el % other_el !=0:
                continue

            curr_val -= divs_answers[other_el]

        divs_answers[el] = curr_val % mod
        ans -= curr_val

print(""divs_answers: "", str(divs_answers))
print(divs_answers[val])
```
</ans>",0,{}
13,"<ans>
import bisect

class BTreeNode:
    def __init__(self):
        self.key = []
        self.child = []

class BTree:
    def __init__(self):
        self.root = BTreeNode()
        print(""self.root: "", str(self.root))

    def search_higher(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_right(ptr.key, key)
            if i != len(ptr.key):
                ret = ptr.key[i]
            ptr = ptr.child[i]
        i = bisect.bisect_right(ptr.key, key)
        if i != len(ptr.key):
            ret = ptr.key[i]
        return ret

    def search_lower(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_left(ptr.key, key)
            if i != 0:
                ret = ptr.key[i - 1]
            ptr = ptr.child[i]
        i = bisect.bisect_left(ptr.key, key)
        if i != 0:
            ret = ptr.key[i - 1]
        return ret

    def insert(self, key):
        def insert_rec(ptr):
            b_size = 10
            if not ptr.child:
                bisect.insort(ptr.key, key)
                print(""ptr.key: "", str(ptr.key))
                if len(ptr.key) == b_size * 2 - 1:
                        ret = BTreeNode()
                        ret.key = ptr.key[:b_size]
                        ptr.key = ptr.key[b_size:]
                        return ret
            else:
                i = bisect.bisect(ptr.key, key)
                temp = insert_rec(ptr.child[i])
                if temp is not None:
                    ptr.key.insert(i, temp.key.pop(-1))
                    ptr.child.insert(i, temp)
                    if len(ptr.child) == b_size * 2:
                        ret = BTreeNode()
                        ret.child = ptr.child[:b_size]
                        ptr.child = ptr.child[b_size:]
                        ret.key = ptr.key[:b_size]
                        ptr.key = ptr.key[b_size:]
                        return ret
            return None
        temp = insert_rec(self.root)
        if temp is not None:
            root = BTreeNode()
            root.key = [temp.key.pop(-1)]
            root.child = [temp, self.root]
            self.root = root
            print(""self.root: "", str(self.root))

    def dump(self):
        def dump_rec(ptr, dep):
            for _ in range(0, dep):
                print(""  "", end="""")
            print(ptr.key)
            for c in ptr.child:
                dump_rec(c, dep + 1)
        dump_rec(self.root, 0)
        print("""")

def main():
    n = int(input())
    p = list(map(int, input().split()))
    idx = [0] * n
    for i in range(0, n):
        idx[i] = i
    idx.sort(key=lambda i: - p[i])
    t = BTree()
    t.insert(-1)
    t.insert(n)
    ans = 0
    for i in idx:
        nex = t.search_higher(i)
        nexnex = t.search_higher(nex)
        pre = t.search_lower(i)
        prepre = t.search_lower(pre)
        if prepre != None:
            ans += p[i] * (pre - prepre) * (nex - i)
        if nexnex != None:
            ans += p[i] * (i - pre) * (nexnex - nex)
        t.insert(i)
        print(""t.root: "", str(t.root))

    print(ans)

main()

</ans>",0,{}
14,"<ans>
k = 72
print(""k: "", str(k))
K = 1<<k
print(""K: "", str(K))
nu = lambda L: int("""".join([bin(K+a)[-k:] for a in L[::-1]]), 2)
print(""nu: "", str(nu))
st = lambda n: bin(n)[2:] + ""0""
print(""st: "", str(st))
li = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]
print(""li: "", str(li))

def grow(d, v, h):
    h += [0] * d
    print(""h: "", str(h))
    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]
    print(""f: "", str(f))

    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):
        t = [1] * (2*d+2)
        print(""t: "", str(t))
        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P
        ti = [1] * (2*d+2)
        ti[-1] = pow(t[-1], P-2, P)
        print(""ti: "", str(ti))
        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P

        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]
        print(""g: "", str(g))
        fg = li(st(nu(f) * nu(g)), d * 2 + 2)
        print(""fg: "", str(fg))

        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
    return h

# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]
def create_table(v):
    s = 1
    X = [1, v+1]
    print(""X: "", str(X))
    while s < v:
        X = grow(s, v, X)
        s *= 2
    table = [1]
    for x in X:
        table.append(table[-1] * x % P)
    print(""table: "", str(table))
    return table

def fact(i, table):
    a = table[i//v]
    print(""a: "", str(a))
    for j in range(i//v*v+1, i+1):
        a = a * j % P
    print(""a: "", str(a))
    return a

P = 10**9+7
print(""P: "", str(P))
v = 1 << 11
print(""v: "", str(v))
fa = [1] * (2*v+2)
fainv = [1] * (2*v+2)
for i in range(2*v+1):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(2*v+1)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

T = create_table(v)

f = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P
print(""f: "", str(f))
r1, c1, r2, c2 = list(map(int, input().split()))
print(""r1, c1, r2, c2: "", str(r1), "", "", str(c1), "", "", str(r2), "", "", str(c2))
print(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))

</ans>",0,{}
15,"<ans>
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        print(""parent: "", str(self.parent))
        self.size = [1] * n
        print(""size: "", str(self.size))
        self.num_sets = n

    def find(self, a):
        to_update = []

        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]

        for b in to_update:
            self.parent[b] = a

        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)

        if a == b:
            return

        if self.size[a] < self.size[b]:
            a, b = b, a

        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]

    def set_size(self, a):
        return self.size[self.find(a)]

def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n, m = read_int_array()
    uf = UnionFind(n)
    for _ in range(m):
        nums = read_int_array()
        sz = nums[0]
        leader = None
        for i in range(sz):
            p = nums[1 + i] - 1
            if leader is None:
                leader = p
            else:
                uf.merge(p, leader)

    ans = [uf.set_size(i) for i in range(n)]
    write(*ans)

main()
</ans>",0,{}
16,"<ans>
#!/usr/bin/env python3
# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015

import unittest
import sys

###############################################################################
# Sponge Class (Main Program)
###############################################################################


class Sponge:
    """""" Sponge representation """"""

    def __init__(self, test_inputs=None):
        """""" Default constructor """"""

        it = iter(test_inputs.split(""\n"")) if test_inputs else None

        def uinput():
            return next(it) if it else sys.stdin.readline().rstrip()

        # Reading single elements
        print(""n, m: "", str([self.n, self.m]))
        [self.n, self.m] = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        print(""numf: "", str(self.numf))
        self.numf = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        print(""numb: "", str(self.numb))
        self.numb = list(map(int, uinput().split()))

        self.fd = {}
        self.fdn = {}
        for (i, n) in enumerate(self.numf):
            self.fd[n] = self.fd.setdefault(n, 0) + 1
            self.fdn[n] = i + 1

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        result = []
        for n in self.numb:
            if n not in self.fd:
                return ""Impossible""
            result.append(self.fdn[n])
        for n in self.numb:
            if self.fd[n] > 1:
                return ""Ambiguity""

        return ""Possible\n"" + "" "".join(map(str, result))

###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_single_test(self):
        """""" Sponge class testing """"""

        # Constructor test
        test = ""3 3\n3 2 1\n1 2 3""
        d = Sponge(test)
        self.assertEqual(d.n, 3)
        self.assertEqual(d.m, 3)
        self.assertEqual(d.numf, [3, 2, 1])
        self.assertEqual(d.numb, [1, 2, 3])

        # Sample test
        self.assertEqual(Sponge(test).calculate(), ""Possible\n3 2 1"")

        # Sample test
        test = ""3 3\n1 1 3\n1 2""
        self.assertEqual(Sponge(test).calculate(), ""Impossible"")

        # Sample test
        test = ""3 3\n1 1 1\n1 1 1""
        self.assertEqual(Sponge(test).calculate(), ""Ambiguity"")

        # My tests
        test = """"
        # self.assertEqual(Sponge(test).calculate(), ""0"")

        # Time limit test
        # self.time_limit_test(5000)

    def time_limit_test(self, nmax):
        """""" Timelimit testing """"""
        import random
        import timeit

        # Random inputs
        test = str(nmax) + "" "" + str(nmax) + ""\n""
        numnums = [str(i) + "" "" + str(i+1) for i in range(nmax)]
        test += ""\n"".join(numnums) + ""\n""
        nums = [random.randint(1, 10000) for i in range(nmax)]
        test += "" "".join(map(str, nums)) + ""\n""

        # Run the test
        start = timeit.default_timer()
        d = Sponge(test)
        calc = timeit.default_timer()
        d.calculate()
        stop = timeit.default_timer()
        print((""\nTimelimit Test: "" +
              ""{0:.3f}s (init {1:.3f}s calc {2:.3f}s)"".
              format(stop-start, calc-start, stop-calc)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(Sponge().calculate())

__starting_point()
</ans>",0,{}
17,"<ans>
n=input().split()
print(""n: "", str(n))
r=int(n[0])
print(""r: "", str(r))
k=int(n[1])
print(""k: "", str(k))
l=[]
for i in range(r):
    li=input()
    l.append(li)
print(""l: "", str(l))
rl=[]
for i in range(r):
    x=[]
    for j in range(r):
        x.append(0)
    rl.append(x)
print(""rl: "", str(rl))
for i in range(r):
    for j in range(len(l[i])):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[i][j+q:j+q+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[i][j+q]=rl[i][j+q]+1
            if flag==1:
                j=q+1
for i in range(r):
    for j in range(r):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[j+q][i:i+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[j+q][i]=rl[j+q][i]+1
            if flag==1:
                j=q+1
maxi=0
print(""maxi: "", str(maxi))
maxj=0
print(""maxj: "", str(maxj))
m=0
print(""m: "", str(m))
for i in range(r):
    for j in range(r):
        if rl[i][j]>m:
            m=rl[i][j]
            maxi=i
            maxj=j
print(""maxi: "", str(maxi))
print(""maxj: "", str(maxj))
print(maxi+1,maxj+1)

</ans>",0,{}
18,"<ans>
"""""" ATSTNG's ejudge Python3 solution template """"""
import sys, queue

try:
    import dev_act_ffc429465ab634
    print(""DEV: "", str(DEV))
except:
    DEV = False

def log(*s):
    if DEV: print('L',list(s),sep='')

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        print(""problem: "", str(problem))
        print(""reclim: "", str(reclim))
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            print(""infile: "", str(infile))
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            print(""outfile: "", str(outfile))
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        tmp = [[[5]*100000 for _ in range(1000)]]
        print(""tmp: "", str(tmp))
        while True: tmp.append([[5]*100000 for _ in range(1000)])

    def get_re(self):
        s = (0,)[8]
        print(""s: "", str(s))

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        return

class IntReader:
    def __init__(self):
        print(""ost: "", str(self.ost))
        self.ost = queue.Queue()

    def get(self):
        print(""return: "", str(int(self.sget())))
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        print(""return: "", str(self.ost.get()))
        return self.ost.get()

    def release(self):
        res = []
        while not self.ost.empty():
            res.append(self.ost.get())
        print(""return: "", str(res))
        return res

###############################################################################
ej = EJudge(  )
print(""ej: "", str(ej))
int_reader = IntReader()
print(""int_reader: "", str(int_reader))
fmap = lambda f,l: list(map(f,l))
print(""fmap: "", str(fmap))
parse_int = lambda: fmap(int, input().split())
print(""parse_int: "", str(parse_int))
sign = lambda x: (x>0)-(x<0)
print(""sign: "", str(sign))

# input
n,x = parse_int()
print(""n: "", str(n))
print(""x: "", str(x))
st = [0]*100500
print(""st: "", str(st))
xored = [0]*100500
print(""xored: "", str(xored))
for _ in range(n): st[int_reader.get()] += 1
for idx in range(100500):
    pair = idx^x
    if pair < 100500:
        xored[pair] = st[idx]

ans = 0
for idx in range(100500):
    ans += st[idx]*xored[idx]

if x == 0: ans -= n

print(""ans: "", str(ans//2))
</ans>",0,{}
19,"<ans>
import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

# Guide:
#   1. construct complex data types while reading (e.g. graph adj list)
#   2. avoid any non-necessary time/memory usage
#   3. avoid templates and write more from scratch
#   4. switch to ""flat"" implementations

def VI(): return list(map(int,input().split()))
print(""VI: "", str(VI))
def I(): return int(input())
print(""I: "", str(I))
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
print(""LIST: "", str(LIST))
def ELIST(n): return [[] for i in range(n)]
print(""ELIST: "", str(ELIST))
def MI(n=None,m=None): # input matrix of integers
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = VI()
    return arr
print(""MI: "", str(MI))
def MS(n=None,m=None): # input matrix of strings
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = input()
    return arr
print(""MS: "", str(MS))
def MIT(n=None,m=None): # input transposed matrix/array of integers
    if n is None: n,m = VI()
    a = MI(n,m)
    arr = LIST(m,n)
    for i,l in enumerate(a):
        for j,x in enumerate(l):
            arr[j][i] = x
    return arr
print(""MIT: "", str(MIT))


def run(n,a):
    for i in range(n+1):
        if a[0]==0:
            if sum([i==a[i] for i in range(n)])==n:
                print(""Yes"")
            else:
                print(""No"")
            return
        for j in range(n):
            if j%2==0:
                a[j] = (a[j]+1)%n
            else:
                a[j] = (a[j]-1)%n
    print(""n: "", str(n), ""a: "", str(a))

def main(info=0):
    n = I()
    a = VI()

    run(n,a)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
20,"<ans>
import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

def e_gcd(a, b ):
    if a==0 and b==0:
        return -1, 0, 0
    if b==0:
        return a, 1,0
    d, y,x = e_gcd(b, a%b )
    y-=  a //b *x
    return d , x,y

def m_reverse(a,n):
    d,x,y = e_gcd(a,n)
    dprint(x,y,a,n)
    assert x*a + y*n == d
    if d==1:
        if x%n<=0:
           return x%n+n
        else:
            return x%n
    else:
        return -1

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit

base = 998244353
d = 1233
t = m_reverse( d, base)
dprint(t)
z = t * d % base
dprint(z)
N, M, K= getIntList()
dprint(""N: "", str(N), ""M: "", str(M), ""K: "", str(K))

J = N-1 - K   # same
dprint(""J: "", str(J))

Z = N - J
dprint(""Z: "", str(Z))

R = M
for i in range(Z-1):
    R *= M-1
    R%= base
dprint(""R: "", str(R))

n0 = J
m0 = Z
dprint(""n0: "", str(n0), ""m0: "", str(m0))

#comb(n0 + m0 -1, m0-1)
for i in range(m0 -1):
    g = n0 + m0 -1  -i
    R*= g
    R%= base

for i in range(2, m0):
    t = m_reverse(i,base)
    R*=t
    R%=base

print(R)
</ans>",0,{}
21,"<ans>
import math
import bisect
import itertools
import sys
I=lambda : sys.stdin.readline()
mod=10**9 +7
print(""mod: "", str(mod))
'''fact=[1]*100001
ifact=[1]*100001
for i in range(1,100001):
    fact[i]=((fact[i-1])*i)%mod
    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod
def ncr(n,r):
    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod
def npr(n,r):
    return (((fact[n]*ifact[n-r])%mod))
    '''

def mindiff(a):
    b=a[:]
    b.sort()
    print(""b: "", str(b))
    m=10000000000
    for i in range(len(b)-1):
        if b[i+1]-b[i]<m:
            m=b[i+1]-b[i]
    return m

def lcm(a,b):
    return a*b//math.gcd(a,b)

def merge(a,b):
    i=0;j=0
    c=0
    ans=[]
    while i<len(a) and j<len(b):
        if a[i]<b[j]:
            ans.append(a[i])
            i+=1
        else:
            ans.append(b[j])
            c+=len(a)-i
            j+=1
    ans+=a[i:]
    ans+=b[j:]
    return ans,c

def mergesort(a):
    if len(a)==1:
        return a,0
    mid=len(a)//2
    print(""mid: "", str(mid))
    left,left_inversion=mergesort(a[:mid])
    right,right_inversion=mergesort(a[mid:])
    m,c=merge(left,right)
    c+=(left_inversion+right_inversion)
    return m,c

def is_prime(num):
    if num == 1: return False
    if num == 2: return True
    if num == 3: return True
    if num%2 == 0: return False
    if num%3 == 0: return False
    t = 5
    a = 2
    while t <= int(math.sqrt(num)):
        if num%t == 0: return False
        t += a
        a = 6 - a
    return True

def ceil(a,b):
    if a%b==0:
        return a//b
    else:
        return (a//b + 1)

def binsearch(arr,b,low,high):
    if low==high:
        return low
    if arr[math.ceil((low+high)/2)]<b:
        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )
    else:
        return binsearch(arr,b,math.ceil((low+high)/2),high)

def ncr1(n,r):
    s=1
    for i in range(min(n-r,r)):
        s*=(n-i)
        s%=mod
        s*=pow(i+1,mod-2,mod)
        s%=mod
    return s

def calc(n,m,r):
    s=0
    for i in range(0,r+1,2):
        s+=ncr1(n,i)*ncr1(m,i)
        s%=mod
    return s

def modu(a,n):
    if a%n==0:
        return n
    return a%n

#/////////////////////////////////////////////////////////////////////////////////////////////////

for i in range(1):
    n,k=map(int,input().split())
    print(""n: "", str(n), ""k: "", str(k))
    a=list(map(int,input().split()))
    print(""a: "", str(a))
    s=input()
    print(""s: "", str(s))
    c=1;b=[]
    for i in range(1,n):
        if s[i-1]==s[i]:
            c+=1
            f=True
        else:
            b.append(c)
            c=1
            f=False
    if True:
        b.append(c)
    print(""b: "", str(b))
    ans=0
    su=0
    for i in b:
        c=a[su:min(su+i,10**9)]
        print(""c: "", str(c))
        c.sort(reverse=True)
        c=c[:min(i,k)]
        su+=i
        ans+=sum(c)
    print(ans)
</ans>",0,{}
22,"<ans>
def solve(printing):

    n = int(input())
    nums = [int(st)-1 for st in input().split("" "")]
    print(""n: "", str(n))
    print(""nums: "", str(nums))
    numdupe = [0] * n
    print(""numdupe: "", str(numdupe))
    dupeindex = []
    dupeindexindv = {}
    missing = []

    if printing:
        print(""nums""); print(nums)

    for i in range(n):
        numdupe[nums[i]] += 1

    for i in range(n):
        if numdupe[i] == 0:
            missing.append(i)

        if numdupe[nums[i]] >= 2:
            dupeindex.append(i)
            if nums[i] in dupeindexindv:
                dupeindexindv[nums[i]][1].append(i)
            else:
                dupeindexindv[nums[i]] = [0, [i], False]
                # left location, dupe indexs, if already located original

    for num in dupeindexindv:
        dupeindexindv[num][0] = len(dupeindexindv[num][1])

    if printing:
        print(""missing""); print(missing)
        print(""dupeindexindv""); print(dupeindexindv)

    misslen = len(missing)
    misindex = 0
    #answer = 0
    for index in dupeindex:

        if misslen <= misindex:
            break

        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:
            # one spot left but original not located yet.
            # locate original.
            dupeindexindv[nums[index]][0] -= 1
            dupeindexindv[nums[index]][2] = True

        elif dupeindexindv[nums[index]][0] > 0:

            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:
                # num is smaller or original is already located.
                # locate missing number.
                dupeindexindv[nums[index]][0] -= 1
                nums[index] = missing[misindex]
                misindex += 1
                #answer += 1

            else: # locate original
                dupeindexindv[nums[index]][0] -= 1
                dupeindexindv[nums[index]][2] = True

    print(misslen)
    for num in nums:
        print(num+1, end = "" "")

solve(False)

</ans>",0,{}
23,"<ans>
from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')):
 #------------------Sublime--------------------------------------#
 sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
 def I():return (int(input()))
 def In():return(map(int,input().split()))
else:
 #------------------PYPY FAst I/o--------------------------------#
 def I():return (int(stdin.readline()))
 def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
 d={}
 print(""d: "", str(d))
 for x in a:
  if d.get(x,-1)!=-1:
   d[x]+=1
  else:
   d[x]=1
 print(""d: "", str(d))
 return d
def find_gt(a, x):
 'Find leftmost value greater than x'
 i = bi.bisect_right(a, x)
 if i != len(a):
  return i
 else:
  return -1

def find_ge(a, x):
 'Find leftmost item greater than or equal to x'
 i = bi.bisect_left(a, x)
 if i != len(a):
  return i
 else:
  return -1
def main():
 try:
  n,Q=In()
  print(""n: "", str(n), ""Q: "", str(Q))
  l=list(In())
  print(""l: "", str(l))
  l.sort()
  print(""l: "", str(l))
  pre=[0]
  su=0
  for x in range(n):
   su+=l[x]
   pre.append(su)
  print(""pre: "", str(pre))
  for x in range(Q):
   q=I()
   print(""q: "", str(q))
   q*=2
   pos=find_ge(l,q)
   print(""pos: "", str(pos))
   if pos==-1:
    print(0)
   else:
    ans=pre[-1]-pre[pos]
    print(""ans: "", str(ans))
    print(ans)
 except:
  pass

M = 998244353
P = 1000000007

def __starting_point():
 #for _ in range(I()):main()
 for _ in range(1):main()
__starting_point()
</ans>",0,{}
24,"<ans>
import sys

def gcd(l):
	if len(l)==0:
		return 0
	if len(l)==1:
		return l[0]
	if len(l)==2:
		print(""l: "", str(l))
		if l[1]==0:
			return l[0]
		return gcd([l[1],l[0]%l[1]])
	return gcd([gcd(l[:-1]),l[-1]])

def brute_force(l1,l2,l,sol):
	if len(l)==0:
		g1=gcd(l1)
		g2=gcd(l2)
		print(""g1: "", str(g1), ""g2: "", str(g2))
		return g1==1 and g2==1,sol

	res,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])
	if res:
		return True,s
	return brute_force(l1,l2+[l[0]],l[1:],sol+[2])

def factor(n):
	res=[]
	i=2
	while i*i<=n:
		if n%i==0:
			res.append(i)
		while n%i==0:
			n=int(n/i)
		i+=1

	if n!=1:
		res.append(n)

	return res

def dumpsol(sol):
	for v in sol:
		print(v,end=' ')

n=int(sys.stdin.readline())
l=sys.stdin.readline().strip().split("" "")[0:n]
l=[int(x) for x in l]
print(""l: "", str(l))
if n<12:
	ret,sol=brute_force([],[],l,[])
	if ret:
		print(""YES"")
		dumpsol(sol)
	else:
		print(""NO"")
	return

factors={}
for i in range(10):
	for key in factor(l[i]):
		factors[key]=0

flists={}
for f in factors:
	flists[f]=[]
	pos=0
	found=False
	for v in l:
		if v%f!=0:
			found=True
			factors[f]+=1
			flists[f].append(pos)
			if (factors[f]>9):
				break
		pos+=1
	if not found:
		print(""NO"")
		return

oftf=[]
isoftf={}
for f in factors:
	if factors[f]==0:
		print(""NO"")
		return

	if factors[f]<10:
		oftf.append(f)
		isoftf[f]=1

sol=[1 for i in range(len(l))]
x=l[0]
sol[0]=2
oxf=factor(x)
xf=[]
nxf=0
isxoftf={}
for f in oxf:
	if f in isoftf:
		nxf+=1
		isxoftf[f]=1
		xf.append(f)
	else:
		sol[flists[f][0]]=2

nonxf=[]
for f in oftf:
	if not f in isxoftf:
		nonxf.append(f)

masks={}
pos=0

for f in xf+nonxf:
	for v in flists[f]:
		if not v in masks:
			masks[v]=0
		masks[v]|=1<<pos
	pos+=1

vals=[{} for i in range(len(masks)+1)]
vals[0][0]=0
pos=0
mlist=[]
for mask in masks:
	mlist.append(mask)
	cmask=masks[mask]
	cmask1=cmask<<10
	for v in vals[pos]:
		vals[pos+1][v|cmask]=v
		if (mask!=0):
			vals[pos+1][v|cmask1]=v
	pos+=1

test_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
for v in vals[pos]:
	if (v&test_val)==test_val:
		print(""YES"")
		while (pos!=0):
			nv=vals[pos][v]
			if (nv^v<1024 and nv^v!=0):
				sol[mlist[pos-1]]=2
			v=nv
			pos-=1
		dumpsol(sol)
		return

print(""NO"")
</ans>",0,{}
25,"<ans>
a, b, f, k = [int(i) for i in input().split()]
print(""a: "", str(a), ""b: "", str(b), ""f: "", str(f), ""k: "", str(k))

##tank = b
##journeys = 0
##refuels = 0
##current = 0
##while(journeys != k):
##    print(""current = %d, tank = %d, refuels = %d, journeys = %d"" % (current, tank, refuels, journeys))
##    if (tank // a >= k):
##        print(refuels)
##        return

##    if current == 0:
##        if tank >= a + (a-f):
##            tank -= a
##        elif tank >= f and b >= a-f:
##            refuels += 1
##            tank = b-(a-f)
##        else:
##            break

##        current = a

##    elif current == a:
##        if tank >= a + f:
##            tank -= a
##        elif tank >= a-f and b >= f:
##            refuels += 1
##            tank = b-f
##        else:
##            break

##        current = 0

##    journeys += 1

if b < f:
    print(-1)
    return

journeys = 0
previous = 0
refuels1 = 0
tank = b-f
print(""journeys: "", str(journeys), ""previous: "", str(previous), ""refuels1: "", str(refuels1), ""tank: "", str(tank))
while(journeys != k): ## necessary? while(True) ?
    if previous == 0:
        if tank >= a-f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= a-f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*(a-f):
            tank -= 2*(a-f)
        elif b >= 2*(a-f):
            refuels1 += 1
            tank = b - 2*(a-f)
        else:
            print(-1)
            return

        journeys += 1
        previous = a

    if previous == a:
        if tank >= f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*f:
            tank -= 2*f
        elif b >= 2*f:
            refuels1 += 1
            tank = b-2*f
        else:
            print(-1)
            return

        journeys += 1
        previous = 0

print(""journeys: "", str(journeys), ""previous: "", str(previous), ""refuels1: "", str(refuels1), ""tank: "", str(tank))

if journeys == k:
    print(refuels1)
else:
    print(-1)

##journeys = 0
##previous = 0
##refuels2 = 1
##tank = b
##cant2 = False
##while(journeys != k):
##    if previous == 0:
##        if tank >= a-f + a*(k-journeys-1):
##            break
##        if tank >= 2*(a-f):
##            tank -= 2*(a-f)
##        elif b >= 2*(a-f):
##            refuels2 += 1
##            tank = b - 2*(a-f)
##        else:
##            cant2 = True
##            break

##        journeys += 1
##        previous = a

##    if previous == a:
##        if tank >= f + a*(k-journeys-1):
##            break
##        if tank >= 2*f:
##            tank -= 2*f
##        elif b >= 2*f:
##            refuels2 += 1
##            tank = b-2*f
##        else:
##            cant2 = True
##            break

##        journeys += 1
##        previous = 0

##if cant1 and not cant2:
##    print(refuels2)
##elif not cant1 and cant2:
##    print(refuels1)
##elif cant1 and cant2:
##    print(-1)
##else:
##    print(min(refuels1, refuels2))
</ans>",0,{}
26,"<ans>
import heapq
n,m,k = list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
connectionList = []
for _ in range(n):
    connectionList.append([])
print(""connectionList: "", str(connectionList))
edgeList = []
for _ in range(m):
    x,y,w = list(map(int,input().split()))
    edgeList.append((x,y,w))
print(""edgeList: "", str(edgeList))
edgeList.sort(key = lambda x: x[2])
if k < m:
    maxDist = edgeList[min(m,k) - 1][2]
else:
    maxDist = sum([x[2] for x in edgeList])
print(""maxDist: "", str(maxDist))
colorList = {}
colorVertex = []
for i in range(n):
    colorList[i] = [i]
    colorVertex.append(i)
print(""colorList: "", str(colorList), ""colorVertex: "", str(colorVertex))

for i in range(min(m,k)):
    x,y,w = edgeList[i]
    connectionList[x-1].append((y-1,w))
    connectionList[y-1].append((x-1,w))
    if colorVertex[x-1] != colorVertex[y-1]:
        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):
            prevColor = colorVertex[y-1]
            for elem in colorList[colorVertex[y-1]]:
                colorVertex[elem] = colorVertex[x-1]
                colorList[colorVertex[x-1]].append(elem)
            del colorList[prevColor]
        else:
            prevColor = colorVertex[x-1]
            for elem in colorList[colorVertex[x-1]]:
                colorVertex[elem] = colorVertex[y-1]
                colorList[colorVertex[y-1]].append(elem)
            del colorList[prevColor]
print(""colorList: "", str(colorList), ""colorVertex: "", str(colorVertex))

pathList = []
for key in colorList:
    vertexList = colorList[key]
    for mainVertex in vertexList:
        vertexPQueue = []
        isCovered = {}
        distanceDic = {}
        for elem in vertexList:
            isCovered[elem] = False
            distanceDic[elem] = maxDist
        isCovered[mainVertex] = True
        for elem in connectionList[mainVertex]:
            heapq.heappush(vertexPQueue,(elem[1],elem[0]))
            distanceDic[elem[0]] = elem[1]
        while vertexPQueue:
            distance, curVertex = heapq.heappop(vertexPQueue)
            if isCovered[curVertex]:
                continue
            elif distance >= maxDist:
                break
            for elem in connectionList[curVertex]:
                if distance + elem[1] < distanceDic[elem[0]]:
                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))
                    distanceDic[elem[0]] = distance + elem[1]
        for key in distanceDic:
            if distanceDic[key] <= maxDist and key > mainVertex:
                pathList.append(distanceDic[key])
        if len(pathList) > k:
            pathList.sort()
            pathList = pathList[0:k]
            if pathList[-1] < maxDist:
                maxDist = pathList[-1]
print(""pathList: "", str(pathList))
pathList.sort()
print(""pathList[k-1]: "", str(pathList[k-1]))
</ans>",0,{}
27,"<ans>
class Ddict:
    def __init__(self):
        self.dicts={}
        print(""self.dicts: "", str(self.dicts))
    def add(self,key):
        d=self.dicts
        for i in key:
            if i not in d:
                d[i]={}
            d=d[i]
        d[' ']=''
    def find(self,key):
        if key=='':
            return '',''
        d=self.dicts
        q=[]
        h=[key[0]]
        for i in key:
            if i not in d:
                if ' ' in d and len(d)==1:
                    return ''.join(q),''.join(h)
                return '',''
            q.append(i)
            if len(d)!=1:
                h=q[:]
            d=d[i]
        if ' ' in d and len(d)==1:
            return ''.join(q),''.join(h)
        return '',''
words = Ddict()
print(""words: "", str(words))
ans=0
while True:
    try:
        x=input()
        if not x:
            break
    except:
        break
    ans+=len(x)+1
    ws=[[]]
    for i in x:
        if i in '.,?!\'- ':
            if ws[-1]:
                ws.append([])
        else:
            ws[-1].append(i)
    ws=list([''.join(e) for e in ws])
    for w in ws:
        next_word,helped_word = words.find(w)
        if next_word and next_word!=helped_word:
            ans-=len(next_word)-len(helped_word)-1
        words.add(w)
print(ans)
</ans>",0,{}
28,"<ans>
```
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
INF = float('inf')
from sys import stdin
readline = stdin.readline
def readInts():
  print(""readInts: "", str(readInts))
  return list(map(int,readline().split()))
def readTuples():
    print(""readTuples: "", str(readTuples))
    return tuple(map(int,readline().split()))
def I():
    print(""I: "", str(I))
    return int(readline())
n = I()
print(""n: "", str(n))
ans = 0
print(""ans: "", str(ans))
def dfs(v):
    if len(v) != 0:
        if int(v) > n:
            return
    if v.count('3') and v.count('5') and v.count('7'):
        nonlocal ans
        ans += 1
    for s in ""357"":
        v += s
        dfs(v)
        v = v[:-1]
dfs("""")
print(""ans: "", str(ans))
</ans>",0,{}
29,"<ans>
```
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
from itertools import accumulate

#T = int(input())
s = input()
#N,M,K,Q = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

def computeGCD(x, y):
    print(""x: "", str(x), ""y: "", str(y))
    while(y):
        x, y = y, x % y
    return x

record = {}
print(""record: "", str(record))

for x in range(10):
    for y in range(10):
        for d in range(10):
            m = 9999
            if (x==0 or y==0) and d==0:
                record[(x,y,d)] = 0
                print(""record[(x,y,d)]: "", str(record[(x,y,d)]))
            elif x==0 and y==0 and d!=0:
                record[(x,y,d)] = -1
                print(""record[(x,y,d)]: "", str(record[(x,y,d)]))
            else:
                for k in range(10):
                    d_tmp = d + 10*k
                    if x==0:
                        if d_tmp%y==0:
                            record[(x,y,d)] = d_tmp//y - 1
                            print(""record[(x,y,d)]: "", str(record[(x,y,d)]))
                            break

                    elif y==0:
                        if d_tmp%x==0:
                            record[(x,y,d)] = d_tmp//x - 1
                            print(""record[(x,y,d)]: "", str(record[(x,y,d)]))
                            break

                    else:
                        for a in range((d_tmp//x)+1):
                            for b in range((d_tmp//y)+1):
                                if x*a+y*b==d_tmp and d_tmp!=0:
                                    m = min(m,a+b-1)

                if (x,y,d) not in record:
                    if m==9999:
                        m = -1
                    record[(x,y,d)] = m
                    print(""record[(x,y,d)]: "", str(record[(x,y,d)]))

data = [[0]*10 for _ in range(10)]
print(""data: "", str(data))

len_s = len(s)
s = list(s)
freq = [0]*10
for i in range(len_s-1):
    A = s[i]
    B = s[i+1]

    d = ord(B)-ord(A)
    if d<0:
        d += 10

    freq[d] += 1

for x in range(10):
    for y in range(10):
        for d in range(10):
            if freq[d]==0:
                data[x][y] += 0
            elif record[(x,y,d)]==-1:
                data[x][y] = -10000000
            else:
                data[x][y] += freq[d]*record[(x,y,d)]
            print(""data[x][y]: "", str(data[x][y]))

for x in range(10):
    for y in range(10):
        if data[x][y]<0:
            print(-1,end=' ')
        else:
            print(data[x][y],end=' ')
    print('',end='\n')

```",0,{}
30,"<ans>
```
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import math

#T = int(input())
#N = int(input())
#print(N)
N, r = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

visited = [0]*N

a = [0]*N
b = [0]*N

pos = 0

for i in range(N):
    arr = [int(x) for x in stdin.readline().split()]
    a[i] = arr[0]
    b[i] = arr[1]

    if b[i]>=0:
        pos += 1

print(""N: "", str(N), ""r: "", str(r), ""visited: "", str(visited), ""a: "", str(a), ""b: "", str(b), ""pos: "", str(pos))

for i in range(pos):
    idx = -1
    start = 0
    gain = -50000
    for j in range(N):
        # find available and largest gain
        # if gain tie, find largest start r
        if visited[j]==1 or b[j]<0:
            continue

        if b[j]>gain and r>=a[j]:
            gain = b[j]
            idx = j
            start = a[j]
        elif b[j]==gain and r>=a[j]:
            if a[j]>start:
                idx = j
                start = a[j]

    if idx==-1:
        print('NO')
        quit()
    else:
        visited[idx] = 1
        r += b[idx]
        print(""idx: "", str(idx), ""r: "", str(r))

tmp = []
for i in range(N):
    if visited[i]==1 or b[i]>=0:
        continue
    tmp.append((a[i],b[i],i))

print(""tmp: "", str(tmp))

tmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)

for i in range(len(tmp)):
    require = tmp[i][0]
    bias = tmp[i][1]

    if r>=require:
        r += bias
    else:
        print('NO')
        quit()

if r<0:
    print('NO')
    quit()

print('YES')
```",0,{}
31,"<ans>
from math import*
from random import*

n = int(input()) * 2
print(""n: "", str(n))
A = list(map(int, input().split()))
print(""A: "", str(A))
amount = [0] * 101
print(""amount: "", str(amount))

B = []
for i in range(n):
    if amount[A[i]] < 2:
        amount[A[i]] += 1
        B += [(A[i], i)]
print(""B: "", str(B))
B.sort()
x, y = [], []
for i in range(len(B)):
    if(i % 2 == 0):
        x.append(B[i][1])
    else:
        y.append(B[i][1])
print(""x: "", str(x))
print(""y: "", str(y))
lolka = 0
aaa = 0
print(len(x) * len(y))
for i in range(n):
    if i in x:
        lolka += 1
        aaa += 1
        print(1, end = ' ')
    elif i in y:
        print(2, end = ' ')
    else:
        if len(x) - lolka + aaa < n // 2:
            print(1, end = ' ')
            aaa += 1
        else:
            print(2, end = ' ')
print()

# B, C = [], []
# for i in range(n):


# S = list(set(A))
# where = [0] * 101
# am1, am2 = 0, 0
# for i in range(len(S)):
#     if(i % 2 == 0):
#         where[S[i]] = 1
#         am1 += 1
#     else:
#         where[S[i]] = 2
#         am2 += 1
# used = [0] * 201
# for i in range(n):
#     if not used[A[i]]:
#         print(where[A[i]])
#         used[A[i]] = True
#     else:
#         print(3 - where[A[i]])
</ans>",0,{}
32,"<ans>
```
def check(mid):
    ans = []
    res = 0
    for c, count in d:
        tmp = count // mid
        if (count % mid != 0):
            tmp += 1
        ans.append((c, tmp))
        res += tmp
    print(""ans: "", str(ans))
    print(""res: "", str(res))
    return res <= n, ans

a = input()
n = int(input())
d = dict()
t = 0
for i in a:
    if i not in d:
        d[i] = 1
        t += 1
    else: d[i] += 1
print(""d: "", str(d))
print(""t: "", str(t))
ans = []
res = """"
for i in d:
    ans.append(i)
    res = i
if n >= len(a):
    print(1)
    print(a, end = '')
    n -= len(a)
    for u in range(n):
        print(res, end ='')
else:
    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))
    l = 1
    r = len(a)
    res = []
    count_res = 0
    while (l <= r):
        mid = (l + r) // 2
        flag, tmp = check(mid)
        print(""flag: "", str(flag))
        print(""tmp: "", str(tmp))
        if (flag):
            r = mid - 1
            count_res = mid
            res = tmp
        else:
            l = mid + 1
        #print(l, r, tmp)
    if (len(res) == 0):
        print(-1)
    else:
        ttt = 0
        print(""count_res: "", str(count_res))
        for c, sl in res:
            for j in range(sl):
                print(c, end = '')
                ttt += 1
        print(""ttt: "", str(ttt))
        n -= ttt
        for i in range(n):
            print(a[0], end = '')
</ans>",0,{}
33,"<ans>
""""""
Codeforces Contest Good Bye 2014 Contest Problem B

Author  : chaotic_iak
Language: Python 3.4.2
""""""

################################################### SOLUTION

def main():
    n, = read()
    print(""n: "", str(n))
    p = read()
    print(""p: "", str(p))
    dsu = DSU()
    print(""dsu: "", str(dsu))
    for i in range(n):
        a = read(0)
        print(""a: "", str(a))
        dsu.make()
        for j in range(i):
            if a[j] == ""1"":
                dsu.union(j, i)
    used = [0] * n
    print(""used: "", str(used))
    res = [0] * n
    print(""res: "", str(res))
    for i in range(n):
        if not used[i]:
            pr = dsu.find(i)
            print(""pr: "", str(pr))
            indices = []
            elements = []
            for j in range(n):
                if dsu.find(j) == pr:
                    used[j] = 1
                    indices.append(j)
                    elements.append(p[j])
            elements.sort()
            for i,e in zip(indices, elements):
                res[i] = e
    write(res)

#################################################### HELPERS

class DSU(object):
    """"""
    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.

    Methods:
    make(): add a new element and returns its index
    find(x): return representative of x
    union(x, y): merge the sets containing x and y

    Not to be used publicly:
    _parent: a list of ints for the parent of each vertex, used internally; call find instead
    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case
    __init__(): called when initialization, initialize DSU to be empty
    __str__(): return a readable string description of the DSU; meant to be printed while debugging
    """"""

    def __init__(self):
        self._parent = []
        self._rank = []
        print(""dsu._parent: "", str(self._parent))
        print(""dsu._rank: "", str(self._rank))

    def make(self):
        i = len(self._parent)
        self._parent.append(i)
        self._rank.append(0)
        print(""dsu._parent: "", str(self._parent))
        print(""dsu._rank: "", str(self._rank))
        return i

    def find(self, x):
        if self._parent[x] != x:
            self._parent[x] = self.find(self._parent[x])
        return self._parent[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        if xr == yr: return
        if self._rank[xr] < self._rank[yr]:
            self._parent[xr] = yr
        elif self._rank[yr] < self._rank[xr]:
            self._parent[yr] = xr
        else:
            self._parent[yr] = xr
            self._rank[xr] += 1
        print(""dsu._parent: "", str(self._parent))
        print(""dsu._rank: "", str(self._rank))

    def __str__(self):
        s = ""DSU\n""
        for i in range(len(self._parent)):
            s += str(i) + "" in set "" + str(self.find(i)) + "" with rank "" + str(self._rank[self.find(i)]) + ""\n""
        return s

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return list(map(int, inputs.split()))

def write(s=""\n""):
    if s is None: s = """"
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

write(main())
</ans>",0,{}
34,"<ans>
from math import log2, floor

def is_power2(num):
    print(""num: "", str(num))
    return num != 0 and ((num & (num - 1)) == 0)

def next_two_pow(val):
    print(""val: "", str(val))
    pw=0
    while 2**pw <= val:
        pw=+1
    return pw

n = int(input())
arr=[int(x) for x in input().split()]

win_idx =-1
selected=[]

for i in range(1,n+1):
    val = arr[i-1]
    if win_idx ==-1:
       if  val == -1:
           win_idx =i
    else:
         if is_power2(i):
             selected.append(val)
             selected.sort()
         else:
             if len(selected) > 0 and val < selected[-1]:
                 selected.pop()
                 selected.append(val)
                 selected.sort()

print(sum(selected))
</ans>",0,{}
35,"<ans>
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__

def go():
    n = int(input())
    print(""n: "", str(n))
    # n, h, l, r = map(int, input().split())
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    e = {i: set() for i in range(n)}
    print(""e: "", str(e))
    for _ in range(n - 1):
        u, v = list(map(int, input().split()))
        u, v = u - 1, v - 1
        e[u].add(v)
        e[v].add(u)
    ranks = [len(e[i]) for i in range(n)]
    print(""ranks: "", str(ranks))
    leafs = [i for i in range(n) if ranks[i] == 1]
    print(""leafs: "", str(leafs))
    index = 0
    vs = {i: {} for i in range(n)}
    print(""vs: "", str(vs))
    done = set()
    while index < len(leafs):
        cur = leafs[index]
        mysum = sum(vs[cur].values())

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        for i in e[cur] - done:
            vs[i][cur] = max(mysum, 0)
            ranks[i] -= 1
            if ranks[i] == 1:
                leafs.append(i)
        done.add(cur)
        index += 1

    sums = [0] * n
    print(""sums: "", str(sums))
    que = [ranks.index(0)]
    done = set()
    index = 0
    while index < len(que):
        cur = que[index]

        mysum = sum(vs[cur].values())

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        sums[cur] = mysum

        for i in e[cur] - done:
            vs[i][cur] = max(mysum - vs[cur][i], 0)
            que.append(i)

        done.add(cur)
        index += 1

    return ' '.join(map(str,sums))

# t = int(input())
for _ in range(1):
    print(go())

</ans>",0,{}
36,"<ans>
```
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
INF = float('inf')
from sys import stdin
readline = stdin.readline
def readInts():
  print(""readInts: "", str(readInts))
  return list(map(int,readline().split()))
def readTuples():
    print(""readTuples: "", str(readTuples))
    return tuple(map(int,readline().split()))
def I():
    print(""I: "", str(I))
    return int(readline())
n = I()
A = readInts()
print(""A: "", str(A))
B = readInts()
print(""B: "", str(B))
ans = 0
for i in range(n):
    v = B[i]
    print(""v: "", str(v))
    # kill = A[i] + A[i+1]
    nya = min(v, A[i])
    print(""nya: "", str(nya))
    A[i] -= nya
    print(""A[i]: "", str(A[i]))
    v -= nya
    print(""v: "", str(v))
    ans += nya
    print(""ans: "", str(ans))
    nya = min(A[i+1], v)
    print(""nya: "", str(nya))
    ans += nya
    print(""ans: "", str(ans))
    A[i+1] -= nya
    print(""A[i+1]: "", str(A[i+1]))
print(ans)
</ans>",0,{}
37,"<ans>
def solve(s,t):
    hash_s = [False] * 256
    print(""hash_s: "", str(hash_s))
    hash_t = [False] * 256
    print(""hash_t: "", str(hash_t))
    arr = []
    print(""arr: "", str(arr))
    n = len(s)
    print(""n: "", str(n))
    for c in s:
        hash_s[ord(c)] = True
    for c in t:
        hash_t[ord(c)] = True
    for i in range(256):
        if not hash_s[i] and hash_t[i]:
            print(-1)
            return
    rev = s[::-1]
    print(""rev: "", str(rev))
    i,j = 0,0
    while i < len(t):
        flag = True
        temp = t[i]
        j = i + 1
        while j < len(t):
            temp += t[j]
            if temp not in s and temp not in rev:
                flag = False
                break
            j += 1
        if flag:
            x = s.find(temp)
            if x != -1:
                arr.append((x + 1,x + len(temp)))
                print('1',x + 1,x + len(temp))
            else:
                y = rev.find(temp)
                arr.append((n - y,n - y - len(temp) + 1))
                print('2',n - y,n - y - len(temp) + 1)
        else:
            x = s.find(temp[:-1])
            if x != -1:
                arr.append((x + 1,x + len(temp) - 1))
                print('3',x + 1,x + len(temp) - 1)
            else:
                x = rev.find(temp[:-1])
                arr.append((n - x,n - x - len(temp) + 2))
                print('4',n - x,n - x - len(temp) + 2)
        i = j
    print(""arr: "", str(arr))
    print(len(arr))
    for x,y in arr:
        print(x,y)

s = input()
print(""s: "", s)
t = input()
print(""t: "", t)

solve(s,t)

</ans>",0,{}
38,"<ans>
from itertools import chain
import sys

def main():
    N = int(input())
    # TLEs were caused mostly by slow input (1s+)
    # S = list(input() for _ in range(N))
    S = sys.stdin.read().split('\n')
    print(""S: "", str(S))
    print((solve(S)))

def get_count(args):
    s, result = args # messy input to work with map.
    cum_sum = 0
    for c in s:
        if c == ')':
            cum_sum -= 1
        else:
            cum_sum += 1
        result[0] = max(result[0], -cum_sum)
    result[1] = result[0] + cum_sum
    return result

# Made-up name, don't remember what to call this. Radix-ish
def silly_sort(array, value_min, value_max, get_value):
    if len(array) == 0:
        return
    cache = [None for _ in range(value_max - value_min + 1)]
    for elem in array:
        # Assume elem[0] is the value
        value = get_value(elem) - value_min
        if cache[value] is None:
            cache[value] = []
        cache[value].append(elem)
    for values in cache:
        if values is None:
            continue
        for value in values:
            yield value

def solve(S):
    counts = [[0,0] for _ in range(len(S))]
    print(""counts: "", str(counts))
    counts = list(map(get_count, list(zip(S,counts))))
    print(""counts after get_count: "", str(counts))
    first_group = []
    second_group = []
    min_first_group = float('inf')
    max_first_group = 0
    min_second_group = float('inf')
    max_second_group = 0

    for c in counts:
        if c[0] - c[1] <= 0:
            first_group.append(c)
            max_first_group = max(max_first_group, c[0])
            min_first_group = min(min_first_group, c[0])
        else:
            second_group.append(c)
            max_second_group = max(max_second_group, c[1])
            min_second_group = min(min_second_group, c[1])
    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])
    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))

    order = chain(first_group, second_group)

    cum_sum = 0
    for c in order:
        cum_sum -= c[0]
        if cum_sum < 0:
            return 'No'
        cum_sum += c[1]
    if cum_sum == 0:
        return 'Yes'
    return 'No'

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
39,"<ans>
import math
from functools import reduce
class SegmentTree():
    def __init__(self, L, function = lambda x,y: x+y):
        self.function = function
        N = self.size = len(L)
        M = 1 << N.bit_length()
        self.margin = 2*M - N
        self.L = [None for i in range(self.margin)] + L
        for i in range(M-1, 0, -1):
            x, y = self.L[i<<1], self.L[i<<1|1]
            self.L[i] = None if x is None or y is None else function(x, y)
    def modify(self, pos, value):
        p = pos + self.margin
        self.L[p] = value
        print(""L["", p, ""]: "", str(self.L[p]))
        while p > 1:
            x, y = self.L[p], self.L[p^1]
            if p&1: x, y = y, x
            self.L[p>>1] = None if x is None or y is None else self.function(x, y)
            print(""L["", p>>1, ""]: "", str(self.L[p>>1]))
            p>>=1
    def query(self, left, right):
        l, r = left + self.margin, right + self.margin
        stack = []
        void = True
        while l < r:
            if l&1:
                if void:
                    result = self.L[l]
                    void = False
                else:
                    result = self.function(result, self.L[l])
                l+=1
            if r&1:
                r-=1
                stack.append(self.L[r])
            l>>=1
            r>>=1
        init = stack.pop() if void else result
        return reduce(self.function, reversed(stack), init)

n = int(input())
pies, index, first_equal = [0]*n, [0]*n, [0]*n
for i in range(n):
    r, h = [int(x) for x in input().split()]
    pies[i] = r*r*h
print(""pies: "", str(pies))
s_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))
for i in range(n): index[s_pies[i][0]] = i
for i in range(1, n):
    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]
towers = SegmentTree([0]*(n+1), max)
for j, pie in enumerate(pies):
    i, k = index[j], first_equal[j]
    q = towers.query(0, k+1)
    towers.modify(i+1, q + pie)
print(""towers.query(0, n+1): "", str(math.pi * towers.query(0, n+1)))

</ans>",0,{}
40,"<ans>
# returns answer to the subproblem with interval range [start, end],
# but with a total of ""extra"" additional stuff on the end
# that must be deleted last.
memo = {}
def f(dat, rewards, start, end, extra):
    curr = (start, end, extra)
    print(""curr: "", str(curr))
    if curr in memo:
        return memo[curr]

    if start > end:
        return 0
    if start == end:
        print(""rewards[dat[start] + extra]: "", str(rewards[dat[start] + extra]))
        memo[curr] = rewards[dat[start] + extra]
        return memo[curr]

    # test all possible ""cut points"".
    # ""cut"" is the earliest index to die in the same deletion as ""end"".
    out = 0
    for cut in range(end, start-1, -2):
        if cut == end:
            # in this case, we're deleting the last interval right away.
            print(""out_curr: "", str(rewards[dat[cut] + extra]))
            out_curr = rewards[dat[cut] + extra]
            out_curr += f(dat, rewards, start, cut-1, 0)
        else:
            # split into 2 pieces:
            # 1) slots [start, cut] plus [end + extra]
            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).
            print(""f(dat, rewards, start, cut, extra + dat[end]): "", str(f(dat, rewards, start, cut, extra + dat[end])))
            print(""f(dat, rewards, cut+1, end-1, 0): "", str(f(dat, rewards, cut+1, end-1, 0)))
            out_curr = f(dat, rewards, start, cut, extra + dat[end])
            out_curr += f(dat, rewards, cut+1, end-1, 0)

        out = max(out, out_curr)

    memo[curr] = out
    return memo[curr]

def solve(dat_str, rewards_orig):
    # break into intervals.
    dat = []
    pos = 0
    while pos < len(dat_str):
        end = pos
        while end < len(dat_str) and dat_str[pos] == dat_str[end]:
            end += 1

        dat.append(end - pos)
        pos = end

    # compute the highest-value way to remove a run of size k.
    # (google translated from C++ thinking)
    rewards = [0, rewards_orig[0]]
    for k in range(2, len(rewards_orig) + 1):
        print(""k: "", str(k))
        print(""rewards[k-j] + rewards_orig[j-1]: "", str([rewards[k-j] + rewards_orig[j-1] for j in range(1, k+1)]))
        rewards.append(
            max(
                rewards[k-j] + rewards_orig[j-1]
                for j in range(1, k+1)
            )
        )

    print(""dat: "", str(dat))
    print(""rewards: "", str(rewards))

    return f(dat, rewards, 0, len(dat)-1, 0)

# get the integer
int_dummy = input()
# get the string
dat_str = input().strip()
# get the array
rewards_input = input().strip().split()
rewards_ints = [int(x) for x in rewards_input]

print((
    solve(
        dat_str,
        rewards_ints,
    )
))

# dat_test = ""10101""
# rewards_test = [3, 10, 15, 15, 15]
# print(solve(dat_test, rewards_test))

</ans>",0,{}
41,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

class RAQ_RMQ():
    def __init__(self, n, inf=2**31-1):
        self.n0 = 1<<(n-1).bit_length()
        print(""self.n0: "", str(self.n0))
        self.INF = inf
        print(""self.INF: "", str(self.INF))
        self.data = [0]*(2*self.n0)
        print(""self.data: "", str(self.data))
        self.lazy = [0]*(2*self.n0)
        print(""self.lazy: "", str(self.lazy))

    def getIndex(self, l, r):
        l += self.n0; r += self.n0
        lm = (l // (l & -l)) >> 1
        rm = (r // (r & -r)) >> 1
        while l < r:
            if r <= rm:
                yield r
            if l <= lm:
                yield l
            l >>= 1; r >>= 1
        while l:
            yield l
            l >>= 1

    def propagates(self, *ids):
        for i in reversed(ids):
            v = self.lazy[i-1]
            if not v:
                continue
            self.lazy[2*i-1] += v; self.lazy[2*i] += v
            self.data[2*i-1] += v; self.data[2*i] += v
            self.lazy[i-1] = 0

    def update(self, l, r, x):
        *ids, = self.getIndex(l, r)

        l += self.n0; r += self.n0
        while l < r:
            if r & 1:
                r -= 1
                self.lazy[r-1] += x; self.data[r-1] += x
            if l & 1:
                self.lazy[l-1] += x; self.data[l-1] += x
                l += 1
            l >>= 1; r >>= 1
        for i in ids:
            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]

    def query(self, l, r):
        self.propagates(*self.getIndex(l, r))
        l += self.n0; r += self.n0

        s = self.INF
        while l < r:
            if r & 1:
                r -= 1
                s = min(s, self.data[r-1])
            if l & 1:
                s = min(s, self.data[l-1])
                l += 1
            l >>= 1; r >>= 1
        return s

n,m,k = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
l = [0]*(n+1)
print(""l: "", str(l))
now = k
point = [0]*n
print(""point: "", str(point))
for i in range(n):
    a,b,c = map(int, input().split())
    point[i] = c
    now = now-a
    l[i] = now
    now += b+a
l[n] = now

RMQ = RAQ_RMQ(n+1)
for i in range(n+1):
    RMQ.update(i,i+1,l[i])

portal = list(range(n))
print(""portal: "", str(portal))
for i in range(m):
    u,v = map(int, input().split())
    u,v = u-1, v-1
    if portal[v]<u:
        portal[v] = u

if RMQ.query(0, n+1) < 0:
    print(-1)
    return

heap = [(-point[i], -portal[i]) for i in range(n)]
print(""heap: "", str(heap))
from heapq import heapify, heappop
heapify(heap)

ans = 0
while heap:
    p,i = heappop(heap)
    p,i = -p,-i
    if RMQ.query(i+1, n+1)>0:
        ans += p
        RMQ.update(i+1, n+1, -1)

print(ans)
</ans>",0,{}
42,"<ans>
import sys
from collections import deque

t=1
print(""t: "", str(t))
for _ in range(int(input())):
    n=int(input())
    print(""n: "", str(n))
    val=set([0,2*10**5+1])
    print(""val: "", str(val))
    seg=[(0,2*10**5+1)]
    print(""seg: "", str(seg))
    for i in range(n):
        l,r=map(int,input().split())
        print(""l: "", str(l), ""r: "", str(r))
        val.add(l)
        val.add(r)
        seg.append((l,r))
    val=list(val)
    val.sort()
    print(""val: "", str(val))
    comp={i:e+1 for e,i in enumerate(val)}
    print(""comp: "", str(comp))
    for i in range(n+1):
        l,r=seg[i]
        print(""l: "", str(l), ""r: "", str(r))
        seg[i]=(comp[l],comp[r])
    print(""seg: "", str(seg))

    deg=[0]*(n+1)
    print(""deg: "", str(deg))
    out=[[] for i in range(n+1)]
    print(""out: "", str(out))
    for i in range(n+1):
        for j in range(i+1,n+1):
            l,r=seg[i]
            print(""l: "", str(l), ""r: "", str(r))
            L,R=seg[j]
            print(""L: "", str(L), ""R: "", str(R))
            if L<=l and r<=R:
                out[j].append(i)
                deg[i]+=1
            elif l<=L and R<=r:
                out[i].append(j)
                deg[j]+=1

    ans=[0]
    print(""ans: "", str(ans))
    deq=deque(ans)
    print(""deq: "", str(deq))

    while deq:
        v=deq.popleft()
        print(""v: "", str(v))
        for nv in out[v]:
            print(""nv: "", str(nv))
            deg[nv]-=1
            if deg[nv]==0:
                deq.append(nv)
                ans.append(nv)

    dp=[0]*(n+1)
    print(""dp: "", str(dp))

    def solve(v):
        query=[[] for i in range(2*n+3)]
        for nv in out[v]:l,r=seg[nv];query[r].append((l,dp[nv]))
        subdp=[0]*(2*n+3)
        for i in range(1,2*n+3):
            res=subdp[i-1]
            for l,val in query[i]:test=subdp[l-1]+val;res=max(test,res)
            subdp[i]=res

        dp[v]=subdp[-1]+1

    for v in ans[::-1]:solve(v)

    print(dp[0]-1)
</ans>",0,{}
43,"<ans>
n=int(input())
print(""n: "", str(n))
arr=list(map(int,input().split()))
print(""arr: "", str(arr))
dict1={}
print(""dict1: "", str(dict1))
for i in range(2*n):
	try:
		dict1[arr[i]].append(i+1)
		dict1[arr[i]].sort()
	except KeyError:
		dict1[arr[i]]=[i+1]
print(""dict1: "", str(dict1))
ans=0
print(""ans: "", str(ans))
curr1=1
print(""curr1: "", str(curr1))
curr2=1
print(""curr2: "", str(curr2))
for i in range(1,n+1):
	# ... (rest of the code)
</ans>",0,{}
44,"<ans>
def gcd(a,b):
    while b:
        a, b = b, a%b
    return a

n = int(input())
P = [[int(x) for x in input().split()] for _ in range(n)]

L = []
print(""L: "", str(L))
def addLine(x,y,dx,dy):
    if dx < 0:
        dx *= -1
        dy *= -1
    elif dx == 0:
        if dy < 0:
            dy *= -1
    g = gcd(dx,dy)
    dx //= g
    dy //= g

    x += dx * (10**9)
    y += dy * (10**9)
    if dx:
        k = x//dx
    else:
        k = y//dy
    x -= k*dx
    y -= k*dy
    L.append((x,y,dx,dy))

for i in range(n):
    for j in range(i+1,n):
        xi,yi = P[i]
        xj,yj = P[j]
        dx,dy = xi-xj,yi-yj
        addLine(xi,yi,dx,dy)

from collections import defaultdict as dd, deque

L = list(set(L))
print(""L: "", str(L))
res = 0

C = dd(int)
print(""C: "", str(C))
for x,y,dx,dy in L:
    C[dx,dy] += 1

ss = sum(C.values())
print(""ss: "", str(ss))

for x in C.values():
    res += (ss-x)*x

print(""res: "", str(res))

print(res//2)
</ans>",0,{}
45,"<ans>
import sys
input = sys.stdin.readline

n, m = list(map(int, input().split()))
print(""n: "", str(n), ""m: "", str(m))
A = [list(map(int, input().split())) for i in range(n)]
print(""A: "", str(A))

for i in range(m):
    ANSR = [0] * n
    print(""ANSR: "", str(ANSR))
    ANSC = [0] * m
    print(""ANSC: "", str(ANSC))

    # ... rest of the code ...

    ANSR = [0] * n
    print(""ANSR: "", str(ANSR))
    ANSC = [0] * m
    print(""ANSC: "", str(ANSC))

    flag = 0
    print(""flag: "", str(flag))

    # ... rest of the code ...

    print(""NO"")

</ans>",0,{}
46,"<ans>
""""""Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I""""""
# from fractions import Fraction

# def convert_to_fractions(poly):
#     """"""convert polygon vertex to fractional type""""""
#     poly_frac = []
#     for x, y, z in poly:
#         vertex = (Fraction(x),
#                   Fraction(y),
#                   Fraction(z))
#         poly_frac.append(vertex)
#     return poly_frac

def convert_to_float(poly):
    """"""convert polygon vertex to float type""""""
    poly_float = []
    for x, y, z in poly:
        vertex = (float(x),
                  float(y),
                  float(z))
        poly_float.append(vertex)
    return poly_float

def cross_product(a, b):
    """"""3-vector product""""""
    return (a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0])

def dot_product(a, b):
    """"""scalar product of 3-vectors""""""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]

def vect_diff(a, b):
    """"""vector difference""""""
    return a[0] - b[0], a[1] - b[1], a[2] - b[2]

def poly_normal(poly):
    """"""return normal vector for first three vertex""""""
    assert len(poly) >= 3
    x, y, z = poly[:3]
    u = vect_diff(y, x)
    v = vect_diff(z, y)
    return cross_product(u, v)

def intersect_list(poly, plain_norm, plain_point, proj_dir):
    """"""list of intersection points

    find points where the edges enter or leave upper half-space over the plain
    :return list of points projection on proj_dir
    """"""
    # vertex projection
    u = [dot_product(vert, proj_dir) for vert in poly]
    print(""u: "", str(u))

    # plain anchor
    vr = dot_product(plain_point, plain_norm)

    # polygon vertex
    v = [dot_product(vert, plain_norm) for vert in poly]
    print(""v: "", str(v))

    u_list = []
    for i in range(len(poly)):
        if (v[i-1] > vr) != (v[i] > vr):
            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])
            u_list.append(ur)

    return u_list

def points_to_str(a_points, b_points):
    """"""string representing the order of points 'a' and 'b'""""""
    a_pairs = [('a', val) for val in a_points]
    b_pairs = [('b', val) for val in b_points]
    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])
    letters = [ch for ch, _ in pairs]
    return ''.join(letters)

def recognize_str(s):
    """"""return True if string s belong to the grammar

    The context-free grammar is given
    S -> SS
    S -> a S a
    S -> b S b
    S -> e

    The recognising automaton is implemented
    """"""
    toggle = {'a':'b', 'b':'a'}
    cross_num = 0
    top = None
    for ch in s:
        if not cross_num:
            cross_num = 1
            top = ch
            continue

        if ch == top:
            cross_num -= 1
        else:
            cross_num += 1

        if cross_num:
            top = toggle[top]
        else:
            top = None
    return not cross_num

def is_well_connected(a, b):
    """"""Two planar polygons are bind together in 3D

    Arguments:
        a_poly,
        b_poly -- lists of vertex triples
    """"""
    a = convert_to_float(a)
    print(""a: "", str(a))
    b = convert_to_float(b)
    print(""b: "", str(b))

    a_norm = poly_normal(a)
    print(""a_norm: "", str(a_norm))
    b_norm = poly_normal(b)
    print(""b_norm: "", str(b_norm))

    common_dir = cross_product(a_norm, b_norm)
    print(""common_dir: "", str(common_dir))
    if not any(common_dir):
        return False

    a_list = intersect_list(a, b_norm, b[0], common_dir)
    print(""a_list: "", str(a_list))
    b_list = intersect_list(b, a_norm, a[0], common_dir)
    print(""b_list: "", str(b_list))

    char_str = points_to_str(a_list, b_list)
    return not recognize_str(char_str)

def run_from_console():
    a_len, = [int(num) for num in input().split()]

    a = []
    for _ in range(a_len):
        vertex = tuple(int(num) for num in input().split())
        a.append(vertex)

    b_len, = [int(num) for num in input().split()]

    b = []
    for _ in range(b_len):
        vertex = tuple(int(num) for num in input().split())
        b.append(vertex)

    if is_well_connected(a, b):
        print('YES')
    else:
        print('NO')

def __starting_point():
    run_from_console()
__starting_point()
</ans>",0,{}
47,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    print(""n: "", str(n))
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    print(""r: "", str(r))
    return r
def divs(n, start=2):
    print(""n: "", str(n))
    print(""start: "", str(start))
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    print(""r: "", str(r))
    return r
def divn(n, primes):
    print(""n: "", str(n))
    print(""primes: "", str(primes))
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
    print(""divs_number: "", str(divs_number))
    return divs_number
def prime(n):
    print(""n: "", str(n))
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    print(""sqr: "", str(sqr))
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    print(""d: "", str(d))
    return True
def convn(number, base):
    print(""number: "", str(number))
    print(""base: "", str(base))
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    print(""newnumber: "", str(newnumber))
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

for _ in range(ii()):
    n = ii()
    a = li()
    if n == 1 and a[0] & 1:
        print(-1)
    else:
        for i in range(n):
            if a[i] % 2 == 0:
                print(1)
                print(i + 1)
                break
        else:
            print(2)
            print(1, 2)

</ans>",0,{}
48,"<ans>
n, k = list(map(int, input().split()))
print(""n: "", str(n), ""k: "", str(k))
p  = {}
np = {}
pair    = []
used    = {}
rev_d   = {}

def push(d, s, v):
    if s not in d:
        d[s] = []
    d[s].append(v)

def is_pal(s):
    n = len(s)
    flg=True
    for i in range(n//2):
        if s[i] != s[n-1-i]:
            flg = False
            break
    return flg

def rev(s):
    return s[::-1]

for _ in range(n):
    s, val = input().split()
    val    = int(val)

    if is_pal(s):
        push(p, s, val)
    else:
        push(np, s, val)

        if s not in rev_d:
            rev_d[s] = rev(s)

for k, v in list(p.items()):
    p[k] = sorted(v, reverse=True)

for k, v in list(np.items()):
    np[k] = sorted(v, reverse=True)

for s in np:
    if s not in used and rev_d[s] in np:
        pair.append([s, rev_d[s]])
        used[s] = True
        used[rev_d[s]] = True

max_remain = 0
minus = 0
max_S = 0

for v_arr in list(p.values()):
    n = len(v_arr)
    for i in range(0, n, 2):
        if i+1==n:
            if v_arr[i] > 0:
                max_remain = max(max_remain, v_arr[i])
        else:
            if v_arr[i] + v_arr[i+1] >= 0:
                max_S += v_arr[i] + v_arr[i+1]

                if v_arr[i+1] < 0:
                    minus = min(minus, v_arr[i+1])
            else:
                if v_arr[i] > 0:
                    max_remain = max(max_remain, v_arr[i])

for [u, v] in pair:
    n = min(len(np[u]), len(np[v]))

    for x, y in  zip(np[u][:n], np[v][:n]):
        if x+y > 0:
            max_S += x+y

print(max(max_S+max_remain, max_S-minus))
</ans>",0,{}
49,"<ans>
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    q = a//k
    r = (a-q*k)%(q+1)
    if r==0:
        return a//k
    v = (a-q*k)//(q+1) + 1
    #print(a,k,q,v)
    return grundy(a-(q+1)*v,k)
""""""

""""""
K = 10
N = 50
V = 5
for k in range(V,V+1):
    a = [0]*N
    for i in range(1,N):
        s = set()
        for j in range(1,1+i//k):
            s.add(a[i-j])
        for j in range(N):
            if j not in s:
                a[i] = j
                break
    print(""a: "", str(a))
    b = [grundy(i,k) for i in range(N)]
    print(""b: "", str(b))
    assert a==b
""""""

# coding: utf-8
# Your code here!
import sys
readline = sys.stdin.readline
read = sys.stdin.read
sys.setrecursionlimit(10**8)

n, = list(map(int,readline().split()))
print(""n: "", str(n))
g = 0
for _ in range(n):
    a,k = list(map(int,readline().split()))
    print(""a: "", str(a), ""k: "", str(k))
    g ^= grundy(a,k)
if g:
    print(""Takahashi"")
else:
    print(""Aoki"")

</ans>",0,{}
50,"<ans>
```
a = input()
print(""a: "", str(a))
ans=[]
print(""ans: "", str(ans))
t=''
print(""t: "", str(t))
qoute =0
print(""qoute: "", str(qoute))
space =0
print(""space: "", str(space))
start =1 if a[0]=='""' else 0
print(""start: "", str(start))
for i in range(len(a)):
    v= a[i]
    if start:
        if t=='':
            if v=='""':
                qoute+=1
                t = '<'
            elif v==' ':
                pass
            else:
                space+=1
                t='<'+v
        elif qoute>0:
            if v =='""':
                t+='>'
                qoute=0
                ans.append(t)
                t=''
                start=0
            else:
                t+=v
        else:
            if v ==' ':
                if t!='<':
                    t+='>'
                    ans.append(t)
                    t=''
                    start=0
            else:
                t+=v
    else:
        if v==' ':
            start=1
        elif v=='""':
            start=1
            t='<'
            qoute=1
        else:
            t='<'+v
            start=1
if t!='':
    t+='>'
    ans.append(t)
for v in ans:
    print(v)
```
</ans>",0,{}
51,"<ans>
def main1():
    buf = input()
    buflist = buf.split()
    print(""n: "", str(n))
    print(""M: "", str(M))
    buf = input()
    buflist = buf.split()
    print(""t: "", str(t))
    student = []
    minimum = []
    for i in range(n):
        count = 0
        pointer = 0
        while pointer < i:
            if count + student[pointer] <= M - t[i]:
                count += student[pointer]
                pointer += 1
            else:
                break
        minimum.append(i - pointer)
        student.append(t[i])
        student.sort()
    print(' '.join(list(map(str, minimum))))

def main2():
    buf = input()
    buflist = buf.split()
    print(""n: "", str(n))
    print(""M: "", str(M))
    buf = input()
    buflist = buf.split()
    print(""t: "", str(t))
    bucket = []
    for i in range(101):
        bucket.append(0)
    minimum = []
    for i in range(n):
        target = M - t[i]
        count = 0
        subtotal = 0
        for j in range(1, 101):
            if subtotal + bucket[j] * j > target:
                count += (target - subtotal) // j
                break
            else:
                count += bucket[j]
                subtotal += bucket[j] * j
        minimum.append(i - count)
        bucket[t[i]] += 1
    print(' '.join(list(map(str, minimum))))

def __starting_point():
    #main1() # for C1
    main2() # for C2

__starting_point()
</ans>",0,{}
52,"<ans>
import itertools
from collections import deque,defaultdict,Counter
from itertools import accumulate
import bisect
from heapq import heappop,heappush,heapify
import math
from copy import deepcopy
import queue
#import numpy as np
# sympy as syp(素因数分解とか)
Mod = 1000000007
print(""Mod: "", str(Mod))
fact = [1, 1]
print(""fact: "", str(fact))
factinv = [1, 1]
print(""factinv: "", str(factinv))
inv = [0, 1]
print(""inv: "", str(inv))
for i in range(2, 10**5 + 1):
    fact.append((fact[-1] * i) % Mod)
    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)
    factinv.append((factinv[-1] * inv[-1]) % Mod)

def cmb(n, r, p):
    if (r < 0) or (n < r):
        return 0
    r = min(r, n - r)
    return fact[n] * factinv[r] * factinv[n - r] % p

def sieve_of_eratosthenes(n):
    if not isinstance(n,int):
        raise TypeError(""n is not int"")
    if n<2:
        raise ValueError(""n is not effective"")
    prime = [1]*(n+1)
    for i in range(2,int(math.sqrt(n))+1):
        if prime[i] == 1:
            for j in range(2*i,n+1):
                if j%i == 0:
                    prime[j] = 0
    res = []
    for i in range(2,n+1):
        if prime[i] == 1:
            res.append(i)
    return res

class UnionFind:
    def __init__(self,n):
        self.parent = [i for i in range(n+1)]
        self.rank = [0 for i in range(n+1)]
        print(""parent: "", str(self.parent))
        print(""rank: "", str(self.rank))

    def findroot(self,x):
        if x == self.parent[x]:
            return x
        else:
            y = self.parent[x]
            y = self.findroot(self.parent[x])
            return y

    def union(self,x,y):
        px = self.findroot(x)
        py = self.findroot(y)
        if px < py:
            self.parent[y] = px
        else:
            self.parent[px] = py

    def same_group_or_no(self,x,y):
        return self.findroot(x) == self.findroot(y)

def pow_k(x, n):
    if n == 0:
        return 1
    K = 1
    while n > 1:
        if n % 2 != 0:
            K *= x
        x *= x
        n //= 2
    return K * x

def main():  #startline-------------------------------------------
    n = int(input())
    print(""n: "", str(n))
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    d = defaultdict(int)
    print(""d: "", str(d))
    ans = 0
    for i in range(n):
        l = i - a[i]
        ans += d[l]
        d[a[i] + i] += 1
    print(""ans: "", str(ans))

def __starting_point():
    main() #endline===============================================
__starting_point()
</ans>",0,{}
53,"<ans>
```python
#template
import sys
sys.setrecursionlimit(10**9)

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

read_int = lambda: int(readline())
read_ints = lambda: map(int,readline().split())
read_ints_list = lambda: list(map(int,readline().split()))
read_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))
read_strs_list = lambda: list(map(str,readline().rstrip().split()))
read_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))

def read_allints_grid(w):
    grid = map(int,read().split())
    grid = list(map(list,zip(*(grid for _ in range(w)))))
    return grid

def read_allstrs_grid(w):
    grid = map(str,read().split())
    grid = list(map(list,zip(*(grid for _ in range(w)))))
    return grid

#import
# from copy import deepcopy
# from decimal import Decimal
# from math import ceil,floor
# from collections import deque,Counter
# from heapq import heapify,heappop,heappush
# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement
# from bisect import bisect_left,bisect_right

#solution
def sol():
    return None

def GCD(a:int,b:int)->int:
    print(""a: "", str(a), ""b: "", str(b))
    '''
    ユークリッドの互除法による最大公約数/O(log min(a,b))
    '''
    if b==0:
        return a
    else:
        return GCD(b,a%b)

def GCD_multi(vec:list)->int:
    print(""vec: "", str(vec))
    '''
    数列の要素の最大公約数を求める/O(N log(a'))
    '''
    l = vec[0]
    for i in range(len(vec)-1):
        l = GCD(l,vec[i+1])
    return l

def main():
    #input data
    print(""n: "", str(n))
    n = read_int()
    print(""A: "", str(A))
    A = read_ints_list()

    #solve
    print(GCD_multi(A))

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
54,"<ans>
__author__ = ""Ryabchun Vladimir""

class Stack:
    """"""
    This is a stack class. There is 5 Procedures we can do with stack:
    1. Push - we add one element at the end of the stack
    2. Pop - we remove last element from the stack and return it
    3. Last - We return last element but don't remove it
    4. len() - returns the length of stack(we don't use len() because it's too
    slow).
    5. Clear - remove all elements from stack
    """"""
    def __init__(self, element=None):
        """"""
        self.length - length of the stack. When we append an element we increase it(length) by 1
        __stack - this is our stack. Because we can't get any elements from the stack except the last one
        we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,
        but we mustn't do it).
        :param element: Can be any type
        """"""
        self.length = 0
        print(""self.length: "", str(self.length))
        if element is None:
            self.__stack = []
            print(""self.__stack: "", str(self.__stack))
        else:
            self.__stack = []
            print(""self.__stack: "", str(self.__stack))
            for el in element:
                self.__stack.append(el)
                print(""self.__stack: "", str(self.__stack))
                self.length += 1
            print(""self.length: "", str(self.length))

    def push(self, element):
        """"""
        This function adds an element at the end of the stack.
        When we append an element we increase self.length by 1.
        :param element: Can be any type
        :return: NoneType
        """"""
        self.__stack.append(element)
        print(""self.__stack: "", str(self.__stack))
        self.length += 1
        print(""self.length: "", str(self.length))
        return None

    def pop(self):
        """"""
        This function removes an element from the end of the stack and
        returns it's value.
        When we append an element we decrease self.length by 1.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            self.length -= 1
            print(""self.length: "", str(self.length))
            return self.__stack.pop()
            print(""self.__stack: "", str(self.__stack))

    def last(self):
        """"""
        This function just returns an element from the end of the stack
        but it doesn't remove it.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            return self.__stack[-1]
            print(""self.__stack: "", str(self.__stack))

    def __len__(self):
        """"""
        This function returns the length of the stack.
        :return: self.length(int)
        """"""
        return self.length
        print(""self.length: "", str(self.length))

    def clear(self):
        """"""
        Clears the stack.
        :return: NoneType
        """"""
        self.__stack = []
        print(""self.__stack: "", str(self.__stack))
        return None

n = int(input())
snekovik = Stack()
wrong_snaks = set()
the_biggest_snek = n
sneks = list(map(int, input().split()))
for i in sneks:
    printing = []
    if i == the_biggest_snek:
        snekovik.push(i)
        printing.append(i)
        the_biggest_snek -= 1
        while the_biggest_snek in wrong_snaks:
            snekovik.push(the_biggest_snek)
            wrong_snaks.remove(the_biggest_snek)
            printing.append(the_biggest_snek)
            the_biggest_snek -= 1
    else:
        wrong_snaks.add(i)
    print(*printing)

</ans>",0,{}
55,"<ans>
H, W = map(int, input().split())
print(""H: "", str(H), ""W: "", str(W))
List = [list(input()) for i in range(H)]
print(""List: "", str(List))
res = ""Yes""
print(""res: "", str(res))
flag = True
print(""flag: "", str(flag))

def checkAround(List, i, j):
  # ... (rest of the function remains the same)

for k in range(H):
  for l in range(W):
    if List[k][l] == ""."":
      pass
    else:
      flag = checkAround(List, k, l)
      if not flag:
        res = ""No""
        print(""res: "", str(res))
        break
  if not flag:
    break
print(""res: "", str(res))
</ans>",0,{}
56,"<ans>
import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))
        print(""self.edges: "", str(self.edges))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity
        print(""self.edges[u][v]: "", str(self.edges[u][v]))

    def bfs(self, s, t):
        open_q = [s]
        print(""open_q: "", str(open_q))

        visited = set()
        print(""visited: "", str(visited))
        parent = dict()
        print(""parent: "", str(parent))
        while open_q:
            close_q = []
            print(""close_q: "", str(close_q))
            for node in open_q:
                for v, capacity in list(self.edges[node].items()):
                    if v not in visited and capacity > 0:
                        close_q.append(v)
                        parent[v] = node
                        visited.add(v)
                        if v == t:
                            result = []
                            n2 = v
                            n1 = node
                            while n1 != s:
                                result.append((n1, n2))
                                n2 = n1
                                n1 = parent[n1]
                            result.append((n1, n2))
                            return result

            open_q = close_q

        return None

    def solve(self, s, t):
        flow = 0
        print(""flow: "", str(flow))
        route = self.bfs(s, t)
        print(""route: "", str(route))
        while route is not None:
            new_flow = float('inf')
            print(""new_flow: "", str(new_flow))
            for _, (n1, n2) in enumerate(route):
                new_flow = min(new_flow, self.edges[n1][n2])
            for _, (n1, n2) in enumerate(route):
                self.edges[n1][n2] -= new_flow
                self.edges[n2][n1] += new_flow
            flow += new_flow

            route = self.bfs(s, t)

        return flow

    def __str__(self):
        result = ""{ ""
        for k, v in list(self.edges.items()):
            result += str(k) + "":"" + str(dict(v)) + "", ""
        result += ""}""
        return result

def main():
    (n, m) = tuple([int(x) for x in input().split()])
    print(""n: "", str(n))
    print(""m: "", str(m))
    r = []
    xs = set()
    ys = set()
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        r.append((x1, y1, x2, y2))
        xs.add(x1)
        xs.add(x2 + 1)
        ys.add(y1)
        ys.add(y2 + 1)

    xx = sorted(xs)
    print(""xx: "", str(xx))
    yy = sorted(ys)
    print(""yy: "", str(yy))
    xsize = len(xs)
    print(""xsize: "", str(xsize))
    ysize = len(ys)
    print(""ysize: "", str(ysize))
    grid = []
    for i in range(ysize):
        grid.append([False] * xsize)
    print(""grid: "", str(grid))

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    grid[i][j] = True

    f = MaxFlow()
    for i in range(len(yy)):
        for j in range(len(xx)):
            if grid[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])

    # print(xx)
    # print(yy)
    # print(f)
    print(f.solve(0, len(xx) + len(yy) + 1))

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
57,"<ans>
```
import os
import sys
from io import BytesIO, IOBase
import heapq as h
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def getMat(n):
    return [getInts() for _ in range(n)]

MOD = 10**9+7

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

def solve():
    N, K = getInts()
    print(""N: "", str(N), ""K: "", str(K))
    graph = dd(set)
    for i in range(N-1):
        A, B = getInts()
        print(""A: "", str(A), ""B: "", str(B))
        graph[A].add(B)
        graph[B].add(A)
    dp_count = [[0 for j in range(5)] for i in range(N+1)]
    print(""dp_count: "", str(dp_count))
    dp_total = [0 for j in range(N+1)]
    print(""dp_total: "", str(dp_total))
    nonlocal ans
    ans = 0
    @bootstrap
    def dfs(node,parent,depth):
        nonlocal ans
        dp_count[node][depth % K] = 1
        dp_total[node] = 1
        for neigh in graph[node]:
            if neigh != parent:
                yield dfs(neigh,node,depth+1)
                for i in range(K):
                    for j in range(K):
                        diff = (i+j-2*depth)%K
                        req = (-diff)%K
                        ans += req * dp_count[node][i] * dp_count[neigh][j]
                for i in range(K):
                    dp_count[node][i] += dp_count[neigh][i]
                dp_total[node] += dp_total[neigh]
        ans += dp_total[node] * (N - dp_total[node])
        yield
    dfs(1,-1,0)
    return ans//K

print(solve())
</ans>",0,{}
58,"<ans>
import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy

print(""sys: "", str(sys))

class UnionFind:

    def __init__(self, n: int):
        self._n = n
        self._parents = [i for i in range(n)]
        self._size = [1 for _ in range(n)]
        print(""_parents: "", str(self._parents))
        print(""_size: "", str(self._size))

    def unite(self, x: int, y: int) -> None:
        px = self.find(x)
        py = self.find(y)

        # 一致していないときはリンクをつける
        if px != py:
            self._link(px, py)

    def _link(self, x: int, y: int):
        if self._size[x] < self._size[y]:
            self._parents[x] = y
            self._size[y] += self._size[x]
        else:
            self._parents[y] = x
            self._size[x] += self._size[y]

    def same(self, x: int, y: int) -> bool:
        px = self.find(x)
        py = self.find(y)
        return px == py

    def find(self, x: int) -> int:
        if self._parents[x] == x:
            return x

        self._parents[x] = self.find(self._parents[x])
        return self._parents[x]

    def size(self, x: int):
        return self._size[self.find(self._parents[x])]

N, K, L = map(int, input().split())
print(""N: "", str(N))
print(""K: "", str(K))
print(""L: "", str(L))

road = UnionFind(N + 1)
rail = UnionFind(N + 1)
share = UnionFind(N + 1)

roads = [list(map(int, input().split())) for _ in range(K)]
print(""roads: "", str(roads))

rails = [list(map(int, input().split())) for _ in range(L)]
print(""rails: "", str(rails))

m = {}

for i in range(1, N + 1):
    cnt = m.get((road.find(i), rail.find(i)), 0)
    m[(road.find(i), rail.find(i))] = cnt + 1

ans = [0] * N
for i in range(N):
    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]

print(""ans: "", str(ans))
print(*ans)
</ans>",0,{}
59,"<ans>
import sys

MOD = (int)(1e9+7)

def add(a, b):
	a += b
	if a >= MOD: a -= MOD
	return a

def mul(a, b):
	return (a * b) % MOD

class fenwickTree:
	def __init__(self, max_val):
		self.max_val = max_val + 5
		self.tree = [0] * self.max_val
		print(""max_val: "", str(self.max_val))
		print(""tree: "", str(self.tree))

	def update(self, idx, value):
		idx += 1
		while idx < self.max_val:
			self.tree[idx] = add(self.tree[idx], value)
			idx += (idx & (-idx))

	def read(self, idx):
		idx += 1
		res = 0
		while idx > 0:
			res = add(res, self.tree[idx])
			idx -= (idx & (-idx))
		return res

inp = [int(x) for x in sys.stdin.read().split()]

n = inp[0]
print(""n: "", str(n))
a = []
for i in range(1, n + 1):
	a.append(inp[i])
	print(""a: "", str(a))

sorted_array = sorted(a)
print(""sorted_array: "", str(sorted_array))
dict = {}
for i in range(n):
	dict[sorted_array[i]] = i
	print(""dict: "", str(dict))

factor = [0] * n
print(""factor: "", str(factor))
for i in range(0, n):
	factor[i] = mul(i + 1, n - i)
	print(""factor: "", str(factor))

left_tree = fenwickTree(n)
for i in range(0, n):
	element_idx = dict[a[i]]
	factor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))
	left_tree.update(element_idx, i + 1)

right_tree = fenwickTree(n)
for i in range(n - 1, -1, -1):
	element_idx = dict[a[i]]
	factor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))
	right_tree.update(element_idx, n - i)

ans = 0
for i in range(n):
	ans = add(ans, mul(a[i], factor[i]))
print(""ans: "", str(ans))

</ans>",0,{}
60,"<ans>
import sys
input = lambda: sys.stdin.readline().strip()

def f(A, r, c, l):
  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]

  print(""q: "", str(q), ""w: "", str(w), ""e: "", str(e), ""x: "", str(x), ""y: "", str(y), ""z: "", str(z), ""l: "", str(l))
  if x != y and y != z and e >= l and  w == q == l:
    return (l, z, y, x)
  else:
    return 0

r, c = list(map(int, input().split()))
print(""r: "", str(r), ""c: "", str(c))
s = """"
for i in range(r):
  s += input()

arr = []
print(""arr: "", str(arr))
narr = [[0]*r for i in range(c)]
print(""narr: "", str(narr))
for i in range(c):
  arr.append(s[i:r*c:c])

r, c = c, r

length_str = [ [0] * c for i in range(r) ]
print(""length_str: "", str(length_str))
for i in range(r):
  for j in range(c):
    if j == 0:
      length_str[i][j] = (1, arr[i][j])
    elif arr[i][j-1] == arr[i][j]:
      length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])
    else:
      length_str[i][j] = (1, arr[i][j])

for i in range(r):
  for j in range(c):
    l, _ = length_str[i][j]
    print(""l: "", str(l))
    if j - l*3 + 1 < 0:
      continue
    else:
      narr[i][j] = f(length_str, i, j, l)

dp =[ [0] * c for i in range(r) ]
print(""dp: "", str(dp))

for j in range(c):
  cnt = 1
  for i in range(r):
    if narr[i][j] == 0:
      cnt = 1
      continue
    else:
      if i == 0:
        dp[i][j] = 1

      elif narr[i][j] == narr[i-1][j]:
        cnt += 1
        dp[i][j] = cnt
        dp[i-1][j] = 0

      else:
        cnt = 1
        dp[i][j] = 1

ans = 0
for i in dp:
  for j in i:
    ans += ((j)*(j+1))//2

print(ans)

</ans>",0,{}
61,"<ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)

class TreapNode:
    _value = None
    _priority = None
    _count = None
    _left = None
    _right = None

    def __init__(self, value):
        self._value = value
        self._priority = random()
        self._count = 1
        print(""_value: "", str(self._value))
        print(""_priority: "", str(self._priority))
        print(""_count: "", str(self._count))

def treap_rotate_right(n):
    l = n._left
    n._left = l._right
    l._right = n
    return l

def treap_rotate_left(n):
    r = n._right
    n._right = r._left
    r._left = n
    return r

def treap_insert(n, v):
    if n is None:
        return TreapNode(v)
    if n._value == v:
        n._count += 1
        print(""n._count: "", str(n._count))
        return n
    if n._value > v:
        n._left = treap_insert(n._left, v)
        if n._priority > n._left._priority:
            n = treap_rotate_right(n)
    else:
        n._right = treap_insert(n._right, v)
        if n._priority > n._right._priority:
            n = treap_rotate_left(n)
    return n

def treap_delete(n, v):
    if n is None:
        raise Exception('no nodes')
    if n._value > v:
        n._left = treap_delete(n._left, v)
        return n
    if n._value < v:
        n._right = treap_delete(n._right, v)
        return n

    # n._value == v
    if n._count > 1:
        n._count -= 1
        print(""n._count: "", str(n._count))
        return n

    if n._left is None and n._right is None:
        return None

    if n._left is None:
        n = treap_rotate_left(n)
    elif n._right is None:
        n = treap_rotate_right(n)
    else:
        # n._left is not None and n._right is not None
        if n._left._priority < n._right._priority:
            n = treap_rotate_right(n)
        else:
            n = treap_rotate_left(n)
    return treap_delete(n, v)

def treap_size(n):
    if n is None:
        return 0
    return n._count + treap_size(n._left) + treap_size(n._right)

def treap_str(n):
    if n is None:
        return """"
    result = []
    if n._left is not None:
        result.append(treap_str(n._left))
    result.append(""%d:%d"" % (n._value, n._count))
    if n._right is not None:
        result.append(treap_str(n._right))
    return ' '.join(result)

def treap_search(n, v):
    # v 未満で最大のノードを検索する. v 未満のノードがなければ None を返す
    if n is None:
        return None
    if n._value >= v:
        if n._left is None:
            return None
        return treap_search(n._left, v)
    # n._value < v
    if n._right is None:
        return n
    r = treap_search(n._right, v)
    if r is None:
        return n
    return r

class Treap:
    _root = None
    _size = 0

    def insert(self, v):
        self._root = treap_insert(self._root, v)
        self._size += 1
        print(""_size: "", str(self._size))

    def delete(self, v):
        self._root = treap_delete(self._root, v)
        self._size -= 1
        print(""_size: "", str(self._size))

    def __len__(self):
        return self._size

    def __str__(self):
        return treap_str(self._root)

    def search(self, v):
        return treap_search(self._root, v)

N = int(input())
A = [int(input()) for _ in range(N)]

t = Treap()
for a in A:
    n = t.search(a)
    if n is not None:
        t.delete(n._value)
    t.insert(a)
print((len(t)))

</ans>",0,{}
62,"<ans>
```
def _3():
    from collections import defaultdict

    print(""defaultdict: "", str(defaultdict))

    def can_pair(s1, s2):
        l = []
        for c1, c2 in zip(s1, s2):
            c = sorted([c1, c2])
            if c in l:
                l.remove(c)
            else:
                l.append(c)

        if len(s1) % 2 == 0:
            return len(l) == 0
        else:
            return len(l) == 1 and l[0][0] == l[0][1]

    print(""can_pair: "", str(can_pair))

    def pair_graph(s1, s2):
        N = len(s1)
        G = np.zeros([N, N])
        for i in range(N):
            for j in range(i+1, N):
                if s1[i] == s2[j] and s1[j] == s2[i]:
                    G[i, j] = 1
                    G[j, i] = 1
        return G

    print(""pair_graph: "", str(pair_graph))

    import numpy as np
    H, W = list(map(int, input().split(' ')))
    print(""H: "", str(H), ""W: "", str(W))

    S = []
    d = defaultdict(list)

    for h in range(H):
        s = input()
        S.append(s)
        d[''.join(sorted(S))].append(h)

    already_paired = np.zeros(H)
    print(""already_paired: "", str(already_paired))

    Gs = []

    for i in range(H):
        if already_paired[i]:
            continue

        for j in range(i+1, H):
            if already_paired[j]:
                continue

            if can_pair(S[i], S[j]):
                already_paired[i] = 1
                already_paired[j] = 1
                G = pair_graph(S[i], S[j])
                Gs.append(G)
                break

    if already_paired.sum() < H - 1:
        print('NO')
        return

    elif already_paired.sum() == H - 1:
        for i in range(H):
            if already_paired[i] == 0:
                G = pair_graph(S[i], S[i])
                Gs.append(G)
                break

    G = np.array(Gs).sum(axis=0) // len(Gs)
    print(""G: "", str(G))

    def is_perfect_matching(G):
        N = len(G)
        if N == 1:
            return True

        for i in range(N):
            for j in range(i+1, N):
                if G[i, j] == 1:
                    l = list(range(N))
                    l.remove(i)
                    l.remove(j)
                    if len(l) == 0:
                        return True
                    if is_perfect_matching(G[l][:, l]):
                        return True
        return False

    print(""is_perfect_matching: "", str(is_perfect_matching))

    if is_perfect_matching(G):
        print('YES')
    else:
        print('NO')

def __starting_point():
    _3()
__starting_point()
</ans>",0,{}
63,"<ans>
import sys
readline = sys.stdin.readline

def accumulate2d(X):
    N = len(X)
    M = len(X[0])

    for i in range(0, N):
        for j in range(1, M):
            X[i][j] += X[i][j-1]
    print(""X after first loop: "", str(X))

    for j in range(0, M):
        for i in range(1, N):
            X[i][j] += X[i-1][j]
    print(""X after second loop: "", str(X))

    return X

N, M, Q = map(int, readline().split())
print(""N: "", str(N), ""M: "", str(M), ""Q: "", str(Q))

table = [None]*100
table[ord('R')] = 0
table[ord('G')] = 1
table[ord('B')] = 2
table[ord('Y')] = 3
print(""table: "", str(table))

INF = 10**3
D = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]
print(""D: "", str(D))

G = [[0]*M for _ in range(N)]
print(""G: "", str(G))

BS = 25
candi = []
geta = M
for i in range(N-1):
    for j in range(M-1):
        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:
            G[i][j] = 1
            print(""G[i][j] after first condition: "", str(G[i][j]))
            nh, nw = i, j
            while True:
                k = G[nh][nw]
                fh, fw = nh-k, nw-k
                k2 = 2*(k+1)
                kh = k+1
                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:
                    break
                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\
                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):
                    break
                G[nh][nw] += 1
            print(""G[nh][nw] after while loop: "", str(G[nh][nw]))
            if G[nh][nw] > BS:
                candi.append((nh, nw))
                print(""candi after appending: "", str(candi))

Gnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]
for h in range(N):
    for w in range(M):
        if G[h][w] > 0:
            for k in range(1, min(BS, G[h][w])+1):
                Gnum[k][h][w] = 1
                print(""Gnum[k][h][w] after assignment: "", str(Gnum[k][h][w]))

Gnum = [None] + [accumulate2d(g) for g in Gnum[1:]]
print(""Gnum after accumulate2d: "", str(Gnum))

Ans = [None]*Q
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())
    print(""h1: "", str(h1), ""w1: "", str(w1), ""h2: "", str(h2), ""w2: "", str(w2))
    res = 0
    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+k-1, w1+k-1
        he, we = h2-k, w2-k
        if hs <= he and ws <= we:
            cnt = Gnum[k][he][we]
            if hs:
                cnt -= Gnum[k][hs-1][we]
            if ws:
                cnt -= Gnum[k][he][ws-1]
            if hs and ws:
                cnt += Gnum[k][hs-1][ws-1]
            if cnt:
                res = k
                break
            print(""res after k loop: "", str(res))

    for nh, nw in candi:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))
            print(""res after candi loop: "", str(res))
    Ans[qu] = 4*res**2
    print(""Ans[qu] after assignment: "", str(Ans[qu]))

print('\n'.join(map(str, Ans)))
</ans>",0,{}
64,"<ans>
# problem http://codeforces.com/contest/1100/problem/E
import copy
import sys

def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    print(""visited: "", str(visited))
    print(""visited_int: "", str(visited_int))
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    print(""visited: "", str(visited))
    print(""order: "", str(order))
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in list(w.items()):
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

def __starting_point():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n))
    print(""m: "", str(m))
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines): #range(1, m + 1):
        u, v, c = list(map(int, line.split()))
        print(""u: "", str(u))
        print(""v: "", str(v))
        print(""c: "", str(c))
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in list(w.keys()):
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in list(w_tmp.keys()):
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)
        # c_m = max(c, c_m)

    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))

    kk.sort()
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        return
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))

__starting_point()
</ans>",0,{}
65,"<ans>
a = list(map(int,input().split()))
print(""a: "", str(a))
b = [0,0,0,0,0];
print(""b: "", str(b))
c = [0,0,0,0,0];
print(""c: "", str(c))
ipt = [];
print(""ipt: "", str(ipt))
ans = [];
print(""ans: "", str(ans))
d = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}
print(""d: "", str(d))

n = int(input())

for i in range(1,n+1) :
    j = input()
    ipt.append(j)
    ans.append(j)
    if j.find(',') == -1 :
        a[d[j]] -= 1
    else :
        b[d[j[0:j.find(',')]]] += 1

ans = False;
print(""ans: "", str(ans))

for i in range(0,6) :
    if (a[i] < 0) and ans == False:
        ans = True
    elif i < 5:
        if i==0 :
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                b[i] -= a[i];
                a[i] = 0;
            else :
                c[i] = 0;
                a[i] -= b[i];
                b[i] = 0;

        else :
            if b[i-1] > 0 :
                if b[i-1] > a[i] :
                    ans = True
                else :
                    a[i] -= b[i-1];
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                b[i] -= a[i];
                a[i] = 0;
            else :
                c[i] = 0;
                a[i] -= b[i];
                b[i] = 0;
    elif i==5 :
        if a[i] < b[i-1]:
            ans = True

if ans == True :
    print(""NO"");

else :
    print(""YES"")
    for i in ipt :
        if i.find(',') == -1 :
            print(i)
        else :
            tmp = i[0:i.find(',')];
            if (c[d[tmp]] > 0) :
                print(i[i.find(',')+1:])
                c[d[tmp]] -= 1
            else :
                print(tmp)
</ans>",0,{}
66,"<ans>
n, m = list(map(int, input().split()))
print(""n: "", str(n), ""m: "", str(m))
A = list(map(int, input().split()))
print(""A: "", str(A))
if n > 300:
    lst = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        lst.append([a, b])
    print(""lst: "", str(lst))
    answer = 0
    print(""answer: "", str(answer))
    answer_1 = []
    print(""answer_1: "", str(answer_1))
    m300 = [[-1, -10**6]]
    for i in range(max(0, m-1)):
        m300.append([-1, -10**6])
    print(""m300: "", str(m300))
    for u in range(n):
        if A[u] > min(m300)[1]:
            m300[m300.index(min(m300))] = [u, A[u]]
    print(""m300: "", str(m300))
    for i, mi in m300:
        B = A.copy()
        print(""B: "", str(B))
        kek = []
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
        elem = max(B)
        if answer < elem - mi:
            answer = elem - mi
            answer_1 = kek.copy()
    print(""answer: "", str(answer))
    print(""answer_1: "", str(answer_1))
    print(' '.join(map(str, answer_1)))
else:
    lst = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        lst.append([a, b])
    print(""lst: "", str(lst))
    answer = 0
    print(""answer: "", str(answer))
    answer_1 = []
    print(""answer_1: "", str(answer_1))
    for i in range(n):
        B = A.copy()
        print(""B: "", str(B))
        kek = []
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
        elem = max(B)
        if answer < elem - B[i]:
            answer = elem - B[i]
            answer_1 = kek.copy()
    print(""answer: "", str(answer))
    print(""answer_1: "", str(answer_1))
    print(' '.join(map(str, answer_1)))
</ans>",0,{}
67,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self, Nodes, is_directed=False):
        print(""Nodes: "", str(Nodes))
        print(""is_directed: "", str(is_directed))
        self.nodes = Nodes
        self.adj_list = {}
        self.is_directed = is_directed

        for node in self.nodes:
            self.adj_list[node] = []
            print(""adj_list[{}]: {}"".format(node, self.adj_list[node]))

    def add_edge(self, u, v):
        print(""u: "", str(u))
        print(""v: "", str(v))
        self.adj_list[u].append(v)
        if self.is_directed == False:
            self.adj_list[v].append(u)
            print(""adj_list[{}]: {}"".format(v, self.adj_list[v]))

    def print_graph(self):
        for node in self.nodes:
            print((node, ""->"", self.adj_list[node]))

    def degree_node(self, node):
        print(""node: "", str(node))
        return len(self.adj_list[node])

    def dfsUTIL(self, v, visited, parents=[]):
        # print(v, end="" "")
        visited[v] = True
        for i in self.adj_list[v]:
            if visited[i] == False:
                self.dfsUTIL(i, visited, parents)
                parents.append(i)

    def dfs(self, v):
        visited = [False] * (max(self.adj_list) + 1)
        parents = [v]
        self.dfsUTIL(v, visited, parents)
        return len(parents)

##### sorting a dictionary by the values #####
def dict_sort(ans):
    print(""ans: "", str(ans))
    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))

##### naive method for testing prime or not O(n^.5) #####
def is_prime(n):
    print(""n: "", str(n))
    if n == 1:
        return 0
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

##### swap function #####
def swap(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    temp = a
    a = b
    b = temp
    return a, b

##### Primes till Nth O(n) #####
def seive_primes(n):
    print(""n: "", str(n))
    flag = [0] * (n + 10)
    flag[1] = flag[0] = 1
    i = 2
    while i * i <= n + 1:
        if flag[i] == 0:
            j = i * i
            while j <= n + 1:
                flag[j] = 1
                j += i
        i += 1
    return flag

##### greatest common divisor of two numbers #####
def gcd(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    if b == 0:
        return a
    return gcd(b, a % b)

##### least common multiplyer of two numbers #####
def lcm(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    return (a * b) // gcd(a, b)

##### function that return all the letters #####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

##### binary search O(logN) #####
def binary_search(ls, n, flag):
    print(""ls: "", str(ls))
    print(""n: "", str(n))
    print(""flag: "", str(flag))
    low = 0
    hi = n - 1
    while low <= hi:
        mid = (low + hi) // 2
        if ls[mid] == flag:
            return mid
        elif ls[mid] > flag:
            hi = mid - 1
        else:
            low = mid + 1
    return -1

##### quadratic #####
def qdrt(a, b, c):
    print(""a: "", str(a))
    print(""b: "", str(b))
    print(""c: "", str(c))
    chk = b * b - 4 * a * c
    if chk >= 0:
        ans1 = (-b + chk ** 0.5) / (2 * a)
        ans2 = (-b - chk ** 0.5) / (2 * a)
        return [int(ans1), int(ans2)]
    return -1

##### taking an array/list as input #####
def inp():
    ls = list(map(int, input().split()))
    print(""ls: "", str(ls))
    return ls

##### taking multiple inputs #####
def mult_inp():
    return list(map(int, input().split()))

##### Main function starts from here #####
n = int(input())
print(""n: "", str(n))
d = {}
while n % 2 == 0:
    if 2 in d:
        d[2] += 1
    else:
        d[2] = 1
    n /= 2
for i in range(3, int(n ** 0.5) + 1, 2):
    while n % i == 0:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
        n /= i
n = int(n)
if n > 1:
    d[n] = 1
print(""d: "", str(d))
n = 1
# print(d,n)
ans = 0
for i in d:
    c = -2 * d[i]
    a = b = 1
    ls = qdrt(a, b, c)
    if ls[0] >= 0:
        ans += ls[0]
    elif ls[1] >= 0:
        ans += ls[1]
print(ans)
</ans>",0,{}
68,"<ans>
N, S = input().split()
print(""N: "", str(N), ""S: "", str(S))
N = int(N)
print(""N: "", str(N))
ans = 0
for i in range(N):
    a = 0;t = 0;c = 0;g = 0;
    print(""a: "", str(a), ""t: "", str(t), ""c: "", str(c), ""g: "", str(g))
    for j in range(i,N):
        if S[j] == 'A':
            a += 1
        elif S[j] == 'T':
            t += 1
        elif S[j] == 'C':
            c += 1
        else:
            g += 1
        print(""a: "", str(a), ""t: "", str(t), ""c: "", str(c), ""g: "", str(g))
        if a == t and c == g:
            ans += 1
print(""ans: "", str(ans))
</ans>",0,{}
69,"<ans>
from collections import deque
import math

def dfs(edges, s):
    stack = deque([s])
    used  = {s}
    while stack:
        x = stack.pop()
        for y in edges[x]:
            if y not in used:
                used.add(y)
                stack.append(y)
    return used

def bfs(edges, s):
    queue = deque([s])
    used  = {s}
    while queue:
        x = queue.popleft()
        for y in edges[x]:
            if y in used:
                continue
            used.add(y)
            queue.append(y)
    return used

def bellman(dist):  #負辺があるケースでの、スタートからゴールへの最短路を求めるアルゴ。
    cost = [float(""inf"")] * n
    cost[0] = 0
    for _ in range(n): #頂点の個数の分だけ回る
        updated = False
        for u,v,c in dist: #辺の個数の分だけ回る
            if cost[u] + c < cost[v]:
                cost[v] = cost[u] + c
                updated = True
    #収束しない場合は負閉路があるため無限に小さくできる。
    if updated==True:
        return -1
    else:
        return max(0, cost[n-1]*-1)

n,m,p = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""p: "", str(p))
dist  = []
edge1 = [[] for _ in range(n)]
edge2 = [[] for _ in range(n)]  # rev_edge
for _ in range(m):
    u,v,c = map(int, input().split())
    u -= 1
    v -= 1
    dist.append((u,v,(c-p)*-1))
    edge1[u].append(v)
    edge2[v].append(u)
print(""dist: "", str(dist), ""edge1: "", str(edge1), ""edge2: "", str(edge2))

use = dfs(edge1, 0) & dfs(edge2, n-1)
print(""use: "", str(use))
dist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]
print(""dist2: "", str(dist2))
print(bellman(dist2))
</ans>",0,{}
70,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self, Nodes, is_directed=False):
        print(""Nodes: "", str(Nodes))
        print(""is_directed: "", str(is_directed))
        self.nodes = Nodes
        self.adj_list = {}
        self.is_directed = is_directed

        for node in self.nodes:
            self.adj_list[node] = []
            print(""adj_list[{}]: {}"".format(node, self.adj_list[node]))

    def add_edge(self, u, v):
        print(""u: "", str(u))
        print(""v: "", str(v))
        self.adj_list[u].append(v)
        if self.is_directed == False:
            self.adj_list[v].append(u)
            print(""adj_list[{}]: {}"".format(v, self.adj_list[v]))

    def print_graph(self):
        for node in self.nodes:
            print((node, ""->"", self.adj_list[node]))

    def degree_node(self, node):
        print(""node: "", str(node))
        return len(self.adj_list[node])

    def dfsUTIL(self, v, visited, parents=[]):
        # print(v, end="" "")
        visited[v] = True
        for i in self.adj_list[v]:
            if visited[i] == False:
                self.dfsUTIL(i, visited, parents)
                parents.append(i)

    def dfs(self, v):
        visited = [False] * (max(self.adj_list) + 1)
        parents = [v]
        self.dfsUTIL(v, visited, parents)
        return len(parents)

##### sorting a dictionary by the values #####
def dict_sort(ans):
    print(""ans: "", str(ans))
    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))

##### naive method for testing prime or not O(n^.5) #####
def is_prime(n):
    print(""n: "", str(n))
    if n == 1:
        return 0
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

##### swap function #####
def swap(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    temp = a
    a = b
    b = temp
    return a, b

##### Primes till Nth O(n) #####
def seive_primes(n):
    print(""n: "", str(n))
    flag = [0] * (n + 10)
    flag[1] = flag[0] = 1
    i = 2
    while i * i <= n + 1:
        if flag[i] == 0:
            j = i * i
            while j <= n + 1:
                flag[j] = 1
                j += i
        i += 1
    return flag

##### all the prime factors of a number #####
def factors(n):
    print(""n: "", str(n))
    d = {}
    while n % 2 == 0:
        if 2 in d:
            d[2] += 1
        else:
            d[2] = 1
        n /= 2
    for i in range(3, int(n ** 0.5) + 1, 2):
        while n % i == 0:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
            n /= i
    n = int(n)
    if n > 1:
        d[n] = 1
    return d

##### greatest common divisor of two numbers #####
def gcd(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    if b == 0:
        return a
    return gcd(b, a % b)

##### least common multiplyer of two numbers #####
def lcm(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    return (a * b) // gcd(a, b)

##### function that return all the letters #####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

##### binary search O(logN) #####
def binary_search(ls, n, flag):
    print(""ls: "", str(ls))
    print(""n: "", str(n))
    print(""flag: "", str(flag))
    low = 0
    hi = n - 1
    while low <= hi:
        mid = (low + hi) // 2
        if ls[mid] == flag:
            return mid
        elif ls[mid] > flag:
            hi = mid - 1
        else:
            low = mid + 1
    return -1

##### quadratic roots #####
def qdrt(a, b, c):
    print(""a: "", str(a))
    print(""b: "", str(b))
    print(""c: "", str(c))
    chk = b * b - 4 * a * c
    if chk >= 0:
        ans1 = (-b + chk ** 0.5) / (2 * a)
        ans2 = (-b - chk ** 0.5) / (2 * a)
        return [int(ans1), int(ans2)]
    return -1

##### permutations #####
def permutation(n, r):
    print(""n: "", str(n))
    print(""r: "", str(r))
    if n < r:
        return 0
    ans = 1
    for i in range(n - r + 1, n + 1):
        ans *= i
    return ans

##### combinations #####
def combination(n, r):
    print(""n: "", str(n))
    print(""r: "", str(r))
    if n < r:
        return 0
    ans = 1
    for i in range(r):
        ans *= (n - i)
    div = 1
    for i in range(2, r + 1):
        div *= i
    return ans // div

##### taking an array/list as input #####
def arinp():
    ls = list(map(int, input().split()))
    print(""ls: "", str(ls))
    return ls

##### taking multiple inputs #####
def mult_inp():
    return list(map(int, input().split()))

##### Main function starts from here #####
def main():
    n, m = mult_inp()
    print(""n: "", str(n))
    print(""m: "", str(m))
    print(combination(n, 2) + combination(m, 2))

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
71,"<ans>
import math
import bisect
import sys

def flrt(exp, x):
    l = max(0, math.floor(x**(1/exp)) - 3)
    print(""l: "", str(l))
    r = math.floor(x**(1/exp)) + 3
    print(""r: "", str(r))
    while l < r:
        mid = (l + r) // 2
        print(""mid: "", str(mid))
        if mid**exp <= x:
            l = mid + 1
        else:
            r = mid
    return l - 1

def c1(r):
    ans = set()
    print(""ans: "", str(ans))
    pr = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
    print(""pr: "", str(pr))
    for i in pr:
        x = 2
        while x**i <= r:
            val = x**i
            b2 = flrt(2, val)
            b3 = flrt(3, val)
            if b2**2 != val and b3**3 != val:
                ans.add(val)
            x += 1
    return ans

def solve(r, pc):
    if r == 0:
        return 0
    a = [2, 3]
    print(""a: "", str(a))
    ans = 0
    for i in range(1, 2**len(a)):
        tot = 0
        mult = 1
        for j, x in enumerate(a):
            if i & (1 << j):
                mult *= x
                tot += 1
        d = flrt(mult, r)
        ans += d if tot % 2 else -d
    return ans + bisect.bisect_right(pc, r)

q = int(input())
pc = c1(1e18 + 1)
pca = list(pc)
pca.sort()
print(""pca: "", str(pca))

for i in range(q):
    l, r = [int(x) for x in sys.stdin.readline().split()]
    ans = solve(r, pca) - solve(l - 1, pca)
    sys.stdout.write(str(ans) + '\n')

</ans>",0,{}
72,"<ans>
'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return list(map(int,input().split()))
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')





def solve():
    print(""n: "", str(n))
    print(""m: "", str(m))
    print(""w: "", str(w))
    a = li()
    print(""a: "", str(a))

    def fessible(mid):
        print(""mid: "", str(mid))
        b = [0]*n
        moves = 0
        if(a[0]<mid):
            b[0]+=(mid-a[0])
            if(w<n):
                b[w]-=(mid-a[0])
            moves+=(mid-a[0])
            if(moves>m):
                return 0
        for i in range(1,n):
            b[i]+=b[i-1]
            x=a[i]+b[i]
            if(x<mid):
                b[i]+=(mid-x)
                if(i+w<n):
                    b[i+w]-=(mid-x)
                moves+=(mid-x)
            if(moves>m):
                return 0
        return 1

    l = 1
    r = 1e10
    while(l<=r):
        mid=l+(r-l)//2
        if(fessible(mid)):
            l=mid+1
            ans=mid
        else:
            r=mid-1
    print(""ans: "", str(int(ans)))




def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
73,"<ans>
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

S=lambda x:sum(map(int,str(x)))

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	z=S(x)%a
	print(""z: "", str(z))
	if z:
		z=a-z
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(z,9-int(digit))
			z-=diff
			tail.append(str(int(digit)+diff))
			if z==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert S(x)%a==0
	x=int(x)
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	while a%5==0: a//=5
	return a==1

def solve(a):
	for first in range(1,60): # 120
		q=str((first*10**3000+a-1) // a) # 5000
		for s1 in range(1,200):
			i=1
			s2=int(q[0])
			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,a)
					if S(small*a)*a==S(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

if 0:
	#for a in (a for a in range(2,1000)):
	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
	#for a in [32]:

		def work():
			nonlocal x
			x=solve(a)

		t=timeit(work,number=1)
		if t>0.5 or x==None:
			if x!=None:
				print(a,t,'>>',powform(a*x))
			else:
				print(a,t,'>> ?????')

	#print(solve(int(input())))


special='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104
582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003
636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5475810970001476 >> 2 * 10 ** 2140 + 439
64 0.5633312410000144 >> ?????
200 0.5639609099998779 >> ?????
100 0.565854023000611 >> ?????
125 0.5663040710005589 >> ?????
160 0.5668467480008985 >> ?????
800 0.5676178080002501 >> ?????
128 0.5676772269998764 >> ?????
80 0.5682811480000964 >> ?????
256 0.5685735130000467 >> ?????
250 0.5691464900000938 >> ?????
512 0.569266141999833 >> ?????
32 0.5692826909998985 >> ?????
50 0.5692834940000466 >> ?????
25 0.5696684799995637 >> ?????
400 0.5703751219998594 >> ?????
20 0.5706145570002263 >> ?????
500 0.5742691679997733 >> ?????
640 0.5749700739997934 >> ?????
40 0.5768258159996549 >> ?????
625 0.5775357299999087 >> ?????
16 0.5789494729997386 >> ?????
833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008
320 0.6031684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.045185064999714 >> 22 * 10 ** 1822 + 1130
990 6.413724044000446 >> 39 * 10 ** 2970 + 302010
666 6.967028857000514 >> 33 * 10 ** 2997 + 32934
941 6.982767053000316 >> 21 * 10 ** 1885 + 312
924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152
858 8.089877333000004 >> 41 * ",0,{}
74,"<ans>
from collections import deque
from sys import stdin

#parser
def parser():
    return map(int, stdin.readline().split())

def DFS_Discriminiting():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                if attacked_city[u]:
                    count_attacked_cities_subtree[u]+=1
                stack.append(u)
                intrudoction_order.append(u)
    for v in intrudoction_order[::-1]:
        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]
        if count_attacked_cities_subtree[v]==0:
            important_cities[v]=False

def DFS_Heigths():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                stack.append(u)
                intrudoction_order.append(u)
    for v in intrudoction_order[::-1]:
        if heights1[pi[v]] < heights1[v]+1:
            heights2[pi[v]]=heights1[pi[v]]
            heights1[pi[v]]=heights1[v]+1
        elif heights2[pi[v]]<heights1[v]+1:
            heights2[pi[v]]=heights1[v]+1

def Distance_Root(s):
    for v in adjacents_list[s]:
        if heights1[v]+1>distances1[s]:
            distances2[s]=distances1[s]
            distances1[s]=heights1[v]+1
        elif heights1[v]+1>distances2[s]:
            distances2[s]=heights1[v]+1

def DFS_Distances():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    stack.append(numbers_of_attacked_cities[0])
    Distance_Root(numbers_of_attacked_cities[0])
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                determinate=False
                stack.append(u)
                if heights1[u]+1==distances1[v]:
                    if heights1[u]+1>distances2[v]:
                        determinate=True
                        distances1[u]=max(heights1[u],distances2[v]+1)
                        if distances1[u]==heights1[u]:
                            distances2[u]=max(distances2[v]+1,heights2[u])
                        else:
                            distances2[u]=heights1[u]
                if not determinate:
                    distances1[u]=distances1[v]+1
                    distances2[u]=heights1[u]

def BFS(s):
    distance=[-1 for x in range(n)]
    distance[s]=0
    q=deque()
    q.append(s)
    while len(q)>0:
        v=q.popleft()
        for u in adjacents_list[v]:
            if distance[u] == -1:
                distance[u]=distance[v]+1
                q.append(u)
    return distance


n,m=parser()
#Creando los arrays necesarios para la ejecucion de DFS
#padres
pi=[0 for x in range(n)]
print(""pi: "", str(pi))
#ciudades atacadas en el subarbol
count_attacked_cities_subtree=[0 for x in range(n)]
print(""count_attacked_cities_subtree: "", str(count_attacked_cities_subtree))
#ciudad atacada o no atacada
attacked_city=[False for x in range(n)]
print(""attacked_city: "", str(attacked_city))
#ciudades_que_son atacadas o sirven para llegar a las mismas
important_cities=[True for x in range(n)]
print(""important_cities: "", str(important_cities))

adjacents_list=[[] for x in range(n)]
for i in range(n-1):
    v1,v2=parser()
    adjacents_list[v1-1].append(v2-1)
    adjacents_list[v2-1].append(v1-1)

#numero de ciudades atacadas
numbers_of_attacked_cities=[x-1 for x in parser()]

if m==1:
    print(numbers_of_attacked_cities[0]+1)
    print(0)
    return

#marcando las ciudades atacadas
for i in numbers_of_attacked_cities:
    attacked_city[i]=True

DFS_Discriminiting()

adjacents_list=[[] for x in range(n)]

count_edges=0
for v in range(n):
    if v==numbers_of_attacked_cities[0]:
        continue
    elif important_cities[v] and important_cities[pi[v]]:
        adjacents_list[v].append(pi[v])
        adjacents_list[pi[v]].append(v)
        count_edges+=1

#padres
pi=[0 for x in range(n)]
print(""pi: "", str(pi))

#alturas
heights1=[0 for x in range(n)]
print(""heights1: "", str(heights1))
heights2=[0 for x in range(n)]
print(""heights2: "", str(heights2))

DFS_Heigths()

#distances
distances1=[0 for x in range(n)]
print(""distances1: "", str(distances1))
distances2=[0 for x in range(n)]
print(""distances2: "", str(distances2))

DFS_Distances()

lower=distances1[numbers_of_attacked_cities[0]]
for i in range(n):
    if important_cities[i] and lower>distances1[i]:
        lower=distances1[i]

centers=[]
for i in range(n):
    if distances1[i]==lower:
        centers.append(i)

posibles_begin_cities=[]

for i in centers:
    distances_center=BFS(i)
    max_distance=0
    for j in range(n):
        if distances_center[j]>max_distance:
            max_distance=distances_center[j]
    for j in range(n):
        if distances_center[j]==max_distance:
            posibles_begin_cities.append(j)

print(min(posibles_begin_cities)+1)

print(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))
</ans>",0,{}
75,"<ans>
from copy import deepcopy
n, k, m, a = [int(i) for i in input().split()]
print(""n: "", str(n), ""k: "", str(k), ""m: "", str(m), ""a: "", str(a))
cn = [0] * (n + 1)
print(""cn: "", str(cn))
last = [-1] * (n + 1)
print(""last: "", str(last))
v = [int(i) for i in input().split()]
print(""v: "", str(v))

for i in range(len(v)):
    last[v[i]] = i
    cn[v[i]] += 1

cn1 = deepcopy(cn)
print(""cn1: "", str(cn1))
last1 = deepcopy(last)
print(""last1: "", str(last1))

for i in range(1, n + 1):
    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last))
    res = [i1 for i1 in range(1, n + 1)]
    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    #print(res)

    for j in range(len(res)):
        if res[j] != i:
            continue
        j1 = j + 1
        lft = m - a
        while j1 < n and lft:
            pls = min(lft, cn[i] - cn[res[j1]] + 1)
            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)
            last[res[j1]] = m
            lft -= pls
            j1 += 1

    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    sans = 0
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break

    if sans == 1:
        print(1, end= ' ')
        continue

    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last))

    if m - a:
        cn[i] += m - a
        last[i] = m - 1

    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break

    if sans:
        print(2, end=' ')
    else:
        print(3, end=' ')

</ans>",0,{}
76,"<ans>
```
def indeksTurun(a):
	for x in range(len(a)-1):
		if a[x] > a[x+1]:
			print(""a[x]: "", str(a[x]))
			print(""a[x+1]: "", str(a[x+1]))
			return x+1
			pass
		pass
	return -1
	pass

def menaik(a,i1):
	for x in range(i1,len(a)-1):
		if a[x] > a[x+1]:
			print(""a[x]: "", str(a[x]))
			print(""a[x+1]: "", str(a[x+1]))
			return False
			pass
		pass
	return True
	pass

a=input()
a=list(map(int,input().split("" "")))

if len(a) == 1:
	print (""yes"")
	print (""1 1"")
else:
	reversed_indeks1=-1
	for x in range(len(a)-1):
		if a[x] > a[x+1]:
			reversed_indeks1=x
			break
			pass
		pass
	if reversed_indeks1 == -1:
		print (""yes"")
		print (""1 1"")
	else:
		reversed_indeks2=len(a)-1
		for x in range(reversed_indeks1,len(a)-1):
			if a[x] < a[x+1]:
				reversed_indeks2=x
				break
		asc=True
		if reversed_indeks2 != len(a)-1:
			asc=menaik(a,reversed_indeks2+1)
		if asc:
			kiri=True
			kanan=True
			if reversed_indeks1 != 0:
				if a[reversed_indeks2] < a[reversed_indeks1-1]:
					kiri=False
					pass
			if reversed_indeks2 != len(a)-1:
				if a[reversed_indeks1] > a[reversed_indeks2+1]:
					kanan=False
					pass
				pass
				pass
			if kiri and kanan:
				print (""yes"")
				print (""%d %d""%(reversed_indeks1+1,reversed_indeks2+1))
				pass
			else:
				print (""no"")
		else:
			print (""no"")
			pass
	pass
```",0,{}
77,"<ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
    if i == 2 * n + 1:
        nonlocal ans
        ans = ""Yes""
        return
    if ans == ""No"":
        if y[i] == 0:
            for k in range(1, n):
                if ok(k, i):
                    dfs(i + 2 * k)
        else:
            if ok(y[i], i):
                dfs(i + 2 * y[i])
    return

def ok(k, i):
    if k + i >= 2 * n + 1:
        return 0
    f = 1
    for l in range(k):
        if k + i + l >= 2 * n + 1:
            f = 0
            break
        if x[i + l] == 2 or x[k + i + l] == 1:
            f = 0
            break
        if not (y[i + l] == 0 or y[i + l] == k):
            f = 0
            break
        if not z[i + l] == z[k + i + l] and min(z[i + l], z[k + i + l]) >= 1:
            f = 0
            break
    return f

n = int(input())
print(""n: "", str(n))
ans = ""Yes""
print(""ans: "", str(ans))
x = [0] * (2 * n + 2)
print(""x: "", str(x))
y = [0] * (2 * n + 2)
print(""y: "", str(y))
z = [0] * (2 * n + 2)
print(""z: "", str(z))
for i in range(1, n + 1):
    a, b = map(int, input().split())
    if a >= b and not (a == -1 or b == -1):
        ans = ""No""
    if not (x[a] == 0 and x[b] == 0):
        ans = ""No""
    if not a == -1:
        x[a] = 1
        z[a] = i
    if not b == -1:
        x[b] = 2
        z[b] = i
    if not (a == -1 or b == -1):
        y[a] = b - a
if ans == ""No"":
    print(ans)
    return
ans = ""No""
print(""ans: "", str(ans))
dfs(1)
print(ans)
</ans>",0,{}
78,"<ans>
n, m = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m))

t = [0] * (n + 1)
print(""t: "", str(t))

p = [0] * (n + 1)
print(""p: "", str(p))

q = [[] for i in range(n + 1)]
print(""q: "", str(q))

def f(x):
    for i in q[x]:
        u, v = i[0], i[1]
        if t[u] and t[v]: continue
        if t[u] and not t[v]:
            t[v] = 7 - t[x] - t[u]
            for j in q[v]:
                p[j[0]] |= t[v]
                p[j[1]] |= t[v]
            #f(u)
            f(v)
        elif not t[u] and t[v]:
            t[u] = 7 - t[x] - t[v]
            for j in q[u]:
                p[j[0]] |= t[u]
                p[j[1]] |= t[u]
            f(u)
            #f(v)
        else:
            for k in [1, 2, 4]:
                t[u], t[v] = k, 7 - t[x] - k
                if not (p[u] & t[u] or p[v] & t[v]): break

            for j in q[v]:
                p[j[0]] |= t[v]
                p[j[1]] |= t[v]
            for j in q[u]:
                p[j[0]] |= t[u]
                p[j[1]] |= t[u]
            f(u)
            f(v)

if m == 49999:
    for j in range(m):
        a, b, c = map(int, input().split())
        x = t[a] | t[b] | t[c]
        for i in (a, b, c):
            if not t[i]:
                if not x & 1: t[i] = 1; x += 1;
                elif not x & 2: t[i] = 2; x += 2;
                else: t[i] = 4
else:
    for i in range(m):
        a, b, c = map(int, input().split())

        q[a].append((b, c))
        q[b].append((a, c))
        q[c].append((a, b))

    for x in range(1, n + 1):
        if not t[x]:
            t[x] = 1
            for j in q[x]:
                p[j[0]] |= 1
                p[j[1]] |= 1
            f(x)

p = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(''.join(p[x] for x in t[1:]))
</ans>",0,{}
79,"<ans>
```
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 missingdays <missingdays@missingdays>
#
# Distributed under terms of the MIT license.

""""""

""""""

def good(nums):
    for num in nums:
        if nums[num] > 1:
            return True
    return False

n = int(input())

a = [int(i) for i in input().split()]

print(""n: "", str(n))
print(""a: "", str(a))

s = []

print(""s: "", str(s))

l, r = 0, 0
nums = {}

print(""l: "", str(l))
print(""r: "", str(r))
print(""nums: "", str(nums))

for i in range(n):
    num = a[i]

    if num in nums:
        break
    else:
        nums[num] = True
else:
    print(-1)
    return

print(""nums: "", str(nums))

nums = {}

while r < n:
    while r < n:
        num = a[r]

        if num in nums:
            r += 1
            break
        else:
            nums[num] = True

        r += 1

    r -= 1

    s.append([l, r])
    print(""s: "", str(s))
    r += 1
    l = r

    nums = {}

print(""nums: "", str(nums))

length = len(s)

print(""length: "", str(length))

last = s[length-1]

print(""last: "", str(last))

for i in range(last[0], last[1]+1):
    num = a[i]
    if num in nums:
        print(length)
        break
    else:
        nums[num] = True
else:
    s.pop()

    s[length-2][1] = n-1

    print(length-1)

for st in s:
    for c in st:
        print(c+1, end="" "")
    print()
</ans>",0,{}
80,"<ans>
import sys
input = sys.stdin.readline

G0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G0: "", str(G0))
G1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G1: "", str(G1))
G2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G2: "", str(G2))

for x in range(1,6):
    for y in range(1,6):
        for z in range(1,6):

            for i in range(1,5500):
                s=G0[x][y][z][max(0,i-x)]
                t=G1[x][y][z][max(0,i-y)]
                u=G2[x][y][z][max(0,i-z)]

                for j in range(5):
                    if j==s or j==t or j==u:
                        continue
                    else:
                        G0[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==s or j==u:
                        continue
                    else:
                        G1[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==s or j==t:
                        continue
                    else:
                        G2[x][y][z][i]=j
                        break

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

t=int(input())
for tests in range(t):
    n,x,y,z=list(map(int,input().split()))
    B=list(map(int,input().split()))
    A=[]
    for a in B:
        if a<=5400:
            A.append(a)
        else:
            A.append(a%2520+2520)

    XOR=0
    print(""XOR: "", str(XOR))
    for a in A:
        XOR^=G0[x][y][z][a]

    ANS=0
    print(""ANS: "", str(ANS))
    for a in A:
        k=XOR^G0[x][y][z][a]

        if G0[x][y][z][max(0,a-x)]==k:
            ANS+=1

        if G1[x][y][z][max(0,a-y)]==k:
            ANS+=1

        if G2[x][y][z][max(0,a-z)]==k:
            ANS+=1

    print(ANS)

</ans>",0,{}
81,"<ans>
def dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
print(""x0: "", str(x0), ""y0: "", str(y0), ""a1: "", str(a1), ""a2: "", str(a2), ""b1: "", str(b1), ""b2: "", str(b2))
xs, ys, t = list(map(int, input().split()))
print(""xs: "", str(xs), ""ys: "", str(ys), ""t: "", str(t))
arr = []
arr.append((x0, y0))
print(""arr: "", str(arr))
now1 = x0
now2 = y0
while (1):
    now1 = a1 * now1 + b1
    now2 = a2 * now2 + b2
    print(""now1: "", str(now1), ""now2: "", str(now2))
    if (now1 < xs or now2 < ys):
        arr.append((now1, now2))
        continue
    arr.append((now1, now2))
    if (dist(now1, now2, xs, ys) > t):
        break
ans = 0
N = len(arr)
for i in range(N):
    need = dist(arr[i][0], arr[i][1], xs, ys)
    if (need > t):
        continue
    left = t - need
    now = 1
    flag = 1
    now1 = arr[i][0]
    now2 = arr[i][1]
    for j in range(i - 1, -1, -1):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        if (d > left):
            flag = 0
            break
        left -= d
        now1 = arr[j][0]
        now2 = arr[j][1]
        now += 1
    if (not flag):
        ans = max(ans, now)
        continue
    for j in range(i + 1, N):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        if (d > left):
            break
        left -= d
        now1 = arr[j][0]
        now2 = arr[j][1]
        now += 1
    ans = max(ans, now)
print(ans)
</ans>",0,{}
82,"<ans>
# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random

""""""
created by shhuan at 2017/10/6 22:19

""""""

print(""t0: "", str(time.time()))
a, b, c = list(map(int, input().split()))
print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

def ct(a, b):
    print(""a: "", str(a), ""b: "", str(b))
    if a > b:
        a, b = b, a
    L=998244353
    s=1
    sx=1
    for k in range(1,a+1):
        s = s*(a+1-k)*(b+1-k)//k
        sx += s % L
    return sx

L=998244353

print(""ct(a, b): "", str(ct(a, b)), ""ct(a, c): "", str(ct(a, c)), ""ct(b, c): "", str(ct(b, c)))
print(ct(a,b)*ct(a,c)*ct(b,c)%L)

# print(time.time()-t0)

# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]
# for i in range(1, MAXN):
#     p[i][0] = 1
#     for j in range(1, i+1):
#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD
# print(time.time() - t0)
# pre = [0] * MAXN
# pre[0] = 1
# for i in range(1, MAXN):
#     pre[i] = (i*pre[i-1]) % MOD
#
#
# def solve(x, y):
#     ans = 0
#     for k in range(min(x, y)+1):
#         d = pre[k]
#         d = (d*p[x][k]) % MOD
#         d = (d*p[y][k]) % MOD
#         ans = (ans+d) % MOD
#
#     return ans
#
# ans = 1
# ans = (ans * solve(a, b)) % MOD
# ans = (ans * solve(b, c)) % MOD
# ans = (ans * solve(a, c)) % MOD
# print(ans)
#
# print(time.time() - t0)

</ans>",0,{}
83,"<ans>
import sys
from functools import reduce

zz=1

sys.setrecursionlimit(10**5)
print(""zz: "", str(zz))
if zz:
	input=sys.stdin.readline
else:
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
di=[[-1,0],[1,0],[0,1],[0,-1]]

def fori(n):
	return [fi() for i in range(n)]
print(""fori: "", str(fori))
def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x
print(""inc: "", str(inc))
def ii():
	return input().rstrip()
print(""ii: "", str(ii))
def li():
	return [int(xx) for xx in input().split()]
print(""li: "", str(li))
def fli():
	return [float(x) for x in input().split()]
print(""fli: "", str(fli))
def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0
print(""comp: "", str(comp))
def gi():
	return [xx for xx in input().split()]
print(""gi: "", str(gi))
def gtc(tc,ans):
	print((""Case #""+str(tc)+"":"",ans))
print(""gtc: "", str(gtc))
def cil(n,m):
	return n//m+int(n%m>0)
print(""cil: "", str(cil))
def fi():
	return int(input())
print(""fi: "", str(fi))
def pro(a):
	return reduce(lambda a,b:a*b,a)
print(""pro: "", str(pro))
def swap(a,i,j):
	a[i],a[j]=a[j],a[i]
print(""swap: "", str(swap))
def si():
	return list(input().rstrip())
print(""si: "", str(si))
def mi():
	return 	list(map(int,input().split()))
print(""mi: "", str(mi))
def gh():
	sys.stdout.flush()
print(""gh: "", str(gh))
def isvalid(i,j,n,m):
	return 0<=i<n and 0<=j<m
print(""isvalid: "", str(isvalid))
def bo(i):
	return ord(i)-ord('a')
print(""bo: "", str(bo))
def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)
print(""graph: "", str(graph))

t=1
uu=t
print(""t: "", str(t))
print(""uu: "", str(uu))

def can(val):
	p=val;c=0
	for i in range(n):
		c+=abs(a[i]-p)
		p+=1
	return c
print(""can: "", str(can))

while t>0:
	t-=1
	n=fi()
	a=li()
	print(""n: "", str(n))
	print(""a: "", str(a))
	l=-2*max(a)
	r=2*max(a)
	print(""l: "", str(l))
	print(""r: "", str(r))
	mini=10**18
	print(""mini: "", str(mini))
	while l<=r:
		lmid=l+(r-l)//3
		rmid=r-(r-l)//3
		p1=can(lmid)
		p2=can(rmid)
		mini=min([mini,p1,p2])
		if p1>=p2:
			l=lmid+1
		else:
			r=rmid-1
	print(mini)

</ans>",0,{}
84,"<ans>
def local_right_to_global(test, local_right):
    print(""test: "", str(test), ""local_right: "", str(local_right))
    return(len(test) + local_right)

def local_left_to_global(test, local_left):
    print(""test: "", str(test), ""local_left: "", str(local_left))
    return(local_left)

def check_left(test, template, good_symbols):
    print(""test: "", str(test), ""template: "", str(template), ""good_symbols: "", str(good_symbols))
    left_idx = -1
    for symbol in template:
        left_idx += 1
        if symbol == '*':
            print(""left_idx: "", str(left_idx))
            return(local_left_to_global(test, left_idx))
        try:
            if test[left_idx] != template[left_idx]:
                if template[left_idx] != '?':
                    print('NO')
                    return('NO')
                elif test[left_idx] not in good_symbols:
                    print('NO')
                    return('NO')
        except:
            print('NO')
            return('NO')

def check_right(test, template, good_symbols):
    print(""test: "", str(test), ""template: "", str(template), ""good_symbols: "", str(good_symbols))
    right_idx = 0
    for symbol in reversed(template):
        right_idx -= 1
        if symbol == '*':
            print(""right_idx: "", str(right_idx))
            return(local_right_to_global(test, right_idx))
        try:
            if test[right_idx] != template[right_idx]:
                if template[right_idx] != '?':
                    print('NO')
                    return('NO')
                elif test[right_idx] not in good_symbols:
                    print('NO')
                    return('NO')
        except:
            print('NO')
            return('NO')

good_symbols = set(list(input()))
print(""good_symbols: "", str(good_symbols))
template = input()
print(""template: "", str(template))
tests_nr = int(input())
print(""tests_nr: "", str(tests_nr))
tests = []
for _ in range(tests_nr):
    tests.append(input())
print(""tests: "", str(tests))

abaca = '*' not in template
print(""abaca: "", str(abaca))
for test in tests:
    if abaca:
        pos = -1
        flag = True
        if len(test) != len(template):
            print('NO')
            continue
        for symbol in template:
            pos += 1
            try:
                if test[pos] != template[pos]:
                    if template[pos] != '?':
                        print('NO')
                        flag = False
                        break
                    elif test[pos] not in good_symbols:
                        print('NO')
                        flag = False
                        break
            except:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')
        continue
    left_idx = check_left(test, template, good_symbols)
    right_idx = check_right(test, template, good_symbols)
    print(""left_idx: "", str(left_idx), ""right_idx: "", str(right_idx))
    if left_idx == 'NO':
        print('NO')
    elif right_idx == 'NO':
        print('NO')
    else:
        if right_idx < left_idx - 1:
            print('NO')
            continue
        flag = True
        for pos in range(left_idx, right_idx + 1):
            if test[pos] in good_symbols:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')

</ans>",0,{}
85,"<ans>
n = int(input())
print(""n: "", str(n))
x0, y0 = map(int, input().split())
print(""x0: "", str(x0), ""y0: "", str(y0))
Nord = 10 ** 9 + 1
print(""Nord: "", str(Nord))
fNord = '-'
print(""fNord: "", str(fNord))
East = 10 ** 9 + 1
print(""East: "", str(East))
fEast = '-'
print(""fEast: "", str(fEast))
South = -10 ** 9 - 1
print(""South: "", str(South))
fSouth = '-'
print(""fSouth: "", str(fSouth))
West = -10 ** 9 - 1
print(""West: "", str(West))
fWest = '-'
print(""fWest: "", str(fWest))

NE = 10 ** 9 + 1
print(""NE: "", str(NE))
fNE = '-'
print(""fNE: "", str(fNE))
NW = 10 ** 9 + 1
print(""NW: "", str(NW))
fNW = '-'
print(""fNW: "", str(fNW))
SE = -10 ** 9 - 1
print(""SE: "", str(SE))
fSE = '-'
print(""fSE: "", str(fSE))
SW = -10 ** 9 - 1
print(""SW: "", str(SW))
fSW = '-'
print(""fSW: "", str(fSW))

for i in range(n):
    f, x, y = input().split()
    x = int(x)
    y = int(y)
    if x == x0:
        if y0 < y < Nord:
            fNord = f
            Nord = y
            print(""fNord: "", str(fNord), ""Nord: "", str(Nord))
        elif y0 > y > South:
            fSouth = f
            South = y
            print(""fSouth: "", str(fSouth), ""South: "", str(South))
    if y == y0:
        if x0 < x < East:
            fEast = f
            East = x
            print(""fEast: "", str(fEast), ""East: "", str(East))
        elif x0 > x > West:
            fWest = f
            West = x
            print(""fWest: "", str(fWest), ""West: "", str(West))

    if x + y == x0 + y0:
        if y0 < y < NW:
            fNW = f
            NW = y
            print(""fNW: "", str(fNW), ""NW: "", str(NW))
        elif y0 > y > SE:
            fSE = f
            SE = y
            print(""fSE: "", str(fSE), ""SE: "", str(SE))
    if x - y == x0 - y0:
        if y0 < y < NE:
            fNE = f
            NE = y
            print(""fNE: "", str(fNE), ""NE: "", str(NE))
        elif y0 > y > SW:
            fSW = f
            SW = y
            print(""fSW: "", str(fSW), ""SW: "", str(SW))

ans  = False
print(""ans: "", str(ans))
if fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':
    ans = True
    print(""ans: "", str(ans))
if fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':
    ans = True
    print(""ans: "", str(ans))
if fSW == 'B' or fSE == 'Q' or fNW == 'B' or fNE == 'B':
    ans = True
    print(""ans: "", str(ans))
if fNord == 'R' or fSouth == 'R' or fWest == 'R' or fEast == 'R':
    ans = True
    print(""ans: "", str(ans))

print('YES' if ans else 'NO')
</ans>",0,{}
86,"<ans>
#n, m = map(int, input().split())
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))
ans = int(n * (n - 1) / 2)
print(""ans: "", str(ans))
c = 0
print(""c: "", str(c))
for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0
print(""c: "", str(c))
for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
s = s[::-1]
print(""s: "", str(s))
c = 0
for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0
print(""c: "", str(c))
for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0
print(""c: "", str(c))
if s[0] == 'A':
    c += 1
for i in range(n):
    if s[i] == 'A':
        c += 1
    elif c >= 1:
        ans -= 1
        c = 0
c = 0
print(""c: "", str(c))
if s[0] == 'B':
    c += 1
for i in range(n):
    if s[i] == 'B':
        c += 1
    elif c >= 1:
        ans -= 1
        c = 0
print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
87,"<ans>
#!/usr/bin/env python3


class CantException(Exception):
    pass


def odd_v(value):
    return 1 if value % 2 == 1 else -1

change_idx = 1

acceptable = {-1: set(), 1: set()}

print(""change_idx: "", str(change_idx))
print(""acceptable: "", str(acceptable))

def change(card_values, oddv, m):
    nonlocal change_idx

    if acceptable[oddv]:
        res = acceptable[oddv].pop()
        card_values.add(res)
        print(""card_values: "", str(card_values))
        return res

    change_idx_start = change_idx

    while change_idx in card_values or odd_v(change_idx) != oddv:
        if change_idx not in card_values:
            acceptable[odd_v(change_idx)].add(change_idx)
            print(""acceptable[odd_v(change_idx)]: "", str(acceptable[odd_v(change_idx)]))
        change_idx += 1
        if change_idx > m:
            change_idx = 1
        if change_idx == change_idx_start:
            raise CantException()

    res = change_idx
    card_values.add(res)
    print(""card_values: "", str(card_values))

    change_idx += 1
    if change_idx > m:
        change_idx = 1
    return res

def solve():
    n, m = list(map(int, input().split()))
    cards = list(map(int, input().split()))

    odd_balance = 0
    card_values = set()
    indices_to_be_changed = set()

    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
        if c in card_values:
            indices_to_be_changed.add(i)
        card_values.add(c)

    print(""indices to be changed: "", str(indices_to_be_changed))
    change_count = len(indices_to_be_changed)

    for i in indices_to_be_changed:
        if odd_v(cards[i]) * odd_balance <= 0:
            print(""Changing "", cards[i])
            cards[i] = change(card_values, odd_v(cards[i]), m)
            print(""Changed to "", cards[i])
        else:
            print(""For the balance changing "", cards[i])
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, - odd_v(cards[i]), m)
            print(""Changed to "", cards[i])

    print(""current odd balance:"", odd_balance)
    for i in range(len(cards)):
        if odd_balance == 0:
            break
        if odd_v(cards[i]) * odd_balance > 0:
            print(""gonna change"")
            change_count += 1
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, -odd_v(cards[i]), m)

    odd_balance = 0
    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
    if odd_balance != 0:
        print(odd_balance)
        print(""WTFFFFF"")

    return change_count, cards

def __starting_point():
    try:
        change_cnt, cards = solve()
        print(change_cnt)
        print("" "".join(map(str, cards)))
    except CantException:
        print(""-1"")

__starting_point()
</ans>",0,{}
88,"<ans>
def dp(ind, max_covered):
	max_covered = min(m, max_covered)

	if ind not in cache:
		cache[ind] = {}

	d = cache[ind]
	if max_covered in d:
		return d[max_covered]

	ans = blah(ind, max_covered)

	d[max_covered] = ans
	print(""cache[ind]: "", str(cache[ind]))
	return ans


# path = {}

class Node:
	def __init__(self, key, val, next=None):
		self.key = key
		self.val = val
		self.next = next

def blah(ind, max_covered):
	x, s = antenna[ind]
	# key = (ind, max_covered)

	if max_covered >= m:
		# path[key] = Node(key, 0)
		return 0

	if ind == len(antenna) - 1:
		if max_covered < x - s - 1:
			left_needed = x - s - (max_covered + 1)
			right_needed = max(m - (x + s), 0)
			ans = max(left_needed, right_needed)
			# path[key] = Node(key, ans)
			return ans
		else:
			right_boundary = max(max_covered, x + s)
			ans = max(0, m - right_boundary)
			# path[key] = Node(key, ans)
			return ans

	if max_covered < x - s - 1:
		num_needed = x - s - (max_covered + 1)
		new_boundary = min(x + s + num_needed, m)
		use_i = num_needed + dp(ind + 1, new_boundary)
		dont_use_i = dp(ind + 1, max_covered)

		# if use_i < dont_use_i:
		# 	path[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])
		# else:
		# 	path[key] = Node(key, 0, path[(ind + 1, max_covered)])

		return min(use_i, dont_use_i)
	else:
		new_boundary = min(max(max_covered, x + s), m)
		ans = dp(ind + 1, new_boundary)
		# path[key] = Node(key, 0, path[(ind + 1, new_boundary)])
		return ans

import sys

cache = {}

n, m = [int(x) for x in sys.stdin.readline().split("" "")]

antenna = []

for i in range(n):
	x, s = [int(x) for x in sys.stdin.readline().split("" "")]

	antenna.append((x, s))

antenna.sort(key=lambda a: a[0])

print(dp(0, 0))

</ans>",0,{}
89,"<ans>
import math;
#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(gx, gy, alpha, x, y):
    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);
    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);
    print(""x1: "", str(x1), ""y1: "", str(y1))
    return x1, y1
#Вычисление угла, на который надо повернуть точку с координатами x, y,
#чтобы она оказалась прямо над gx, gy
def getAngle(gx, gy, x, y):
    x=x-gx;
    y=y-gy;
    cos=x/math.sqrt(x**2+y**2);
    alpha=math.acos(cos);
    if y<0:
        alpha=-alpha;
    print(""alpha: "", str(alpha))
    return math.pi/2-alpha;
n, q = list(map(int, input().split(' ')));
print(""n: "", str(n), ""q: "", str(q))
x=[0]*n;
y=[0]*n;
for i in range(n):
    x[i], y[i]=list(map(int, input().split(' ')));
print(""x: "", str(x), ""y: "", str(y))
r=[0]*q;
f=[0]*q;
t=[0]*q;
v=[0]*q;
for i in range(q):
    l=list(map(int, input().split(' ')));
    r[i]=l[0];
    if r[i]==1:
        f[i]=l[1]-1;
        t[i]=l[2]-1;
    else:
        v[i]=l[1]-1;
print(""r: "", str(r), ""f: "", str(f), ""t: "", str(t), ""v: "", str(v))
gx=0;
gy=0;
s=0;
for i in range(n):
    ip=i+1;
    if ip==n:
        ip=0;
    ds=x[i]*y[ip]-x[ip]*y[i];
    s+=ds;
    gx+=(x[i]+x[ip])*ds;
    gy+=(y[i]+y[ip])*ds;
s/=2;
gx/=6*s;
gy/=6*s;
print(""gx: "", str(gx), ""gy: "", str(gy))
angles=[0]*n;
for i in range(n):
    angles[i]=getAngle(gx, gy, x[i], y[i]);
print(""angles: "", str(angles))
for i in range(n):
    x[i]-=gx;
    y[i]-=gy;
alpha=0;
#print('pos',gx, gy, alpha);
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
fix={0, 1}
for i in range(q):
    if r[i]==2:
        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);
        print(""currX: "", str(currX), ""currY: "", str(currY))
    else:
        if len(fix)==2:
            fix.remove(f[i]);
        #print('remove',f[i])
        #j - единственный элемент в множестве
        for j in fix:
            #print(j);
            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);
            #print('fix:', currX, currY)
            #dalpha=getAngle(gx, gy, currX, currY);
            #alpha+=dalpha;
            alpha=angles[j];
            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол
            #dalpha относительно currX, currY
            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);
            print(""gx: "", str(gx), ""gy: "", str(gy), ""alpha: "", str(alpha/math.pi))
        fix.add(t[i]);
</ans>",0,{}
90,"<ans>
import collections, atexit, math, sys, bisect

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass

inId = 0
outId = 0
print(""inId: "", str(inId))
print(""outId: "", str(outId))
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit

N, = getIntList()
print(""N: "", str(N))
re = 1
mc = 1
zc = []
for i in range(2, 10000):
    if N%i != 0 : continue
    re *= i
    c = 0
    while N%i==0:
        N//=i
        c+=1

    zc.append(c)
if N>1:
    re*=N
    zc.append(1)
if zc:
    mc = max(zc)
t =1
for i in range(100):
    if mc<=t:
        break
    t*=2
dprint(t)
dprint(zc)
g = i
for x in zc:
    if x<t:
        g+=1
        break

print(re,g)

</ans>",0,{}
91,"<ans>
#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=1000000007
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
vsInput()

n, m, o = value()
print(""n: "", str(n), ""m: "", str(m), ""o: "", str(o))
for i in range(n):
    input()

print(""m*(m-1)//2: "", str(m*(m-1)//2))
for i in range(1, m+1):
    for j in range(i+1, m+1):
        if(o == 0):
            print(""i: "", str(i), ""j: "", str(j))
        else:
            print(""m-i+1: "", str(m-i+1), ""m-j+1: "", str(m-j+1))
</ans>",0,{}
92,"<ans>
def solve1(a, n):
    left = []
    st = []
    i = 0
    while i < (n):
        if not st:
            left.append(-1)
            st.append(i)
        elif st and a[i] < a[st[-1]]:
            left.append(st[-1])
            st.append(i)
        else:
            while st and a[i] > a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                left.append(-1)
            else:
                left.append(st[-1])
                st.append(i)
        i += 1
    print(""left: "", str(left))
    right = []
    st = []
    i = n - 1
    while i > (-1):
        if not st:
            right.append(n)
            st.append(i)
        elif st and a[i] < a[st[-1]]:
            right.append(st[-1])
            st.append(i)
        else:
            while st and a[i] >= a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                right.append(n)
            else:
                right.append(st[-1])
                st.append(i)
        i -= 1
    right = right[::-1]
    print(""right: "", str(right))
    c = 0
    for i in range(len(left)):
        x = (right[i] - i) * (i - left[i]) * a[i]
        print(""x: "", str(x))
        if x == 0:
            c += a[i]
        else:
            c += x
    print(""c: "", str(c))
    return c

def solve2(a, n):
    left = []
    st = []
    i = 0
    while i < (n):
        if not st:
            left.append(-1)
            st.append(i)
        elif st and a[i] > a[st[-1]]:
            left.append(st[-1])
            st.append(i)
        else:
            while st and a[i] < a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                left.append(-1)
            else:
                left.append(st[-1])
                st.append(i)
        i += 1
    print(""left: "", str(left))
    right = []
    st = []
    i = n - 1
    while i > (-1):
        if not st:
            right.append(n)
            st.append(i)
        elif st and a[i] > a[st[-1]]:
            right.append(st[-1])
            st.append(i)
        else:
            while st and a[i] <= a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                right.append(n)
            else:
                right.append(st[-1])
                st.append(i)
        i -= 1
    right = right[::-1]
    print(""right: "", str(right))
    c = 0
    for i in range(len(left)):
        x = (right[i] - i) * (i - left[i]) * a[i]
        print(""x: "", str(x))
        if x == 0:
            c += a[i]
        else:
            c += x
    print(""c: "", str(c))
    return c

n = int(input())
arr = [int(x) for x in input().split()]
print(""n: "", str(n))
print(""arr: "", str(arr))
print(solve1(arr, n) - solve2(arr, n))
</ans>",0,{}
93,"<ans>
import math
N=int(input())

def get_circle_2p(p1,p2):
  x1,y1=p1
  x2,y2=p2

  print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))

  x=(x1+x2)/2
  y=(y1+y2)/2
  print(""x: "", str(x), ""y: "", str(y))

  r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
  print(""r: "", str(r))
  return x,y,r

def get_circle_3p(p1,p2,p3):
  x1,y1=p1
  x2,y2=p2
  x3,y3=p3
  print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2), ""x3: "", str(x3), ""y3: "", str(y3))

  d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))
  print(""d: "", str(d))

  if d==0:
    rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
    rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2
    rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2
    print(""rad1: "", str(rad1), ""rad2: "", str(rad2), ""rad3: "", str(rad3))

    if rad1>=rad2 and rad1>=rad3:
      x=(x1+x2)/2
      y=(y1+y2)/2
      print(""x: "", str(x), ""y: "", str(y))
      return x,y,rad1
    elif rad2>=rad1 and rad2>=rad3:
      x=(x1+x3)/2
      y=(y1+y3)/2
      print(""x: "", str(x), ""y: "", str(y))
      return x,y,rad2
    elif rad3>=rad1 and rad3>=rad2:
      x=(x2+x3)/2
      y=(y2+y3)/2
      print(""x: "", str(x), ""y: "", str(y))
      return x,y,rad3
  else:
    x=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/d
    y=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-d
    print(""x: "", str(x), ""y: "", str(y))

    r=math.sqrt((x-x1)**2+(y-y1)**2)
    print(""r: "", str(r))
    return x,y,r

xylist=[]
for i in range(N):
  xi,yi=map(int,input().split())
  print(""xi: "", str(xi), ""yi: "", str(yi))
  xylist.append((xi,yi))

#print(xylist)

if N==2:
  x,y,r=get_circle_2p(xylist[0],xylist[1])
  print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
  print(r)
else:
  min_radius=float(""inf"")
  for i in range(N):
    for j in range(i+1,N):
      #print(xylist[i],xylist[j])
      x,y,r=get_circle_2p(xylist[i],xylist[j])
      print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
      if r>min_radius:
        continue

      for l in range(N):
        if l==i or l==j:
          continue

        xl,yl=xylist[l]
        print(""xl: "", str(xl), ""yl: "", str(yl))

        diff_xl=xl-x
        diff_yl=yl-y
        print(""diff_xl: "", str(diff_xl), ""diff_yl: "", str(diff_yl))

        if math.sqrt(diff_xl**2+diff_yl**2)>r:
          break
      else:
        min_radius=r

  for i in range(N):
    for j in range(i+1,N):
      for k in range(j+1,N):
        #print(xylist[i],xylist[j],xylist[k])
        x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])
        print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
        if r>min_radius:
          continue

        for l in range(N):
          if l==i or l==j or l==k:
            continue

          xl,yl=xylist[l]
          print(""xl: "", str(xl), ""yl: "", str(yl))

          diff_xl=xl-x
          diff_yl=yl-y
          print(""diff_xl: "", str(diff_xl), ""diff_yl: "", str(diff_yl))

          if math.sqrt(diff_xl**2+diff_yl**2)>r:
            break
        else:
          min_radius=r

  print(""min_radius: "", str(min_radius))
  print(min_radius)
</ans>",0,{}
94,"<ans>
import math
from decimal import Decimal
import heapq
from collections import deque
def na():
	n = int(input())
	b = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	return n,b

def nab():
	n = int(input())
	b = [int(x) for x in input().split()]
	c = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	print(""c: "", str(c))
	return n,b,c

def dv():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n))
	print(""m: "", str(m))
	return n,m

def dva():
	n, m = list(map(int, input().split()))
	a = [int(x) for x in input().split()]
	b = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""m: "", str(m))
	print(""a: "", str(a))
	print(""b: "", str(b))
	return n,m,b

def eratosthenes(n):
	sieve = list(range(n + 1))
	print(""sieve: "", str(sieve))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))

def lol(lst,k):
	k=k%len(lst)
	ret=[0]*len(lst)
	print(""lst: "", str(lst))
	print(""k: "", str(k))
	print(""ret: "", str(ret))
	for i in range(len(lst)):
		if i+k<len(lst) and i+k>=0:
			ret[i]=lst[i+k]
		if i+k>=len(lst):
			ret[i]=lst[i+k-len(lst)]
		if i+k<0:
			ret[i]=lst[i+k+len(lst)]
	return(ret)

def nm():
	n = int(input())
	b = [int(x) for x in input().split()]
	m = int(input())
	c = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	print(""m: "", str(m))
	print(""c: "", str(c))
	return n,b,m,c

def dvs():
	n = int(input())
	m = int(input())
	print(""n: "", str(n))
	print(""m: "", str(m))
	return n, m

def fact(a, b):
	c = []
	ans = 0
	f = int(math.sqrt(a))
	print(""a: "", str(a))
	print(""b: "", str(b))
	print(""c: "", str(c))
	print(""ans: "", str(ans))
	print(""f: "", str(f))
	for i in range(1, f + 1):
		if a % i == 0:
			c.append(i)
	l = len(c)
	for i in range(l):
		c.append(a // c[i])
	for i in range(len(c)):
		if c[i] <= b:
			ans += 1
	if a / f == f and b >= f:
		return ans - 1
	return ans

t = int(input())
for i in range(t):
	x, y = list(map(int, input().split()))
	print(""x: "", str(x))
	print(""y: "", str(y))
	if x >= y:
		print('YES')
		continue
	if x == 2 and y == 3:
		print('YES')
		continue
	elif x <= 3 and y > 3:
		print('NO')
		continue
	if x == 1:
		print('NO')
	else:
		print('YES')
</ans>",0,{}
95,"<ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(x) for x in input().split(' ')]
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))

if k&1:
  print('IMPOSSIBLE')
  return

s = [None]*n
for i in range(n):
  s[i] = [None]*m
  t = input()
  for j in range(m):
    s[i][j] = t[j]
    if t[j] == 'X': x, y = j, i
print(""x: "", str(x), ""y: "", str(y))

def bfs(x, y):
  res = [[10000000]*m for i in range(n)]
  if s[y][x] == '*': return res
  q = Queue()
  q.put((x, y))
  step = 0

  def add(x, y):
    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return
    q.put((x, y))
    res[y][x] = step+1

  res[y][x] = step

  while not q.empty():
    x, y = q.get()
    step = res[y][x]
    #print('-')
    if y < n-1: add(x, y+1) #D
    if x > 0: add(x-1, y)   #L
    if x < m-1: add(x+1, y) #R
    if y > 0: add(x, y-1)   #U
  return res

res = bfs(x, y)
print(""res: "", str(res))

path = []
add = lambda s: path.append(s)
for i in range(k):
  step = k-i
  #print(step, (y, x), k-i)
  if y < n-1 and res[y+1][x] <= step: #D
    add('D')
    y = y+1
  elif x > 0 and res[y][x-1] <= step: #L
    add('L')
    x = x-1
  elif x < m-1 and res[y][x+1] <= step: #R
    add('R')
    x = x+1
  elif y > 0 and res[y-1][x] <= step: #U
    add('U')
    y = y-1
  else:
    print('IMPOSSIBLE')
    return

print(""path: "", str(path))
print(str.join('', path))

</ans>",0,{}
96,"<ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

inf = float('inf')
Edge = namedtuple('Edge', 'start, end, cost')

def make_edge(start, end, cost=1):
    print(""start: "", str(start), ""end: "", str(end), ""cost: "", str(cost))
    return Edge(start, end, cost)

class Graph:
    def __init__(self, edges, bi=True):
        wrong_edges = [i for i in edges if len(i) not in [2, 3]]
        if wrong_edges:
            raise ValueError('Wrong edges data: {}'.format(wrong_edges))
        self.edges = [make_edge(*edge) for edge in edges]
        print(""self.edges: "", str(self.edges))
        self.vertices = set(
            sum(
                ([edge.start, edge.end] for edge in self.edges), []
            ))
        print(""self.vertices: "", str(self.vertices))
        self.neighbors = {vertex: set() for vertex in self.vertices}
        print(""self.neighbors: "", str(self.neighbors))
        for edge in self.edges:
            self.neighbors[edge.start].add(edge.end)

    def get_node_pairs(self, n1, n2, both_ends=True):
        print(""n1: "", str(n1), ""n2: "", str(n2), ""both_ends: "", str(both_ends))
        if both_ends:
            node_pairs = [[n1, n2], [n2, n1]]
        else:
            node_pairs = [[n1, n2]]
        return node_pairs

    def remove_edge(self, n1, n2, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        edges = self.edges[:]
        for edge in edges:
            if[edge.start, edge.end] in node_pairs:
                self.edges.remove(edge)

    def add_edge(self, n1, n2, cost=1, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        for edge in self.edges:
            if [edge.start, edge.end] in node_pairs:
                return ValueError('Edge {} {} already exists'.format(n1, n2))

        self.edges.append(Edge(start=n1, end=n2, cost=cost))
        print(""self.edges: "", str(self.edges))
        if both_ends:
            self.edges.append(Edge(start=n2, end=n1, cost=cost))

    def dijkstra(self, source, dest):
        assert source in self.vertices, 'Such source node doesn\'t exist'
        distances = {vertex: inf for vertex in self.vertices}
        distances[source] = 0
        print(""distances: "", str(distances))

        q, seen = [(0, source)], set()
        while q:
            (curr_cost, current_vertex) = heappop(q)
            if current_vertex in seen:
                continue
            seen.add(current_vertex)
            for neighbor in self.neighbors[current_vertex]:
                cost = 1
                if neighbor in seen:
                    continue
                alternative_route = distances[current_vertex] + cost
                if alternative_route < distances[neighbor]:
                    distances[neighbor] = alternative_route
                    heappush(q, (alternative_route, neighbor))

        return distances

n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]
print(""n: "", str(n), ""m: "", str(m), ""s: "", str(s), ""t: "", str(t))

verts = []
for i in range(m):
    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
print(""verts: "", str(verts))
rev_verts = []
for i in verts:
    rev_verts.append((i[1], i[0]))
for i in rev_verts:
    verts.append(i)
print(""verts: "", str(verts))
graph = Graph(verts)
print(""graph: "", str(graph))
s_dist = graph.dijkstra(s, t)
print(""s_dist: "", str(s_dist))
t_dist = graph.dijkstra(t, s)
print(""t_dist: "", str(t_dist))
SHORTEST_DIST = s_dist[t]
print(""SHORTEST_DIST: "", str(SHORTEST_DIST))
count = 0

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        if j not in graph.neighbors[i] and \
                i not in graph.neighbors[j] and \
                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \
                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:
            count = count + 1

print(""count: "", str(count))

</ans>",0,{}
97,"<ans>
N, K = readInts()
print(""N: "", str(N), ""K: "", str(K))
def calc(n):
    print(""n: "", str(n))
    if n <= 0 or n > 2*N:
        return 0
    else:
        return min(n-1, 2*N-n+1)
ans = 0
for AB in range(2*N+1):
    print(""AB: "", str(AB))
    #print(AB,calc(AB),AB-K, calc(K-AB))
    ans += calc(AB) * calc(AB-K)
print(""ans: "", str(ans))
</ans>",0,{}
98,"<ans>
import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline    ####
def int1(x): return int(x) - 1
print(""int1: "", str(int1))
def II(): return int(input())
print(""II: "", str(II))
def MI(): return list(map(int, input().split()))
print(""MI: "", str(MI))
def MI1(): return list(map(int1, input().split()))
print(""MI1: "", str(MI1))
def LI(): return list(map(int, input().split()))
print(""LI: "", str(LI))
def LI1(): return list(map(int1, input().split()))
print(""LI1: "", str(LI1))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
print(""LLI: "", str(LLI))
def MS(): return input().split()
print(""MS: "", str(MS))
def LS(): return list(input())
print(""LS: "", str(LS))
def LLS(rows_number): return [LS() for _ in range(rows_number)]
print(""LLS: "", str(LLS))
def printlist(lst, k=' '): print((k.join(list(map(str, lst)))))
print(""printlist: "", str(printlist))
INF = float('inf')
print(""INF: "", str(INF))
# from math import ceil, floor, log2
# from collections import deque
from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum  # accumulate

def solve():
    N, K = MI()
    print(""N: "", str(N), ""K: "", str(K))
    A = LI()
    print(""A: "", str(A))

    M = sum(A)
    print(""M: "", str(M))
    divs = []
    for i in range(1, int(pow(M, 0.5))+1):
        if M % i: continue
        divs.append(i)
        if i != M//i: divs.append(M//i)
    divs.sort(reverse=True)
    print(""divs: "", str(divs))

    for d in divs:
        B = list([x%d for x in A])
        print(""B: "", str(B))
        B.sort()
        C = list([d-x for x in B])
        print(""C: "", str(C))
        Ba = list(accumulate(B))
        print(""Ba: "", str(Ba))
        Ca = list(accumulate(C))
        print(""Ca: "", str(Ca))
        for i in range(0, N-1):
            b = Ba[i]
            c = Ca[-1] - Ca[i]
            print(""b: "", str(b), ""c: "", str(c))
            if b == c and b <= K:
                print(d)
                return
    print((1))


def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
99,"<ans>
import sys

def matching(node, visited, adj, assigned):
	if node == -1:
		return True
	if visited[node]:
		return False
	visited[node] = True
	print(""visited: "", str(visited))
	for neighbor in adj[node]:
		if matching(assigned[neighbor], visited, adj, assigned):
			assigned[neighbor] = node
			print(""assigned: "", str(assigned))
			return True
	return False

INF = 1000 * 1000

inp = [int(x) for x in sys.stdin.read().split()]

print(""inp: "", str(inp))

n, m = inp[0], inp[1]
print(""n: "", str(n), ""m: "", str(m))
inp_idx = 2

G = [[INF] * n for _ in range(n)]

print(""G: "", str(G))

for _ in range(m):
	a, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1
	inp_idx += 2
	G[a][b] = G[b][a] = 1

for v in range(n):
	G[v][v] = 0

for k in range(n):
	for i in range(n):
		for j in range(n):
			G[i][j] = min(G[i][j], G[i][k] + G[k][j])

s, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]
print(""s: "", str(s), ""b: "", str(b), ""k: "", str(k), ""h: "", str(h))
inp_idx += 4

spaceships = []
for _ in range(s):
	x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]
	inp_idx += 3
	spaceships.append((x, a, f))
	print(""spaceships: "", str(spaceships))

bases = []
for _ in range(b):
	x, d = inp[inp_idx] - 1, inp[inp_idx + 1]
	inp_idx += 2
	bases.append((x, d))
	print(""bases: "", str(bases))

adj = [[] for _ in range(s)]
assigned = [[] for _ in range(b)]
for i in range(s):
	space = spaceships[i]
	for j in range(b):
		base = bases[j]
		u, v = space[0], base[0]
		fuel = space[2]
		if G[u][v] <= fuel and space[1] >= base[1]:
			adj[i].append(j)
	print(""adj: "", str(adj))
	print(""assigned: "", str(assigned))

visited = [False] * s
assigned = [-1] * b

matched = 0
for i in range(s):
	visited = [False] * s
	if matching(i, visited, adj, assigned):
		matched += 1

print(""matched: "", str(matched))

print(min(matched * k, h * s))
</ans>",0,{}
100,"<ans>
import sys

inp = sys.stdin.readline
input = lambda: inp().strip()

# flush= sys.stdout.flush
# import threading
# sys.setrecursionlimit(10**6)
# threading.stack_size(2**26)

def iin(): return int(input())

def lin(): return list(map(int, input().split()))

def main():
    import heapq as hq
    n = iin()
    print(""n: "", str(n))
    a = lin()
    print(""a: "", str(a))
    t = lin()
    print(""t: "", str(t))
    dc = {}
    for i in range(n):
        try:
            dc[a[i]].append(t[i])
        except:
            dc[a[i]] = [t[i], ]
    print(""dc: "", str(dc))
    sa = list(dc.keys())
    print(""sa: "", str(sa))
    sa.sort()
    print(""sa (sorted): "", str(sa))
    n = len(sa)
    ch = 0
    pt = sa[ch]
    temp = []
    sm = 0
    ans = 0
    hq.heapify(temp)
    done = 0
    while ch < n:
        # print(temp, sa[ch])
        pt = sa[ch]
        if len(dc[pt]) > 1 or done:
            a1 = sorted(dc[pt])
            for item in a1:
                hq.heappush(temp, -item)
                sm += item
            x = hq.heappop(temp) * (-1)
            dc[pt] = [x]
            sm -= x
            while len(temp):
                # print('A', ch, pt, temp )
                ans += sm
                pt += 1
                if pt in dc:
                    ch += 1
                    done = 1
                    break
                else:
                    x = hq.heappop(temp) * (-1)
                    sm -= x
            else:
                done = 0
        else:
            ch += 1
            done = 0
    # print(dc)
    print(""ans: "", str(ans))

main()
</ans>",0,{}
101,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return [int(i) for i in input().split()]
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    print(""n: "", str(n))
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    print(""n: "", str(n))
    print(""start: "", str(start))
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    print(""n: "", str(n))
    print(""primes: "", str(primes))
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    print(""n: "", str(n))
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    print(""sqr: "", str(sqr))
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    print(""number: "", str(number))
    print(""base: "", str(base))
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

for _ in range(ii()):
    a, b = mi()
    print(""a: "", str(a))
    print(""b: "", str(b))
    print(b - a % b) if a % b else print(0)
</ans>",0,{}
102,"<ans>
```
def add(a,b):
	a = a%(1000000000+7)
	b=b%(1000000000+7)
	print(""a: "", str(a), ""b: "", str(b))
	return (a+b)%(1000000000+7)

n  =int(input())
print(""n: "", str(n))
i=1
statements = []
dp = [[0 for i in range(n)] for i in range(n)]
prefix = [[0 for i in range(n)] for i in range(n)]
while(i<=n):
	s = input()
	statements.append(s)
	i+=1

dp[0][0]=1
prefix[0][0]=1
j=1
while(j<n):
	dp[0][j]=0
	prefix[0][j] = dp[0][j] + prefix[0][j-1]
	j+=1

i=1
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		while(j<n):
			dp[i][0]=0
			prefix[i][0]=0
			dp[i][j] = dp[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			print(""dp[i][j]: "", str(dp[i][j]), ""prefix[i][j]: "", str(prefix[i][j]))
			j+=1
	else:
		j=0
		while(j<n):
			if(j==0):
				dp[i][j] = prefix[i-1][n-1]
			else:
				dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			print(""dp[i][j]: "", str(dp[i][j]), ""prefix[i][j]: "", str(prefix[i][j]))
			j+=1
	i+=1

ans = 0
j=0
while(j<n):
	ans=add(ans,dp[n-1][j])
	j+=1

print(""ans: "", str(ans%(1000000000+7)))
```
</ans>",0,{}
103,"<ans>
def compute():
    n, m = [int(s) for s in input().split()]
    print(""n: "", str(n), ""m: "", str(m))
    p = {}
    print(""p: "", str(p))
    for i in range(m):
        u, v = [int(s) for s in input().split()]
        print(""u: "", str(u), ""v: "", str(v))
        if u > v:
            if p.get(u) == 2:
                return 0
            if p.get(v) == 1:
                return 0
            p[u] = 1
            p[v] = 2
        else:
            if p.get(v) == 2:
                return 0
            if p.get(u) == 1:
                return 0
            p[v] = 1
            p[u] = 2
    div1, div2 = [], []
    print(""div1: "", str(div1), ""div2: "", str(div2))
    for k, v in list(p.items()):
        if v == 1:
            div1.append(k)
        else:
            div2.append(k)
    p_left = [i for i in range(1, n + 1) if i not in p]
    print(""p_left: "", str(p_left))
    if not div1:
        if p_left:
            div1.append(p_left[-1])
            p_left.remove(p_left[-1])
        else:
            return 0
    if not div2:
        if p_left:
            div2.append(p_left[0])
            p_left.remove(p_left[0])
        else:
            return 0
    div1_easiest = min(div1)
    div2_hardest = max(div2)
    print(""div1_easiest: "", str(div1_easiest), ""div2_hardest: "", str(div2_hardest))
    if div2_hardest > div1_easiest:
        return 0

    res = 1
    for i in range(len(p_left)):
        if p_left[i] > div1_easiest:
            pass
        elif p_left[i] < div2_hardest:
            pass
        else:
            res += 1

    return res
res = compute()
print(res)
</ans>",0,{}
104,"<ans>
import itertools


class SolutionImpossible(Exception):
    pass


blocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]
print(""blocks_cnt: "", str(blocks_cnt), ""finish: "", str(finish), ""min_sprint: "", str(min_sprint), ""max_jump: "", str(max_jump))

def read_blocks_coords():
    it = (int(x) for x in input().split())
    return (x for x in it if x < finish)
print(""read_blocks_coords: "", str(read_blocks_coords))

# TODO: код можно сократить за счет избавления от лишней записи в `_grouper._current_key`
def _grouper(value):
    if _grouper._prev_value is not None:
        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        if value - _grouper._prev_value - 1 <= min_sprint:
            # расстояние между препятствиями слишком мало
            # чтобы между ними приземляться, и затем разогнаться для нового прыжка, считаем их за одно
            _current_key = _grouper._current_key
        else:
            _current_key = id(value)
    else:
        # первое вхождение, ставим данные по умолчанию
        _current_key = id(_grouper)

    _grouper._prev_value = value
    _grouper._current_key = _current_key

    return _current_key
print(""_grouper._prev_value: "", str(_grouper._prev_value), ""_grouper._current_key: "", str(_grouper._current_key))

_grouper._prev_value = None
_grouper._current_key = None
print(""_grouper._prev_value: "", str(_grouper._prev_value), ""_grouper._current_key: "", str(_grouper._current_key))

def check_chunk(run_from, block=None):
    if block is None:
        return

    next_run_from = block[-1] + 1  # следующая за преградой позиция (точка приземления)
    if next_run_from - block[0] >= max_jump:
        # если преграда слишком длинная, то мы не можем ее пересечь
        raise SolutionImpossible

    if abs(run_from - block[0]) <= min_sprint:
        # нет возможности для разбега
        raise SolutionImpossible


def solve_chunk(run_from, block=None):
    if block is not None:
        run_len = block[0] - run_from - 1  # добегаем ДО преграды
        jump_len = block[-1] - block[0] + 2  # прыгаем ЗА нее
        print((
            ""RUN {run_len}\n""
            ""JUMP {jump_len}"".format(
                run_len=run_len,
                jump_len=jump_len,
            )
        ))

    else:
        run_len = finish - run_from
        if run_len > 0:
            print(""RUN {run_len}"".format(run_len=run_len))


def main():
    # некоторые препятствия могут находиться так близко, что между ними нет возможности разогнаться
    # считаем такие препятствия за одно
    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))
    print(""blocks: "", str(blocks))

    chunks = []

    run_from = 0
    while True:
        block = next(blocks, None)

        chunk = (run_from, block)
        check_chunk(*chunk)

        chunks.append(chunk)

        if block is None:
            break

        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        run_from = block[-1] + 1

    #print(chunks)

    for chunk in chunks:
        solve_chunk(*chunk)


def __starting_point():
    try:
        main()
    except SolutionImpossible:
        print(""IMPOSSIBLE"")

__starting_point()
</ans>",0,{}
105,"<ans>
#import sys
#sys.stdin = open('in.txt')
#sys.setrecursionlimit(10000)
def isPrefix(sa, sb):
    print(""sa: "", str(sa), ""sb: "", str(sb))
    if len(sa) <= len(sb):
        return False
    return sa[0:len(sb)] == sb

def getOrder(sa, sb):
    print(""sa: "", str(sa), ""sb: "", str(sb))
    for i in range(0, min(len(sa), len(sb))):
        if sa[i] != sb[i]:
            return sa[i], sb[i]

test = False
print(""test: "", str(test))
if test:
    fp = open(""in.txt"", 'r')
    print(""fp: "", str(fp))
    n = int(fp.readline().strip())
    print(""n: "", str(n))
    names = [fp.readline().strip() for i in range(0, n)]
    print(""names: "", str(names))
    fp.close()
else:
    n = int(input().strip())
    print(""n: "", str(n))
    names = [input().strip() for i in range(0, n)]
    print(""names: "", str(names))

g = [[False] * 26 for i in range(0, 26)]
print(""g: "", str(g))

res = True
print(""res: "", str(res))
for i in range(1, n):
    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):
        continue
    elif isPrefix(names[i - 1], names[i]):
        res = False
        break
    else:
        ca, cb = getOrder(names[i - 1], names[i])
        print(""ca: "", str(ca), ""cb: "", str(cb))
        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:
            res = False
            break
        else:
            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True

def printG():
    print(""   abcdefghijklmnopqrstuvwxyz"")
    for i in range(0, 26):
        print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in g[i]]), sep =

"""")
#printG()

if not res:
    print(""Impossible"")
else:

    def getZeroIndegreeNode():
        print(""used: "", str(used), ""indegree: "", str(indegree))
        for i in range(0, 26):
            if not used[i] and indegree[i] == 0:
                return i
        return -1
    print(""getZeroIndegreeNode: "", str(getZeroIndegreeNode()))
    #topo sort
    theOrder = []
    indegree = [0] * 26
    used = [False] * 26
    print(""theOrder: "", str(theOrder), ""indegree: "", str(indegree), ""used: "", str(used))

    #calc indegree
    for i in range(0, 26):
        ithIndegree = 0
        for j in range(0, 26):
           if g[j][i]: ithIndegree += 1
        indegree[i] = ithIndegree
    print(""indegree: "", str(indegree))
    for i in range(0, 26):
        zeroIndegreeNode = getZeroIndegreeNode()
        if zeroIndegreeNode == -1:
            res = False
            break
        else:
            used[zeroIndegreeNode] = True
            theOrder.append(chr(ord('a') + zeroIndegreeNode))
            for j in range(0, 26):
                if g[zeroIndegreeNode][j]:
                    indegree[j] -= 1
    print(""theOrder: "", str(theOrder), ""indegree: "", str(indegree), ""used: "", str(used))
    if not res:
        print(""Impossible"")
    else:
        print("""".join(theOrder))
</ans>",0,{}
106,"<ans>
#!/usr/bin/env python3
class UnionFind:
    # 作りたい要素数nで初期化
    # 使用するインスタンス変数の初期化
    def __init__(self, n):
        self.n = n
        print(""n: "", str(n))
        # root[x]<0ならそのノードが根かつその値が木の要素数
        # rootノードでその木の要素数を記録する
        self.root = [-1] * (n + 1)
        print(""root: "", str(self.root))
        # 木をくっつける時にアンバランスにならないように調整する
        self.rnk = [0] * (n + 1)
        print(""rnk: "", str(self.rnk))

    # ノードxのrootノードを見つける
    def Find_Root(self, x):
        if self.root[x] < 0:
            return x
        else:
            # ここで代入しておくことで、後の繰り返しを避ける
            self.root[x] = self.Find_Root(self.root[x])
            return self.root[x]

    # 木の併合、入力は併合したい各ノード
    def Unite(self, x, y):
        # 入力ノードのrootノードを見つける
        x = self.Find_Root(x)
        y = self.Find_Root(y)
        # すでに同じ木に属していた場合
        if x == y:
            return
        # 違う木に属していた場合rnkを見てくっつける方を決める
        elif self.rnk[x] > self.rnk[y]:
            self.root[x] += self.root[y]
            self.root[y] = x

        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            # rnkが同じ（深さに差がない場合）は1増やす
            if self.rnk[x] == self.rnk[y]:
                self.rnk[y] += 1

    # xとyが同じグループに属するか判断
    def isSameGroup(self, x, y):
        return self.Find_Root(x) == self.Find_Root(y)

    # ノードxが属する木のサイズを返す
    def Count(self, x):
        return -self.root[self.Find_Root(x)]


def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n))
    print(""m: "", str(m))
    uf = UnionFind(n)

    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a))
        print(""b: "", str(b))
        uf.Unite(a, b)

    for i in range(n):
        i += 1
        uf.isSameGroup(i, i)

    ans = 0
    for i in range(n):
        ans = max(ans, -uf.root[i + 1])

    # print(uf.root)
    print(""ans: "", str(ans))


main()

</ans>",0,{}
107,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    print(""n: "", str(n))
    if n < 2:
        return False
    if n == 2:
        print(""n: "", str(n))
        return True
    if not n & 1:
        print(""n: "", str(n))
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            print(""n: "", str(n))
            return False
    return True

def mhd(a,b):
    print(""a: "", str(a), ""b: "", str(b))
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    print(""x: "", str(x))
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    print(""x: "", str(x))
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    print(""x: "", str(x), ""y: "", str(y))
    a = y[0]-x[0]
    b = x[1]-y[1]
    print(""a: "", str(a), ""b: "", str(b))
    return (a*a+b*b)**0.5

def lgcd(a):
    print(""a: "", str(a))
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    print(""a: "", str(a))
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    print(""n: "", str(n), ""r: "", str(r))
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD



def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    a,b,c = arrIN()
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
    print((a+b+c)//2)

</ans>",0,{}
108,"<ans>
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))

flag = True
print(""flag: "", str(flag))
if n == 1:
    if s == '0':
        print(pow(10, 10))
    elif s == '1':
        print(pow(10, 10) * 2)
elif n == 2:
    if s in ['11', '10']:
        print(pow(10, 10))
    elif s == '01':
        print(pow(10, 10) - 1)
    else:
        print(0)
else:
    flag = True
    f = n // 3
    print(""f: "", str(f))
    r = n % 3
    print(""r: "", str(r))
    for i in range(0, n, 3):
        if i == 0:
            ans = s[0:3]
            print(""ans: "", str(ans))
            if ans not in ['110', '101', '011']:
                flag = False
                break
        elif i < 3 * f:
            tmp = s[i:i + 3]
            print(""tmp: "", str(tmp))
            if tmp != ans:
                flag = False
                break
        else:
            tmp = s[i:n]
            print(""tmp: "", str(tmp))
            if tmp != ans[0:n - i]:
                flag = False
                break
    if not flag:
        print(0)
    else:
        if ans == '110':
            if r == 0:
                print(pow(10, 10) - f + 1)
            else:
                print(pow(10, 10) - f)
        elif ans == '101':
            print(pow(10, 10) - f)
        elif ans == '011':
            if r < 2:
                print(pow(10, 10) - f)
            else:
                print(pow(10, 10) - f - 1)
</ans>",0,{}
109,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

def gcd(a,b):
	while b != 0:
		a,b = b,a%b
	return a

def stupid(x):
	r = 1
	for i in range(1, x):
		r = max(r, gcd(i&x, i^x))
	return r

d = dict()
d[511] = 73
d[2047] = 89
d[32767] = 4681
d[2097151] = 299593
d[8388607] = 178481
d[33554431] = 1082401
def smart(x):
	if x in d:
		return d[x]
	if (x & (x+1)) == 0:
		i = 0
		while ((1<<i)-1) != x:
			i += 1
		if i % 2 == 0:
			z = 0
			for i in range(0,i,2):
				z += (1<<i)
			return z
		else:
			return 1
	else:
		i = 1
		z = 0
		while i < x:
			if (i & x) == 0:
				z += i
			i *= 2
		return x+z

q = mint()
for i in range(q):
	x = mint()
	print(""x: "", str(x))
	print(smart(x))
	#if (x & (x+1)) == 0:
	#	a = stupid(x)
	#	b = smart(x)
	#	if a != b:
	#		print(x,a,b)

</ans>",0,{}
110,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
print(""getcontext().prec: "", str(getcontext().prec))
MAX = sys.maxsize
print(""MAX: "", str(MAX))
MAXN = 1000010
print(""MAXN: "", str(MAXN))
MOD = 10**9+7
print(""MOD: "", str(MOD))
spf = [i for i in range(MAXN)]
print(""spf: "", str(spf))
spf[0]=spf[1] = -1
def sieve():
    for i in range(2,MAXN,2):
        spf[i] = 2
    for i in range(3,int(MAXN**0.5)+1):
        if spf[i]==i:
            for j in range(i*i,MAXN,i):
                if spf[j]==j:
                    spf[j]=i
def fib(n,m):
    if n == 0:
        return [0, 1]
    else:
        a, b = fib(n // 2)
        print(""a: "", str(a), ""b: "", str(b))
        c = ((a%m) * ((b%m) * 2 - (a%m)))%m
        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m
        if n % 2 == 0:
            return [c, d]
        else:
            return [d, c + d]

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n = int(input())
    if n%2:
        print(n//2)
    else:
        print(n//2-1)

</ans>",0,{}
111,"<ans>
from math import log
from decimal import Decimal

def a1(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (y ** z) * Decimal(log(x))

def s1(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""x^y^z""

def a2(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (z ** y) * Decimal(log(x))

def s2(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""x^z^y""

def a3(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (y * z) * Decimal(log(x))

def s3(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(x^y)^z""

def a4(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (y * z) * Decimal(log(x))

def s4(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(x^z)^y""

def a5(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (x ** z) * Decimal(log(y))

def s5(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""y^x^z""

def a6(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (z ** x) * Decimal(log(y))

def s6(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""y^z^x""

def a7(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (x * z) * Decimal(log(y))

def s7(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(y^x)^z""

def a8(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (z * x) * Decimal(log(y))

def s8(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(y^z)^x""

def a9(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (x ** y) * Decimal(log(z))

def s9(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""z^x^y""

def a10(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (y ** x) * Decimal(log(z))

def s10(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""z^y^x""

def a11(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (x * y) * Decimal(log(z))

def s11(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(z^x)^y""

def a12(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return (y * x) * Decimal(log(z))

def s12(x, y, z):
    print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    return ""(z^y)^x""

x, y, z = list(map(Decimal, input().split()))
print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
ans = s1(x, y, z)
a = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]
s = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]
max = a1(x, y, z)
for i in range (12):
    if max < a[i](x, y, z):
        ans = s[i](x, y, z)
        max = a[i](x, y, z)
print(ans)

</ans>",0,{}
112,"<ans>
s = input()
print(""s: "", str(s))
cur_len = 1
a = []
char = []
for i in range(1, len(s)):
    if s[i] == s[i-1]: cur_len += 1
    else:
      a.append(cur_len)
      char.append(s[i-1])
      print(""a: "", a, ""; char: "", char)
      cur_len = 1

a.append(cur_len)
char.append(s[len(s)-1])
print(""a: "", a, ""; char: "", char)

ans = 0
while len(a) > 1:
    n = len(a)
    print(""n: "", n)
    inner_min = 100000000
    for i in range(1,n-1):
        if a[i] < inner_min: inner_min = a[i]

    k = min(a[0], a[n-1],(inner_min + 1)//2)
    print(""a: "", a, ""; k = "", k)
    b = []
    new_char = []
    for i in range(n):
        if i == 0 or i == n-1:
            if a[i] > k:
                b.append(a[i]-k)
                new_char.append(char[i])
        else:
            if a[i] > 2*k:
                b.append(a[i] - 2*k)
                new_char.append(char[i])
    print(""b: "", b, ""; new_char: "", new_char)
    ans += k
    if len(b) > 1:
        c = [0]*n
        newnew_char = [new_char[0]]
        count = 0

        for i in range(0,len(b)-1):
            c[count] += b[i]
            if new_char[i] == new_char[i+1]: continue
            else:
                count += 1
                newnew_char.append(new_char[i+1])
        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]
        else:
            newnew_char.append(new_char[i+1])
            c[count] = b[len(b)-1]
        a = c[:count+1]
        char = newnew_char[:]
        print(""a: "", a, ""; char: "", char)
    else:
        a = b[:]
        print(""a: "", a)

print(ans)
</ans>",0,{}
113,"<ans>
a, r, l, m = list(map(int, input().split()))
print(""a: "", str(a), ""r: "", str(r), ""l: "", str(l), ""m: "", str(m))
_l = list(map(int, input().split()))
print(""_l: "", str(_l))
s = set(_l)
print(""s: "", str(s))
if abs(a) > l:
    print(0)
    return
if a == 0:
    if 0 in s:
        print(0)
        return
    else:
        print(""inf"")
        return
if r == 0:
    if a == 0:
        if 0 in s:
            print(0)
            return
        else:
            print(""inf"")
            return
    else:
        if a not in s:
            if abs(a) <= l:
                if 0 in s:
                    print(1)
                    return
                else:
                    print(""inf"")
                    return
            else:
                print(0)
                return
        else:
            if 0 in s:
                print(0)
                return
            else:
                print(""inf"")
                return
if r == 1:
    if a in s or abs(a) > l:
        print(0)
        return
    else:
        print(""inf"")
        return
if r == -1:
    if a in s:
        if 0 - a in s:
            print(0)
            return
        else:
            if abs(a) <= l:
                print(""inf"")
                return
            else:
                print(0)
                return
    else:
        if abs(a) <= l:
            print(""inf"")
            return
        else:
            print(0)
            return
tot = 0
while abs(a) <= l:
    if a not in s:
        tot += 1
    a *= r
print(tot)
</ans>",0,{}
114,"<ans>
import datetime
import sys
import copy
import functools
import collections
import itertools

class Solution:
    def __init__(self):
        print(""self.N: "", str(self.N))
        print(""self.boards: "", str(self.boards))
        self.N = 0
        self.boards = None

    def test(self):
        pass

    def readInput(self):
        self.N = int(input())
        print(""self.N: "", str(self.N))
        self.boards = []
        for i in range(self.N):
            self.boards.append(list(input()))
        print(""self.boards: "", str(self.boards))

    def readMockInput(self):
        pass

    def solve(self):
        N = self.N
        print(""N: "", str(N))
        impossibleMoves = set()
        print(""impossibleMoves: "", str(impossibleMoves))
        chesses = list()
        print(""chesses: "", str(chesses))
        notAttacked = list()
        print(""notAttacked: "", str(notAttacked))
        # record all impossible moves
        for r in range(N):
            for c in range(N):
                if self.boards[r][c] == 'o':
                    chesses.append((r, c))
                elif self.boards[r][c] == '.':
                    notAttacked.append((r, c))
        print(""chesses: "", str(chesses))
        print(""notAttacked: "", str(notAttacked))
        for r, c in chesses:
            for i, j in notAttacked:
                impossibleMoves.add((i-r, j-c))
        print(""impossibleMoves: "", str(impossibleMoves))

        # ... rest of the code ...
</ans>",0,{}
115,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import copy
import decimal

print(""sys: "", str(sys))
print(""math: "", str(math))
print(""os: "", str(os))
print(""itertools: "", str(itertools))
print(""string: "", str(string))
print(""heapq: "", str(heapq))
print(""_collections: "", str(_collections))
print(""Counter: "", str(Counter))
print(""defaultdict: "", str(defaultdict))
print(""deque: "", str(deque))
print(""lru_cache: "", str(lru_cache))
print(""bisect: "", str(bisect))
print(""re: "", str(re))
print(""queue: "", str(queue))
print(""copy: "", str(copy))
print(""decimal: "", str(decimal))

class Scanner():
    @staticmethod
    def int():
        print(""Scanner.int: "", str(Scanner.int))
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        print(""Scanner.string: "", str(Scanner.string))
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        print(""Scanner.map_int: "", str(Scanner.map_int))
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        print(""Scanner.string_list: "", str(Scanner.string_list))
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        print(""Scanner.int_list_list: "", str(Scanner.int_list_list))
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        print(""Scanner.int_cols_list: "", str(Scanner.int_cols_list))
        return [Scanner.int() for i in range(n)]


def pop_count(x):
    print(""x: "", str(x))
    x = x - ((x >> 1) & 0x5555555555555555)
    print(""x: "", str(x))
    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)
    print(""x: "", str(x))
    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f
    print(""x: "", str(x))
    x = x + (x >> 8)
    print(""x: "", str(x))
    x = x + (x >> 16)
    print(""x: "", str(x))
    x = x + (x >> 32)
    print(""x: "", str(x))
    return x & 0x0000007f

def solve():
    S = Scanner.string()
    print(""S: "", str(S))
    N = len(S)
    print(""N: "", str(N))
    K = Scanner.int()
    print(""K: "", str(K))
    dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]
    print(""dp: "", str(dp))
    dp[0][0][0] = 1
    for i in range(N):
        for j in range(4):
            for k in range(2):
                nd = int(S[i])
                print(""nd: "", str(nd))
                for d in range(10):
                    ni, nj, nk = i + 1, j, k
                    if d != 0:
                        nj += 1
                    if nj > K:
                        continue
                    if k == 0:
                        if d > nd:
                            continue
                        if d < nd:
                            nk += 1
                    dp[ni][nj][nk] += dp[i][j][k]
    print((dp[N][K][0] + dp[N][K][1]))

def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()

def __starting_point():
    main()

__starting_point()
</ans>",1,{}
116,"<ans>
import heapq

INF = float('inf')
N, M = map(int, input().split())
print(""N: "", str(N), ""M: "", str(M))
to = [[] for _ in range(N)]
print(""to: "", str(to))

sides = [[0] * N for _ in range(N)]
print(""sides: "", str(sides))

for _ in range(M):
    a, b, c = map(int, input().split())
    a, b = a - 1, b - 1
    to[a].append((c, b))
    to[b].append((c, a))
    sides[a][b] = 1 #a, b間に辺がある
    sides[b][a] = 1
print(""sides after loop: "", str(sides))

def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq)
    cost = [[INF, []] for i in range(N)]
    cost[s][0] = 0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v][0]:
            continue
        for d, u in to[v]:
            tmp = d + cost[v][0]
            if tmp < cost[u][0]:
                cost[u][0] = tmp
                cost[u][1] = [v] # 更新する場合は直前の頂点を保持
                heapq.heappush(hq, (tmp, u))
            elif tmp == cost[u][0]:
                cost[u][1].append(v) # 距離が等しい場合はリストで直前の頂点を保持
                heapq.heappush(hq, (tmp, u))
    return cost

def dfs(v, tree, p=-1):
    if p >= 0:
        sides[v][p] = 0
        sides[p][v] = 0
    for nv in tree[v][1]:
        dfs(nv, tree, v)

def main():
    for s in range(N):
        tree = dijkstra(s)
        for g in range(N):
            dfs(g, tree)

    print(sum(sum(column) for column in sides) // 2)

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
117,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

n, k = mints()
print(""n: "", str(n), ""k: "", str(k))
q = list(mints())
print(""q: "", str(q))
for i in range(n):
	q[i] -= 1
s = list(mints())
print(""s: "", str(s))
a = [i for i in range(1,n+1)]
print(""a: "", str(a))
d = [0]*n
print(""d: "", str(d))
b = [False]*(k+1)
print(""b: "", str(b))
c = [False]*(k+1)
print(""c: "", str(c))
e = [10000]*2
print(""e: "", str(e))
f = [10000]*2
print(""f: "", str(f))
for i in range(k+1):
	#print(a)
	b[i] = (a == s)
	if b[i]:
		e[i%2] = min(e[i%2], i)
	for j in range(n):
		d[j] = a[q[j]]
	a,d = d,a
#print('====')
a = [i for i in range(1,n+1)]
print(""a: "", str(a))
for i in range(k+1):
	#print(a)
	c[i] = (a == s)
	if c[i]:
		f[i%2] = min(f[i%2], i)
	for j in range(n):
		d[q[j]] = a[j]
	a,d = d,a
#print('====')
#print(e)
#print(f)
if e[0] == 0:
	print('NO')
elif e[1] == 1:
	if f[1] == 1 and k > 1:
		print('NO')
	elif k%2 == 1 or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
elif f[1] == 1:
	if k%2 == 1 or e[k%2] <= k:
		print('YES')
	else:
		print('NO')
else:
	if e[k%2] <= k or f[k%2] <= k:
		print('YES')
	else:
		print('NO')

</ans>",1,{}
118,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t

def flin(d, x, default=-1):
    left = right = -1
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    if left == -1:
        return default, default
    else:
        return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' ', end='\n'): print(sep.join(map(str, a)), end=end)
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, m = mi()
    print(""n: "", str(n), ""m: "", str(m))
    if n == 1:
        print(0)
    elif n == 2:
        print(m)
    else:
        print(2*m)
</ans>",0,{}
119,"<ans>
from random import randint

def factMod(n, mod):
    res = 1
    for i in range(2, n+1):
        res = (res * i) % mod
    return res

def powMod(n, p, mod):
    res = 1

    while p > 0:
        if p % 2 == 1:
            res = (res * n) % mod

        p //= 2
        n = (n * n) % mod

    return res

def invMod(n, mod):
    print(""n: "", str(n), ""mod: "", str(mod))
    return powMod(n, mod - 2, mod)

#t = 6
#print(invMod(t, 97))
#print( (invMod(t, 97) * t) % 97 )
#return

def CnkMod(n, k, mod):
    print(""n: "", str(n), ""k: "", str(k), ""mod: "", str(mod))
    return (
        factMod(n, mod) *
        invMod(factMod(k, mod) * factMod(n-k, mod), mod)
    ) % mod

def computeCnksMod(N, mod):
    print(""N: "", str(N), ""mod: "", str(mod))
    res = [[0] * (N+1) for i in range(N+1)]
    res[0][0] = 1
    for n in range(1, N+1):
        res[n][0] = res[n-1][0]
        for k in range(1, n+1):
            res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod

    return res

magic = 998244353

n = int(input()) + 1
print(""n: "", str(n))
aa = [1] + [int(s)+1 for s in input().split(' ')]
print(""aa: "", str(aa))

cnks = computeCnksMod(n, magic)

d = [0] * (n + 1)
print(""d: "", str(d))
d[n] = 1

for i in reversed(list(range(n))):
    if i != 0 and aa[i] < 2:
        continue

    cur = 0

    tosel = aa[i] - 1
    for j in range(i + tosel + 1, n + 1):
        avail = j - i - 1
        #cur = (cur + CnkMod(avail, tosel, magic) * d[j]) % magic
        cur = (cur + cnks[avail][tosel] * d[j]) % magic

    d[i] = cur

print(""d: "", str(d))
print(d[0] - 1)

</ans>",0,{}
120,"<ans>
from math import sin
def mp():  return list(map(int,input().split()))
def lt():  return list(map(int,input().split()))
def pt(x):  print(x)
def ip():  return input()
def it():  return int(input())
def sl(x):  return [t for t in x]
def spl(x): return x.split()
def aj(liste, item): liste.append(item)
def bin(x):  return ""{0:b}"".format(x)
def listring(l): return ' '.join([str(x) for x in l])
def ptlist(l): print(' '.join([str(x) for x in l]))

n = it()
print(""n: "", str(n))
step = lt()
print(""step: "", str(step))
dict = {}
print(""dict: "", str(dict))
def explosion(start,s,d):
    (i,j) = start
    t = s+1
    if d == 0:
        for k in range(j+1,j+t):
            dict[(i,k)] = True
        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)
    if d == 1:
        for k in range(1,t):
            dict[(i+k,j+k)] = True
        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)
    if d == 2:
        for k in range(1,t):
            dict[(i+k,j)] = True
        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)
    if d == 3:
        for k in range(1,t):
            dict[(i+k,j-k)] = True
        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)
    if d == 4:
        for k in range(1,t):
            dict[(i,j-k)] = True
        return ((i,j-t+1),(d+7)%8),((i,j-t+1),(d+1)%8)
    if d == 5:
        for k in range(1,t):
            dict[(i-k,j-k)] = True
        return ((i-t+1,j-t+1),(d+7)%8),((i-t+1,j-t+1),(d+1)%8)
    if d == 6:
        for k in range(1,t):
            dict[(i-k,j)] = True
        return ((i-t+1,j),(d+7)%8),((i-t+1,j),(d+1)%8)
    if d == 7:
        for k in range(1,t):
            dict[(i-k,j+k)] = True
        return ((i-t+1,j+t-1),(d+7)%8),((i-t+1,j+t-1),(d+1)%8)

start = [((0,0),0)]
print(""start: "", str(start))
for i in range(n):
    l = []
    for p,q in start:
        a,b = explosion(p,step[i],q)
        l.append(a)
        l.append(b)
    start = set(l)
print(""start: "", str(start))
pt(len(dict))
</ans>",0,{}
121,"<ans>
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
import itertools
from functools import *
from itertools import permutations,combinations,groupby
import sys
import bisect
import string
import math
import time
import random
def Golf():
    *a,=map(int,open(0))
def S_():
    return input()
def IS():
    return input().split()
def LS():
    return [i for i in input().split()]
def I():
    return int(input())
def MI():
    return map(int,input().split())
def LI():
    return [int(i) for i in input().split()]
def LI_():
    return [int(i)-1 for i in input().split()]
def NI(n):
    return [int(input()) for i in range(n)]
def NI_(n):
    return [int(input())-1 for i in range(n)]
def StoI():
    return [ord(i)-97 for i in input()]
def ItoS(nn):
    return chr(nn+97)
def LtoS(ls):
    return ''.join([chr(i+97) for i in ls])
def GI(V,E,Directed=False,index=0):
    org_inp=[]
    g=[[] for i in range(n)]
    for i in range(E):
        inp=LI()
        org_inp.append(inp)
        if index==0:
            inp[0]-=1
            inp[1]-=1
        if len(inp)==2:
            a,b=inp
            g[a].append(b)
            if not Directed:
                g[b].append(a)
        elif len(inp)==3:
            a,b,c=inp
            aa=(inp[0],inp[2])
            bb=(inp[1],inp[2])
            g[a].append(bb)
            if not Directed:
                g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):
#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage
    mp=[1]*(w+2)
    found={}
    for i in range(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[1]+[mp_def[j] for j in s]+[1]
    mp+=[1]*(w+2)
    return h+2,w+2,mp,found
def bit_combination(k,n=2):
    rt=[]
    for tb in range(n**k):
        s=[tb//(n**bt)%n for bt in range(k)]
        rt+=[s]
    return rt
def show(*inp,end='\n'):
    if show_flg:
        print(*inp,end=end)
YN=['YES','NO']
Yn=['Yes','No']

mo=10**9+7
inf=float('inf')
l_alp=string.ascii_lowercase
u_alp=string.ascii_uppercase
#ts=time.time()
#sys.setrecursionlimit(10**7)
input=lambda: sys.stdin.readline().rstrip()

def ran_input():
    import random
    n=random.randint(4,16)
    rmin,rmax=1,10
    a=[random.randint(rmin,rmax) for _ in range(n)]
    return n,a

def ran_input():
    import random
    n=random.randint(4,16)
    rmin,rmax=1,10
    a=[random.randint(rmin,rmax) for _ in range(n)]
    return n,a

show_flg=False
show_flg=True

ans=0

n=I()
m=LI()
tot=0
for i in range(n):
    print(""i: "", str(i))
    l,r=[],[]
    print(""l: "", str(l))
    print(""r: "", str(r))
    tmp=m[i]
    print(""tmp: "", str(tmp))
    p=m[i]
    print(""p: "", str(p))
    # right
    for j in range(i+1,n):
        if m[j]<p:
            p=m[j]
        tmp+=p
        r+=[p]
        print(""r: "", str(r))
    p=m[i]
    # left
    for j in range(i-1,-1,-1):
        if m[j]<p:
            p=m[j]
        tmp+=p
        l+=[p]
        print(""l: "", str(l))
    if tmp>tot:
        tot=tmp
        ans=l[::-1]+[m[i]]+r
        print(""ans: "", str(ans))
print(*ans)
</ans>",0,{}
122,"<ans>
import sys
sys.setrecursionlimit(10000)

#file = open(""btest"", ""r"")
#f = lambda:file.readline()
f = lambda:input()

print(""f: "", str(f))

n,m = list(map(int, f().split()))

print(""n: "", str(n), ""m: "", str(m))

matrix = []

print(""matrix: "", str(matrix))

disco = [[0 for _ in range(m)] for _ in range(n)]

print(""disco: "", str(disco))

for i in range(n):
    matrix.append(f())

def valid_node(i, j):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, k, cc = 0):
    if disco[i][j] == k:
        return True

    disco[i][j] = k

    res = False
    dd = [[0,1], [1,0], [-1,0], [0,-1]]
    for d in dd:
        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:
                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)

    return res

ok = False
k = 1
for i in range(n):
    for j in range(m):
        if disco[i][j] == 0:
            ok = ok or dfs(i, j, [i, j], k)
            k += 1

if ok:
    print(""Yes"")
else:
    print(""No"")
</ans>",0,{}
123,"<ans>
D = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100}

k = int(input())
print(""k: "", str(k))
start = k - k%100
print(""start: "", str(start))
i = D[start]
print(""i: "", str(i))
j = start

while j < k:
    i += 1
    if sum(int(d) for d in str(i))==10:
        j += 1
print(""i: "", str(i))

</ans>",0,{}
124,"<ans>
MOD = 998244353

def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
print(""f: "", str(f))
print(""w: "", str(w))
def prepare() :
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    print(""p10: "", str(p10))
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    print(""pop: "", str(pop))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) :
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)]
    n = len(sx)
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) :
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) :
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) :
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = list(map(int, input().split()))
print(""l: "", str(l))
print(""r: "", str(r))
print(""k: "", str(k))
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(""ans: "", str(ans))
</ans>",0,{}
125,"<ans>
def main():
    N, M = (int(i) for i in input().split())
    print(""N: "", str(N), ""M: "", str(M))
    par = [i for i in range(N)]
    print(""par: "", str(par))
    size = [1 for i in range(N)]
    print(""size: "", str(size))

    def find(x):
        if par[x] == x:
            return x
        else:
            par[x] = find(par[x])
            size[x] = size[par[x]]
            return par[x]

    def same(x, y):
        return find(x) == find(y)

    def union(x, y):
        x = find(x)
        y = find(y)
        if x == y:
            return
        if size[x] < size[y]:
            x, y = y, x
        size[x] += size[y]
        par[y] = x

    def get_size(x):
        return size[find(x)]

    G = [[] for _ in range(N)]
    for _ in range(M):
        a, b = (int(i) for i in input().split())
        print(""a: "", str(a), ""b: "", str(b))
        G[a-1].append(b-1)
        G[b-1].append(a-1)
        union(a-1, b-1)

    S = [False]*4
    for i in range(N):
        S[min(3, get_size(i))] = True
        if S[3]:
            break
    t = 0
    if S[3]:
        t = 1
    elif S[2]:
        t = 2
    else:
        t = 3

    color = [-1]*N

    def dfs(s):
        stack = [s]
        color[s] = 0
        b = 1
        w = 0
        while stack:
            v = stack.pop()
            for u in G[v]:
                if color[u] != -1:
                    if color[u] == color[v]:
                        return False, b*w
                    continue
                color[u] = color[v] ^ 1
                if color[u] == 0:
                    b += 1
                else:
                    w += 1
                stack.append(u)
        return True, b*(b-1)//2 + w*(w-1)//2

    is_bipartite, _ = dfs(0)
    if is_bipartite:
        w = 0
        if t == 3:
            w = N*(N-1)*(N-2)//3//2
        elif t == 2:
            used = [False]*N
            for i in range(N):
                if not used[find(i)] and get_size(i) == 2:
                    w += (N-2)
                    used[find(i)] = True
        elif t == 1:
            used = [False]*N
            color = [-1]*N
            for i in range(N):
                if not used[find(i)] and get_size(i) >= 3:
                    _, ways = dfs(i)
                    w += ways
                    used[find(i)] = True
        print(t, w)
    else:
        print(0, 1)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
126,"<ans>
__author__ = 'Michael Ilyin'

import math

# debug = True
debug = False


def dist(x1, y1, x2, y2):
    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))

def get_y(x1, y1, x2, y2, x):
    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1

if debug:
    with open(""input.txt"", ""r"") as inp:
        firstLine = inp.readline()
        secondLine = inp.readline()
        thirdLine = inp.readline()
        fourthLine = inp.readline()
else:
    firstLine = input()
    secondLine = input()
    thirdLine = input()
    fourthLine = input()

first = firstLine.split()
n = float(first[0])
m = float(first[1])
a = float(first[2])
b = float(first[3])

A = [float(x) for x in secondLine.split()]
B = [float(x) for x in thirdLine.split()]
L = [float(x) for x in fourthLine.split()]

if debug:
    print(""A: "", str(A))
    print(""B: "", str(B))
    print(""L: "", str(L))

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
    d = dist(0, 0, b, bi) + L[i]
    if d <= optimalLen:
        optimalLen = d
        optimalBIdx = i

if debug:
    print(""optimalBIdx: "", str(optimalBIdx + 1), ""optimalLen: "", str(optimalLen))

intersectY = get_y(0, 0, b, B[optimalBIdx], a)

if debug:
    print(""intersectY: "", str(intersectY))

pointDist = float(""inf"")
optimalAIdx = -1
for i, ai in enumerate(A):
    d = dist(a, ai, a, intersectY)
    if d < pointDist:
        pointDist = d
        optimalAIdx = i

if debug:
    print(""optimalAIdx: "", str(optimalAIdx + 1), ""pointDist: "", str(pointDist))

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
    d = dist(a, A[optimalAIdx], b, bi) + L[i]
    if d <= optimalLen:
        optimalLen = d
        optimalBIdx = i

print(""optimalAIdx: "", str(optimalAIdx + 1), ""optimalBIdx: "", str(optimalBIdx + 1))
</ans>",0,{}
127,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

# M = mod = 998244353
def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]

print(""n: "", str(n))
print(""l: "", str(l))
print(""l1: "", str(l1))
print(""l2: "", str(l2))

i = 0
l1 = sorted(list(set(l1)))
print(""l1: "", str(l1))
doit = tot1 = 0
print(""doit: "", str(doit))
print(""tot1: "", str(tot1))
cn = Counter(l1)
print(""cn: "", str(cn))
l = l1[:]
while i < len(l1):
    if cn[l[i] - 1] > 0:
        cn[l[i]] -= 1
        cn[l[i] - 1] += 1
        l[i] -= 1
        i += 1
    else:
        cn[l[i]] -= 1
        cn[l[i] + 1] += 1
        l[i] += 1
        if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2
        else:i += 1
print(""cn: "", str(cn))
tot1 = sum(1 for i in cn if cn[i])
print(""tot1: "", str(tot1))









# print(l1)



i = 0

cnt = Counter(l2)
print(""cnt: "", str(cnt))
l2 = sorted(l2)
print(""l2: "", str(l2))

l = l2[:]



for i in range(n):
    if cnt[l[i] - 1] == 0:
        cnt[l[i] - 1] += 1
        cnt[l[i]] -= 1
        l[i] -= 1
    elif cnt[l[i]] > 1:
        cnt[l[i] + 1] += 1
        cnt[l[i]] -= 1
        l[i] += 1


tot2 = sum(1 for i in cnt if cnt[i])
print(""tot2: "", str(tot2))





print(tot1,tot2)
</ans>",0,{}
128,"<ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush

input = sys.stdin.readline
def RD(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]

print(""N: "", str(N))
def main():
    N = I()
    print(""N: "", str(N))
    if N == 0:
        print(0)
        return
    if N < 0:
        N = -N
        D = defaultdict(int)
        index = 0
        while N >= 1:
            #bitフラグがたっていたら
            if N & 1 == 1:
                #2の倍数の場合D[index]とD[index+1]に1を足す
                if index % 2 == 0:
                    D[index] += 1
                    D[index+1] += 1
                else:
                    D[index] += 1
            else:
                D[index] = D[index]
            N = N>>1
            index += 1
    else:
        D = defaultdict(int)
        if N & 1 == 1:
            D[0] = 1
        else:
            D[0] = 0
        index = 1
        N = N >> 1

        while N >= 1:
            #bitフラグがたっていたら
            if N & 1 == 1:
                #2の倍数の場合D[index]とD[index+1]に1を足す
                if index % 2 == 1:
                    D[index] += 1
                    D[index+1] += 1
                else:
                    D[index] += 1
            else:
                D[index] = D[index]
            N = N>>1
            index += 1

    print(""D: "", str(D))
    index = 0
    while True:
        if not index in D.keys():
            break
        if D[index] <= 1:
            pass
        else:
            temp = D[index]
            D[index] = temp % 2
            D[index+1] += (temp // 2)
            D[index+2] += (temp // 2)
            if D[index+1] >= D[index+2] * 2:
                temp = D[index+2]
                D[index+2] -= temp
                D[index+1] -= temp * 2
        index += 1
    print(""D: "", str(D))
    res = True

    for i in reversed(D.values()):
        if res and i == 1:
            res = False
        if not res:
            print(i, end="""")
    print()

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
129,"<ans>
n, k = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k))
XY = [list(map(int, input().split())) for _ in range(n)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[0])
XY = [xy + [x] for x, xy in enumerate(XY)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[1])
XY = [xy + [y] for y, xy in enumerate(XY)]
print(""XY: "", str(XY))

gr = [[0] * n for _ in range(n)]
print(""gr: "", str(gr))
for _, _, i, j in XY:
  gr[i][j] = 1
print(""gr: "", str(gr))

rui = [[0] * (n + 1) for _ in range(n + 1)]
print(""rui: "", str(rui))
for i in range(n):
  for j in range(n):
    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]
print(""rui: "", str(rui))

# XYの2点,3点,4点を総当たり
ans = 10 ** 21
for i in range(n - 1):
  for j in range(i + 1, n):
    x = [XY[m][0] for m in [i, j]]
    y = [XY[m][1] for m in [i, j]]
    ii = [XY[m][2] for m in [i, j]]
    jj = [XY[m][3] for m in [i, j]]
    innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                + rui[min(ii)][min(jj)] \
                - rui[min(ii)][max(jj) + 1] \
                - rui[max(ii) + 1][min(jj)]
    if innerPoints >= k:
      area = (max(x) - min(x)) * (max(y) - min(y))
      if area < ans:
        ans = area

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        x = [XY[m][0] for m in [i, j, l]]
        y = [XY[m][1] for m in [i, j, l]]
        ii = [XY[m][2] for m in [i, j, l]]
        jj = [XY[m][3] for m in [i, j, l]]
        innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                    + rui[min(ii)][min(jj)] \
                    - rui[min(ii)][max(jj) + 1] \
                    - rui[max(ii) + 1][min(jj)]
        if innerPoints >= k:
          area = (max(x) - min(x)) * (max(y) - min(y))
          if area < ans:
            ans = area

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          x = [XY[m][0] for m in [i, j, o, l]]
          y = [XY[m][1] for m in [i, j, o, l]]
          ii = [XY[m][2] for m in [i, j, o, l]]
          jj = [XY[m][3] for m in [i, j, o, l]]
          innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                      + rui[min(ii)][min(jj)] \
                      - rui[min(ii)][max(jj) + 1] \
                      - rui[max(ii) + 1][min(jj)]
          if innerPoints >= k:
            area = (max(x) - min(x)) * (max(y) - min(y))
            if area < ans:
              ans = area

print(""ans: "", str(ans))
</ans>",0,{}
130,"<ans>
import math
from fractions import gcd

def primes(limit):
    Ans=[]
    C=[True]*(limit+1)
    L=list(range(2,limit+1))
    for item in L:
        if(C[item]):
            i=2
            while(item*i<=limit):
                C[item*i]=False
                i+=1
    for item in L:
        if(C[item]):
            Ans+=[item]
    return Ans

print(""limit: "", str(limit))
print(""Ans: "", str(Ans))
print(""C: "", str(C))
print(""L: "", str(L))

a,b=list(map(int,input().split()))
aa=a
bb=b
print(""a: "", str(a))
print(""b: "", str(b))
print(""aa: "", str(aa))
print(""bb: "", str(bb))
A=[]
B=[]

p=primes(int(math.sqrt(10**9)))

print(""p: "", str(p))

for i in range(len(p)):
    if(p[i]>a):
        break
    while(a%p[i]==0):
        A.append(p[i])
        a//=p[i]
print(""A: "", str(A))
print(""a: "", str(a))

if(a!=1):
    A.append(a)
print(""A: "", str(A))

for i in range(len(p)):
    if(p[i]>b):
        break
    while(b%p[i]==0):
        B.append(p[i])
        b//=p[i]
print(""B: "", str(B))
print(""b: "", str(b))

if(b!=1):
    B.append(b)
print(""B: "", str(B))

if(aa==1 and bb==1):
    print(0)

elif(aa==1):
    Done=True
    for item in B:
        if(item>5):
            Done=False
            break
    print(""Done: "", str(Done))
    if(Done):
        print(len(B))
    else:
        print(-1)
elif(bb==1):
    Done=True
    for item in A:
        if(item>5):
            Done=False
            break
    print(""Done: "", str(Done))
    if(Done):
        print(len(A))
    else:
        print(-1)

else:

    B.sort()
    A.sort()
    Done=True
    ind=0
    ans=0
    while(A!=B):
        if(ind>=len(A) and ind>=len(B)):
            Done=False
            break
        elif(ind>=len(A)):
            if(B[-1]>5):
                Done=False
                break
            else:
                ans+=len(B)-ind
                break
        elif(ind>=len(B)):
            if(A[-1]>5):
                Done=False
                break
            else:
                ans+=len(A)-ind
                break
        if(A[ind]==B[ind]):
            ind+=1
            continue

        if(A[ind]<B[ind]):
            if(A[ind]>5):
                Done=False
                break
            else:
                ans+=1
                A.pop(ind)
        else:
            if(B[ind]>5):
                Done=False
                break
            else:
                ans+=1
                B.pop(ind)
    print(""Done: "", str(Done))
    if(Done):
        print(ans)
    else:
        print(-1)

</ans>",0,{}
131,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import decimal

class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]

MOD = int(1e09) + 7
INF = int(1e15)

def solve():
    N = Scanner.int()
    print(""N: "", str(N))
    A = [0 for _ in range(N)]
    B = [0 for _ in range(N)]
    for i in range(N):
        A[i], B[i] = Scanner.map_int()
    print(""A: "", str(A))
    print(""B: "", str(B))
    A.sort()
    B.sort()
    if N % 2 == 0:
        mA = A[N // 2] + A[N // 2 - 1]
        mB = B[N // 2] + B[N // 2 - 1]
        print(""mA: "", str(mA))
        print(""mB: "", str(mB))
        print((mB - mA + 1))
    else:
        mA = A[N // 2]
        mB = B[N // 2]
        print(""mA: "", str(mA))
        print(""mB: "", str(mB))
        print((mB - mA + 1))

def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
132,"<ans>
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))

c=[0]*1001
print(""c: "", str(c))

for i in range (len(a)):
	c[a[i]]+=1
print(""c: "", str(c))

sym=0
sin=0

for i in range (1001):
	sym+=(c[i]//4)
	if(c[i]%2==1):
		sin+=1

print(""sym: "", str(sym))
print(""sin: "", str(sin))

if(n%2==0 and sym==((n*n)//4)):
	mat= [([0]*(n//2)) for i in range (n//2)]
	print(""mat: "", str(mat))
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	print(""ar: "", str(ar))

	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			k+=1
	print(""mat: "", str(mat))

	newm=[([0]*n) for i in range (n)]
	print(""newm: "", str(newm))
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]

	print(""newm: "", str(newm))

elif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):
	mat= [([0]*(n//2)) for i in range (n//2)]
	print(""mat: "", str(mat))
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	print(""ar: "", str(ar))

	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			ar.pop(k)
	print(""mat: "", str(mat))

	newm=[([0]*n) for i in range (n)]
	print(""newm: "", str(newm))
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]

	na=len(ar)
	ar2=[]
	for i in range (na):
		ar2.append(ar[i])
		ar2.append(ar[i])

	for i in range (1001):
		while(c[i]>=2):
			ar2.append(i)
			c[i]-=2
	print(""ar2: "", str(ar2))

	for i in range (n//2):
		newm[n//2 ][i]=ar2[0]
		newm[n//2 ][n-i-1]=ar2[0]
		ar2.pop(0)
		newm[i][n//2 ]=ar2[0]
		newm[n-i-1][n//2 ]=ar2[0]
		ar2.pop(0)

	for i in range (1001):
		if(c[i]==1):
			newm[n//2][n//2]=i

	print(""newm: "", str(newm))

else:
	print(""NO"")

</ans>",0,{}
133,"<ans>
import sys
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))
height=n
print(""height: "", str(height))
ans=[]
print(""ans: "", str(ans))
last3=-1
print(""last3: "", str(last3))
fail=0
print(""fail: "", str(fail))
used=-1
print(""used: "", str(used))
for i in range(n):
    if a[i]==3:
        if height==n:
            ans.append((n-height+1,i+1))
            height-=1
        else:
            ans.append((n+1-(height+1),i+1))
            ans.append((n+1-height,i+1))
            height-=1
        last3=i
print(""last3: "", str(last3))
if last3==n-1:
    print(-1)
    return
if last3>-1:
    flag=0
    for i in range(last3,n):
        if a[i]==2:
            flag=1
            ans.append((n+1-(height+1),i+1))
            height-=1
            break
    print(""flag: "", str(flag))
    if flag==0:
        flag2=0
        for i in range(last3,n):
            if a[i]==1:
                ans.append((n+1-(height+1),i+1))
                height-=1
                flag2=1
                used=i
                break
        print(""flag2: "", str(flag2))
        if flag2==0:
            print(-1)
            return
ones=[]
if used==-1:
    height-=1
for i in range(n-1,-1,-1):
    if a[i]==1 and i!=used:
        ones.append(i)
    if a[i]==2:
        if len(ones)==0:
            print(-1)
            return
        k=ones.pop()
        ans.append((n+1-(height+1),i+1))
        ans.append((n+1-(height+1),k+1))
        height-=1
if used>-1:
    ones.append(used)
for i in ones:
    ans.append((n+1-(height+1),i+1))
    height-=1
print(""ans: "", str(ans))
print(len(ans))
for x,y in ans:
    print(x,y)
</ans>",0,{}
134,"<ans>
__author__ = 'zhan'

import time
[a1, b1] = [int(i) for i in input().split()]
[a2, b2] = [int(i) for i in input().split()]

t0 = time.time()
q1 = [[a1, b1, 0]]
q2 = [[a2, b2, 0]]
tested1 = []
tested2 = []
tested_total1 = []
tested_total2 = []

print(""a1: "", str(a1), ""b1: "", str(b1))
print(""a2: "", str(a2), ""b2: "", str(b2))
print(""q1: "", str(q1))
print(""q2: "", str(q2))
print(""tested1: "", str(tested1))
print(""tested2: "", str(tested2))
print(""tested_total1: "", str(tested_total1))
print(""tested_total2: "", str(tested_total2))

def equal(t, q):
    lo = 0
    hi = len(q)
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        p = q[m]
        temp = p[0] * p[1]
        if t == temp:
            return [p[0], p[1], p[2]]
        if t < temp:
            lo = m + 1
        elif t > temp:
            hi = m

def found(key, a):
    lo = 0
    hi = len(a)
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        p = a[m]
        if key[0] == p[0] and key[1] == p[1]:
            return True
        if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:
            lo = m + 1
        if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:
            hi = m

while True:
    if len(q1) > 0 and len(q2) > 0:
        total1 = q1[0][0] * q1[0][1]
        total2 = q2[0][0] * q2[0][1]
        print(""total1: "", str(total1), ""total2: "", str(total2))
        if total1 > total2:
            ans = equal(total1, q2)
            if ans:
                print(str(ans[2] + q1[0][2]) + ""\n"" + str(q1[0][0]) + "" "" + str(q1[0][1]) + ""\n"" + str(ans[0]) + "" "" + str(ans[1]))
            else:
                if not(q1[0][0] & 1):
                    tt = [q1[0][0] // 2, q1[0][1], q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        q1.append(tt)
                        tested_total1.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q1[0][0] % 3 == 0:
                    tt = [q1[0][0] // 3 * 2, q1[0][1], q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        q1.append(tt)
                        tested_total1.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(q1[0][1] & 1):
                    tt = [q1[0][0], q1[0][1] // 2, q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        q1.append(tt)
                        tested_total1.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q1[0][1] % 3 == 0:
                    tt = [q1[0][0], q1[0][1] // 3 * 2, q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        q1.append(tt)
                        tested_total1.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                q1.pop(0)
                q1.sort(key=lambda x: x[0]*x[1], reverse=True)
                print(""q1: "", str(q1))

        elif total1 < total2:
            ans = equal(total2, q1)
            if ans:
                print(str(ans[2] + q2[0][2]) + ""\n"" + str(ans[0]) + "" "" + str(ans[1]) + ""\n"" + str(q2[0][0]) + "" "" + str(q2[0][1]))
                break
            else:
                if not(q2[0][0] & 1):
                    tt = [q2[0][0] // 2, q2[0][1], q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        q2.append(tt)
                        tested_total2.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q2[0][0] % 3 == 0:
                    tt = [q2[0][0] // 3 * 2, q2[0][1], q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        q2.append(tt)
                        tested_total2.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(q2[0][1] & 1):
                    tt = [q2[0][0], q2[0][1] // 2, q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        q2.append(tt)
                        tested_total2.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q2[0][1] % 3 == 0:
                    tt = [q2[0][0], q2[0][1] // 3 * 2, q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        q2.append(tt)
                        tested_total2.append(tt[0]*tt[1])
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                q2.pop(0)
                q2.sort(key=lambda x: x[0]*x[1], reverse=True)
                print(""q2: "", str(q2))

        else:
            print(str(q1[0][2] + q2[0][2]) + ""\n"" + str(q1[0][0]) + "" "" + str(q1[0][1]) + ""\n"" + str(q2[0][0]) + "" "" + str(q2[0][1]))
            break
    else:
        print(-1)
        break

t1 = time.time()
#print(t1-t0)

</ans>",0,{}
135,"<ans>
```
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from fractions import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
#mod = 998244353
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
  return int(readline())
print(""I: "", str(I()))
n = I()
s = input()
print(""s: "", str(s))
ans = """"
prv = None
print(""ans: "", str(ans))
print(""prv: "", str(prv))
for i in range(n):
    if i == 0:
        prv = s[i]
        ans += s[i]
        continue
    if s[i] == prv:
        continue
    else:
        prv = s[i]
        ans += s[i]
print(""ans: "", str(ans))
print((len(ans)))
</ans>",0,{}
136,"<ans>
import sys

n = int(sys.stdin.readline().split()[0])

print(""n: "", str(n))

class Polynomial:
    def __init__(self, coef):
        first_nonzero = False
        index = len(coef) - 1
        while not first_nonzero:
            if not coef[index] == 0:
                first_nonzero = True
            else:
                if index == 0:
                    first_nonzero = True
                else:
                    index -= 1
        self.degree = index
        self.coef = [coef[j] for j in range(index + 1)]
        print(""self.degree: "", str(self.degree))
        print(""self.coef: "", str(self.coef))

    def multiply_by_x(self):
        new_coef = [0]
        for j in range(self.degree + 1):
            new_coef.append(self.coef[j])
        return Polynomial(new_coef)
        print(""new_coef: "", str(new_coef))

    def minus(self):
        new_coef = [-self.coef[j] for j in range(self.degree + 1)]
        return Polynomial(new_coef)
        print(""new_coef: "", str(new_coef))

    def add(self, other):
        other_coef = other.coef
        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]
        m = min(self.degree, other.degree)
        M = max(self.degree, other.degree)
        if self.degree > other.degree:
            bigger_poly = self
        else:
            bigger_poly = other
        for j in range(m + 1):
            new_coef[j] = self.coef[j] + other_coef[j]
        for j in range(m + 1, M+1):
            new_coef[j] = bigger_poly.coef[j]
        return Polynomial(new_coef)
        print(""new_coef: "", str(new_coef))

    def is_legal(self):
        result = True
        bools = [None for j in range(self.degree + 1)]
        bools[self.degree] = self.coef[self.degree] == 1
        for j in range(self.degree):
            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1
        for j in range(self.degree + 1):
            result = result and bools[j]
        return result

    def print(self):
        output = """"
        for j in range(self.degree + 1):
            output += str(self.coef[j]) + "" ""
        print(output)

f = []

f.append(Polynomial([1]))
f.append(Polynomial([0, 1]))

for j in range(2, 151):
    xf = f[j-1].multiply_by_x()
    t_1 = xf.add(f[j - 2])
    t_2 = xf.add(f[j - 2].minus())
    if t_1.is_legal():
        f.append(t_1)
    elif t_2.is_legal():
        f.append(t_2)

print(""f[n]: "", str(f[n]))
f[n].print()
print(""f[n-1]: "", str(f[n-1]))
f[n-1].print()

#for j in range(len(f)):
    #f[j].print()

</ans>",0,{}
137,"<ans>
class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""
    def __init__(self, n_max, mod=10**9+7):
        self.mod = mod
        print(""mod: "", str(mod))
        self.modinv = self.make_modinv_list(n_max)
        print(""modinv: "", str(self.modinv))
        self.fac, self.facinv = self.make_factorial_list(n_max)
        print(""fac: "", str(self.fac))
        print(""facinv: "", str(self.facinv))

    def __call__(self, n, r):
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n+1):
            fac.append(fac[i-1] * i % self.mod)
            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n+1)
        modinv[1] = 1
        for i in range(2, n+1):
            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod
        return modinv
mod = 998244353
print(""mod: "", str(mod))
K, N = map(int, input().split())
print(""K: "", str(K))
print(""N: "", str(N))
comb = Combination(10000, mod=mod)
def C(n, r):
    if n<r or r<0:
        return 0
    else:
        return comb(n, r)
def H(n, r):
    return C(n+r-1, r)
L = []
for i in range(2, 2*K+1, 2):
    ans = 0
    M = i//2
    b = 1
    for j, a in enumerate(range(M, K)):
        if M-j<0:
            break
        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b
        #print((j, a), C(M, j) , H(N, K-a), b, pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b)
        ans %= mod
        b = -b
    print(""ans: "", str(ans))
    if i == K+1:
        break
    elif i == K:
        print(""ans: "", str(ans))
        print(""ans: "", str(ans))
        break
    L.append(ans)
    print(""L: "", str(L))
    L.append(ans)

print(*L[::-1], sep=""\n"")

</ans>",0,{}
138,"<ans>
import sys
import math
import random
n, k, x = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k), ""x: "", str(x))
a = list(map(int, input().split()))
print(""a: "", str(a))
ans = 0
if n == 1:
    print(0)
    return
for i in range(0, n - 1):
    if a[i] == a[i + 1] == x:
        l = i
        print(""l: "", str(l))
        while l >= 0 and a[i] == a[l]:
            l -= 1
        r = i + 1
        print(""r: "", str(r))
        while r < n and a[r] == x:
            r += 1
        while (1):
            if l == -1 or r == n:
                break
            if a[l] != a[r]:
                break
            if l == 0 and r == n - 1:
                break
            if l == 0:
                if a[0] == a[r + 1]:
                    while r < n and a[r] == a[0]:
                        r += 1
                    l -= 1
                    continue
                else:
                    break
            if r == n - 1:
                if a[n - 1] == a[l - 1]:
                    while l >= 0 and a[l] == a[n - 1]:
                        l -= 1
                    r += 1
                    continue
                else:
                    break
            if a[l] == a[r + 1] or a[l - 1] == a[r]:
                t = a[l]
                print(""t: "", str(t))
                while l >= 0 and a[l] == t:
                    l -= 1
                while r < n and a[r] == t:
                    r += 1
            else:
                break
        ans = max(ans, r - l - 1)
print(""ans: "", str(ans))
</ans>",0,{}
139,"<ans>
ka, kb = 0, 0
print(""ka: "", str(ka), ""kb: "", str(kb))

def g(a, b):
    nonlocal ka, kb
    if a == b:
        return
    if abs(a - b) == 2:
        if a == 1:
            ka += 1
        else:
            kb += 1
    else:
        if a > b:
            ka += 1
        else:
            kb += 1

def main():
    nonlocal ka, kb
    k, a, b = list(map(int, input().split()))
    print(""k: "", str(k), ""a: "", str(a), ""b: "", str(b))
    aa = [[] for i in [1, 1, 1]]
    bb = [[] for i in [1, 1, 1]]
    print(""aa: "", str(aa), ""bb: "", str(bb))
    aa[0] = list(map(int, input().split()))
    aa[1] = list(map(int, input().split()))
    aa[2] = list(map(int, input().split()))
    bb[0] = list(map(int, input().split()))
    bb[1] = list(map(int, input().split()))
    bb[2] = list(map(int, input().split()))
    print(""aa: "", str(aa), ""bb: "", str(bb))
    x = a
    y = b
    o = 1
    c = [[x, y]]
    d = [[0, 0]]
    g(x, y)
    if k == 1:
        return
    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
    print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb))
    while [x, y] not in c:
        o += 1
        c += [[x, y]]
        d += [[ka, kb]]
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb))
        if o == k:
            return
    ind = c.index([x, y])
    dka = ka - d[ind][0]
    dkb = kb - d[ind][1]
    delta = o - ind
    kk = (k - ind) // delta - 1
    print(""dka: "", str(dka), ""dkb: "", str(dkb), ""delta: "", str(delta))
    ka += kk * dka
    kb += kk * dkb
    o += kk * delta
    while o != k:
        o += 1
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb))

main()
print(""ka: "", str(ka), ""kb: "", str(kb))
</ans>",0,{}
140,"<ans>
```
import sys
sys.setrecursionlimit(4100000)
import math
import fractions

'''
1行のint
N, K = map(int, input().split())

1行のstring
S, T = input().split()

1行の整数配列
P = list(map(int,input().split()))

複数行2数値
x = []
y = []
for i in range(5):
    x1,y1=[int(i) for i in input().split()]
    x.append(x1)
    y.append(y1)

'''

print(""S: "", str(S))
check = len(S)-1
print(""check: "", str(check))

while(check >= 0):

    if S[check] == ""r"":
        print(""S[check]: "", str(S[check]))
        if S[check-2] == ""m"":
            print(""S[check-2]: "", str(S[check-2]))
            remove = S[check-6: check+1]
            print(""remove: "", str(remove))
            if remove == ""dreamer"":
                check -= 7
                print(""check: "", str(check))
            else:
                print(""NO"")
                return

        elif S[check-2] == ""s"":
            print(""S[check-2]: "", str(S[check-2]))
            remove = S[check-5: check+1]
            print(""remove: "", str(remove))
            if remove == ""eraser"":
                check -= 6
                print(""check: "", str(check))
            else:
                print(""NO"")
                return

        else:
            print(""NO"")
            return

    elif S[check] == ""e"":
        print(""S[check]: "", str(S[check]))
        remove = S[check-4: check+1]
        print(""remove: "", str(remove))
        if remove == ""erase"":
            check -= 5
            print(""check: "", str(check))
        else:
            print(""NO"")
            return

    elif S[check] == ""m"":
        print(""S[check]: "", str(S[check]))
        remove = S[check-4: check+1]
        print(""remove: "", str(remove))
        if remove == ""dream"":
            check -= 5
            print(""check: "", str(check))
        else:
            print(""NO"")
            return

    else:
        print(""NO"")
        return

print(""YES"")
```",0,{}
141,"<ans>
class UnionFind():
    def __init__(self, n):
        self.n = n + 1
        self.parents = [-1] * self.n
        print(""self.n: "", str(self.n))
        print(""self.parents: "", str(self.parents))

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

        # TODO 根を返す
        return x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
    N, M = list(map(int, input().split()))
    print(""N: "", str(N))
    print(""M: "", str(M))
    A = list(map(int, input().split()))
    print(""A: "", str(A))
    B = list(map(int, input().split()))
    print(""B: "", str(B))
    A.append(0)
    B.append(0)
    uf = UnionFind(N+1)
    for _ in range(M):
        c, d = list(map(int,input().split()))
        print(""c: "", str(c))
        print(""d: "", str(d))
        uf.union(c, d)
    A_sums = defaultdict(int)
    B_sums = defaultdict(int)
    for i in range(1, N+1):
        x = uf.find(i)
        A_sums[x] += A[i-1]
        B_sums[x] += B[i-1]
    for a, b in zip(list(A_sums.values()), list(B_sums.values())):
        if a != b:
            print('No')
            return
    print('Yes')


main()

</ans>",0,{}
142,"<ans>
from sys import stdin, stdout

k = int(stdin.readline())

print(""k: "", str(k))

n, m = list(map(int, stdin.readline().split()))

print(""n, m: "", str(n), "", "", str(m))

left, right, down, up = [], [], [], []

coordinates = []

for i in range(k):

    x1, y1, x2, y2 = list(map(int, stdin.readline().split()))

    if x1 == x2:

        if y1 < y2:

            coordinates.append((x1, y1, x2, y2, i))

        else:

            coordinates.append((x2, y2, x1, y1, i))

    else:

        if x1 < x2:

            coordinates.append((x1, y1, x2, y2, i))

        else:

            coordinates.append((x2, y2, x1, y1, i))

    left.append(coordinates[-1])

    right.append(coordinates[-1])

    up.append(coordinates[-1])

    down.append(coordinates[-1])

left.sort(key = lambda x: (x[0], x[2]))

down.sort(key = lambda x: (x[1], x[3]))

challengers = [[], [], [], []]

cntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))

label = 1

if cntl or not cntl:

    for i in range(cntl, -1, -1):

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

            challengers[0].append(left[i][-1])

        else:

            break

    for i in range(cntl + 1, k):

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:

            label = 0

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

            challengers[0].append(left[i][-1])

        else:

            break

if cntr or not cntr:

    for i in range(k - 1 - cntr, k):

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

            challengers[1].append(left[i][-1])

        else:

            break

    for i in range(k - 2 - cntr, -1, -1):

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:

            label = 0

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

            challengers[1].append(left[i][-1])

        else:

            break

#!!!!!!!!!!

if cntd or not cntd:

    for i in range(cntd, -1, -1):

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

            challengers[2].append(down[i][-1])

        else:

            break

    for i in range(cntd + 1, k):

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:

            label = 0

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

            challengers[2].append(down[i][-1])

        else:

            break

if cntu or not cntu:

    for i in range(k - 1 - cntu, k):

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

            challengers[3].append(down[i][-1])

        else:

            break

    for i in range(k - 2 - cntu, -1, -1):

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:

            label = 0

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

            challengers[3].append(down[i][-1])

        else:

            break

ans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])

if not len(ans) or not label:

    stdout.write('-1')

else:

    stdout.write(str(list(ans)[0] + 1))

# Made By Mostafa_Khaled
</ans>",0,{}
143,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self, Nodes, is_directed=False):
        print(""Nodes: "", str(Nodes))
        print(""is_directed: "", str(is_directed))
        self.nodes = Nodes
        self.adj_list = {}
        self.is_directed = is_directed

        for node in self.nodes:
            self.adj_list[node] = []
            print(""adj_list[{}]: "".format(node), str(self.adj_list[node]))

    def add_edge(self, u, v):
        print(""u: "", str(u))
        print(""v: "", str(v))
        self.adj_list[u].append(v)
        if self.is_directed == False:
            self.adj_list[v].append(u)

    def print_graph(self):
        for node in self.nodes:
            print((node, ""->"", self.adj_list[node]))

    def degree_node(self, node):
        print(""node: "", str(node))
        return len(self.adj_list[node])

    def dfsUTIL(self, v, visited, parents=[]):
        # print(v, end="" "")
        visited[v] = True
        for i in self.adj_list[v]:
            if visited[i] == False:
                self.dfsUTIL(i, visited, parents)
                parents.append(i)

    def dfs(self, v):
        visited = [False] * (max(self.adj_list) + 1)
        parents = [v]
        self.dfsUTIL(v, visited, parents)
        return len(parents)

##### sorting a dictionary by the values #####
def dict_sort(ans):
    print(""ans: "", str(ans))
    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))

##### naive method for testing prime or not O(n^.5) #####
def is_prime(n):
    print(""n: "", str(n))
    if n == 1:
        return 0
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

##### swap function #####
def swap(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    temp = a
    a = b
    b = temp
    return a, b

##### Primes till Nth O(n) #####
def seive_primes(n):
    print(""n: "", str(n))
    flag = [0] * (n + 10)
    flag[1] = flag[0] = 1
    i = 2
    while i * i <= n + 1:
        if flag[i] == 0:
            j = i * i
            while j <= n + 1:
                flag[j] = 1
                j += i
        i += 1
    return flag

##### all the prime factors of a number #####
def factors(n):
    print(""n: "", str(n))
    d = {}
    while n % 2 == 0:
        if 2 in d:
            d[2] += 1
        else:
            d[2] = 1
        n /= 2
    for i in range(3, int(n ** 0.5) + 1, 2):
        while n % i == 0:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
            n /= i
    n = int(n)
    if n > 1:
        d[n] = 1
    return d

##### greatest common divisor of two numbers #####
def gcd(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    if b == 0:
        return a
    return gcd(b, a % b)

##### least common multiplyer of two numbers #####
def lcm(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    return (a * b) // gcd(a, b)

##### function that return all the letters #####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

##### binary search O(logN) #####
def binary_search(ls, n, flag):
    print(""ls: "", str(ls))
    print(""n: "", str(n))
    print(""flag: "", str(flag))
    low = 0
    hi = n - 1
    while low <= hi:
        mid = (low + hi) // 2
        if ls[mid] == flag:
            return mid
        elif ls[mid] > flag:
            hi = mid - 1
        else:
            low = mid + 1
    return -1

##### quadratic roots #####
def qdrt(a, b, c):
    print(""a: "", str(a))
    print(""b: "", str(b))
    print(""c: "", str(c))
    chk = b * b - 4 * a * c
    if chk >= 0:
        ans1 = (-b + chk ** 0.5) / (2 * a)
        ans2 = (-b - chk ** 0.5) / (2 * a)
        return [int(ans1), int(ans2)]
    return -1

##### permutations #####
def permutation(n, r):
    print(""n: "", str(n))
    print(""r: "", str(r))
    if n < r:
        return 0
    ans = 1
    for i in range(n - r + 1, n + 1):
        ans *= i
    return ans

##### combinations #####
def combination(n, r):
    print(""n: "", str(n))
    print(""r: "", str(r))
    if n < r:
        return 0
    ans = 1
    for i in range(r):
        ans *= (n - i)
    div = 1
    for i in range(2, r + 1):
        div *= i
    return ans // div

##### taking an array/list as input #####
def arinp():
    ls = list(map(int, input().split()))
    print(""ls: "", str(ls))
    return ls

##### taking multiple inputs #####
def mult_inp():
    return list(map(int, input().split()))

##### Main function starts from here #####
def main():
    s = input()
    print(""s: "", str(s))
    n = len(s)
    print(""n: "", str(n))
    if s == s[::-1] and s[:n // 2] == s[n // 2 + 1:]:
        print('Yes')
    else:
        print('No')

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
144,"<ans>
from array import array
inf = (1 << 30)

def main():
    print(""n, k: "", str([int(x) for x in input().split(' ')]))
    n, k = [int(x) for x in input().split(' ')]
    Matrix = []
    for i in range(n):
        Matrix.append(array('b',[ord(x) for x in input()]))
    print(""Matrix: "", str(Matrix))
    dp = [array('l', [inf for j in range(n)]) for i in range(n)]
    print(""dp: "", str(dp))
    direct = [[ord('d') for j in range(n)] for i in range(n)]
    print(""direct: "", str(direct))
    opt = """"
    for s in range (2 * n - 1):
        opchar = chr(ord('z') + 1)
        positions = []
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(i > 0 and j > 0):
                    if(dp[i-1][j] < dp[i][j-1]):
                        dp[i][j] = dp[i-1][j]
                        direct[i][j] = 'l'
                    else:
                       dp[i][j] = dp[i][j-1]
                       direct[i][j] = 'd'
                elif i > 0:
                    dp[i][j] = dp[i-1][j]
                    direct[i][j] = 'l'
                elif j > 0:
                    dp[i][j] = dp[i][j-1]
                    direct[i][j] = 'd'
                else:
                    dp[i][j] = 0
                    direct[i][j] = 'e'
                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):
                    dp[i][j]+=1
                    Matrix[i][j] = ord('a')
                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):
                     opchar = chr(Matrix[i][j])
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(Matrix[i][j] is not ord(opchar)):
                    dp[i][j] = inf
    ans = """"
    a,b = (n-1,n-1)
    while(direct[a][b] is not 'e'):
        ans += chr(Matrix[a][b])
        if(direct[a][b] is 'l'):
            a-=1
        else:
            b-=1
    ans += chr(Matrix[0][0])
    print(ans[::-1])

main()
</ans>",0,{}
145,"<ans>
import sys

cases = False

# Pre-defined function
# Begin
def fast_pow(a:int, b:int):
    print(""a: "", str(a), ""b: "", str(b))
    res = 1
    while b > 0:
        if b & 1:
            res *= a
        a *= a
        b >>= 1
    return res

def c2(n):
    print(""n: "", str(n))
    return n * (n-1) // 2

def get():
    print(""input: "", str(input()))
    return list(map(int, input().split()))

def bits(n: int):
    print(""n: "", str(n))
    return list(bin(n)).count('1')

def main(test_case = False):
    print(""test_case: "", str(test_case))
    n = int(input()) if test_case else 1
    for _ in range(n):
        test()

def flush():
    sys.stdout.flush()

def parr(arr):
    print(""arr: "", str(arr))
    print(*arr, sep=' ')

def gcd(a, b):
    print(""a: "", str(a), ""b: "", str(b))
    while b:
        if b % a == 0:
            break
        tmp = a
        a = b % a
        b = tmp
    return a

def ext_gcd(a: int, b: int):
    print(""a: "", str(a), ""b: "", str(b))
    if (b == 0):
        return [a, [1, 0]]

    res = ext_gcd(b, a % b)
    g = res[0]
    x1 = res[1][0]
    y1 = res[1][1]
    x = y1
    y = x1 - y1 * (a // b)

    return [g, [x, y]]

# End

b = []
p = []
n = m = a = 0

def check(cnt):
    print(""cnt: "", str(cnt))
    if cnt == 0:
        return True
    x = b[-cnt:]
    y = p[:cnt]
    s = a
    i = 0
    while i < cnt and s >= 0:
        s -= max(0, y[i]-x[i])
        i += 1
    return s >= 0

def test():
    nonlocal n, m, a, b, p
    n, m, a = get()
    b = sorted(get())
    p = sorted(get())

    left = 0
    right = min(n, m)

    ans = -1

    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            ans = max(ans, mid)
            left = mid + 1
        else:
            right = mid - 1

    if ans == -1:
        print(0, 0)
        return

    # print(ans)

    t = 0
    x = b[-ans:]
    y = p[:ans]
    i = 0
    while i < ans:
        t += min(x[i], y[i])
        a -= max(0, y[i]-x[i])
        i += 1
    print(ans, max(0, t-a))

main(cases)
</ans>",0,{}
146,"<ans>
n=int(input())
print(""n: "", str(n))
la=[]
print(""la: "", str(la))
le=[]
print(""le: "", str(le))
li=[]
print(""li: "", str(li))
lo=[]
print(""lo: "", str(lo))
lu=[]
print(""lu: "", str(lu))
ans=[]
print(""ans: "", str(ans))
d1={}
for i in range(n):
    s=input()
    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')
    print(""x: "", str(x))
    if x>0:
        for c in s[::-1]:
            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':
                break
        if (x,c) in d1:
            d1[(x,c)].append(s)
        else :
            d1[(x,c)]=[s]
d2={}
pairs1=[]
print(""pairs1: "", str(pairs1))
pairs2=[]
print(""pairs2: "", str(pairs2))
for k in d1:
    if len(d1[k])%2==1:
        if k[0] in d2:
            d2[k[0]].append(d1[k][0])
        else :
            d2[k[0]]=[d1[k][0]]
        for i in range(1,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
    else :
        for i in range(0,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
for k in d2:
    if len(d2[k])>1:
        if len(d2[k])%2==1:
            d2[k].pop()
        for i in range(0,len(d2[k]),2):
            pairs2.append((d2[k][i],d2[k][i+1]))
if len(pairs1)<len(pairs2):
    print(""len(pairs1): "", str(len(pairs1)))
    for i in range(len(pairs1)):
        print(""pairs2[i][0]: "", str(pairs2[i][0]), ""pairs1[i][0]: "", str(pairs1[i][0]))
        print(""pairs2[i][1]: "", str(pairs2[i][1]), ""pairs1[i][1]: "", str(pairs1[i][1]))
else :
    print(""len(pairs2)+(len(pairs1)-len(pairs2))//2: "", str(len(pairs2)+(len(pairs1)-len(pairs2))//2))
    for i in range(len(pairs2)):
        print(""pairs2[i][0]: "", str(pairs2[i][0]), ""pairs1[i][0]: "", str(pairs1[i][0]))
        print(""pairs2[i][1]: "", str(pairs2[i][1]), ""pairs1[i][1]: "", str(pairs1[i][1]))
    for j in range(len(pairs2),len(pairs1),2):
        if j==len(pairs1)-1:
            break
        else :
            print(""pairs1[j][0]: "", str(pairs1[j][0]), ""pairs1[j+1][0]: "", str(pairs1[j+1][0]))
            print(""pairs1[j][1]: "", str(pairs1[j][1]), ""pairs1[j+1][1]: "", str(pairs1[j+1][1]))
</ans>",0,{}
147,"<ans>
import sys
from functools import lru_cache

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007

def main():
    N, K, *A = list(map(int, read().split()))
    print(""N: "", str(N), ""K: "", str(K), ""A: "", str(A))

    K = list(map(int, f'{K:>040b}'))
    print(""K: "", str(K))

    A2 = [list(map(int, f'{a:>040b}')) for a in A]
    print(""A2: "", str(A2))

    B = [0] * 40
    for a in A2:
        for i, bit in enumerate(a):
            B[i] += bit
    print(""B: "", str(B))

    for i in range(40):
        if B[i] == N - B[i]:
            B[i] = 2
        elif B[i] < N - B[i]:
            B[i] = 1
        else:
            B[i] = 0
    print(""B: "", str(B))

    @lru_cache(maxsize=None)
    def rec(i, x, smaller):
        if i == 40:
            ans = 0
            for a in A:
                ans += x ^ a
            return ans
        elif smaller:
            if B[i] == 2:
                return rec(i + 1, (x << 1), True)
            else:
                return rec(i + 1, (x << 1) + B[i], True)
        else:
            if B[i] == 2:
                if K[i] == 0:
                    return rec(i + 1, (x << 1), False)
                else:
                    return rec(i + 1, (x << 1), True)
            elif K[i] == B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            elif K[i] < B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            else:
                return rec(i + 1, (x << 1) + B[i], True)

    print((rec(0, 0, False)))
    return

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
148,"<ans>
#
# abc069 c
#
import sys
from io import StringIO
import unittest

class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
1 10 100""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""4
1 2 3 4""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""3
1 4 1""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_4(self):
        input = """"""2
1 1""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_5(self):
        input = """"""6
2 7 1 8 2 8""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

def resolve():
    N = int(input())
    print(""N: "", str(N))
    A = list(map(int, input().split()))
    print(""A: "", str(A))

    Q = 0
    E = 0
    O = 0
    for a in A:
        if a % 4 == 0:
            Q += 1
        elif a % 2 == 0:
            E += 1
        else:
            O += 1
    print(""Q: "", str(Q), ""E: "", str(E), ""O: "", str(O))

    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:
        print(""Yes"")
    else:
        print(""No"")

def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",0,{}
149,"<ans>
import sys
input = sys.stdin.readline
enum = enumerate
inf = 1001001001

print(""inf: "", str(inf))

import collections
import random

print(""collections: "", str(collections))
print(""random: "", str(random))

def linput(ty=int, cvt=list):
	return cvt(list(map(ty,input().split())))

print(""linput: "", str(linput))

def vinput(rep=1, ty=int, cvt=list):
	return cvt(ty(input().rstrip()) for _ in ""*""*rep)

print(""vinput: "", str(vinput))

def gcd(a: int, b: int):
	while b: a, b = b, a%b
	return a

print(""gcd: "", str(gcd))

def lcm(a: int, b: int):
	return a * b // gcd(a, b)

print(""lcm: "", str(lcm))

def dist(x1,y1,x2,y2):
	return abs(x1-x2)+abs(y1-y2)

print(""dist: "", str(dist))

#vD = [chr(ord(""a"")+i) for i in range(26)]

print(""vD: "", str(vD))

def ran():
	vRan = [random.randint(1, 10),
	        random.randint(0, 10),
	        random.randint(1, 100)]
	return vRan

print(""ran: "", str(ran))

def bye(res):
	sT = ""No Yes"".split()
	print((sT[res]))
	#return

print(""bye: "", str(bye))

def sol_n(a,b,c):
	res = 0
	cnt = 0
	while cnt<c:
		res += 1
		cnt += a
		if res%7==0:
			cnt += b
	return res

print(""sol_n: "", str(sol_n))

def sol(a,b,c):
	#a,b,c = linput()
	### 3 6 9 12 15
	### 1 2 3 4  5

	res = 0
	L = -(-a//c)
	R = (b//c)
	res = R-L+1

	return res

print(""sol: "", str(sol))

def deb():
	#vI = linput()
	vI = ran()
	#print(vI)
	I = sol_n(*vI)
	J = sol(*vI)
	if 1:#I!=J:
		print((vI, I, J))

print(""deb: "", str(deb))

def main():
	vI = linput()
	print((sol(*vI)))

print(""main: "", str(main))

def __starting_point():
	#for _ in ""*""*1000:
	#	deb()
	main()

print(""__starting_point: "", str(__starting_point))
</ans>",0,{}
150,"<ans>
from math import sqrt, pow, log, log2, log10, exp
from copy import deepcopy
from fractions import gcd

def read_ints():
    return list(map(int, input().split()))

def read_int():
    print(""read_int: "", str(read_int()))
    return read_ints()[0]

def read_floats():
    return list(map(float, input().split()))

def read_float():
    print(""read_float: "", str(read_float()))
    return read_floats()[0]

def format_list(l):
    print(""format_list: "", str(format_list(l)))
    return ' '.join(list(map(str, l)))

def one_dim_array(n, value=0):
    print(""one_dim_array: "", str(one_dim_array(n, value)))
    return [deepcopy(value) for x in range(n)]

def two_dim_array(n, m, value=0):
    print(""two_dim_array: "", str(two_dim_array(n, m, value)))
    return [[deepcopy(value) for x in range(m)] for x in range(n)]

def is_prime(n):
    print(""is_prime: "", str(is_prime(n)))
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, sqrt(n) + 1):
        if n % i == 0:
            return False
    return True

def max_len_sublist(l, f):
    print(""max_len_sublist: "", str(max_len_sublist(l, f)))
    start, max_length, length = 0, 0, 0
    for i in range(1, len(l)):
        if f(l[i], l[i - 1]):
            length += 1
        else:
            if max_length < length:
                start = i - length
                max_length = length
            length = 0
    return start, max_length

def tf_to_yn(b):
    print(""tf_to_yn: "", str(tf_to_yn(b)))
    return 'YES' if b else 'NO'

def longest_non_descent_subsequence(s, restore_sequence=False):
    print(""longest_non_descent_subsequence: "", str(longest_non_descent_subsequence(s, restore_sequence)))
    d = one_dim_array(len(s), 0)
    for i in range(len(s)):
        possible = [d[j] + 1 if s[j] <= s[i] else 1 for j in range(i)]
        d[i] = 1 if len(possible) == 0 else max(possible)

    if not restore_sequence:
        return d[-1] if len(d) != 0 else 0

l = read_int()
p = read_int()
q = read_int()
t = l / (p + q)
print(""t: "", str(t))
print(t*p)

</ans>",0,{}
151,"<ans>
z=[int(p) for p in input().split()]
print(""z: "", str(z))
m=z[2]
print(""m: "", str(m))
lst=[]
print(""lst: "", str(lst))
lst.append(z[0])
print(""lst: "", str(lst))
lst.append(z[1])
print(""lst: "", str(lst))
tempi=min(lst)
print(""tempi: "", str(tempi))
tempa=max(lst)
print(""tempa: "", str(tempa))

count=0
print(""count: "", str(count))
fibo=[]
print(""fibo: "", str(fibo))

n=1000000000000000000
print(""n: "", str(n))

def fib(n):
        a, b = 0, 1
        while b < n:
                fibo.append(b)
                a, b = b, a+b

def add(m):
        n=10**18
        print(""n: "", str(n))
        tempi=min(lst)
        print(""tempi: "", str(tempi))
        tempa=max(lst)
        print(""tempa: "", str(tempa))
        count=0
        print(""count: "", str(count))
        if(tempi>0 and tempa>0 and m>tempa):
                fib(n)
                for p in range(1,len(fibo)+1):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count
        elif(tempi==0 or tempa==0):
                count=1
                fib(n)
                tempi=tempa+(tempi)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count

        elif(tempi<0 and tempa>0):
                val=(-(tempi)//tempa)+1
                count=val
                tempi=tempi+(val*tempa)
                fib(n)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count

</ans>",0,{}
152,"<ans>
```python
# NOT MY CODE
# https://codeforces.com/contest/919/submission/80857331

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        to = f(*args, **kwargs)
        if stack:
            return to
        else:
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        return to
                    to = stack[-1].send(to)
    return wrappedfunc

import sys
input=sys.stdin.readline
from collections import defaultdict as dd

n, m = list(map(int, input().split()))
s = input()
print(""n: "", str(n), ""m: "", str(m), ""s: "", str(s))
d = dd(list)
print(""d: "", str(d))
lol = 0
for i in range(m):
    u, v = list(map(int, input().split()))
    print(""u: "", str(u), ""v: "", str(v))
    if(u == v):
        lol = 1
        print(-1)
        return
    d[u].append(v)
print(""d: "", str(d))

vis = [0] * (n + 1)
rvis = [0] * (n + 1)
cou = [0]
dp = [dd(int) for i in range(n + 1)]
print(""vis: "", str(vis), ""rvis: "", str(rvis), ""cou: "", str(cou), ""dp: "", str(dp))
mx = [0]
h = [0]
print(""mx: "", str(mx), ""h: "", str(h))

@bootstrap
def dfs(u):
    if(h[0] == 1):
        yield
    vis[u] = 1
    rvis[u] = 1
    print(""vis[u]: "", str(vis[u]), ""rvis[u]: "", str(rvis[u]))
    for i in d[u]:
        if(h[0] == 1):
            yield
        if(vis[i] == 0):
            yield dfs(i)
            if(h[0] == 1):
                yield
        elif(rvis[i] == True):
            h[0] = 1
            yield
    rvis[u] = 0
    print(""rvis[u]: "", str(rvis[u]))
    if(h[0] == 1):
        yield
    for i in d[u]:
        for j in dp[i]:
            dp[u][j] = max(dp[u][j], dp[i][j])
            mx[0] = max(mx[0], dp[u][j])
    print(""dp[u]: "", str(dp[u]), ""mx[0]: "", str(mx[0]))
    dp[u][s[u - 1]] += 1
    print(""dp[u][s[u - 1]]: "", str(dp[u][s[u - 1]]))
    mx[0] = max(mx[0], dp[u][s[u - 1]])
    print(""mx[0]: "", str(mx[0]))
    yield

for i in range(1, n + 1):
    if(vis[i] == 0):
        cou = [0]
        dfs(i)
if(h[0]):
    print(-1)
else:
    print(mx[0])
```",0,{}
153,"<ans>
#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float(""inf"")

def solve(N: int, X: int, D: int):
    print(""N: "", str(N), ""X: "", str(X), ""D: "", str(D))
    if D == 0:
        if X == 0:
            print((1))
        else:
            print((N+1))
        return

    if D < 0:
        X = X + (N-1)*D
        D = abs(D)

    segs = defaultdict(list)
    print(""segs: "", str(segs))
    for k in range(N+1):
        L = k*(k-1)//2
        R = k*N - k*(k+1)//2
        Ck = k*X + D*L
        Rk = R-L
        seg = (Ck//D, Ck//D+Rk+1)
        s = Ck % D
        segs[s].append(seg)

    tot = 0
    print(""tot: "", str(tot))
    for k in segs:
        event = defaultdict(int)
        print(""event: "", str(event))
        for l, r in segs[k]:
            event[l] += 1
            event[r] -= 1

        curr = 0
        pre = -1
        for k in sorted(event.keys()):
            if curr > 0:
                tot += k - pre
            curr += event[k]
            pre = k
    print(""tot: "", str(tot))

    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    X = int(next(tokens))  # type: int
    D = int(next(tokens))  # type: int
    solve(N, X, D)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
154,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
p = list(map(int, input().split()))
print(""p: "", str(p))
odd = (n+1)//2
print(""odd: "", str(odd))
even = n-odd
print(""even: "", str(even))
for i in p:
    if i:
        if i%2 == 0:
            even -= 1
        else:
            odd -= 1

if even == 0:
    p = [i if i else 1 for i in p]
    print(""p: "", str(p))
if odd*even == 0:
    ans = 0
    prev = p[0]
    for pi in p:
        ans += (pi+prev)%2
        prev = pi
    print(""ans: "", str(ans))
    return

DP = [[float(""inf"")]*(even+1) for i in range(2)]
print(""DP: "", str(DP))
for i in range(n):
    nxt = [[float(""inf"")]*(even+1) for i in range(2)]
    if i == 0:
        if p[i]:
            if p[i]%2 == 0:
                nxt[0][0] = 0
            else:
                nxt[1][0] = 0
        else:
            nxt[0][1] = 0
            nxt[1][0] = 0
    else:
        if p[i]:
            if p[i]%2 == 0:
                for j in range(even+1):
                    nxt[0][j] = min(DP[0][j], DP[1][j]+1)
            else:
                for j in range(even+1):
                    nxt[1][j] = min(DP[0][j]+1, DP[1][j])
        else:
            for j in range(1, even+1):
                nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)
            for j in range(even+1):
                nxt[1][j] = min(DP[0][j]+1, DP[1][j])
    DP = nxt
    print(""DP: "", str(DP))
print(min(DP[0][-1], DP[1][-1]))
</ans>",0,{}
155,"<ans>
```
# E
N = int(input())
print(""N: "", str(N))
P_list = list(map(int, input().split()))
print(""P_list: "", str(P_list))
X_list = list(map(int, input().split()))
print(""X_list: "", str(X_list))

# graph
child_list = [[] for _ in range(N+1)]
print(""child_list: "", str(child_list))
for i in range(2, N+1):
    child_list[P_list[i-2]].append(i)

# from root
# minimize local total weight

color1 = [0]+X_list
print(""color1: "", str(color1))
color2 = [0]*(N+1)
print(""color2: "", str(color2))

# solve knapsack
def solve_knapsack(L, M):
    min_acc = sum([min(color1[j], color2[j]) for j in L])
    print(""min_acc: "", str(min_acc))
    if min_acc > M:
        return -1
    else:
        add_can = M - min_acc
        add_set = set([0])
        print(""add_set: "", str(add_set))
        for j in L:
            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])
            add_set_ = set(add_set)
            for s in add_set:
                if s + add_j <= add_can:
                    add_set_.add(s + add_j)
            add_set = add_set_
        print(""add_set: "", str(add_set))

        total = sum([color1[j]+color2[j] for j in L])
        print(""total: "", str(total))
        return total - max(add_set) - min_acc

res = ""POSSIBLE""
print(""res: "", str(res))

for i in range(N, 0, -1):
    if len(child_list[i]) == 0:
        pass
    elif len(child_list[i]) == 1:
        j = child_list[i][0]
        if min(color1[j], color2[j]) > X_list[i-1]:
            res = ""IMPOSSIBLE""
            break
        elif max(color1[j], color2[j]) > X_list[i-1]:
            color2[i] = max(color1[j], color2[j])
        else:
            color2[i] = min(color1[j], color2[j])
    else:
        c2 = solve_knapsack(child_list[i], X_list[i-1])
        if c2 < 0:
            res = ""IMPOSSIBLE""
            break
        else:
            color2[i] = c2

print(res)
</ans>",0,{}
156,"<ans>
```
def prime_factor(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            while n % i == 0:
                n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    print(""factors: "", str(factors))
    return factors

def divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    divisors.sort()
    print(""divisors: "", str(divisors))
    return divisors

def mebius(n):
    res = {}
    primes = prime_factor(n)
    m = len(primes)
    for i in range(1 << m):
        mu = 1
        d = 1
        for j in range(m):
            if i >> j & 1:
                mu *= -1
                d *= primes[j]
        res[d] = mu
    print(""res: "", str(res))
    return res

mod = 10**9+7
N, K = list(map(int, input().split()))
div = divisors(N)
print(""N: "", str(N), ""K: "", str(K), ""div: "", str(div))

ans = 0

for x in div:
    div2 = divisors(x)
    mu = mebius(x)
    cnt = 0
    for y in list(mu.keys()):
        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]
    if x % 2 == 0:
        cnt *= pow(2, mod-2, mod)
    ans += x*cnt
    ans %= mod

print(""ans: "", str(ans))
```
</ans>",0,{}
157,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

n = int(minp())
print(""n: "", str(n))
m = [None]*n
print(""m: "", str(m))
k = [None]*3
print(""k: "", str(k))
dp = [None]*3
print(""dp: "", str(dp))
dp[0] = [None]*(n*n)
print(""dp[0]: "", str(dp[0]))
dp[1] = [None]*(n*n)
print(""dp[1]: "", str(dp[1]))
dp[2] = [None]*(n*n)
print(""dp[2]: "", str(dp[2]))
path = [None]*(n*n)
print(""path: "", str(path))
for i in range(n):
	m[i] = list(map(int, minp().split()))
	for j in range(n):
		path[m[i][j]-1] = (i,j)
for z in range(3):
	k_ = [None]*n
	print(""k_: "", str(k_))
	for i in range(n):
		kk = [None]*n
		for j in range(n):
			kkk_ = [None]*3
			for zz in range(3):
				kkk = [None]*n
				for w in range(n):
					kkk[w] = [(1000000,0)]*n
				kkk_[zz] = kkk
			kk[j] = kkk_
		k_[i] = kk
	k[z] = k_

q = [0]*(10*n*n)
print(""q: "", str(q))
qr = 0
km = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
print(""km: "", str(km))
sm = [(1,1),(1,-1),(-1,1),(-1,-1)]
print(""sm: "", str(sm))
lm = [(0,1),(0,-1),(-1,0),(1,0)]
print(""lm: "", str(lm))
mm = [km,sm,lm]
print(""mm: "", str(mm))
for z in range(3):
	for i in range(n):
		for j in range(n):
			ql = 0
			qr = 1
			q[0] = (z, i, j, (0,0))
			kc = k[z][i][j]
			kc[z][i][j] = (0, 0)
			while ql < qr:
				t, x, y, dd = q[ql]
				d = kc[t][x][y]
				ql += 1
				if d != dd:
					continue
				dd = (d[0]+1, d[1]+1)
				for tt in range(3):
					if t != tt and kc[tt][x][y] > dd:
						kc[tt][x][y] = dd
						q[qr] = (tt,x,y,dd)
						qr += 1
				dd = (d[0]+1,d[1])
				if t == 0:
					for w in mm[t]:
						xx,yy = w[0]+x,w[1]+y
						if xx >= 0 and xx < n and yy >= 0 and yy < n:
							if kc[t][xx][yy] > dd:
								kc[t][xx][yy] = dd
								q[qr] = (t,xx,yy,dd)
								qr += 1
				else:
					for w in mm[t]:
						for hm in range(n*2):
							xx,yy = w[0]*hm+x,w[1]*hm+y
							if xx >= 0 and xx < n and yy >= 0 and yy < n:
								if kc[t][xx][yy] > dd:
									kc[t][xx][yy] = dd
									q[qr] = (t,xx,yy,dd)
									qr += 1
							else:
								break
dp[0][0] = (0,0)
dp[1][0] = (0,0)
dp[2][0] = (0,0)
for i in range(0,n*n-1):
	x,y = path[i]
	xx,yy = path[i+1]
	for z in range(3):
		for j in range(3):
			dist = k[j][x][y][z][xx][yy]
			if dp[j][i] != None:
				nd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])
				if dp[z][i+1] == None:
					dp[z][i+1] = nd
				else:
					dp[z][i+1] = min(dp[z][i+1],nd)
for j in range(n*n-1,n*n):
	qq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]
	qm = min(qq)
	print(""qm: "", str(qm[0]), "" "", str(qm[1]))
</ans>",0,{}
158,"<ans>
def increasing(arr):
    n = len(arr)
    print(""n: "", str(n))
    for i in range(n-1):
        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
            return False

    return True

def getFacts(n,mod):
    facts = [1]*n
    print(""facts: "", str(facts))
    for i in range(1,n):
        facts[i] = facts[i-1]*i
        facts[i] %= mod

    return facts

def solve(arr1,arr2,n,mod):
    facts = getFacts(4*10**5+1,mod)
    print(""facts: "", str(facts))
    total = facts[n]
    dist1 = {}
    print(""dist1: "", str(dist1))
    for i in arr1:
        if i[0] not in list(dist1.keys()):
            dist1[i[0]] = 1
        else:
            dist1[i[0]] += 1

    dist2 = {}
    print(""dist2: "", str(dist2))
    for i in arr2:
        if i[0] not in list(dist2.keys()):
            dist2[i[0]] = 1
        else:
            dist2[i[0]] += 1

    count = 1
    for i in dist1:
        count *= facts[dist1[i]]
        count = count%mod

    total -= count
    count = 1

    for i in dist2:
        count *= facts[dist2[i]]
        count = count%mod

    #print(count)
    total -= count

    arr1.sort()
    if increasing(arr1):
        count = 1
    else:
        count = 0
    dist3 = {}
    print(""dist3: "", str(dist3))
    for i in arr1:
        if i not in list(dist3.keys()):
            dist3[i] = 1
        else:
            dist3[i] += 1

    for i in dist3:
        count *= facts[dist3[i]]
        count = count%mod

    #print(count,total)
    total += count
    total = total%mod
    print(total)

def main():
    mod = 998244353
    n = int(input())
    first = []
    second = []
    for i in range(n):
        a,b = list(map(int,input().split()))
        first.append((a,b))
        second.append((b,a))

    solve(first,second,n,mod)

main()
</ans>",0,{}
159,"<ans>
import sys

#縦k、横kのマスに移動させて考える
n, k = map(int, sys.stdin.readline().strip().split())
print(""n: "", str(n), ""k: "", str(k))
x = []
y = []
mx = []
my = []
for _ in range(n):
    xx, yy, c = sys.stdin.readline().strip().split()
    xx = int(xx)
    yy = int(yy)
    print(""xx: "", str(xx), ""yy: "", str(yy), ""c: "", str(c))
    if c == 'W':
        xx += k
    xx %= 2 * k
    yy %= 2 * k
    if xx >= k:
        if yy >= k:
            x.append(xx - k)
            y.append(yy - k)
        else:
            mx.append(xx - k)
            my.append(yy)
    else:
        if yy >= k:
            mx.append(xx)
            my.append(yy - k)
        else:
            x.append(xx)
            y.append(yy)

graph = [[0 for _ in range(k)] for __ in range(k)]
print(""graph: "", str(graph))

#累積和
#lx + lmx = n
lx = len(x)
print(""lx: "", str(lx))
graph[0][0] += lx
for i in range(lx):
    graph[x[i]][0] -= 1
    graph[0][y[i]] -= 1
    graph[x[i]][y[i]] += 2

lmx = len(mx)
print(""lmx: "", str(lmx))
graph[0][0] -= lmx
for i in range(lmx):
    graph[mx[i]][0] += 1
    graph[0][my[i]] += 1
    graph[mx[i]][my[i]] -= 2

for i in graph:
    for j in range(k-1):
        i[j+1] += i[j]

for i in range(k):
    for j in range(k-1):
        graph[j+1][i] += graph[j][i]

#最大値、最小値を取得
big = max([max(i) for i in graph]) + lmx
print(""big: "", str(big))
small = min([min(i) for i in graph]) - lx
print(""small: "", str(small))

if big + small >= 0:
    print(big)
else:
    print(-small)
</ans>",0,{}
160,"<ans>
# coding: utf-8
import sys
#from operator import itemgetter
sysread = sys.stdin.buffer.readline
read = sys.stdin.buffer.read
#from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque
#from decimal import Decimal
#from numba import jit

INF = 1 << 50
EPS = 1e-8
mod = 10 ** 9 + 7

def run():
    N = int(input())
    print(""N: "", str(N))
    nines = [9 ** i for i in range(1, 10) if 9 ** i <= N]
    print(""nines: "", str(nines))
    sixes = [6 ** i for i in range(1, 10) if 6 ** i <= N][::-1]
    print(""sixes: "", str(sixes))
    L = len(nines)
    print(""L: "", str(L))
    min_ans = INF
    for K in product(list(range(9)), repeat = L):
        print(""K: "", str(K))
        ans = 0
        s = 0
        for k, x in zip(K, nines):
            if k:
                ans += k
                s += x * k
        print(""ans: "", str(ans), ""s: "", str(s))

        if s > N:continue
        resid = N - s
        print(""resid: "", str(resid))
        for six in sixes:
            print(""six: "", str(six))
            tmp = resid // six
            if tmp:
                ans += tmp
                resid -= six * tmp
        print(""resid: "", str(resid), ""ans: "", str(ans))
        #if resid >= 6:
        #    print(resid)
        ans += resid
        min_ans = min(min_ans,ans)

    print(min_ans)

def __starting_point():
    run()

__starting_point()
</ans>",0,{}
161,"<ans>
# -*- coding: utf-8 -*-
import sys
# from operator import itemgetter
# from fractions import gcd
# from math import ceil, floor
# from copy import deepcopy
# from itertools import accumulate
from collections import deque
# import math
# from functools import reduce
input = sys.stdin.readline
def ii(): return int(input())
def mi(): return list(map(int, input().rstrip().split()))
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())
# template

# BEGIN CUT HERE


class BIT:
    def __init__(self, x, d=0):
        print(""x: "", str(x), ""d: "", str(d))
        if isinstance(x, int):
            self.size = x
            print(""self.size: "", str(self.size))
            self.tree = [d for _ in range(self.size + 1)]
            print(""self.tree: "", str(self.tree))
        elif isinstance(x, list):
            self.size = len(x)
            print(""self.size: "", str(self.size))
            self.tree = [d for _ in range(self.size + 1)]
            print(""self.tree: "", str(self.tree))
            self.build(x)
        else:
            raise TypeError

    def build(self, arr):
        print(""arr: "", str(arr))
        if not isinstance(arr, list):
            raise TypeError
        for num, x in enumerate(arr):
            print(""num: "", str(num), ""x: "", str(x))
            self.add0(num, x)

    def sum(self, i):
        print(""i: "", str(i))
        s = self.tree[0]
        while i > 0:
            s += self.tree[i]
            i -= (i & -i)
        return s

    def add(self, i, a):
        print(""i: "", str(i), ""a: "", str(a))
        if(i == 0):
            return
        while (i <= self.size):
            self.tree[i] += a
            i += (i & -i)

    def bisect_left(self, w):
        print(""w: "", str(w))
        if w <= 0:
            return 0
        x = 0
        r = 1
        while (r < self.size):
            r <<= 1
        k = r
        while (k > 0):
            if x + k <= self.size and self.tree[x + k] < w:
                w -= self.tree[x + k]
                x += k
            k >>= 1
        return x + 1

    def query(self, l, r):
        print(""l: "", str(l), ""r: "", str(r))
        return self.sum(r - 1) - self.sum(l - 1)

    def sum0(self, i):
        print(""i: "", str(i))
        return self.sum(i + 1)

    def add0(self, i, a):
        print(""i: "", str(i), ""a: "", str(a))
        self.add(i + 1, a)

    def query0(self, l, r):
        print(""l: "", str(l), ""r: "", str(r))
        return self.sum(r) - self.sum(l)

    def __getitem__(self, item):
        _tmp = item.indices(self.size + 1)
        print(""item: "", str(item), ""_tmp: "", str(_tmp))
        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]

    def __str__(self):
        return str(self[1:self.size + 1])

# END CUT


def main():
    n = ii()
    print(""n: "", str(n))
    a = lmi()
    print(""a: "", str(a))
    q = ii()
    print(""q: "", str(q))
    bit = BIT(a)
    print(""bit: "", str(bit))
    for i in range(q):
        l, r = mi()
        print(""l: "", str(l), ""r: "", str(r))
        a = bit.query(l, r+1)
        print(""a: "", str(a))
        print((a-a % 10)//10)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
162,"<ans>
```python
import logging
import collections

fmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'
formatter = logging.Formatter(fmt)

ch = logging.StreamHandler()
ch.setLevel(logging.NOTSET)
ch.setFormatter(formatter)

logger = logging.getLogger('bus_of_characters')
logger.setLevel(logging.NOTSET)
logger.addHandler(ch)

def solve(w, s):
    print(""w: "", str(w))
    free = collections.deque()
    print(""free: "", str(free))
    used = collections.deque()
    print(""used: "", str(used))

    for w in sorted(enumerate(w), key=lambda x: x[1]):
        print(""w: "", str(w))
        free.append([w[0] + 1, w[1]])
        print(""free: "", str(free))

    ids = [-1] * len(s)
    print(""ids: "", str(ids))

    order = []
    for pid, p in enumerate(s):
        logger.debug('pid: %s', pid)
        if p == '0':
            taken = free.popleft()
            print(""taken: "", str(taken))
            used.appendleft(taken)
            print(""used: "", str(used))
            # order.append(pid, taken[0])
        else:
            logger.debug('used %s', used)
            taken = used.popleft()
            print(""taken: "", str(taken))
        #order.append([pid, taken[0]])
        ids[pid] = taken[0]

    print(""ids: "", str(ids))
    return [x for x, y in ids]

def main():
    n = int(input().strip())
    w = [int(x) for x in input().strip().split()]
    s = input().strip()

    result = solve(w, s)
    print(' '.join(map(str, result)))

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
163,"<ans>
#!/usr/bin/env python3
from sys import stdin
from bisect import bisect_left, bisect_right

INF = int(1e9)

def find(par, a):
    print(""par: "", str(par))
    print(""a: "", str(a))
    if par[a] == a:
        return a
    par[a] = find(par, par[a])
    return par[a]

def union(par, rnk, a, b):
    a = find(par,a)
    b = find(par,b)
    print(""a: "", str(a))
    print(""b: "", str(b))
    if a==b:
        return

    if rnk[a]<rnk[b]:
        par[a] = b
    else:
        par[b] = a
        if rnk[a]==rnk[b]:
            rnk[a] += 1

def solve():
    n, m, k = map(int, stdin.readline().split())
    print(""n: "", str(n))
    print(""m: "", str(m))
    print(""k: "", str(k))
    cnts = list(map(int, stdin.readline().split()))
    print(""cnts: "", str(cnts))
    for i in range(1,k):
        cnts[i] += cnts[i-1]

    group = list(range(n))
    print(""group: "", str(group))
    rnk = [0 for i in range(n)]
    print(""rnk: "", str(rnk))
    adj = [[INF for j in range(k)] for i in range(k)]
    print(""adj: "", str(adj))
    for i in range(m):
        u, v, x = map(int, stdin.readline().split())
        print(""u: "", str(u))
        print(""v: "", str(v))
        print(""x: "", str(x))
        if x==0:
            union(group, rnk, u-1, v-1)
        tu = bisect_left(cnts, u)
        tv = bisect_left(cnts, v)
        adj[tu][tv] = min(adj[tu][tv], x)
        adj[tv][tu] = min(adj[tv][tu], x)

    p = 0
    for i in range(k):
        cur = group[p]
        while p<cnts[i]:
            if group[p]!=cur:
                print(""No"")
                return
            p += 1
    print(""Yes"")

    for p in range(k):
        for i in range(k):
            for j in range(k):
                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])

    for i in range(k):
        adj[i][i] = 0
        for j in range(k):
            if adj[i][j] == INF:
                adj[i][j] = -1

    for i in range(k):
        print(' '.join(map(lambda x: str(x), adj[i])))

solve()
</ans>",0,{}
164,"<ans>
from sys  import stdin,stdout

st=lambda:list(stdin.readline().strip())
li=lambda:list(map(int,stdin.readline().split()))
mp=lambda:list(map(int,stdin.readline().split()))
inp=lambda:int(stdin.readline())
pr=lambda n: stdout.write(str(n)+""\n"")

def valid(x,y):
    print(""x: "", str(x), ""y: "", str(y))
    if x>=n or y>=m or x<0 or y<0:
        return False
    if v[x][y] or l[x][y]=='*':
        return False
    return True

dx=[-1,1,0,0]
dy=[0,0,1,-1]

def DFS(i,j,val):
    print(""i: "", str(i), ""j: "", str(j), ""val: "", str(val))
    ans=1
    connected=[(i,j)]
    stack=[(i,j)]
    v[i][j]=True
    while stack:
        a,b=stack.pop()
        for x in range(4):
            newX,newY=a+dx[x], b+dy[x]
            if valid(newX,newY):
                stack.append((newX,newY))
                v[newX][newY]=True
                connected.append((newX,newY))
                ans= (ans%10 + 1%10) % 10

    for i in connected:
        a,b=i
        l[a][b]=(ans,val)

n,m=mp()
print(""n: "", str(n), ""m: "", str(m))
l=[st() for i in range(n)]
print(""l: "", str(l))
val=0
k=[list(i) for i in l]
v=[[False for i in range(m)] for j in range(n)]
print(""v: "", str(v))
for i in range(n):
    for j in range(m):
        if l[i][j]=='.' and not v[i][j]:
            DFS(i,j,val)
            val+=1

for  i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            k[i][j]=1
            s=set()
            for x in range(4):
                newX,newY= i+dx[x], j+dy[x]
                if newX>=0 and newY>=0 and newX<n and newY<m:
                    if type(l[newX][newY])==tuple:
                        A,B=l[newX][newY]
                        if B not in s:
                            k[i][j]+=A
                            k[i][j]%=10
                            s.add(B)

print('\n'.join([''.join([str(i) for i in j]) for j in k]))
</ans>",0,{}
165,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]

print(""M: "", str(M), ""mod: "", str(mod))

for _ in range(val()):
    n,l,r = li()
    print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))
    orig = r
    l -= 1
    r -= l

    currleft = 0
    curs = n - 1
    print(""currleft: "", str(currleft), ""curs: "", str(curs))
    while curs and currleft + 2*curs <= l:
        currleft += 2*curs
        curs -= 1

    start = n - curs
    print(""start: "", str(start))
    ans = []
    head = start
    l -= currleft

    last = head + 1
    half = 0
    print(""last: "", str(last), ""half: "", str(half))
    while l:
        half = 1
        start = last
        last += 1
        l -= 1
        if not l:break
        half = 0
        start = head
        l -= 1

    if half:
        ans.append(start)
        if last == n + 1:
            head += 1
            last = head + 1
        start = head
        r -= 1

    while r:
        ans.append(start)
        r -= 1
        if not r:break
        start = last
        ans.append(start)
        last += 1
        if last == n + 1:
            head += 1
            last = head + 1
        r -= 1
        start = head

    if orig == n*(n-1) + 1:
        ans[-1] = 1

    print(*ans)

</ans>",0,{}
166,"<ans>
array2=input("""").split(' ')
print(""array2: "", str(array2))
summ=0
print(""summ: "", str(summ))
array=list()
print(""array: "", str(array))
for t in range (0,int(array2[0])):
    g=input("""")
    array.append(g)
if (int(array2[1])==0):
    for b in range (0,int(array2[0])):
        if '0' in array[b]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==1):
    for c in range (0,int(array2[0])):
        if '0' in array[c] and '1' in array[c]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==2):
    for d in range (0,int(array2[0])):
        if '0' in array[d] and '1' in array[d] and '2' in array[d]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==3):
    for e in range (0,int(array2[0])):
        if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==4):
    for f in range (0,int(array2[0])):
        if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==5):
    for g in range (0,int(array2[0])):
        if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==6):
    for h in range (0,int(array2[0])):
        if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==7):
     for i in range (0,int(array2[0])):
                if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:
                    summ=summ+1
     print(""summ: "", str(summ))
if (int(array2[1])==8):
    for j in range (0,int(array2[0])):
        if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==9):
    for k in range (0,int(array2[0])):
        if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:
            summ=summ+1
    print(""summ: "", str(summ))
</ans>",0,{}
167,"<ans>
import sys
import random
from math import *

def input():
    return sys.stdin.readline().strip()

def iinput():
    print(""iinput: "", str(iinput))
    return int(input())

def finput():
    print(""finput: "", str(finput))
    return float(input())

def tinput():
    print(""tinput: "", str(tinput))
    return input().split()

def linput():
    print(""linput: "", str(linput))
    return list(input())

def rinput():
    print(""rinput: "", str(rinput))
    return map(int, tinput())

def fiinput():
    print(""fiinput: "", str(fiinput))
    return map(float, tinput())

def rlinput():
    print(""rlinput: "", str(rlinput))
    return list(map(int, input().split()))

def trinput():
    print(""trinput: "", str(trinput))
    return tuple(rinput())

def srlinput():
    print(""srlinput: "", str(srlinput))
    return sorted(list(map(int, input().split())))

def NOYES(fl):
    print(""NOYES: "", str(NOYES), ""fl: "", str(fl))
    if fl:
        print(""NO"")
    else:
        print(""YES"")

def YESNO(fl):
    print(""YESNO: "", str(YESNO), ""fl: "", str(fl))
    if fl:
        print(""YES"")
    else:
        print(""NO"")

def main():
    x, y, n = rinput()
    res = n - y
    print(x * (res // x) + y)

for inytd in range(iinput()):
    main()
</ans>",0,{}
168,"<ans>
```
def bitmake(digit):#bit文字列生成（取り扱い注意）
    print(""digit: "", str(digit))
    bit_list =list()

    for i in range(2 ** digit):
        bit = []
        for j in range(digit):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                bit.append(j)
        bit_list.append(bit)
    print(""bit_list: "", str(bit_list))
    return bit_list
h,w,k = list(map(int,input().split()))
print(""h: "", str(h), ""w: "", str(w), ""k: "", str(k))
grid = [""""]*h
for i in range(h):
    grid[i] = list(map(str,input()))
# print(grid)

bit_list = bitmake(h+w)
# print(bit_list)
blackh = [0]*h#横
blackw = [0]*w#縦
blacksum = 0
for i in range(h):
    for j in range(w):
        if(grid[i][j] == ""#""):
            blackh[i]+=1
            blackw[j]+=1
            grid[i][j] = 1
            blacksum += 1
        else:
            grid[i][j] = 0
print(""blackh: "", str(blackh), ""blackw: "", str(blackw), ""blacksum: "", str(blacksum))
ans = 0
for i in range(2**(h+w)):
    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1
    remove = 0
    hight = []
    width = []
    for j in range(len(bit)):
        l = bit[j]
        if(l <= h-1):
            remove += blackh[l]
            hight.append(l)
        else:
            ind = l - h
            remove += blackw[ind]
            width.append(ind)
    print(""hight: "", str(hight), ""width: "", str(width))
    rid = 0
    for j in range(len(hight)):
        for l in range(len(width)):
            if(grid[hight[j]][width[l]] == 1):
                rid += 1

    if((blacksum - remove) + rid == k):
        # print(blacksum,remove,rid,""___"",blacksum-remove+rid)
        ans += 1
print(""ans: "", str(ans))

# 2 3 2
# ..#
# ###
```
</ans>",0,{}
169,"<ans>
n=int(input())
print(""n: "", str(n))
if (n == 1) :
 print (""Washington"")
elif (n == 2):
 print (""Adams"")
elif (n == 3):
 print (""Jefferson"")
elif (n == 4):
 print (""Madison"")
elif (n == 5):
 print (""Monroe"")
elif (n == 6):
 print (""Adams"")
elif (n == 7):
 print (""Jackson"")
elif (n == 8):
 print (""Van Buren"")
elif (n == 9):
 print(""Harrison"")
elif (n == 10):
 print(""Tyler"")
elif (n == 11):
 print(""Polk"")
elif (n == 12):
 print(""Taylor"")
elif (n == 13):
 print(""Fillmore"")
elif (n == 14):
 print(""Pierce"")
elif (n == 15):
 print(""Buchanan"")
elif (n == 16):
 print (""Lincoln"")
elif (n == 17):
 print (""Johnson"")
elif (n == 18):
 print (""Grant"")
elif (n == 19):
 print (""Hayes"")
elif (n == 20):
 print (""Garfield"")
elif (n == 21):
 print (""Arthur"")
elif (n == 22):
 print (""Cleveland"")
elif (n == 23):
 print (""Harrison"")
elif (n == 24):
 print (""Cleveland"")
elif (n == 25):
 print (""McKinley"")
elif (n == 26):
 print (""Roosevelt"")
elif (n == 27):
 print (""Taft"")
elif (n == 28):
 print (""Wilson"")
elif (n == 29):
 print ('Harding')
elif (n == 30):
 print (""Coolidge"")
elif (n == 31):
 print (""Hoover"")
elif (n == 32):
 print (""Roosevelt"")
elif (n == 33):
 print (""Truman"")
elif (n == 34):
 print (""Eisenhower"")
elif (n == 35):
 print (""Kennedy"")
elif (n == 36):
 print (""Johnson"")
elif (n == 37):
 print (""Nixon"")
elif n == 38:
 print (""Ford"")
elif n == 39:
 print (""Carter"")
elif n == 40:
 print (""Reagan"")
</ans>",1,{}
170,"<ans>
import math
from decimal import Decimal
import heapq
def na():
	n = int(input())
	b = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	return n,b

def nab():
	n = int(input())
	b = [int(x) for x in input().split()]
	c = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	print(""c: "", str(c))
	return n,b,c

def dv():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n))
	print(""m: "", str(m))
	return n,m

def dva():
	n, m = list(map(int, input().split()))
	a = [int(x) for x in input().split()]
	b = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""m: "", str(m))
	print(""a: "", str(a))
	print(""b: "", str(b))
	return n,m,b

def eratosthenes(n):
	sieve = list(range(n + 1))
	print(""sieve: "", str(sieve))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))

def lol(lst,k):
	k=k%len(lst)
	ret=[0]*len(lst)
	print(""lst: "", str(lst))
	print(""k: "", str(k))
	print(""ret: "", str(ret))
	for i in range(len(lst)):
		if i+k<len(lst) and i+k>=0:
			ret[i]=lst[i+k]
		if i+k>=len(lst):
			ret[i]=lst[i+k-len(lst)]
		if i+k<0:
			ret[i]=lst[i+k+len(lst)]
	return(ret)

def nm():
	n = int(input())
	b = [int(x) for x in input().split()]
	m = int(input())
	c = [int(x) for x in input().split()]
	print(""n: "", str(n))
	print(""b: "", str(b))
	print(""m: "", str(m))
	print(""c: "", str(c))
	return n,b,m,c

def dvs():
	n = int(input())
	m = int(input())
	print(""n: "", str(n))
	print(""m: "", str(m))
	return n, m

def Factor(n):
	Ans = []
	d = 2
	while d * d <= n:
		if n % d == 0:
			Ans.append(d)
			n //= d
		else:
			d += 1
	if n > 1:
		Ans.append(n)
	print(""Ans: "", str(Ans))
	return Ans

s = input()
a1 = 'Mike'
a2 = 'Ann'
if len(s) == 1:
	print(a1)
	return
print(a1)
tc = s[0]
pre = []
n = len(s)
for i in range(1, n):
	d = min(s[i], tc)
	pre.append(d)
	tc = d
print(""pre: "", str(pre))
for i in range(1, n):
	if pre[i - 1] < s[i]:
		print(a2)
	else:
		print(a1)

</ans>",0,{}
171,"<ans>
t,sx,sy,ex,ey=map(int,input().split())
print(""t: "", str(t), ""sx: "", str(sx), ""sy: "", str(sy), ""ex: "", str(ex), ""ey: "", str(ey))
w=input()
print(""w: "", str(w))
n=len(w)
print(""n: "", str(n))
w+="" ""
print(""w: "", str(w))
ans=-1
print(""ans: "", str(ans))
i=0
print(""i: "", str(i))
dx=ex-sx
print(""dx: "", str(dx))
dy=ey-sy
print(""dy: "", str(dy))
if abs(dx)+abs(dy)>t:
    pass
else:
    while i<=t and i<n:
        if dx==0 and dy==0:
            ans=i
            break
        if dx>=0 and dy>=0:
            if ((w[i]!=""E"" and w[i]!=""N"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                dx-=1
            if dy>0 and w[i]==""N""and i<n:
                i+=1
                dy-=1
        elif dx>=0 and dy<=0:
            if ((w[i]!=""E"" and w[i]!=""S"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                dx-=1
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                dy+=1
        elif dx<=0 and dy>=0:
            if ((w[i]!=""W"" and w[i]!=""N"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                dx+=1
            if dy>0 and w[i]==""N"" and i<n:
                i+=1
                dy-=1
        elif dx<=0 and dy<=0:
            if ((w[i]!=""W"" and w[i]!=""S"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                dx+=1
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                dy+=1
if dx==0 and dy==0:
            ans=i
print(""ans: "", str(ans))
</ans>",1,{}
172,"<ans>
def __starting_point():
    inp = input()
    arr = inp.split(' ')
    print(""inp: "", str(inp))
    print(""arr: "", str(arr))
    L = [int(x) for x in arr]
    print(""L: "", str(L))
    ans = [0,0,0]
    print(""ans: "", str(ans))
    s = 0
    for l in L:
        s+=l
    print(""s: "", str(s))
    imp = False
    for l in L:
        if l>s/2:
            imp = True
    if imp:
        print('Impossible')
    else:
##        m = min(L)//2
##        for i in (0,1,2):
##            ans[i]+=m
##            L[i]-=m*2
####        print(ans)
        imp = False
        if L[0]==min(L):
            if L[1]>L[2]:
                bonds = L[1]-L[2]
                ans[0] += bonds
                L[0]-= bonds
                L[1] -=bonds
            else:
                bonds = L[2]-L[1]
                ans[2] += bonds
                L[0] -= bonds
                L[2] -= bonds
            if L[0]%2==1:
                imp = True
            else:
                bonds = L[0]//2
                ans[0] += bonds
                ans[2] += bonds
                ans[1] += (L[1]+L[2])//2 - bonds
        elif L[1]==min(L):
            if L[0]>L[2]:
                bonds = L[0]-L[2]
                ans[0] += bonds
                L[1]-= bonds
                L[0] -= bonds
            else:
                bonds = L[2]-L[0]
                ans[1] += bonds
                L[1] -= bonds
                L[2] -= bonds
            if L[1]%2==1:
                imp = True
            else:
                bonds = L[1]//2
                ans[0] += bonds
                ans[1] += bonds
                ans[2] += (L[0]+L[2])//2 - bonds

        else:
            if L[0]>L[1]:
                bonds = L[0]-L[1]
                ans[2] += bonds
                L[2]-= bonds
                L[0]-=bonds
            else:
                bonds = L[1]-L[0]
                ans[1] += bonds
                L[2] -= bonds
                L[1] -= bonds
            if L[2]%2==1:
                imp = True
            else:
                bonds = L[2]//2
                ans[2] += bonds
                ans[1] += bonds
                ans[0] += (L[0]+L[1])//2 - bonds

        for i in ans:
            if i<0:
                imp = True
        if imp:
            print('Impossible')
        else:
            for i in range(3):
                print(ans[i],end=' ')
            print()

__starting_point()
</ans>",0,{}
173,"<ans>
import math as ma
import sys
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))
print(""li: "", str(li))

def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	return x
print(""modInverse: "", str(modInverse))

def num():
	return map(int , input().split())
print(""num: "", str(num))

def nu():
	return int(input())
print(""nu: "", str(nu))

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x
print(""find_gcd: "", str(find_gcd))

n,k=num()
print(""n: "", str(n), ""k: "", str(k))
h=li()
print(""h: "", str(h))
a=[0]*(max(h)+5)
print(""a: "", str(a))
mx=max(h)
print(""mx: "", str(mx))
mn=min(h)
print(""mn: "", str(mn))
fo=True
print(""fo: "", str(fo))
for i in range(1,n):
	if(h[i]!=h[i-1]):
		fo=False
		break
for i in range(n):
	a[0]+=1
	a[h[i]+1]-=1
for i in range(1,len(a)):
	a[i]=a[i]+a[i-1]
s=a[mx]
print(""s: "", str(s))
cc=0
fl=False
for i in range(mx-1,mn,-1):
	if(s+a[i]>k):
		fl=True
		s=a[i]
		cc+=1
	else:
		fl=False
		s+=a[i]
if(s<=k and fo==False):
	cc+=1
print(""cc: "", str(cc))
print(cc)
</ans>",0,{}
174,"<ans>
MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]
print(""MOVS: "", str(MOVS))
def check(a):
    return 0<=a<8
print(""check: "", str(check))
set1 = set()
print(""set1: "", str(set1))
set2 = set()
print(""set2: "", str(set2))
dic1 = dict()
print(""dic1: "", str(dic1))
dic2 = dict()
print(""dic2: "", str(dic2))
def cango1(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check (nx) or not check(ny):
            continue
        if (nx,ny) in set1:
            continue
        dic1[(nx,ny)]=lap%2
        set1.add((nx,ny))
        cango1(matrix,(nx,ny),lap+1)
def cango2(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check(nx) or not check(ny):
            continue
        if (nx,ny) in set2:
            continue
        dic2[(nx,ny)]=lap%2
        set2.add((nx,ny))
        cango2(matrix,(nx,ny),lap+1)
q = int(input())
for ww in range(q):
    matrix = [input().strip() for i in range(8)]
    pos = []
    bad = set()
    for i in range(8):
        for j in range(8):
            if matrix[i][j] == 'K':
                pos.append((i,j))
            if matrix[i][j]=='#':
                bad.add((i,j))
    set1,set2,dic1,dic2=set(),set(),dict(),dict()
    cango1(matrix, pos[0],0)
    cango2(matrix,pos[1],0)
    if ww!=q-1:
        input()
    sec = (set1&set2) - bad
    for x,y in sec:
        if dic1[(x,y)]==dic2[(x,y)]:
            print(""YES"")
            break
    else:
        print(""NO"")
</ans>",0,{}
175,"<ans>
```python
'''input
3
0 2 0
1 0 3
'''
from sys import stdin
from copy import deepcopy
from collections import deque

def find_start(pile):
    start = 1
    index = -1
    print(""start: "", str(start))
    print(""index: "", str(index))
    for i in range(len(pile)):
        if pile[i] == start:
            index = i
            break
    latest = start
    print(""latest: "", str(latest))
    if index != -1:
        flag = True
        print(""flag: "", str(flag))
        for i in range(index, len(pile)):
            if pile[i] == latest:
                latest += 1
            else:
                flag = False
                break
        print(""latest: "", str(latest))
        print(""flag: "", str(flag))
        if flag:
            start = latest
    print(""start: "", str(start))
    return start

def check_start(num, op):
    op[0] = 0
    nonlocal arr
    nonlocal barr
    print(""op[0]: "", str(op[0]))
    mydict = [0] * (n + 1)
    print(""mydict: "", str(mydict))
    for i in range(len(arr)):
        mydict[arr[i]] += 1
    print(""mydict: "", str(mydict))
    zeroes = mydict[0]
    print(""zeroes: "", str(zeroes))
    pile = deque(barr[:])
    print(""pile: "", str(pile))
    for i in range(num):
        if zeroes > 0:
            op[0] += 1
            print(""op[0]: "", str(op[0]))
            pile.append(0)
            zeroes -= 1
            mydict[0] -= 1
        else:
            return False
        element = pile.popleft()
        print(""element: "", str(element))
        mydict[element] += 1
        print(""mydict: "", str(mydict))
        if element == 0:
            zeroes += 1
    print(""zeroes: "", str(zeroes))
    start = find_start(barr)
    print(""start: "", str(start))
    for i in range(start, n + 1):
        if mydict[i] > 0:
            op[0] += 1
            print(""op[0]: "", str(op[0]))
            pile.append(i)
            mydict[i] -= 1
            element = pile.popleft()
            mydict[element] += 1
        else:
            return False
    return True

n = int(stdin.readline().strip())
arr = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
start = 0
end = 2 * n
op = [0]
print(""n: "", str(n))
print(""arr: "", str(arr))
print(""barr: "", str(barr))
print(""start: "", str(start))
print(""end: "", str(end))
print(""op: "", str(op))
if check_start(0, op):
    print(op[0])
    return
pos = [0] * (n + 1)
print(""pos: "", str(pos))
for i in range(n):
    pos[barr[i]] = i + 1
print(""pos: "", str(pos))
ans = -float('inf')
print(""ans: "", str(ans))
for i in range(1, n + 1):
    ans = max(pos[i] - i  + 1 + n, ans)
print(""ans: "", str(ans))
```",0,{}
176,"<ans>
def xmax(x, y):
    print(""x: "", str(x), ""y: "", str(y))
    if x[1] > y[1]:
        return x
    return y

class SegTree:
    def __init__(self, init_val, n, ide_ele, seg_func):
        self.segfunc = seg_func
        print(""segfunc: "", str(seg_func))
        self.num = 2**(n-1).bit_length()
        print(""num: "", str(self.num))
        self.ide_ele = ide_ele
        print(""ide_ele: "", str(self.ide_ele))
        self.seg=[self.ide_ele]*2*self.num
        print(""seg: "", str(self.seg))
        for i in range(n):
            self.seg[i+self.num-1]=init_val[i]
        print(""init_val: "", str(init_val))
        for i in range(self.num-2,-1,-1) :
            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])

    def update(self, k, x):
        ll = k
        k += self.num-1
        self.seg[k] = (ll, self.seg[k][1] + x)
        print(""k: "", str(k), ""x: "", str(x), ""self.seg[k]: "", str(self.seg[k]))
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])

    def update2(self, k, x):
        k += self.num-1
        self.seg[k] = x
        print(""k: "", str(k), ""x: "", str(x))
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])

    def query(self, p, q):
        if q<=p:
            return self.ide_ele
        p += self.num-1
        q += self.num-2
        res=self.ide_ele
        while q-p>1:
            if p&1 == 0:
                res = self.segfunc(res,self.seg[p])
            if q&1 == 1:
                res = self.segfunc(res,self.seg[q])
                q -= 1
            p = p//2
            q = (q-1)//2
        if p == q:
            res = self.segfunc(res,self.seg[p])
        else:
            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])
        return res

import sys;input=sys.stdin.readline
N, M = map(int, input().split())
print(""N: "", str(N), ""M: "", str(M))
X = list(map(int, input().split()))
print(""X: "", str(X))
sts = [[] for _ in range(N)]
for i in range(1, M+1):
    a, b = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b))
    sts[a-1].append((i, b-1))
    sts[b-1].append((i, a-1))
    X[a-1] -= 1
    X[b-1] -= 1
minf = -(10 ** 18)-1
ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)
f = False
R = []
vs = set()
while True:
    j, mx = ss.query(0, N)
    print(""j: "", str(j), ""mx: "", str(mx))
    if mx<0:
        f=True
        break
    while sts[j]:
        i, co = sts[j].pop()
        print(""i: "", str(i), ""co: "", str(co))
        if i in vs:
            continue
        vs.add(i)
        ss.update(co, 1)
        R.append(i)
    if len(R) == M:break
    ss.update2(j, (j, minf))

if f or len(R) != M:print(""DEAD"")
else:print(""ALIVE"");print(*R[::-1])
</ans>",0,{}
177,"<ans>
import sys
import math

def ii():
    return sys.stdin.readline().strip()

def idata():
    print(""idata: "", str(idata))
    return [int(x) for x in ii().split()]

def bfs(graph1, root1):
    visited1 = set()
    print(""visited1: "", str(visited1))
    queue1 = [[root1, 0]]
    print(""queue1: "", str(queue1))
    visited1.add(root1)
    qw, ver = 0, 1
    while queue1:
        vertex1 = queue1[0]
        queue1 = queue1[1:]
        for neig1 in graph1[vertex1[0]]:
            if neig1 not in visited1:
                visited1.add(neig1)
                queue1 += [[neig1, vertex1[1] + 1]]
                if qw < vertex1[1] + 1:
                    ver, qw = neig1, vertex1[1] + 1
    return ver, qw

def dfs(graph, ver):
    used_v = set()
    print(""used_v: "", str(used_v))
    depth = [0] * (len(graph) + 1)
    print(""depth: "", str(depth))
    level = [ver]
    print(""level: "", str(level))
    num_of_level = 0
    while level:
        new_level = []
        for v in level:
            depth[v] = num_of_level
            used_v.add(v)
            for v1 in graph[v]:
                if v1 not in used_v:
                    new_level += [v1]
        level = new_level
        num_of_level += 1
    return depth

def binary_search(array, x):
    left, right = -1, len(array)
    print(""left: "", str(left), ""right: "", str(right))
    while left + 1 != right:
        middle = (left + right) // 2
        print(""middle: "", str(middle))
        if array[middle] >= x:
            right = middle
        elif array[middle] < x:
            left = middle
    return right

def c_mod(n1, k1, mod1):
    num = den = 1
    print(""num: "", str(num), ""den: "", str(den))
    for i in range(n1 - k1):
        num = (num * (n1 - i)) % mod1
        den = (den * (i + 1)) % mod1
    return (num * pow(den, mod1 - 2, mod1)) % mod1

def c(n1, k1):
    num = den = 1
    print(""num: "", str(num), ""den: "", str(den))
    for i in range(n1 - k1):
        num = num * (n1 - i)
        den = den * (i + 1)
    return num // den

def v_sistemu(x, k):
    x = int(x)
    print(""x: "", str(x))
    z = ''
    while x:
        z += str(x % k)
        x //= k
    return z[::-1]

def iz_sistemi(x, k):
    x = str(x)[::-1]
    print(""x: "", str(x))
    ans = 0
    for i in range(len(x)):
        ans += int(x[i]) * pow(k, i)
    return ans

def solve_of_problem():
    n = int(ii())
    print(""n: "", str(n))
    ans = 2
    for i in range(n):
        ans *= 2
        if n % (ans - 1) == 0:
            print(n // (ans - 1))
            return
    return

for ______ in range(int(ii())):
    solve_of_problem()

</ans>",0,{}
178,"<ans>
import sys

def Min(x, y):
    if x > y:
        return y
    else:
        return x

def Gcd(x, y):
    if x == 0:
        return y
    else:
        return Gcd(y % x, x)

def Lcm(x, y):
    return x * y // Gcd(x, y)

n = int(input())
print(""n: "", str(n))
a = [int(i) for i in input().split()]
print(""a: "", str(a))
d = [int(0) for i in range(0, n)]
print(""d: "", str(d))

ok = 0

cur = 0

len = Lcm(7, n)
print(""len: "", str(len))

for i in range(0, 7 * n):
    if a[i % n] == 0 :
        print(i % n + 1)
        ok = 1
        break
    if cur != 6:
        a[i % n] -= 1
        d[i % n] += 1
    cur = (cur + 1) % 7

if ok == 0:
    k = 10**20

    for i in range(0, n):
        a[i] += d[i]
        if d[i] == 0: continue
        if a[i] % d[i] > 0:
            k = Min(k, a[i] // d[i])
        else:
            k = Min(k, a[i] // d[i] - 1)

    if k == 10**20:
        k = 0

    for i in range(0, n):
        a[i] -= k * d[i]

    iter = 0
    cur = 0

    while True:
        if a[iter] == 0:
            print(iter % n + 1)
            break
        else:
            if cur != 6:
                a[iter] -= 1
            cur = (cur + 1) % 7
            iter = (iter + 1) % n

</ans>",0,{}
179,"<ans>
A, B, C, X, Y = map(int, input().split())
print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))

if 2 * C > A + B:
    print(A * X + B * Y)
else:
    if X > Y:
        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))
    else:
        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))
</ans>",0,{}
180,"<ans>
import sys
sys.setrecursionlimit(10**9)
N, M = map(int, input().split())
print(""N: "", str(N), ""M: "", str(M))

def find_negative_loop(n, w, es):
  dist = [float(""inf"")] * n
  print(""dist: "", str(dist))
  # この始点はどこでもよい
  dist[1] = 0

  for i in range(n):
    for j in range(w):
      e = es[j]
      if dist[e[1]] > dist[e[0]] + e[2]:
        dist[e[1]] = dist[e[0]] + e[2]
        print(""dist[{}]: {}"".format(e[1], dist[e[1]]))
        if i == n - 1:
          return True
  return False

def shortest_path(s, n, w, es):
  # s→iの最短距離
  # s: 始点, n: 頂点数, w: 辺の数, es[i]: [辺の始点, 辺の終点, 辺のコスト]
  dist = [float(""inf"")] * n
  print(""dist: "", str(dist))
  # d[i]: s→iの最短距離
  dist[s] = 0

  while True:
    update = False
    for p, q, r in es:
      # e: 辺iについて [from, to, cost]
      if dist[p] != float(""inf"") and dist[q] > dist[p] + r:
        dist[q] = dist[p] + r
        print(""dist[{}]: {}"".format(q, dist[q]))
        update = True
    if not update:
      break

  return dist

graph = [[] for _ in range(N + 1)]
elist = []
for _ in range(M):
  a, b, c = map(int, input().split())
  graph[a].append(b)
  elist.append((a, b, -c))
  print(""graph[{}]: {}"".format(a, graph[a]))

# remove unnecessary vertex and edge
visited = [None] * (N + 1)
def check_reachable(u):
  visited[u] = True
  if u == N:
    reachable[u] = True
    return True
  elif reachable[u] != None:
    return reachable[u]

  cnt = 0
  for v in graph[u]:
    if not visited[v]:
      ret = check_reachable(v)
      if ret:
        cnt += 1

  if cnt > 0:
    reachable[u] = True
    return True
  else:
    reachable[u] = False
    return False

reachable = [None] * (N + 1)
for i in range(1, N + 1):
  if reachable[i] == None:
    visited = [False] * (N + 1)
    check_reachable(i)
#print(reachable)

elist2 = []
for a, b, nc in elist:
  if reachable[b]:
    elist2.append((a, b, nc))
    print(""elist2: "", str(elist2))

M2 = len(elist2)
res1 = find_negative_loop(N + 1, M2, elist2)

if res1:
  print(""inf"")
else:
  res2 = shortest_path(1, N + 1, M2, elist2)
  print(""-res2[N]: "", -res2[N])
</ans>",0,{}
181,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    print(""r: "", str(r))
    return r

def divs(n, start=1):
    divisors = []
    print(""divisors: "", str(divisors))
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    print(""divisors: "", str(divisors))
    return divisors

def divn(n, primes):
    divs_number = 1
    print(""divs_number: "", str(divs_number))
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
    print(""divs_number: "", str(divs_number))
    return divs_number

def flin(d, x, default=-1):
    left = right = -1
    print(""left: "", str(left), ""right: "", str(right))
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    print(""left: "", str(left), ""right: "", str(right))
    if left == -1:
        return default, default
    else:
        return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, k = mi()
    even = n - 2*(k - 1)
    print(""even: "", str(even))
    odd = n - (k - 1)
    print(""odd: "", str(odd))
    if odd > 0 and odd % 2:
        res = [1]*(k - 1) + [odd]
        print(""res: "", str(res))
        print('YES')
        prr(res, ' ')
    elif even > 0 and even % 2 == 0:
        res = [2] * (k - 1) + [even]
        print(""res: "", str(res))
        print('YES')
        prr(res, ' ')
    else:
        print('NO')

</ans>",0,{}
182,"<ans>
```
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
import math

def isSubSequence(str1,str2):
    m = len(str1)
    n = len(str2)
    j = 0    # Index of str1
    i = 0    # Index of str2
    print(""m: "", str(m), ""n: "", str(n), ""j: "", str(j), ""i: "", str(i))
    while j<m and i<n:
        if str1[j] == str2[i]:
            j = j+1
        i = i + 1
    print(""j: "", str(j), ""m: "", str(m))
    return j==m

T = int(input())
print(""T: "", str(T))

for t in range(T):
    #N,M = [int(x) for x in stdin.readline().split()]
    s = input()
    t = input()
    p = input()
    print(""s: "", str(s), ""t: "", str(t), ""p: "", str(p))

    freq_s = {}
    freq_t = {}
    freq_p = {}
    for i in range(26):
        freq_s[chr(97+i)] = 0
        freq_t[chr(97+i)] = 0
        freq_p[chr(97+i)] = 0
    print(""freq_s: "", str(freq_s), ""freq_t: "", str(freq_t), ""freq_p: "", str(freq_p))

    for letter in s:
        freq_s[letter] += 1
    for letter in t:
        freq_t[letter] += 1
    for letter in p:
        freq_p[letter] += 1
    print(""freq_s: "", str(freq_s), ""freq_t: "", str(freq_t), ""freq_p: "", str(freq_p))

    # check s is subsequence of t, if not, print no
    sub = isSubSequence(s,t)
    print(""sub: "", str(sub))
    if sub==0:
        print('NO')
    else:
        flag = 0
        for i in range(26):
            d = freq_t[chr(97+i)] - freq_s[chr(97+i)]
            print(""chr(97+i): "", str(chr(97+i)), ""d: "", str(d))
            if d>0:
                #print(chr(97+i))
                if freq_p[chr(97+i)]<d and flag==0:
                    print('NO')
                    flag = 1

        if flag==0:
            print('YES')
</ans>",0,{}
183,"<ans>
#
# abc147 c
#
import sys
from io import StringIO
import unittest

class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
1
2 1
1
1 1
1
2 0""""""
        output = """"""2""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""3
2
2 1
3 0
2
3 1
1 0
2
1 1
2 0""""""
        output = """"""0""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""2
1
2 0
1
1 0""""""
        output = """"""1""""""
        self.assertIO(input, output)

def resolve():
    N = int(input())
    print(""N: "", str(N))
    C = []
    for i in range(N):
        a = int(input())
        print(""a: "", str(a))
        C.append([list(map(int, input().split())) for j in range(a)])
    print(""C: "", str(C))

    ans = 0
    for bit in range(1 << N):
        f = True
        for i in range(N):
            if bit & (1 << i):
                for c in C[i]:
                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
                        f = False
                        break
        if f == True:
            ans = max(ans, bin(bit).count(""1""))
    print(""ans: "", str(ans))

def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",0,{}
184,"<ans>
# alpha = ""abcdefghijklmnopqrstuvwxyz""
prime = 998244353
t = 1#int(input())
from heapq import heappop, heappush
for test in range(t):
    n = int(input())
    print(""n: "", str(n))
    s = input()
    print(""s: "", str(s))
    grp = []
    cnt = []
    tmp = 0
    cur = s[0]
    for i in s:
        if i==cur:
            tmp+=1
        else:
            grp.append(cur)
            cnt.append(tmp)
            cur = i
            tmp = 1
    grp.append(cur)
    cnt.append(tmp)
    print(""grp: "", str(grp))
    print(""cnt: "", str(cnt))
    if len(grp)==1:
        ans = ((n*(n+1))//2)%prime
        print(""ans: "", str(ans))
    else:
        if grp[0]==grp[-1]:
            ans = ((cnt[0]+1)*(cnt[-1]+1))%prime
            print(""ans: "", str(ans))
        else:
            ans = cnt[0]+1+cnt[-1]
            ans = ans%prime
            print(""ans: "", str(ans))
</ans>",0,{}
185,"<ans>
n, l, r = [int(i) for i in input().split()]
print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))

number_of_zeros = 0
number_of_ones = 0
number_of_twos = 0

if l%3 == 0:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
elif l%3 == 1:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3 + 1
elif l%3 == 2:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    elif r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1

print(""number_of_zeros: "", str(number_of_zeros), ""number_of_ones: "", str(number_of_ones), ""number_of_twos: "", str(number_of_twos))

dp = [[-1 for i in range(3)] for j in range(n+1)]
print(""dp: "", str(dp))

MOD = 10**9 + 7
dp[1][0] = number_of_zeros%MOD
dp[1][1] = number_of_ones%MOD
dp[1][2] = number_of_twos%MOD

for i in range(2,n+1):
    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD
    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD
    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD

print(""dp: "", str(dp))

if dp[n][0]!=-1:
    print(dp[n][0]%MOD)
else:
    print(0)
</ans>",0,{}
186,"<ans>
from sys import stdin, stdout
from bisect import bisect_left, bisect_right
from collections import defaultdict
import math
from fractions import Fraction as frac
from random import random
cin = stdin.readline
def cout(x):
	stdout.write(str(x)+'\n')
def var(type = int):
    print(""type: "", str(type))
    return type(stdin.readline())
def readline(type = int):
    print(""type: "", str(type))
    return list(map(type,stdin.readline().split()))
def readlist(type = int):
    print(""type: "", str(type))
    return list(map(type,stdin.readline().split()))
def sorted_indexes(arr):
    print(""arr: "", str(arr))
    return sorted(list(range(len(arr))),key=arr.__getitem__)
def printr(arr):
    print(""arr: "", str(arr))
    [stdout.write(str(x)+' ')   for x in arr]
    cout('')
def find_lt(a, x):#'Find rightmost value less than x'
    print(""a: "", str(a), ""x: "", str(x))
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError
def find_gt(a, x):#'Find leftmost value greater than x'
    print(""a: "", str(a), ""x: "", str(x))
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
def dist(x,y):
    print(""x: "", str(x), ""y: "", str(y))
    return math.sqrt(x*x + y*y)
def binary_search(arr, x):
    print(""arr: "", str(arr), ""x: "", str(x))
    i = bisect_left(arr, x)
    if i == len(arr) or arr[i] != x:
        return -1
    return i

# mp = [0]*201
# ops = [0]*201
# def go(arr,i,j ,dp):
#     print(""arr: "", str(arr), ""i: "", str(i), ""j: "", str(j), ""dp: "", str(dp))
#     if i==j and ops[i] is None:
#         return [mp[i],mp[i]]
#     if i>j:
#         return [0,0]
#     if dp[i][j]:
#         return dp[i][j]
#     mx = -1000000000
#     mn = 1000000000
#     for k in range(i+1,j,2):
#         if ops[k]:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] + right[0])
#             mn = min(mn,left[1] + right[1])
#         else:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] - right[1])
#             mn = min(mn,left[1] - right[0])
#     dp[i][j] = [mx,mn]
#     return [mx,mn]

n , a , b = readline(int)
print(""n: "", str(n), ""a: "", str(a), ""b: "", str(b))
price = [a,b]
print(""price: "", str(price))
arr = readlist(int)
print(""arr: "", str(arr))
half = n//2
print(""half: "", str(half))
cost = 0
print(""cost: "", str(cost))
flg = True
print(""flg: "", str(flg))
for i in range(half):
    if arr[i] == arr[n-1-i] == 2:
        cost += 2*min(a,b)
    elif arr[i] ==2 and arr[n-1-i] <= 1:
        cost += price[arr[n-1-i]]
    elif arr[i] <= 1 and arr[n-1-i] == 2:
        cost += price[arr[i]]
    elif arr[i] != arr[n-1-i]:
        flg = False
        break
if n%2 == 1:
    if arr[half] == 2:
        cost += min(a,b)
if not flg:
    print(-1)
else:
    print(cost)
</ans>",0,{}
187,"<ans>
from sys import stdin
import sys
import numpy as np
import collections
from functools import cmp_to_key
import heapq
sys.setrecursionlimit(100000)

##  input functions for me
def rsa(sep = ''):
    print(""sep: "", str(sep))
    if sep == '' :
        return input().split()
    else: return input().split(sep)
def rip(sep = ''):
    print(""sep: "", str(sep))
    if sep == '' :
        return list(map(int, input().split()))
    else: return list(map(int, input().split(sep)))
def ria(sep = ''):
    print(""sep: "", str(sep))
    return list(rip(sep))
def ri():
    print(""No separator"")
    return int(input())
def rd():
    print(""No separator"")
    return float(input())
def rs():
    print(""No separator"")
    return input()
##
class mint:
    mod = int(1e9 + 7)
    def __init__(self, v = 0):
        print(""v: "", str(v))
        if not ((v >= 0) and (v < mint.mod)):
            v %= mint.mod
            if v < 0: v += mint.mod
        self.V = v
    # ... rest of the class remains the same ...

def main():
    N = ri()
    print(""N: "", str(N))
    A = ria()
    print(""A: "", str(A))
    A = sorted(A)
    print(""A (sorted): "", str(A))
    A = list(reversed(A))
    print(""A (reversed): "", str(A))
    Pow2 = [mint(0)] * (N + 1)
    print(""Pow2: "", str(Pow2))
    Pow2[0] = mint(1)
    print(""Pow2[0]: "", str(Pow2[0]))
    for i in range(1,N+1): Pow2[i] = Pow2[i-1] * 2

    tot = mint(0)
    print(""tot: "", str(tot))
    for i in range(N):
        tot += mint(A[i]) * Pow2[N-1]
        if i > 0: tot += mint(A[i]) * i * Pow2[N-2]
    tot *= Pow2[N]
    print(""tot: "", str(tot))

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
188,"<ans>
r1=input()
r2=input()
print(""r1: "", str(r1))
print(""r2: "", str(r2))
n=len(r1)
print(""n: "", str(n))
l=[0]
print(""l: "", str(l))
for i in range(n):
	if r1[i]=='0':
		if r2[i]=='0':
			l.append(2)
		else:
			l.append(1)
	else:
		if r2[i]=='X':
			l.append(0)
		else:
			l.append(-1)
print(""l: "", str(l))
l.append(0)
print(""l: "", str(l))
s=len(l)
print(""s: "", str(s))
count=0
print(""count: "", str(count))
u=1
print(""u: "", str(u))
e=1
print(""e: "", str(e))
while(u<s-1):
	if l[u]==2 and e==1:
		if l[u+1]==2:
			e=2
			u=u+1
			continue
		elif (l[u+1]==1 or l[u+1]==-1):
			count=count+1
			u=u+2
			continue
		else:
			u=u+2
			continue
	if l[u]==2 and e==2:
		if l[u+1]==2:
			count=count+2
			u=u+2
			e=1
			continue
		else:
			count=count+1
			u=u+1
			e=1
			continue
	if l[u]==1 or l[u]==-1:
		if l[u+1]==2:
			count=count+1
			u=u+2
			continue
		else:
			u=u+1
			continue
	if l[u]==0:
		u=u+1
print (count)
</ans>",0,{}
189,"<ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

print(""opr: "", str(opr))
print(""namespace: "", str(namespace))
print(""rules: "", str(rules))
print(""lookup: "", str(lookup))
print(""cnt: "", str(cnt))

N = int(input())
for _ in range(N):
    lval, rval = input().split('=')
    print(""lval: "", str(lval))
    print(""rval: "", str(rval))
    for c in opr:
        if c in rval:
            arg1, arg2 = list(map(get_tag, rval.split(c)))
            print(""arg1: "", str(arg1))
            print(""arg2: "", str(arg2))
            rule = (arg1, arg2, c)
            print(""rule: "", str(rule))
            if rule in rules:
                namespace[lval] = (True, rules[rule])
            else:
                cnt += 1
                namespace[lval] = (True, cnt)
                rules[rule] = cnt
                lookup[cnt] = rule
            break
    else:
        if rval in namespace:
            namespace[lval] = namespace[rval]
        else:
            namespace[lval] = (False, rval)

print(""namespace: "", str(namespace))

if namespace[""res""] == (False, ""res""):
    print(""0"")
    return

program = []
print(""program: "", str(program))
myvars = dict()
print(""myvars: "", str(myvars))

def reserve():
    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4))

def implement(rule, final):
    if type(rule) == str:
        return rule
    elif rule in myvars:
        return myvars[rule]
    else:
        if final:
            name = ""res""
        else:
            name = reserve()
        myvars[rule] = name
        arg1, arg2, op = lookup[rule]
        var1, var2 = implement(arg1, False), implement(arg2, False)
        program.append(name + ""="" + var1 + op + var2)
        return name

seed(123)
if namespace[""res""][0]:
    implement(namespace[""res""][1], True)
else:
    program.append(""res="" + namespace[""res""][1])
print(""program: "", str(program))
print(""len(program): "", str(len(program)))
print(""\n"".join(program))

#print(namespace)
#print(rules)

</ans>",0,{}
190,"<ans>
''' CODED WITH LOVE BY SATYAM KUMAR '''

from sys import stdin, stdout
import heapq
import cProfile, math
from collections import Counter, defaultdict, deque
from bisect import bisect_left, bisect, bisect_right
import itertools
from copy import deepcopy
from fractions import Fraction
import sys, threading
import operator as op
from functools import reduce
import sys

sys.setrecursionlimit(10 ** 6)  # max depth of recursion
threading.stack_size(2 ** 27)  # new thread will get stack of such size
fac_warm_up = False
printHeap = str()
memory_constrained = False
P = 10 ** 9 + 7


class MergeFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n
        self.lista = [[_] for _ in range(n)]
        print(""self.parent: "", str(self.parent))
        print(""self.size: "", str(self.size))
        print(""self.num_sets: "", str(self.num_sets))
        print(""self.lista: "", str(self.lista))

    def find(self, a):
        to_update = []
        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]
        for b in to_update:
            self.parent[b] = a
        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return
        if self.size[a] < self.size[b]:
            a, b = b, a
        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]
        self.lista[a] += self.lista[b]
        print(""self.parent: "", str(self.parent))
        print(""self.size: "", str(self.size))
        print(""self.num_sets: "", str(self.num_sets))
        print(""self.lista: "", str(self.lista))

    def set_size(self, a):
        return self.size[self.find(a)]

    def __len__(self):
        return self.num_sets


def display(string_to_print):
    stdout.write(str(string_to_print) + ""\n"")


def prime_factors(n):  # n**0.5 complex
    factors = dict()
    for i in range(2, math.ceil(math.sqrt(n)) + 1):
        while n % i == 0:
            if i in factors:
                factors[i] += 1
            else:
                factors[i] = 1
            n = n // i
    if n > 2:
        factors[n] = 1
    return (factors)


def all_factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


def fibonacci_modP(n, MOD):
    if n < 2: return 1
    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(
        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD


def factorial_modP_Wilson(n, p):
    if (p <= n):
        return 0
    res = (p - 1)
    for i in range(n + 1, p):
        res = (res * cached_fn(InverseEuler, i, p)) % p
    return res


def binary(n, digits=20):
    b = bin(n)[2:]
    b = '0' * (digits - len(b)) + b
    return b


def is_prime(n):
    """"""Returns True if n is prime.""""""
    if n < 4:
        return True
    if n % 2 == 0:
        return False
    if n % 3 == 0:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w
    return True


def generate_primes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    return prime


factorial_modP = []


def warm_up_fac(MOD):
    nonlocal factorial_modP, fac_warm_up
    if fac_warm_up: return
    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]
    for i in range(2, fac_warm_up_size):
        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD
    fac_warm_up = True


def InverseEuler(n, MOD):
    return pow(n, MOD - 2, MOD)


def nCr(n, r, MOD):
    nonlocal fac_warm_up, factorial_modP
    if not fac_warm_up:
        warm_up_fac(MOD)
        fac_warm_up = True
    return (factorial_modP[n] * (
            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD


def get_int():
    return int(stdin.readline().strip())


def get_tuple():
    return list(map(int, stdin.readline().split()))


def get_list():
    return list(map(int, stdin.readline().split()))


memory = dict()


def clear_cache():
    nonlocal memory
    memory = dict()


def cached_fn(fn, *args):
    nonlocal memory
    if args in memory:
        return memory[args]
    else:
        result = fn(*args)
        memory[args] = result
        return result


def ncr(n, r):
    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))


def binary_search(i, li):
    fn = lambda x: li[x] - x // i
    x = -1
    b = len(li)
    while b >= 1:
        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like
            x += b
        b = b // 2
    return x


# -------------------------------------------------------------- MAIN PROGRAM


TestCases = True
optimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3


def main():
    a, b, c, d, k = get_tuple()
    x = (a+c-1)//c
    y = (b+d-1)//d
    print(""x: "", str(x))
    print(""y: "", str(y))
    if x+y<=k:
        print(x, y)
    else: print(-1)


# --------------------------------------------------------------------- END=


if TestCases:
    for i in range(get_int()):
        main()
else:
    main() if not optimise_for_recursion else threading.Thread(target=main).start()

</ans>",0,{}
191,"<ans>
import sys
input = sys.stdin.readline

# def find(a):
#     if par[a] == a:
#         return a
#     par[a] = find(par[a])
#     return par[a]

def find(a):
    print(""a: "", str(a))
    upd = []
    print(""upd: "", str(upd))
    cur = a
    while par[cur] != cur:
        upd.append(cur)
        print(""upd: "", str(upd))
        cur = par[cur]
    for x in upd:
        par[x] = cur
    print(""par: "", str(par))
    return cur

def union(a, b):
    print(""a: "", str(a))
    print(""b: "", str(b))
    a = find(a)
    print(""a: "", str(a))
    b = find(b)
    print(""b: "", str(b))
    if a == b:
        return
    par[a] = b
    print(""par: "", str(par))

def mst():
    print(""edges: "", str(edges))
    ret = []
    for edge in edges:
        u, v, w = edge
        print(""u: "", str(u))
        print(""v: "", str(v))
        print(""w: "", str(w))
        u = find(u)
        print(""u: "", str(u))
        v = find(v)
        print(""v: "", str(v))
        if u != v:
            union(u, v)
            ret.append(edge)
    print(""ret: "", str(ret))
    return ret

def dfs(u, par):
    print(""u: "", str(u))
    print(""par: "", str(par))
    for v, w in adj[u]:
        print(""v: "", str(v))
        print(""w: "", str(w))
        if v != par:
            dist[v] = max(dist[u], w)
            print(""dist: "", str(dist))
            dfs(v, u)

def bfs(u):
    print(""u: "", str(u))
    visit = [False] * (n+1)
    print(""visit: "", str(visit))
    from collections import deque

    dq = deque()
    dq.append(u)
    visit[u] = True
    while dq:
        u = dq.popleft()
        print(""u: "", str(u))
        for v, w in adj[u]:
            print(""v: "", str(v))
            print(""w: "", str(w))
            if not visit[v]:
                dist[v] = max(dist[u], w)
                print(""dist: "", str(dist))
                dq.append(v)
                visit[v] = True

n, m, k = list(map(int, input().split()))
print(""n: "", str(n))
print(""m: "", str(m))
print(""k: "", str(k))
a = list(map(int, input().split()))
print(""a: "", str(a))
# n = 50000
# m = 2 * n
# k = n
# a = [i for i in range(1, n+1)]
# import random

par = [0] * (n+1)
print(""par: "", str(par))
for i in range(1, n+1):
    par[i] = i
edges = []
# for i in range(1, n+1):
#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))
#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))
#     edges.append(edge)
for i in range(m):
    edge = tuple(map(int, input().split()))
    print(""edge: "", str(edge))
    edges.append(edge)
edges.sort(key=lambda x: x[2])
print(""edges: "", str(edges))
edges = mst()
adj = [list() for i in range(n+1)]
print(""adj: "", str(adj))
for edge in edges:
    u, v, w = edge
    print(""u: "", str(u))
    print(""v: "", str(v))
    print(""w: "", str(w))
    adj[u].append((v, w))
    adj[v].append((u, w))

dist = [0] * (n+1)
print(""dist: "", str(dist))
# dfs(a[0], -1)
bfs(a[0])
ans = 0
for x in a:
    print(""x: "", str(x))
    ans = max(ans, dist[x])
print(""ans: "", str(ans))
ans = [ans] * k
print(""ans: "", str(ans))
print(*ans)

</ans>",0,{}
192,"<ans>
n=int(input())
print(""n: "", str(n))
s1=[int(x) for x in input().split()]
print(""s1: "", str(s1))
s2=[int(x) for x in input().split()]
print(""s2: "", str(s2))
S1=sorted(s1)
print(""S1: "", str(S1))
S2=sorted(s2)
print(""S2: "", str(S2))
S1=[0]+S1
print(""S1: "", str(S1))
S2=[0]+S2
print(""S2: "", str(S2))
S1=S1[::-1]
print(""S1: "", str(S1))
S2=S2[::-1]
print(""S2: "", str(S2))
pta=0
print(""pta: "", str(pta))
ptb=0
print(""ptb: "", str(ptb))
sm1=0
print(""sm1: "", str(sm1))
sm2=0
print(""sm2: "", str(sm2))
for j in range(0,(2*n)+1):
    if(j%2==0):
        if(S2[ptb]>S1[pta]):
            ptb=ptb+1
        else:
            sm1=sm1+S1[pta]
            pta=pta+1
    else:
        if(S1[pta]>S2[ptb]):
            pta=pta+1
        else:
            sm2=sm2+S2[ptb]
            ptb=ptb+1
    if(pta==n+1 and ptb==n+1):
        break
print(""sm1: "", str(sm1))
print(""sm2: "", str(sm2))
print(sm1-sm2)
</ans>",0,{}
193,"<ans>
import sys
# from collections import deque
input=sys.stdin.readline
def binary_search(org,arr,l,r,n,L,value):
	mid=(l+r)//2
	# print(mid,""ppppp"")
	if(mid>0 and arr[mid]-value>=org and arr[mid-1]-value<org):
		return mid
	elif(mid==0 and arr[mid]-value>=org ):
		return mid
	elif(mid==L and arr[mid]-value>=org ):
		return mid

	elif(mid==n):
		return mid

	elif(mid>0 and arr[mid]-value>org and arr[mid-1]-value>=org):
		return binary_search(org,arr,l,mid,n,L,value)

	elif(arr[mid]-value<org):
		# print(""dddddd"")
		return binary_search(org,arr,mid+1,r,n,L,value)
	return mid

n=int(input())
print(""n: "", str(n))
l= list(map(int,input().split()))
print(""l: "", str(l))
u= list(map(int,input().split()))
print(""u: "", str(u))
extra=[0]*n
print(""extra: "", str(extra))
pre=[0]*n
print(""pre: "", str(pre))
t=[0]*n
print(""t: "", str(t))
t[0]=u[0]
for i in range(1,n):
	t[i]+=t[i-1]+u[i]
# print(t)
for i in range(n):
	if(i>0):
		v=t[i-1]
	else:
		v=0
	index=binary_search(l[i],t,i,n-1,n-1,i,v)
	# print(i,index)
	if(index>0 and index!=i):
		value=t[index]-t[index-1]
		remain=l[i]-(t[index-1]-v)
	elif(index>0 and index==i):
		value=t[index]-t[index-1]
		remain=l[i]


	else:
		value=t[index]
		remain=l[i]
	if(value>=remain):
		extra[index]+=remain
		# print(extra[index],""ooooo"")
	elif(remain>value):

		extra[index]+=value
		# print(extra[index],""oooooopp"")
	if(i>0 and index>0):
		pre[i-1]-=1
		pre[index-1]+=1
	elif(i==0 and index>0):
		pre[index-1]+=1
	elif(i==0 and index==0):
		continue
	# print(extra,pre)
# print(extra,pre)
for i in range(n-2,-1,-1):
	pre[i]+=pre[i+1]
# print(extra,pre)
r=[0]*n
print(""r: "", str(r))
for i in range(n):
	r[i]=(u[i]*pre[i])+extra[i]

for i in r:
	print (i,end="" "")
</ans>",0,{}
194,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
from math import *
from decimal import *
from copy import *
getcontext().prec = 30
print(""getcontext().prec: "", str(getcontext().prec))
MAX = sys.maxsize
print(""MAX: "", str(MAX))
MAXN = 10**5+10
print(""MAXN: "", str(MAXN))
MOD = 10**9+7
print(""MOD: "", str(MOD))
def isprime(n):
    n = abs(int(n))
    print(""n: "", str(n))
    if n < 2:
        return False
    if n == 2:
        return True
    if not n & 1:
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def dis(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    print(""g: "", str(g))
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    print(""msf: "", str(msf))
    meh = 0
    print(""meh: "", str(meh))
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n,k = arrIN()
    ans = 0
    while 1:
        if n%k==0:
            n//=k
            ans+=1
        else:
            x = n%k
            ans+=x
            n-=x
        if n==0:
            print(ans)
            break
</ans>",0,{}
195,"<ans>
MOD = 1000000007

def isSubset(a, b):
	print(""a: "", str(a), ""b: "", str(b))
	return (a & b) == a

def isIntersect(a, b):
	print(""a: "", str(a), ""b: "", str(b))
	return (a & b) != 0

# Solve for each weakly connected component (WCC)
def cntOrder(s, t):
	print(""s: "", str(s), ""t: "", str(t))
	p = len(s)
	m = len(t)

	inMask = [0 for i in range(m)]

	for x in range(p):
		for i in range(m):
			if t[i] % s[x] == 0:
				inMask[i] |= 1 << x

	print(""inMask: "", str(inMask))

	cnt = [0 for mask in range(1<<p)]
	for mask in range(1<<p):
		for i in range(m):
			if isSubset(inMask[i], mask):
				cnt[mask] += 1

	print(""cnt: "", str(cnt))

	dp = [[0 for mask in range(1<<p)] for k in range(m+1)]
	for i in range(m):
		dp[1][inMask[i]] += 1
	for k in range(m):
		for mask in range(1<<p):
			for i in range(m):
				if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
					dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
			dp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD

	print(""dp: "", str(dp))

	return dp[m][(1<<p)-1]

def dfs(u):
	nonlocal a, graph, degIn, visited, s, t

	visited[u] = True
	if degIn[u] == 0:
		s.append(a[u])
	else:
		t.append(a[u])

	print(""u: "", str(u), ""s: "", str(s), ""t: "", str(t))

	for v in graph[u]:
		if not visited[v]:
			dfs(v)

def main():
	nonlocal a, graph, degIn, visited, s, t

	# Reading input
	n = int(input())
	a = list(map(int, input().split()))

	print(""n: "", str(n), ""a: "", str(a))

	# Pre-calculate C(n, k)
	c = [[0 for j in range(n)] for i in range(n)]
	for i in range(n):
		c[i][0] = 1
		for j in range(1, i+1):
			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD

	print(""c: "", str(c))

	# Building divisibility graph
	degIn = [0 for u in range(n)]
	graph = [[] for u in range(n)]
	for u in range(n):
		for v in range(n):
			if u != v and a[v] % a[u] == 0:
				graph[u].append(v)
				graph[v].append(u)
				degIn[v] += 1

	print(""degIn: "", str(degIn), ""graph: "", str(graph))

	# Solve for each WCC of divisibility graph and combine result
	ans = 1
	curLen = 0
	visited = [False for u in range(n)]
	for u in range(n):
		if not visited[u]:
			s = []
			t = []
			dfs(u)

			if len(t) > 0:
				sz = len(t) - 1
				cnt = cntOrder(s, t)

				# Number of orders for current WCC
				ans = (ans * cnt) % MOD
				# Number of ways to insert <sz> number to array of <curLen> elements
				ans = (ans * c[curLen + sz][sz]) % MOD
				curLen += sz

	print(""ans: "", str(ans))

def __starting_point():
	main()
__starting_point()
</ans>",0,{}
196,"<ans>
N=int(input())
print(""N: "", str(N))
S=input()
print(""S: "", str(S))
S=[1 if S[i]=='o' else -1 for i in range(N)]
print(""S: "", str(S))

#0番目は羊のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=1
if S[0]==1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

  #0番目の両隣は狼
  tmp[1]=-1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

#0番目は狼のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=-1
if S[0]==-1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

  #0番目の両隣は狼
  tmp[1]=-1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))

  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
  print(""tmp: "", str(tmp))

  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return

print(-1)
</ans>",0,{}
197,"<ans>
n=int(input())
print(""n: "", str(n))
l=list(map(int,input().split()))
print(""l: "", str(l))
s=input()
print(""s: "", str(s))
water=0
print(""water: "", str(water))
grass=0
print(""grass: "", str(grass))
cgrass=0
print(""cgrass: "", str(cgrass))
time=0
print(""time: "", str(time))
seen=False
print(""seen: "", str(seen))
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            print(""water: "", str(water))
            time+=2*dist
            print(""time: "", str(time))
            cgrass+=dist
            print(""cgrass: "", str(cgrass))
        else:
            dist-=water
            print(""dist: "", str(dist))
            time+=2*water
            print(""time: "", str(time))
            cgrass+=water
            print(""cgrass: "", str(cgrass))
            water=0
            print(""water: "", str(water))
            time+=3*dist
            print(""time: "", str(time))
            grass+=dist
            print(""grass: "", str(grass))
    elif s[i]==""W"":
        water+=l[i]
        print(""water: "", str(water))
        time+=2*l[i]
        print(""time: "", str(time))
        seen=True
        print(""seen: "", str(seen))
    else:
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            print(""water: "", str(water))
            time+=2*dist
            print(""time: "", str(time))
        else:
            dist-=water
            print(""dist: "", str(dist))
            time+=2*water
            print(""time: "", str(time))
            water=0
            print(""water: "", str(water))
            if cgrass>=dist:
                cgrass-=dist
                print(""cgrass: "", str(cgrass))
                grass+=dist
                print(""grass: "", str(grass))
                time+=3*dist
                print(""time: "", str(time))
            else:
                dist-=cgrass
                print(""dist: "", str(dist))
                grass+=cgrass
                print(""grass: "", str(grass))
                time+=3*cgrass
                print(""time: "", str(time))
                cgrass=0
                print(""cgrass: "", str(cgrass))
                if grass>=dist:
                    grass-=dist
                    print(""grass: "", str(grass))
                    time+=3*dist
                    print(""time: "", str(time))
                else:
                    dist-=grass
                    print(""dist: "", str(dist))
                    time+=3*grass
                    print(""time: "", str(time))
                    grass=0
                    print(""grass: "", str(grass))
                    if seen:
                        time+=4*dist
                        print(""time: "", str(time))
                    else:
                        time+=6*dist
                        print(""time: "", str(time))
print(time)
</ans>",1,{}
198,"<ans>
from math import gcd

m,a,b = list(map(int,input().split()))
print(""m: "", str(m), ""a: "", str(a), ""b: "", str(b))

g = gcd(a,b)
print(""g: "", str(g))

vis = [0]*(a+b+1)
print(""vis: "", str(vis))
vis[0] = 1

nvis = 1
print(""nvis: "", str(nvis))

count = 0
print(""count: "", str(count))
last = 0
print(""last: "", str(last))
t = 0
print(""t: "", str(t))

while True:
    #print(t, vis)
    if t >= b:
        #print('back')
        t -= b
        if vis[t]:
            break
        vis[t] = 1
        nvis += 1
        print(""nvis: "", str(nvis))
    else:
        t += a
        if t > m:
            break
        if t > last:
            #print('forward', t - last, 'with', nvis)
            count += (t - last)*nvis
            print(""count: "", str(count))
            last = t
            print(""last: "", str(last))
        if vis[t]:
            break
        vis[t] = 1
        nvis += 1
        print(""nvis: "", str(nvis))
    #print(nvis,count)
    #print('---')

if t > m:
    # we're done
    count += (m - last + 1)*nvis
    print(""count: "", str(count))
else:
    def sumto(n):
        whole = n//g + 1
        r = whole*(whole+1)//2 * g
        corr = whole * (g-1 - (n%g))
        r -= corr
        return r

    #S = 0
    #for i in range(last, m+1):
    #    S += i//g + 1
    #count += S
    #assert S == sumto(m) - sumto(last-1)

    count += sumto(m) - sumto(last-1)
    print(""count: "", str(count))

#print(vis)
print(count)

</ans>",0,{}
