{"idx": 4, "result": 0, "generated": "<ans>\nimport math\nfrom collections import defaultdict\nimport sys\n#input = sys.stdin.readline\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    print(\"n: \", str(n), \"m: \", str(m))\n    k = list(map(int, input().split()))\n    print(\"k: \", str(k))\n    sales = [(0, 0)] * m\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        sales[i] = (b, a)\n    print(\"sales: \", str(sales))\n\n    def check(days):\n        last_sale = {}\n        for sale in sales:\n            if sale[1] <= days:\n                if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:\n                    last_sale[sale[0]] = sale[1]\n\n        date_last_sales = {}\n        for t, d in list(last_sale.items()):\n            if d not in date_last_sales:\n                date_last_sales[d] = [t]\n            else:\n                date_last_sales[d].append(t)\n\n        balance = 0\n        required = [0] + k.copy()\n\n        end = 0\n        for d in range(1, days+1):\n            balance += 1\n            if d in date_last_sales:\n                for t in date_last_sales[d]:\n                    if required[t] > 0:\n                        if required[t] > balance:\n                            end += required[t] - balance\n                        balance -= min(required[t], balance)\n                        required[t] = 0\n            if d == days:  # last day\n                for r in required:\n                    if r > 0:\n                        end += r\n\n        return 2*end <= balance\n\n    total = sum(k)\n    print(\"total: \", str(total))\n    hi = 2*total\n    print(\"hi: \", str(hi))\n    lo = 1\n    print(\"lo: \", str(lo))\n\n    while lo + 1 < hi:\n        mid = (lo + hi) // 2\n        print(\"mid: \", str(mid))\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid\n\n    if check(lo):\n        print(lo)\n    else:\n        print(hi)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 5, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import deque\nimport heapq\ninput = sys.stdin.readline\n\nN=int(input())\nEDGE=[list(map(int,input().split())) for i in range(N-1)]\n\nEDGELIST=[[] for i in range(N+1)]\n\nfor i,j in EDGE:\n    EDGELIST[i].append(j)\n    EDGELIST[j].append(i)\n\n#EDGES=[[] for i in range(N+1)]\nREDG=[None for i in range(N+1)]\nQUE=deque([1])\ncheck=[0]*(N+1)\nDEPTH=[None]*(N+1)\ni=0\nwhile QUE:\n    NQUE=deque()\n    i+=1\n    \n    while QUE:\n        x=QUE.pop()\n        DEPTH[x]=i\n        check[x]=1\n        for to in EDGELIST[x]:\n            if check[to]==1:\n                continue\n            else:\n                #EDGES[x].append(to)\n                REDG[to]=x\n                NQUE.append(to)\n    QUE=NQUE\n\nprint(\"N: \", str(N), \"EDGE: \", str(EDGE), \"EDGELIST: \", str(EDGELIST))\n\ncheck=[0]*(N+1)\ncheck[1]=1\n#NEXT=[]\n\n#for i in EDGES[1]:\n#    check[i]=1\n#    NEXT.append(i)\n\n#for j in NEXT:\n#    for k in EDGES[j]:\n#        check[k]=1\n\n\nLEAF=[]\nfor i in range(2,N+1):\n    if len(EDGELIST[i])==1:\n        LEAF.append((-DEPTH[i],i))\n\nQUE=LEAF\nheapq.heapify(QUE)\nANS=0\n\n#print(check,QUE)\n\nwhile QUE:\n    dep,x=heapq.heappop(QUE)\n    if check[x]!=0 or dep>=-3:\n        continue\n\n    if check[REDG[x]]==2:\n        continue\n\n    if check[x]==0:\n        check[x]=1\n    if check[REDG[REDG[x]]]==0:\n        check[REDG[REDG[x]]]=1\n    check[REDG[x]]=2   \n    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))\n    ANS+=1\n\n    #print(x,QUE,check)\n\nprint(\"ANS: \", str(ANS))\n</ans>", "format_properties": {}}
{"idx": 0, "result": 0, "generated": "<ans>\n'''input\n9 4 8\n6 8 5 1 8 1 1 2 1\n9 2\n8 4\n5 3\n9 7\n'''\nfrom sys import stdin\nimport math\nfrom copy import deepcopy\nfrom collections import defaultdict\n\n\ndef process_offer(offers):\n\taux = []\n\tfor i in offers:\n\t\ttemp = offers[i]\n\t\ttemp.sort()\n\t\taux.append([i, temp[-1]])\n\n\taux = sorted(aux, key = lambda x: x[0])\n\treturn aux\n\n\ndef make(first, second):\n\treturn str(first) + ' ' + str(second)\n\n\ndef brute(arr, dp, offers, index, remain):\n\tprint(\"arr: \", str(arr), \"dp: \", str(dp), \"offers: \", str(offers), \"index: \", str(index), \"remain: \", str(remain))\n\t#print(index, remain)\n\t# base case:\n\tif remain == 0:\n\t\treturn 0\n\n\tif make(index, remain) in dp:\n\t\treturn dp[make(index, remain)]\n\n\tmin_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)\n\t#print(min_cost)\n\tfor i in range(len(offers)):\n\t\tcost = 0\n\t\tif offers[i][0] <= remain:\n\t\t\tfree = offers[i][1]\n\t\t\tfor  j in range(index + free, index + offers[i][0]):\n\t\t\t\tcost += arr[j]\n\t\t\tcost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])\n\t\t\tmin_cost = min(min_cost, cost)\n\t\telse:\n\t\t\tbreak\n\tdp[make(index, remain)] = min_cost\n\treturn min_cost\n\n\n\n# main starts\nn, m, k = list(map(int, stdin.readline().split()))\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\narr = list(map(int, stdin.readline().split()))\nprint(\"arr: \", str(arr))\narr.sort()\noffers = defaultdict(list)\nfor _ in range(m):\n\tx, y = list(map(int, stdin.readline().split()))\n\tprint(\"x: \", str(x), \"y: \", str(y))\n\toffers[x].append(y)\n\noffers = process_offer(offers)\nprint(\"offers: \", str(offers))\ndp = dict()\nprint(\"dp: \", str(dp))\nprint(brute(arr, dp, offers, 0, k))\n#print(dp)\n</ans>", "format_properties": {}}
{"idx": 2, "result": 0, "generated": "<ans>\nfrom math import sqrt,gcd\n\n\ndef gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    \"\"\"\n    #\n    D = {}\n    print(\"D: \", str(D))\n    # The running integer that's checked for primeness\n    q = 2\n    print(\"q: \", str(q))\n    while True:\n        if q not in D:\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations\n            #\n            yield q\n            D[q * q] = [q]\n            print(\"D: \", str(D))\n            print(\"q: \", str(q))\n        else:\n            # q is composite. D[q] is the list of primes that\n            # divide it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next\n            # multiples of its witnesses to prepare for larger\n            # numbers\n            #\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n            print(\"D: \", str(D))\n        q += 1\n        print(\"q: \", str(q))\n\n\ndef is_prime(n):\n    if n<=1:\n        return False\n        print(\"n: \", str(n))\n    if n == 2:\n        return True\n        print(\"n: \", str(n))\n    if n % 2 ==0:\n        return False\n        print(\"n: \", str(n))\n    return all(n%i for i in range(3,int(sqrt(n))+1))\n    print(\"n: \", str(n))\n\n\ndef calculate_colors(n):\n    primes = gen_primes()\n    sqr_n = int(sqrt(n)) + 1\n    print(\"n: \", str(n))\n    print(\"sqr_n: \", str(sqr_n))\n    if n == 1:\n        return 1\n        print(\"n: \", str(n))\n    for p in primes:\n        if n % p == 0:\n            while n % p == 0:\n                g= gcd(p,n)\n                n = int(n//g)\n                print(\"n: \", str(n))\n            if n > 1:\n                return 1\n                print(\"n: \", str(n))\n            else:\n                return p\n                print(\"p: \", str(p))\n        if p > sqr_n:\n            return n\n            print(\"n: \", str(n))\n    print(\"n: \", str(n))\n    print(\"sqr_n: \", str(sqr_n))\n    print(\"primes: \", str(primes))\n\n\nn = int(input())\nprint(calculate_colors(n))\n</ans>", "format_properties": {}}
{"idx": 8, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\n\nprint(\"sys: \", str(sys), \"math: \", str(math), \"itertools: \", str(itertools), \"functools: \", str(functools), \"collections: \", str(collections))\n\ndef ii(): return int(input())\nprint(\"ii: \", str(ii))\ndef mi(): return list(map(int, input().split()))\nprint(\"mi: \", str(mi))\ndef li(): return list(map(int, input().split()))\nprint(\"li: \", str(li))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\nprint(\"lcm: \", str(lcm))\ndef wr(arr): return ' '.join(map(str, arr))\nprint(\"wr: \", str(wr))\ndef revn(n): return str(n)[::-1]\nprint(\"revn: \", str(revn))\ndef dd(): return collections.defaultdict(int)\nprint(\"dd: \", str(dd))\ndef ddl(): return collections.defaultdict(list)\nprint(\"ddl: \", str(ddl))\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\nprint(\"sieve: \", str(sieve))\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\nprint(\"divs: \", str(divs))\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\nprint(\"divn: \", str(divn))\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\nprint(\"prime: \", str(prime))\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\nprint(\"convn: \", str(convn))\ndef cdiv(n, k): return n // k + (n % k != 0)\nprint(\"cdiv: \", str(cdiv))\n\nt = ii()\nprint(\"t: \", str(t))\nfor _ in range(t):\n    r, g, b = sorted(mi())\n    print(\"r: \", str(r), \"g: \", str(g), \"b: \", str(b))\n    if b > r + g + 1:\n        print('No')\n    else:\n        print('Yes')\n</ans>", "format_properties": {}}
{"idx": 6, "result": 0, "generated": "<ans>\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        print(\"N: \", str(N), \"_parent: \", str(self._parent), \"_size: \", str(self._size))\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def calc_group_num(self):\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i) == i:\n                ans += 1\n        return ans\n\nimport sys\n\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nt=list(map(int,input().split()))\nprint(\"t: \", str(t))\nt=[t[i]-1 for i in range(n)]\nprint(\"t: \", str(t))\nquery=[]\nfor i in range(m-1):\n    a,b=list(map(int,input().split()))\n    print(\"a: \", str(a), \"b: \", str(b))\n    query.append((a-1,b-1))\n\ntower=[[] for i in range(m)]\nfor i in range(n):\n    id=t[i]\n    if not tower[id]:\n        tower[id].append((i+1,i+1))\n    else:\n        start,end=tower[id].pop()\n        if end+1==i+1:\n            tower[id].append((start,i+1))\n        else:\n            tower[id].append((start,end))\n            tower[id].append((i+1,i+1))\n\ntest=[]\nfor i in range(m):\n    for start,end in tower[i]:\n        if end!=n:\n            test.append((t[start-1],t[end]))\n\nstart=[-1]*len(test)\nend=[m-1]*len(test)\ntemp=[[] for i in range(m)]\nfor i in range(len(test)):\n    T=(end[i]+start[i])//2\n    temp[T].append(i)\n\ndef parabisect():\n    uf=UnionFindVerSize(m)\n    for i in range(m-1):\n        a,b=query[i]\n        uf.unite(a,b)\n        while temp[i]:\n            j=temp[i].pop()\n            id1,id2=test[j]\n            if uf.is_same_group(id1,id2):\n                end[j]=i\n            else:\n                start[j]=i\n            if end[j]-start[j]>1:\n                T=(end[j]+start[j])//2\n                temp[T].append(j)\n\nfor i in range(20):\n    parabisect()\n\nres=[0]*m\nfor i in range(len(test)):\n    res[end[i]+1]-=1\n\nfor i in range(1,m):\n    res[i]+=res[i-1]\n\nfor i in range(m):\n    print(len(test)+res[i])\n</ans>", "format_properties": {}}
{"idx": 1, "result": 0, "generated": "<ans>\ndef PrimeDecomp(N,ConcFlag):\n    if ConcFlag:\n        if N<=1:\n            print(\"N: \", str(N))\n            return [1],1\n        else:\n            I = 2\n            PrimeDec = []\n            DivCount = 1\n            while I*I<=N:\n                Cnt = 0\n                while N%I==0:\n                    N //= I\n                    PrimeDec.append(I)\n                DivCount *= (Cnt+1)\n                I += 1\n            if N>=2:\n                PrimeDec.append(N)\n                DivCount *= 2\n            print(\"PrimeDec: \", str(PrimeDec), \"DivCount: \", str(DivCount))\n            return PrimeDec,DivCount        \n    else:\n        if N<=1:\n            print(\"N: \", str(N))\n            return [1],[1],1\n        else:\n            I = 2\n            PrimeDec = []\n            PrimeCnt = []\n            DivCount = 1\n            while I*I<=N:\n                Cnt = 0\n                while N%I==0:\n                    N //= I\n                    Cnt += 1\n                if Cnt>=1:\n                    PrimeDec.append(I)\n                    PrimeCnt.append(Cnt)\n                    DivCount *= (Cnt+1)\n                I += 1\n            if N>=2:\n                PrimeDec.append(N)\n                PrimeCnt.append(1)\n                DivCount *= 2\n            print(\"PrimeDec: \", str(PrimeDec), \"PrimeCnt: \", str(PrimeCnt), \"DivCount: \", str(DivCount))\n            return PrimeDec,PrimeCnt,DivCount\n\ndef DivisorFactorial(N,FactDec,FactCnt,MemoFlag,Mod,ModFlag):\n    if MemoFlag:\n        if N<=1:\n            print(\"N: \", str(N))\n            FDivCnt = 1\n            return FactDec,FactCnt,FDivCnt\n        else:\n            PrimeDec,PrimeCnt,_ = PrimeDecomp(N,False)\n            print(\"PrimeDec: \", str(PrimeDec), \"PrimeCnt: \", str(PrimeCnt))\n            for TP in range(0,len(PrimeDec)):\n                if PrimeDec[TP] in set(FactDec):\n                    FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]\n                else:\n                    FactDec.append(PrimeDec[TP])\n                    FactCnt.append(PrimeCnt[TP])\n            print(\"FactDec: \", str(FactDec), \"FactCnt: \", str(FactCnt))\n            FDivCnt = 1\n            for TF in FactCnt:\n                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]\n            print(\"FDivCnt: \", str(FDivCnt))\n            return FactDec,FactCnt,FDivCnt\n    else:\n        if N<=1:\n            print(\"N: \", str(N))\n            FDivCnt = 1\n            return FactDec,FactCnt,FDivCnt\n        else:\n            for TN in range(2,N+1): \n                PrimeDec,PrimeCnt,_ = PrimeDecomp(TN,False)\n                print(\"PrimeDec: \", str(PrimeDec), \"PrimeCnt: \", str(PrimeCnt))\n                for TP in range(0,len(PrimeDec)):\n                    if PrimeDec[TP] in set(FactDec):\n                        FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]\n                    else:\n                        FactDec.append(PrimeDec[TP])\n                        FactCnt.append(PrimeCnt[TP])\n                print(\"FactDec: \", str(FactDec), \"FactCnt: \", str(FactCnt))\n            FDivCnt = 1\n            for TF in FactCnt:\n                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]\n            print(\"FDivCnt: \", str(FDivCnt))\n            return FactDec,FactCnt,FDivCnt\nFactDec,FactCnt,FDivCnt = DivisorFactorial(int(input()),[],[],False,10**9+7,True)\nprint(FDivCnt)\n</ans>", "format_properties": {}}
{"idx": 11, "result": 0, "generated": "<ans>\nfrom math import sqrt\n\neps = 1e-9\n\nprint(\"eps: \", str(eps))\n\ndef mysqrt(x):\n    if x <= 0:\n        return 0\n    return sqrt(x)\n\nprint(\"mysqrt: \", str(mysqrt))\n\ndef good(R):\n    nonlocal xs\n    nonlocal ys\n    nonlocal n\n    \n    left = -10**20\n    right = 10**20\n    \n    for i in range(n):\n        # (x - xi)**2 + (y - yi)**2 = R**2\n        # y = R\n        xi = xs[i]\n        yi = abs(ys[i])\n        \n        D = 2 * R * yi - yi**2\n        \n        if D + eps < 0:\n            return False\n        \n        sD = mysqrt(D)\n        \n        new_left = xi - sD\n        new_right = xi + sD\n        \n        left = max(left, new_left)\n        right = min(right, new_right)\n        \n        if left + eps > right:\n            return False\n    \n    return True\n        \n\ndef solve(lower, high, md):\n    R = 0\n    for _ in range(150):\n        R = md(lower, high)\n        \n        if good(R):\n            high = R\n        else:\n            lower = R\n        \n    return R\n\nn = int(input())\n\nprint(\"n: \", str(n))\n\nxs = [0.0 for _ in range(n)]\nys = [0.0 for _ in range(n)]\n\nfor i in range(n):\n    xs[i], ys[i] = list(map(float, input().split()))\n    if i > 0:\n        if ys[i] * ys[0] < 0:\n            print(-1)\n            return\n\nR = None\nif good(1):\n    R = solve(0, 1, lambda x, y: (x + y) / 2)\nelse:\n    R = solve(1, 1e16, lambda x, y: sqrt(x * y))\n\nprint('{:.16}'.format(R))\n</ans>", "format_properties": {}}
{"idx": 7, "result": 0, "generated": "<ans>\n# from collections import deque\nimport io\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # \u795e\u5947\u5feb\u8bfb\uff0c\u65e0\u6cd5\u8fd0\u884c\u8c03\u8bd5\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nn, m = map(int, input().split())\n# d = {}\ninc = {\n    # chr(97+i):0 for i in range(26)\n\n}\nl = [None for i in range(n*m)]\n\nprint(\"n: \", str(n), \"m: \", str(m))\nfor i in range(n):\n    t = int(input())\n    # tmp = []\n    for j in range(m):\n        # tmp.append(input())\n        ipt = input()\n        l[t*m+j] = ipt\n        if len(inc)==26:continue\n        print(\"ipt: \", str(ipt))\n        for q in ipt:\n            inc.setdefault(q, 0)\n            print(\"q: \", str(q))\n    # d[t] = tmp\n# l = []\n# for i in range(n):\n#     for j in d[i]:\n#         l.append(j)\n\nd = {}\n\n\n# f = l[0][0]\n\ndef ae(u, v):\n    t = d.setdefault(u, set())\n    if v not in t:\n        t.add(v)\n        inc[v] = inc.get(v, 0) + 1\n\n\nfor p, i in enumerate(l[1:]):\n    for j in range(min(len(l[p]), len(i))):\n        if l[p][j] != i[j]:\n            # if len(l[p])-1 != j:\n                # ae(l[p][j],i[j])\n            ae(i[j], l[p][j])\n            break\n        if len(i)-1==j and len(l[p])-1 > j:\n            print(\"IMPOSSIBLE\")\n            return\n\n\nans = []\ndq = []\n# dq = deque()\nptr = 0\n\n\nninc = {}\n\nfor k, v in inc.items():\n    if v == 0:\n        dq.append(k)\n    else:\n        ninc[k] = v\n\n\n# if ctr>1:\n    # print(\"IMPOSSIBLE\")\n    # return\n\ninc = ninc\n\n\nwhile ptr != len(dq):\n    fst = dq[ptr]\n    ans.append(fst)\n\n    for i in d.get(fst, []):\n        inc[i] -= 1\n        if inc[i] == 0:\n            dq.append(i)\n            inc.pop(i)\n\n    # if ctr>1:\n        # print(\"IMPOSSIBLE\")\n        # return\n    ptr += 1\n\nif len(inc):\n    print(\"IMPOSSIBLE\")\n    return\n\nprint(*reversed(ans), sep='')\n</ans>", "format_properties": {}}
{"idx": 12, "result": 0, "generated": "<ans>\ndef bin_pow(num, degree , module):\n    if degree == 0:\n        return 1\n    if degree == 1:\n        return num % module\n\n    if degree % 2 == 0:\n        val = bin_pow(num, degree // 2, module)\n        return (val * val) % module\n    \n    return (num * bin_pow(num , degree - 1, module)) % module\n\n\n\nx, y = list(map(int,input().split()))\nprint(\"x: \", str(x), \"y: \", str(y))\n\nif y % x != 0:\n    print(0)\n    return\n\ny //= x\nprint(\"x: \", str(x), \"y: \", str(y))\n\ndivs = set()\nto_gen = []\n\nnum = 2\nval = y\n\nwhile num * num <= val:\n    degree = 0\n    while y % num == 0:\n        degree+=1\n        y //= num\n    if degree != 0:\n        to_gen.append((num, degree))\n\n    if num == 2:\n        num += 1\n    else:\n        num += 2\n\nif y != 1:\n    to_gen.append((y, 1))\n\n    \nto_gen_len = len(to_gen)\n\ndef generate(ind):\n    if ind == to_gen_len:\n        yield 1\n        return \n    gen_val = to_gen[ind][0]\n    \n    for deg in range(1 + to_gen[ind][1]):\n        for each in generate(ind  + 1):\n            yield gen_val**deg * each\n\nfor each in generate(0):\n    divs.add(each)\n\ndivs = list(divs)\ndivs.sort()\ndivs_answers = {}\nmod = 10**9 + 7\nans = bin_pow(2, val - 1, mod)\n\nfor el in divs:\n    if el == 1:\n        divs_answers[el] = 1\n        ans -= 1\n    else:\n        curr_val = bin_pow(2, el - 1 ,mod)\n        for other_el in divs:\n            if other_el >= el:\n                break\n            if el % other_el !=0:\n                continue\n            \n            curr_val -= divs_answers[other_el]\n\n        divs_answers[el] = curr_val % mod\n        ans -= curr_val\n\nprint(divs_answers[val])\n</ans>", "format_properties": {}}
{"idx": 10, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import defaultdict\n \nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * n\n        print(\"n: \", str(n), \"tree: \", str(self.tree))\n    \n    def _get_sum(self, r):\n        '''\n        sum on interval [0, r)\n        '''\n        result = 0\n        while r > 0:\n            result += self.tree[r-1]\n            r &= (r - 1)\n        return result\n    \n    def get_sum(self, l, r):\n        '''\n        sum on interval [l, r)\n        '''\n        return self._get_sum(r) - self._get_sum(l)\n    \n    def add(self, i, value=1):\n        while i < self.n:\n            self.tree[i] += value\n            i |= (i + 1)\n        print(\"i: \", str(i), \"tree: \", str(self.tree))\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\nprint(\"n: \", str(n))\nswaps = []\nfor _ in range(n):\n    i, j = list(map(int, input().split()))\n    swaps.append(i)\n    swaps.append(j)\n    print(\"i: \", str(i), \"j: \", str(j))\n\npos = defaultdict(list)\nfor i, val in enumerate(swaps):\n    pos[val].append(i)\n    print(\"i: \", str(i), \"val: \", str(val), \"pos: \", str(pos))\n\nc = 0\nprev = -1\ncompr = [0] * (2*n)\ndecompr = {}\nfor val in sorted(swaps):\n    if prev == val: continue\n    for j in pos[val]:\n        compr[j] = c\n    decompr[c] = val\n    c += 1\n    prev = val\n    print(\"val: \", str(val), \"c: \", str(c), \"compr: \", str(compr), \"decompr: \", str(decompr))\n\narr = list(range(c))\nfor t in range(n):\n    i, j = compr[t<<1], compr[t<<1|1]\n    arr[i], arr[j] = arr[j], arr[i]\n    print(\"t: \", str(t), \"i: \", str(i), \"j: \", str(j), \"arr: \", str(arr))\n\nbit = BIT(c)\ntotal_inv = 0\nfor i, val in enumerate(arr):\n    total_inv += bit.get_sum(val+1, c)\n    if i != val:\n        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)\n    bit.add(val)\nprint(\"total_inv: \", str(total_inv))\n</ans>", "format_properties": {}}
{"idx": 15, "result": 0, "generated": "<ans>\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        print(\"parent: \", str(self.parent), \"size: \", str(self.size), \"num_sets: \", str(self.num_sets))\n\n    def find(self, a):\n        to_update = []\n\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n\n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a == b:\n            return\n\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        print(\"parent: \", str(self.parent), \"size: \", str(self.size), \"num_sets: \", str(self.num_sets))\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n, m = read_int_array()\n    print(\"n: \", str(n), \"m: \", str(m))\n    uf = UnionFind(n)\n    for _ in range(m):\n        nums = read_int_array()\n        print(\"nums: \", str(nums))\n        sz = nums[0]\n        leader = None\n        for i in range(sz):\n            p = nums[1 + i] - 1\n            if leader is None:\n                leader = p\n            else:\n                uf.merge(p, leader)\n\n    ans = [uf.set_size(i) for i in range(n)]\n    print(\"ans: \", str(ans))\n    write(*ans)\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 17, "result": 0, "generated": "<ans>\nn=input().split()\nprint(\"n: \", str(n))\nr=int(n[0])\nprint(\"r: \", str(r))\nk=int(n[1])\nprint(\"k: \", str(k))\nl=[]\nprint(\"l: \", str(l))\nfor i in range(r):\n    li=input()\n    l.append(li)\n    print(\"li: \", str(li))\nrl=[]\nprint(\"rl: \", str(rl))\nfor i in range(r):\n    x=[]\n    for j in range(r):\n        x.append(0)\n    rl.append(x)\n    print(\"x: \", str(x))\nfor i in range(r):\n    for j in range(len(l[i])):\n        flag=0\n        f=0\n        if j+k<=r:\n            for q in range(k):\n                if l[i][j+q:j+q+1]=='.':\n                    continue\n                else:\n                    flag=1\n                    break\n            if flag==0:\n                for q in range(k):\n                    rl[i][j+q]=rl[i][j+q]+1\n            if flag==1:\n                j=q+1\nfor i in range(r):\n    for j in range(r):\n        flag=0\n        f=0\n        if j+k<=r:\n            for q in range(k):\n                if l[j+q][i:i+1]=='.':\n                    continue\n                else:\n                    flag=1\n                    break\n            if flag==0:\n                for q in range(k):\n                    rl[j+q][i]=rl[j+q][i]+1\n            if flag==1:\n                j=q+1\nmaxi=0\nmaxj=0\nm=0\nfor i in range(r):\n    for j in range(r):\n        if rl[i][j]>m:\n            m=rl[i][j]\n            maxi=i\n            maxj=j\nprint(maxi+1,maxj+1)\n</ans>", "format_properties": {}}
{"idx": 13, "result": 0, "generated": "<ans>\nimport bisect\n\n\nclass BTreeNode:\n    def __init__(self):\n        print(\"BTreeNode: \", str(self))\n        self.key = []\n        print(\"key: \", str(self.key))\n        self.child = []\n        print(\"child: \", str(self.child))\n\n\nclass BTree:\n    def __init__(self):\n        print(\"BTree: \", str(self))\n        self.root = BTreeNode()\n        print(\"root: \", str(self.root))\n\n    def search_higher(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_right(ptr.key, key)\n            if i != len(ptr.key):\n                ret = ptr.key[i]\n            ptr = ptr.child[i]\n        i = bisect.bisect_right(ptr.key, key)\n        if i != len(ptr.key):\n            ret = ptr.key[i]\n        return ret\n\n    def search_lower(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_left(ptr.key, key)\n            if i != 0:\n                ret = ptr.key[i - 1]\n            ptr = ptr.child[i]\n        i = bisect.bisect_left(ptr.key, key)\n        if i != 0:\n            ret = ptr.key[i - 1]\n        return ret\n\n    def insert(self, key):\n        def insert_rec(ptr):\n            b_size = 10\n            if not ptr.child:\n                bisect.insort(ptr.key, key)\n                if len(ptr.key) == b_size * 2 - 1:\n                        ret = BTreeNode()\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            else:\n                i = bisect.bisect(ptr.key, key)\n                temp = insert_rec(ptr.child[i])\n                if temp is not None:\n                    ptr.key.insert(i, temp.key.pop(-1))\n                    ptr.child.insert(i, temp)\n                    if len(ptr.child) == b_size * 2:\n                        ret = BTreeNode()\n                        ret.child = ptr.child[:b_size]\n                        ptr.child = ptr.child[b_size:]\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            return None\n        temp = insert_rec(self.root)\n        if temp is not None:\n            root = BTreeNode()\n            root.key = [temp.key.pop(-1)]\n            root.child = [temp, self.root]\n            self.root = root\n\n    def dump(self):\n        def dump_rec(ptr, dep):\n            for _ in range(0, dep):\n                print(\"  \", end=\"\")\n            print(ptr.key)\n            for c in ptr.child:\n                dump_rec(c, dep + 1)\n        dump_rec(self.root, 0)\n        print(\"\")\n\n\ndef main():\n    n = int(input())\n    print(\"n: \", str(n))\n    p = list(map(int, input().split()))\n    print(\"p: \", str(p))\n    idx = [0] * n\n    print(\"idx: \", str(idx))\n    for i in range(0, n):\n        idx[i] = i\n        print(\"idx[{}]: {} = {}\".format(i, i, idx[i]))\n    idx.sort(key=lambda i: - p[i])\n    print(\"idx: \", str(idx))\n    t = BTree()\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.search_higher(i)\n        nexnex = t.search_higher(nex)\n        pre = t.search_lower(i)\n        prepre = t.search_lower(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n    print(\"ans: \", str(ans))\n\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 9, "result": 0, "generated": "<ans>\n#!/usr/bin/env python\n# 560B_art.py - Codeforces.com 560B Art program\n#\n# Copyright (C) 2015 Sergey\n\n\"\"\"\nGerald asks whether it is possible to place the paintings on the board,\nor is the board he bought not large enough?\nInput\n\nThe first line contains two space-separated numbers a1 and b1 the sides\nof the board. Next two lines contain numbers a2 b2 a3 and b3 the sides\nof the paintings. All numbers ai,?bi in the input are integers and fit into\nthe range from 1 to 1000.\n\nOutput\n\nIf the paintings can be placed on the wall, print \"YES\" (without the quotes),\nand if they cannot, print \"NO\" (without the quotes).\n\"\"\"\n\n# Standard modules\nimport unittest\nimport sys\n\n# Additional modules\n\n\n###############################################################################\n# Art Class\n###############################################################################\n\n\nclass Art:\n    \"\"\" Art representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        print(\"args: \", str(args))\n        self.numa, self.numb = args\n\n        print(\"numa: \", str(self.numa), \"numb: \", str(self.numb))\n        self.r = self.rect(self.numa[0], self.numb[0])\n        self.rmax = self.rect(self.numa[1], self.numb[1])\n        self.rmin = self.rect(self.numa[2], self.numb[2])\n        if self.rmax[0] < self.rmax[1]:\n            self.rmax, self.rmin = self.rmin, self.rmax\n\n        print(\"r: \", str(self.r), \"rmax: \", str(self.rmax), \"rmin: \", str(self.rmin))\n        self.remain = []\n        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:\n            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))\n        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:\n            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))\n\n        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:\n            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))\n        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:\n            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))\n\n        print(\"remain: \", str(self.remain))\n\n    def rect(self, a, b):\n        if a > b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for rec in self.remain:\n            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:\n                return \"YES\"\n            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:\n                return \"YES\"\n        return \"NO\"\n\n\n###############################################################################\n# Helping classes\n###############################################################################\n\n\n###############################################################################\n# Art Class testing wrapper code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    imax = 3\n    numnums = list(map(int, \" \".join(uinput() for i in range(imax)).split()))\n\n    # Splitting numnums into n arrays\n    numa = []\n    numb = []\n    for i in range(0, 2*imax, 2):\n        numa.append(numnums[i])\n        numb.append(numnums[i+1])\n\n    # Decoding inputs into a list\n    print(\"numnums: \", str(numnums))\n    print(\"numa: \", str(numa), \"numb: \", str(numb))\n    return [numa, numb]\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Art(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_Art_class__basic_functions(self):\n        \"\"\" Art class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Art([[3, 1, 2], [2, 3, 1]])\n        self.assertEqual(d.numa[0], 3)\n\n        self.assertEqual(d.r, (3, 2))\n        self.assertEqual(d.rmax, (3, 1))\n        self.assertEqual(d.rmin, (2, 1))\n\n        self.assertEqual(d.remain, [(3, 1)])\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"3 2\\n1 3\\n2 1\"\n        self.assertEqual(calculate(test), \"YES\")\n        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])\n        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])\n\n        # Sample test 2\n        test = \"5 5\\n3 3\\n3 3\"\n        self.assertEqual(calculate(test), \"NO\")\n\n        # Sample test 3\n        test = \"4 2\\n2 3\\n1 2\"\n        self.assertEqual(calculate(test), \"YES\")\n\n        # My test 4\n        test = \"5 5\\n1 5\\n1 5\"\n        self.assertEqual(calculate(test), \"YES\")\n\n    def test_time_limit_test(self):\n        \"\"\" Quiz time limit test \"\"\"\n\n        import random\n\n        # Time limit test\n        test = \"1000 1000\"\n        test += \"\\n900 900\"\n        test += \"\\n50 50\"\n\n        import timeit\n\n        start = timeit.default_timer()\n        args = get_inputs(test)\n\n        init = timeit.default_timer()\n        d = Art(args)\n\n        calc = timeit.default_timer()\n        d.calculate()\n\n        stop = timeit.default_timer()\n        print((\n            \"\\nTime Test: \" +\n            \"{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)\".\n            format(stop-start, init-start, calc-init, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate())\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 19, "result": 0, "generated": "<ans>\nimport math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): \n    print(\"VI: \", str(VI()))\n    return list(map(int,input().split()))\ndef I(): \n    print(\"I: \", str(I()))\n    return int(input())\ndef LIST(n,m=None): \n    print(\"LIST: \", str(LIST(n,m)))\n    return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): \n    print(\"ELIST: \", str(ELIST(n)))\n    return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    print(\"MI: \", str(MI(n,m)))\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    print(\"MS: \", str(MS(n,m)))\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    print(\"MIT: \", str(MIT(n,m)))\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\n\n\ndef run(n,a):\n    print(\"a: \", str(a))\n    for i in range(n+1):\n        if a[0]==0:\n            if sum([i==a[i] for i in range(n)])==n:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n            return\n        for j in range(n):\n            if j%2==0:\n                a[j] = (a[j]+1)%n\n            else:\n                a[j] = (a[j]-1)%n\n\n\ndef main(info=0):\n    print(\"n: \", str(I()))\n    print(\"a: \", str(VI()))\n    n = I()\n    a = VI()\n\n    run(n,a)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 18, "result": 0, "generated": "<ans>\n\"\"\" ATSTNG's ejudge Python3 solution template \"\"\"\nimport sys, queue\n\ntry:\n    import dev_act_ffc429465ab634\n    DEV = True\nexcept:\n    DEV = False\n\ndef log(*s):\n    if DEV: print('L',list(s),sep='')\n\nclass EJudge:\n    def __init__(self, problem=\"default\", reclim=1<<30):\n        self.problem = problem\n        sys.setrecursionlimit(reclim)\n        print(\"problem: \", str(problem), \"reclim: \", str(reclim))\n\n    def use_files(self, infile='', outfile=''):\n        if infile!='':\n            self.infile = open(infile)\n            sys.stdin = self.infile\n        if infile!='':\n            self.outfile = open(outfile, 'w')\n            sys.stdout = self.outfile\n\n    def use_bacs_files(self):\n        self.use_files(self.problem+'.in', self.problem+'.out')\n\n    def get_tl(self):\n        while True: pass\n\n    def get_ml(self):\n        tmp = [[[5]*100000 for _ in range(1000)]]\n        while True: tmp.append([[5]*100000 for _ in range(1000)])\n        print(\"tmp: \", str(tmp))\n\n    def get_re(self):\n        s = (0,)[8]\n        print(\"s: \", str(s))\n\n    def get_wa(self, wstr='blablalblah'):\n        for _ in range(3): print(wstr)\n        return\n\nclass IntReader:\n    def __init__(self):\n        self.ost = queue.Queue()\n        print(\"ost: \", str(self.ost))\n\n    def get(self):\n        return int(self.sget())\n\n    def sget(self):\n        if self.ost.empty():\n            for el in input().split():\n                self.ost.put(el)\n        return self.ost.get()\n\n    def release(self):\n        res = []\n        while not self.ost.empty():\n            res.append(self.ost.get())\n        return res\n\n###############################################################################\nej = EJudge(  )\nprint(\"ej: \", str(ej))\nint_reader = IntReader()\nprint(\"int_reader: \", str(int_reader))\nfmap = lambda f,l: list(map(f,l))\nparse_int = lambda: fmap(int, input().split())\nsign = lambda x: (x>0)-(x<0)\n\n# input\nn,x = parse_int()\nprint(\"n: \", str(n), \"x: \", str(x))\nst = [0]*100500\nxored = [0]*100500\nfor _ in range(n): \n    st[int_reader.get()] += 1\n    print(\"st: \", str(st))\nfor idx in range(100500):\n    pair = idx^x\n    if pair < 100500:\n        xored[pair] = st[idx]\n        print(\"xored: \", str(xored))\n\nans = 0\nfor idx in range(100500):\n    ans += st[idx]*xored[idx]\n\nif x == 0: ans -= n\n\nprint(ans//2)\n</ans>", "format_properties": {}}
{"idx": 20, "result": 0, "generated": "<ans>\n#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ndef e_gcd(a, b ):\n    if a==0 and b==0:\n        return -1, 0, 0\n    if b==0:\n        return a, 1,0\n    d, y,x = e_gcd(b, a%b )\n    y-=  a //b *x\n    return d , x,y\n\ndef m_reverse(a,n):\n    d,x,y = e_gcd(a,n)\n    dprint(x,y,a,n)\n    assert x*a + y*n == d\n    if d==1:\n        if x%n<=0:\n           return x%n+n\n        else:\n            return x%n\n    else:\n        return -1\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\nbase = 998244353\nd = 1233\nt = m_reverse( d, base)\ndprint(t)\nz = t * d % base\ndprint(z)\nN, M, K= getIntList()\ndprint(\"N: \", str(N), \"M: \", str(M), \"K: \", str(K))\n\nJ = N-1 - K   # same\n\nZ = N - J\ndprint(\"Z: \", str(Z))\nR = M\nfor i in range(Z-1):\n    R *= M-1\n    R%= base\ndprint(\"R: \", str(R))\nn0 = J\nm0 = Z\ndprint(\"n0: \", str(n0), \"m0: \", str(m0))\n#comb(n0 + m0 -1, m0-1)\nfor i in range(m0 -1):\n    g = n0 + m0 -1  -i\n    R*= g\n    R%= base\n    dprint(\"R: \", str(R))\nfor i in range(2, m0):\n    t = m_reverse(i,base)\n    R*=t\n    R%=base\n    dprint(\"R: \", str(R))\n\nprint(R)\n</ans>", "format_properties": {}}
{"idx": 14, "result": 0, "generated": "<ans>\nk = 72\nprint(\"k: \", str(k))\nK = 1<<k\nprint(\"K: \", str(K))\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\nst = lambda n: bin(n)[2:] + \"0\"\nli = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]\n\ndef grow(d, v, h):\n    h += [0] * d\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    \n    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):\n        t = [1] * (2*d+2)\n        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P\n        ti = [1] * (2*d+2)\n        ti[-1] = pow(t[-1], P-2, P)\n        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P\n        \n        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]\n        fg = li(st(nu(f) * nu(g)), d * 2 + 2)\n            \n        if idx == 1:\n            for i in range(d+1):\n                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n        elif idx == 0:\n            for i in range(d):\n                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P\n        elif idx == 2:\n            for i in range(d):\n                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v):\n    s = 1\n    X = [1, v+1]\n    print(\"X: \", str(X))\n    while s < v:\n        X = grow(s, v, X)\n        s *= 2\n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    return a\n\nP = 10**9+7\nv = 1 << 11\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nT = create_table(v)\nprint(\"T: \", str(T))\n\nf = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P\nr1, c1, r2, c2 = list(map(int, input().split()))\nprint(\"r1, c1, r2, c2: \", str(r1), str(c1), str(r2), str(c2))\nprint(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))\n</ans>", "format_properties": {}}
{"idx": 16, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\n# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Sponge Class (Main Program)\n###############################################################################\n\n\nclass Sponge:\n    \"\"\" Sponge representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        print(\"n, m: \", str(self.n), str(self.m))\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        print(\"numf: \", str(self.numf))\n        self.numf = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        print(\"numb: \", str(self.numb))\n        self.numb = list(map(int, uinput().split()))\n\n        self.fd = {}\n        self.fdn = {}\n        for (i, n) in enumerate(self.numf):\n            self.fd[n] = self.fd.setdefault(n, 0) + 1\n            self.fdn[n] = i + 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        for n in self.numb:\n            if n not in self.fd:\n                return \"Impossible\"\n            result.append(self.fdn[n])\n        for n in self.numb:\n            if self.fd[n] > 1:\n                return \"Ambiguity\"\n\n        return \"Possible\\n\" + \" \".join(map(str, result))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Sponge class testing \"\"\"\n\n        # Constructor test\n        test = \"3 3\\n3 2 1\\n1 2 3\"\n        d = Sponge(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 3)\n        self.assertEqual(d.numf, [3, 2, 1])\n        self.assertEqual(d.numb, [1, 2, 3])\n\n        # Sample test\n        self.assertEqual(Sponge(test).calculate(), \"Possible\\n3 2 1\")\n\n        # Sample test\n        test = \"3 3\\n1 1 3\\n1 2\"\n        self.assertEqual(Sponge(test).calculate(), \"Impossible\")\n\n        # Sample test\n        test = \"3 3\\n1 1 1\\n1 1 1\"\n        self.assertEqual(Sponge(test).calculate(), \"Ambiguity\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Sponge(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Sponge(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Sponge().calculate())\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 22, "result": 0, "generated": "<ans>\ndef solve(printing):\n\n    n = int(input())\n    print(\"n: \", str(n))\n    nums = [int(st)-1 for st in input().split(\" \")]\n    print(\"nums: \", str(nums))\n    numdupe = [0] * n\n    dupeindex = []\n    dupeindexindv = {}\n    missing = []\n\n    if printing:\n        print(\"nums\"); print(nums)\n\n    for i in range(n):\n        numdupe[nums[i]] += 1\n\n    for i in range(n):\n        if numdupe[i] == 0:\n            missing.append(i)\n            print(\"missing: \", str(missing))\n            \n        if numdupe[nums[i]] >= 2:\n            dupeindex.append(i)\n            if nums[i] in dupeindexindv:\n                dupeindexindv[nums[i]][1].append(i)\n                print(\"dupeindexindv: \", str(dupeindexindv))\n            else:\n                dupeindexindv[nums[i]] = [0, [i], False]\n                print(\"dupeindexindv: \", str(dupeindexindv))\n                # left location, dupe indexs, if already located original\n\n    for num in dupeindexindv:\n        dupeindexindv[num][0] = len(dupeindexindv[num][1])\n\n    if printing:\n        print(\"missing\"); print(missing)\n        print(\"dupeindexindv\"); print(dupeindexindv)\n\n    misslen = len(missing)\n    misindex = 0\n    #answer = 0\n    for index in dupeindex:\n\n        if misslen <= misindex:\n            break\n\n        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:\n            # one spot left but original not located yet.\n            # locate original.\n            dupeindexindv[nums[index]][0] -= 1\n            dupeindexindv[nums[index]][2] = True\n            print(\"dupeindexindv: \", str(dupeindexindv))\n\n        elif dupeindexindv[nums[index]][0] > 0:\n            \n            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:\n                # num is smaller or original is already located.\n                # locate missing number.\n                dupeindexindv[nums[index]][0] -= 1\n                nums[index] = missing[misindex]\n                misindex += 1\n                #answer += 1\n\n            else: # locate original\n                dupeindexindv[nums[index]][0] -= 1\n                dupeindexindv[nums[index]][2] = True\n                print(\"dupeindexindv: \", str(dupeindexindv))\n\n    print(misslen)\n    for num in nums:\n        print(num+1, end = \" \")\n\nsolve(False)\n</ans>", "format_properties": {}}
{"idx": 23, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport random\nimport bisect as bi\nprint(\"sys: \", str(stdin), \"stdout: \", str(stdout))\nprint(\"math: \", str(math), \"sys: \", str(sys), \"heapq: \", str(heapq))\nprint(\"itertools: \", str(permutations), \"combinations: \", str(combinations))\nprint(\"collections: \", str(defaultdict), \"deque: \", str(deque), \"OrderedDict: \", str(OrderedDict))\nprint(\"os: \", str(path))\nprint(\"random: \", str(random))\nprint(\"bisect: \", str(bi))\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')): \n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def I():return (int(input()))\n def In():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def I():return (int(stdin.readline()))\n def In():return(map(int,stdin.readline().split()))\n#sys.setrecursionlimit(1500)\ndef dict(a):\n d={} \n for x in a:\n  if d.get(x,-1)!=-1:\n   d[x]+=1\n  else:\n   d[x]=1\n return d\ndef find_gt(a, x):\n 'Find leftmost value greater than x'\n i = bi.bisect_right(a, x)\n if i != len(a):\n  return i\n else:            \n  return -1\n\ndef find_ge(a, x):\n 'Find leftmost item greater than or equal to x'\n i = bi.bisect_left(a, x)\n if i != len(a):\n  return i\n else:\n  return -1\ndef main():\n try:\n  n,Q=In()\n  print(\"n: \", str(n), \"Q: \", str(Q))\n  l=list(In())\n  print(\"l: \", str(l))\n  l.sort()\n  print(\"l: \", str(l))\n  pre=[0]\n  su=0\n  for x in range(n):\n   su+=l[x]\n   pre.append(su)\n  print(\"pre: \", str(pre))\n  for x in range(Q):\n   q=I()\n   print(\"q: \", str(q))\n   q*=2\n   print(\"q: \", str(q))\n   pos=find_ge(l,q)\n   print(\"pos: \", str(pos))\n   if pos==-1:\n    print(\"0\")\n   else:\n    print(\"ans: \")\n    ans=pre[-1]-pre[pos]\n    print(ans)\n except:\n  pass\n  \nM = 998244353\nP = 1000000007\n \ndef __starting_point():\n #for _ in range(I()):main()\n for _ in range(1):main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 27, "result": 0, "generated": "<ans>\nclass Ddict:\n    def __init__(self):\n        self.dicts={}\n        print(\"dicts: \", str(self.dicts))\n    def add(self,key):\n        d=self.dicts\n        for i in key:\n            if i not in d:\n                d[i]={}\n                print(\"i: \", str(i), \"d: \", str(d))\n            d=d[i]\n        d[' ']=''\n    def find(self,key):\n        if key=='':\n            return '',''\n        d=self.dicts\n        q=[]\n        h=[key[0]]\n        for i in key:\n            if i not in d:\n                if ' ' in d and len(d)==1:\n                    return ''.join(q),''.join(h)\n                return '',''\n            q.append(i)\n            if len(d)!=1:\n                h=q[:]\n            d=d[i]\n        if ' ' in d and len(d)==1:\n            return ''.join(q),''.join(h)\n        return '',''\nwords = Ddict()\nans=0\nwhile True:\n    try:\n        x=input()\n        if not x:\n            break\n    except:\n        break\n    ans+=len(x)+1\n    ws=[[]]\n    for i in x:\n        if i in '.,?!\\'- ':\n            if ws[-1]:\n                ws.append([])\n        else:\n            ws[-1].append(i)\n    ws=list([''.join(e) for e in ws])\n    for w in ws:\n        next_word,helped_word = words.find(w)\n        if next_word and next_word!=helped_word:\n            ans-=len(next_word)-len(helped_word)-1\n        words.add(w)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 28, "result": 0, "generated": "<ans>\nfrom math import gcd\nprint(\"gcd: \", str(gcd))\nfrom itertools import combinations,permutations,accumulate, product \nprint(\"combinations,permutations,accumulate,product: \", str(combinations), str(permutations), str(accumulate), str(product))\nfrom collections import deque,defaultdict,Counter\nprint(\"deque,defaultdict,Counter: \", str(deque), str(defaultdict), str(Counter))\nimport decimal\nprint(\"decimal: \", str(decimal))\nimport re\nprint(\"re: \", str(re))\nimport math\nprint(\"math: \", str(math))\nimport bisect\nprint(\"bisect: \", str(bisect))\nimport heapq\nprint(\"heapq: \", str(heapq))\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nprint(\"sys: \", str(sys))\nsys.setrecursionlimit(10000000)\nprint(\"sys.setrecursionlimit: \", str(sys.setrecursionlimit))\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nprint(\"mod: \", str(mod))\nINF = float('inf')\nprint(\"INF: \", str(INF))\nfrom sys import stdin\nprint(\"stdin: \", str(stdin))\nreadline = stdin.readline\nprint(\"readline: \", str(readline))\ndef readInts():\n  print(\"readInts: \", str(readInts))\n  return list(map(int,readline().split()))\ndef readTuples():\n    print(\"readTuples: \", str(readTuples))\n    return tuple(map(int,readline().split()))\ndef I():\n    print(\"I: \", str(I))\n    return int(readline())\nn = I()\nprint(\"n: \", str(n))\nans = 0\nprint(\"ans: \", str(ans))\ndef dfs(v):\n    print(\"v: \", str(v))\n    if len(v) != 0:\n        if int(v) > n:\n            return\n    if v.count('3') and v.count('5') and v.count('7'):\n        nonlocal ans\n        ans += 1\n    for s in \"357\":\n        v += s\n        dfs(v)\n        v = v[:-1]\ndfs(\"\")\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 26, "result": 0, "generated": "<ans>\nimport heapq\nn,m,k = list(map(int,input().split()))\nprint(\"n,m,k: \", str(n), str(m), str(k))\nconnectionList = []\nprint(\"connectionList: \", str(connectionList))\nfor _ in range(n):\n    connectionList.append([])\n    print(\"connectionList: \", str(connectionList))\nedgeList = []\nfor _ in range(m):\n    x,y,w = list(map(int,input().split()))\n    print(\"x,y,w: \", str(x), str(y), str(w))\n    edgeList.append((x,y,w))\n    print(\"edgeList: \", str(edgeList))\nedgeList.sort(key = lambda x: x[2])\nif k < m:\n    maxDist = edgeList[min(m,k) - 1][2]\nelse:\n    maxDist = sum([x[2] for x in edgeList])\nprint(\"maxDist: \", str(maxDist))\ncolorList = {}\ncolorVertex = []\nfor i in range(n):\n    colorList[i] = [i]\n    colorVertex.append(i)\n    print(\"colorList: \", str(colorList), \"colorVertex: \", str(colorVertex))\nfor i in range(min(m,k)):\n    x,y,w = edgeList[i]\n    connectionList[x-1].append((y-1,w))\n    connectionList[y-1].append((x-1,w))\n    if colorVertex[x-1] != colorVertex[y-1]:\n        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):\n            prevColor = colorVertex[y-1]\n            for elem in colorList[colorVertex[y-1]]:\n                colorVertex[elem] = colorVertex[x-1]\n                colorList[colorVertex[x-1]].append(elem)\n            del colorList[prevColor]\n        else:\n            prevColor = colorVertex[x-1]\n            for elem in colorList[colorVertex[x-1]]:\n                colorVertex[elem] = colorVertex[y-1]\n                colorList[colorVertex[y-1]].append(elem)\n            del colorList[prevColor]\n\npathList = []\nfor key in colorList:\n    vertexList = colorList[key]\n    for mainVertex in vertexList:\n        vertexPQueue = []\n        isCovered = {}\n        distanceDic = {}\n        for elem in vertexList:\n            isCovered[elem] = False\n            distanceDic[elem] = maxDist\n        isCovered[mainVertex] = True\n        for elem in connectionList[mainVertex]:\n            heapq.heappush(vertexPQueue,(elem[1],elem[0]))\n            distanceDic[elem[0]] = elem[1]\n        while vertexPQueue:\n            distance, curVertex = heapq.heappop(vertexPQueue)\n            if isCovered[curVertex]:\n                continue\n            elif distance >= maxDist:\n                break\n            for elem in connectionList[curVertex]:\n                if distance + elem[1] < distanceDic[elem[0]]:\n                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))\n                    distanceDic[elem[0]] = distance + elem[1]\n        for key in distanceDic:\n            if distanceDic[key] <= maxDist and key > mainVertex:\n                pathList.append(distanceDic[key])\n        if len(pathList) > k:\n            pathList.sort()\n            pathList = pathList[0:k]\n            if pathList[-1] < maxDist:\n                maxDist = pathList[-1]\npathList.sort()\nprint(\"pathList: \", str(pathList))\nprint(pathList[k-1])\n</ans>", "format_properties": {}}
{"idx": 24, "result": 0, "generated": "<ans>\nimport sys\n\ndef gcd(l):\n\tif len(l)==0:\n\t\treturn 0\n\tif len(l)==1:\n\t\treturn l[0]\n\tif len(l)==2:                                   \n\t\tif l[1]==0:\n\t\t\treturn l[0]  \n\t\treturn gcd([l[1],l[0]%l[1]])\n\treturn gcd([gcd(l[:-1]),l[-1]])\n\t\t\ndef brute_force(l1,l2,l,sol):                   \n\tif len(l)==0:\n\t\tg1=gcd(l1)\n\t\tg2=gcd(l2)\n\t\treturn g1==1 and g2==1,sol\n\t\n\tres,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])\n\tif res:\n\t\treturn True,s\n\treturn brute_force(l1,l2+[l[0]],l[1:],sol+[2])\n\ndef factor(n):\n\tres=[]\n\ti=2\n\twhile i*i<=n:\n\t\tif n%i==0:\n\t\t\tres.append(i)\n\t\twhile n%i==0:\n\t\t\tn=int(n/i)\n\t\ti+=1\n\n\tif n!=1:\n\t\tres.append(n)\n\n\treturn res\n\ndef dumpsol(sol):\n\tfor v in sol:\n\t\tprint(v,end=' ')\n\nn=int(sys.stdin.readline())\nl=sys.stdin.readline().strip().split(\" \")[0:n]\nl=[int(x) for x in l]\nif n<12:\n\tret,sol=brute_force([],[],l,[])\n\tif ret:\n\t\tprint(\"YES\")\n\t\tdumpsol(sol)\n\telse:\n\t\tprint(\"NO\")\n\treturn\n\nfactors={}\nfor i in range(10):\n\tfor key in factor(l[i]):\n\t\tfactors[key]=0\n\nflists={}\nfor f in factors:\n\tflists[f]=[]\n\tpos=0\n\tfound=False\n\tfor v in l:\n\t\tif v%f!=0:\n\t\t\tfound=True\n\t\t\tfactors[f]+=1\n\t\t\tflists[f].append(pos)\n\t\t\tif (factors[f]>9):\n\t\t\t\tbreak\n\t\tpos+=1\n\tif not found:\n\t\tprint(\"NO\")\n\t\treturn\n\noftf=[]\nisoftf={}\nfor f in factors:\n\tif factors[f]==0:\n\t\tprint(\"NO\")\n\t\treturn\n\n\tif factors[f]<10:\n\t\toftf.append(f)\n\t\tisoftf[f]=1\n\n#print(oftf)\n\nsol=[1 for i in range(len(l))]\nx=l[0]\nsol[0]=2\nprint(\"x: \", str(x), \"sol: \", str(sol))\noxf=factor(x)\n#print(oxf)\nxf=[]\nnxf=0\nisxoftf={}\nfor f in oxf:\n\tif f in isoftf:\n\t\tnxf+=1\n\t\tisxoftf[f]=1\n\t\txf.append(f)\n\telse:\n\t\tsol[flists[f][0]]=2\n\nnonxf=[]\nfor f in oftf:\n\tif not f in isxoftf:\n\t\tnonxf.append(f)\n\nmasks={}\npos=0\n\n#print(xf)\n#print(nonxf)\n\nfor f in xf+nonxf:\n\tfor v in flists[f]:\n\t\tif not v in masks:\t\n\t\t\tmasks[v]=0\n\t\tmasks[v]|=1<<pos\n\tpos+=1\n\nvals=[{} for i in range(len(masks)+1)]\nvals[0][0]=0\npos=0\nmlist=[]\nfor mask in masks:\n\tmlist.append(mask)\n\tcmask=masks[mask]\n\tcmask1=cmask<<10\n\t#print(vals)\n\tfor v in vals[pos]:\n\t\tvals[pos+1][v|cmask]=v\n\t\t# first number is always in group2\n\t\tif (mask!=0):\n\t\t\tvals[pos+1][v|cmask1]=v\n\tpos+=1\t\n\n#print(vals)\n#print(masks)\n#print(sol)\n\ntest_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)\n#print(test_val)\nfor v in vals[pos]:\n\tif (v&test_val)==test_val:\n\t\tprint(\"YES\")\n\n\t\t#print(pos)\n\t\twhile (pos!=0):\n\t\t\t#print(v)\n\t\t\t#print(vals[pos])\n\t\t\tnv=vals[pos][v]\n\t\t\t#print(nv)\n\t\t\tif (nv^v<1024 and nv^v!=0):\n\t\t\t\tsol[mlist[pos-1]]=2\n\t\t\tv=nv\n\t\t\tpos-=1\n\n\t\tdumpsol(sol)\n\t\treturn\n\nprint(\"NO\")\n\n#print(oftf)\n#print(masks)\n</ans>", "format_properties": {}}
{"idx": 29, "result": 0, "generated": "<ans>\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom itertools import accumulate\n\n#T = int(input())\ns = input()\n#N,M,K,Q = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\ndef computeGCD(x, y):\n\n   while(y):\n       x, y = y, x % y\n\n   return x\n\nrecord = {}\n\nprint(\"s: \", str(s))\nprint(\"record: \", str(record))\n\nfor x in range(10):\n    for y in range(10):\n        for d in range(10):\n            m = 9999\n            if (x==0 or y==0) and d==0:\n                record[(x,y,d)] = 0\n            elif x==0 and y==0 and d!=0:\n                record[(x,y,d)] = -1\n            else:\n                for k in range(10):\n                    d_tmp = d + 10*k\n                    if x==0:\n                        if d_tmp%y==0:\n                            record[(x,y,d)] = d_tmp//y - 1\n                            break\n\n                    elif y==0:\n                        if d_tmp%x==0:\n                            record[(x,y,d)] = d_tmp//x - 1\n                            break\n\n                    else:\n                        for a in range((d_tmp//x)+1):\n                            for b in range((d_tmp//y)+1):\n                                if x*a+y*b==d_tmp and d_tmp!=0:\n                                    m = min(m,a+b-1)\n\n                if (x,y,d) not in record:\n                    if m==9999:\n                        m = -1\n                    record[(x,y,d)] = m\n            print(\"x: \", str(x), \"y: \", str(y), \"d: \", str(d), \"record: \", str(record[(x,y,d)]))\n\ndata = [[0]*10 for _ in range(10)]\n\nlen_s = len(s)\ns = list(s)\nfreq = [0]*10\nprint(\"s: \", str(s), \"len_s: \", str(len_s))\nfor i in range(len_s-1):\n    A = s[i]\n    B = s[i+1]\n\n    d = ord(B)-ord(A)\n    if d<0:\n        d += 10\n\n    freq[d] += 1\n    print(\"A: \", str(A), \"B: \", str(B), \"d: \", str(d), \"freq: \", str(freq[d]))\n\nfor x in range(10):\n    for y in range(10):\n        for d in range(10):\n            if freq[d]==0:\n                data[x][y] += 0\n            elif record[(x,y,d)]==-1:\n                data[x][y] = -10000000\n            else:\n                data[x][y] += freq[d]*record[(x,y,d)]\n            print(\"x: \", str(x), \"y: \", str(y), \"d: \", str(d), \"data: \", str(data[x][y]))\n\nfor x in range(10):\n    for y in range(10):\n        if data[x][y]<0:\n            print(-1,end=' ')\n        else:\n            print(data[x][y],end=' ')\n    print('',end='\\n')\n</ans>", "format_properties": {}}
{"idx": 31, "result": 0, "generated": "<ans>\nfrom math import*\nfrom random import*\n\nn = int(input()) * 2\nprint(\"n: \", str(n))\nA = list(map(int, input().split()))\nprint(\"A: \", str(A))\namount = [0] * 101\nprint(\"amount: \", str(amount))\nB = []\nfor i in range(n):\n    if amount[A[i]] < 2:\n        amount[A[i]] += 1\n        B += [(A[i], i)]\nprint(\"B: \", str(B))\nB.sort()\nx, y = [], []\nfor i in range(len(B)):\n    if(i % 2 == 0):\n        x.append(B[i][1])\n    else:\n        y.append(B[i][1])\nprint(\"x: \", str(x))\nprint(\"y: \", str(y))\nlolka = 0\naaa = 0\n# print(x)\n# print(y)\nprint(len(x) * len(y))\nfor i in range(n):\n    if i in x:\n        lolka += 1\n        aaa += 1\n        print(1, end = ' ')\n    elif i in y:\n        print(2, end = ' ')\n    else:\n        if len(x) - lolka + aaa < n // 2:\n            print(1, end = ' ')\n            aaa += 1\n        else:\n            print(2, end = ' ')\nprint()\n\n# B, C = [], []\n# for i in range(n):\n\n\n# S = list(set(A))\n# where = [0] * 101\n# am1, am2 = 0, 0\n# for i in range(len(S)):\n#     if(i % 2 == 0):\n#         where[S[i]] = 1\n#         am1 += 1\n#     else:\n#         where[S[i]] = 2\n#         am2 += 1\n# used = [0] * 201\n# for i in range(n):\n#     if not used[A[i]]:\n#         print(where[A[i]])\n#         used[A[i]] = True\n#     else:\n#         print(3 - where[A[i]])\n</ans>", "format_properties": {}}
{"idx": 3, "result": 0, "generated": "<ans>\nimport numpy as np\nmod = 998244353\n\ndef poly_mul(f, g):\n    # \u53c2\u8003: https://judge.yosupo.jp/submission/2380\n    Lf = len(f); Lg = len(g); L = Lf + Lg - 1\n    if Lf <= 16 or Lg <= 16:\n        if Lf == 0 or Lg == 0:\n            return np.zeros((0,), dtype=np.int64)\n        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)\n    fft = np.fft.rfft; ifft = np.fft.irfft\n    fft_len = 1 << L.bit_length()\n    fl = f & (1 << 15) - 1; fh = f >> 15\n    gl = g & (1 << 15) - 1; gh = g >> 15\n    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    return (x + ((y - x - z) << 15) + (z << 30)) % mod\n\ndef poly_inv(fps, n=None):\n    assert fps[0] != 0\n    if n is None:\n        n = len(fps)\n    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)\n    res[0] = pow(int(fps[0]), mod-2, mod)\n    i = 1\n    while i < n:\n        i <<= 1\n        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod\n    return res[:n]\n\ndef poly_div(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return np.zeros((0,), dtype=np.int64)\n    n = n1 - n2 + 1\n    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]\n    return res\n\ndef poly_mod(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return fps1\n    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]\n    return res % mod\n\ndef multipoint_evaluation(fps, xs):\n    threshold = 8\n    n_xs = len(xs)\n    bit = (n_xs-1).bit_length()\n    if bit <= threshold:\n        res = np.zeros_like(xs)\n        xs_cumprod = np.ones_like(xs)\n        for coef in fps:\n            res += xs_cumprod * coef\n            xs_cumprod *= xs\n            xs_cumprod %= mod\n        return res\n    k = 1<<bit\n    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)\n    fpss[0, :n_xs] = -xs % mod\n    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod\n    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod\n    for i in range(1, bit):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+step] = f[:-1]\n    f = poly_mod(fps, f)\n    fpss[-1, :len(f)] = f\n    fpss[-1, len(f):] = 0\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f = fpss[i+1, j:j+step]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss[i, j:j+half] = poly_mod(f, f1)\n            fpss[i, j+half:j+step] = poly_mod(f, f2)\n    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)\n    xs_cumprod = np.ones_like(xs)\n    res = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    return res.reshape(-1)[:n_xs] % mod\n\ndef poly_differential(fps):\n    return fps[1:] * np.arange(1, len(fps)) % mod\n\ndef lagrange_interpolation(X, Y, mod):\n    # old\n    n = len(X)\n    g = [0]*(n+1)\n    g[0] = 1\n    for i, x in enumerate(X):\n        for j in range(i, -1, -1):\n            g[j+1] += g[j] * (-x) % mod\n    res = [0]*n\n    for x, y in zip(X, Y):\n        f = g[:]\n        denom = 0\n        v = 1\n        pow_x = [1]  # x \u306e idx \u4e57\n        for _ in range(n-1):\n            v = v * x % mod\n            pow_x.append(v)\n        pow_x.reverse()  # n-1 \u4e57 ~ 0 \u4e57\n        for i, po in enumerate(pow_x):\n            f_i = f[i]\n            f[i+1] += f_i * x % mod  # f = g / (x - x_i) \u3092\u7d44\u7acb\u9664\u6cd5\u3067\u6c42\u3081\u308b\n            denom = (denom + f_i * po) % mod\n        denom_inv = pow(denom, mod-2, mod)\n        for i, f_i in enumerate(f[:n]):\n            res[i] += (f_i * y * denom_inv)# % mod  # mod \u304c\u5927\u304d\u3044\u3068 64bit \u306b\u53ce\u307e\u3089\u306a\u304f\u306a\u308b\u306e\u3067\u3072\u3068\u3064\u305a\u3064 mod \u53d6\u3063\u305f\u65b9\u304c\u3044\u3044\u304b\uff1f\n    return [v % mod for v in res]\n\ndef polynomial_interpolation(xs, ys):\n    # \u53c2\u8003: https://rsk0315.hatenablog.com/entry/2020/04/05/203210\n    assert len(xs) == len(ys)\n    threshold = 8\n    as_strided = np.lib.stride_tricks.as_strided\n    n = len(xs)\n    if n==1:\n        return ys.copy()\n    bit = (n-1).bit_length()\n    if bit <= threshold:\n        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)\n        return np.array(res[::-1], dtype=np.int64)\n    k = 1<<bit\n    fpss = np.zeros((bit+1, n+1), dtype=np.int64)\n    fpss[0, :n] = -xs % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss[i+1, j:n] = fpss[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+len(f)-1] = f[:-1]\n    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)\n    fpss2[bit, :n] = poly_differential(f)\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss2[i, j:n] = fpss2[i+1, j:n]\n                continue\n            f = fpss2[i+1, j:min(j+step, n)]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:min(j+step, n)+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i, j:j+half] = poly_mod(f, f1)\n            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)\n    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))\n    xs_cumprod = np.ones_like(xs)\n    f = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    f = f.ravel()\n    for j in range(n):\n        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, k, step):\n            if j+half >= n:\n                fpss2[i+1, j:n] = fpss2[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i+1, j:min(j+step, n)] = (\n                poly_mul(fpss2[i, j:j+half], f2)\n                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)\n            ) % mod\n    return fpss2[bit, :n]\n\nmod = int(input())\nA = np.array(input().split(), dtype=np.int64)\nX = np.arange(mod, dtype=np.int64)\nprint(\"mod: \", str(mod))\nprint(\"A: \", str(A))\nprint(\"X: \", str(X))\nAns = polynomial_interpolation(X, A)\nprint(\"Ans: \", str(Ans.tolist()))\nprint((\" \".join(map(str, Ans.tolist()))))\n</ans>", "format_properties": {}}
{"idx": 32, "result": 0, "generated": "<ans>\ndef check(mid):\n    ans = []\n    res = 0\n    for c, count in d:\n        tmp = count // mid\n        if (count % mid != 0):\n            tmp += 1\n        ans.append((c, tmp))\n        res += tmp\n    print(\"ans: \", str(ans), \"res: \", str(res))\n    return res <= n, ans\n        \n\na = input()\nn = int(input())\nprint(\"a: \", str(a), \"n: \", str(n))\nd = dict()\nt = 0\nprint(\"d: \", str(d), \"t: \", str(t))\nfor i in a:\n    if i not in d:\n        d[i] = 1\n        t += 1\n        print(\"i: \", str(i), \"d: \", str(d), \"t: \", str(t))\n    else: d[i] += 1\nans = []\nres = \"\"\nfor i in d:\n    ans.append(i)\n    res = i\nif n >= len(a):\n    print(1)\n    print(a, end = '')\n    n -= len(a)\n    for u in range(n):\n        print(res, end ='')\nelse:\n    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))\n    l = 1\n    r = len(a)\n    res = []\n    count_res = 0\n    while (l <= r):\n        mid = (l + r) // 2\n        flag, tmp = check(mid)\n        if (flag):\n            r = mid - 1\n            count_res = mid\n            res = tmp\n        else:\n            l = mid + 1\n        #print(l, r, tmp)\n    if (len(res) == 0):\n        print(-1)\n    else:\n        ttt = 0\n        print(count_res)\n        for c, sl in res:\n            for j in range(sl):\n                print(c, end = '')\n                ttt += 1\n        n -= ttt\n        for i in range(n):\n            print(a[0], end = '')\n</ans>", "format_properties": {}}
{"idx": 30, "result": 0, "generated": "<ans>\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport math\n\n#T = int(input())\n#N = int(input())\n#print(N)\nN,r = [int(x) for x in stdin.readline().split()]\nprint(\"N: \", str(N), \"r: \", str(r))\n#arr = [int(x) for x in stdin.readline().split()]\n\nvisited = [0]*N\nprint(\"visited: \", str(visited))\n\na = [0]*N\nb = [0]*N\nprint(\"a: \", str(a), \"b: \", str(b))\n\npos = 0\nprint(\"pos: \", str(pos))\n\nfor i in range(N):\n    arr = [int(x) for x in stdin.readline().split()]\n    a[i] = arr[0]\n    b[i] = arr[1]\n    print(\"a[{}]: \".format(i), str(a[i]), \"b[{}]: \".format(i), str(b[i]))\n    \n    if b[i]>=0:\n        pos += 1\n        print(\"pos: \", str(pos))\n\nfor i in range(pos):\n    idx = -1\n    start = 0\n    gain = -50000\n    for j in range(N):\n        # find available and largest gain\n        # if gain tie, find largest start r\n        if visited[j]==1 or b[j]<0:\n            continue\n            \n        if b[j]>gain and r>=a[j]:\n            gain = b[j]\n            idx = j\n            start = a[j]\n        elif b[j]==gain and r>=a[j]:\n            if a[j]>start:\n                idx = j\n                start = a[j]\n                \n    if idx==-1:\n        print('NO')\n        quit()\n    else:\n        visited[idx] = 1\n        r += b[idx]\n        print(\"idx: \", str(idx), \"r: \", str(r))\n        \n        \ntmp = []\nfor i in range(N):\n    if visited[i]==1 or b[i]>=0:\n        continue\n    tmp.append((a[i],b[i],i))\n    \ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\n\nfor i in range(len(tmp)):\n    require = tmp[i][0]\n    bias = tmp[i][1]\n    \n    if r>=require:\n        r += bias\n    else:\n        print('NO')\n        quit()\n        \n\nif r<0:\n    print('NO')\n    quit()\n        \nprint('YES')\n</ans>", "format_properties": {}}
{"idx": 25, "result": 0, "generated": "<ans>\na, b, f, k = [int(i) for i in input().split()]\nprint(\"a: \", str(a), \"b: \", str(b), \"f: \", str(f), \"k: \", str(k))\n\n##tank = b\n##journeys = 0\n##refuels = 0\n##current = 0\n##while(journeys != k):\n##    print(\"current = %d, tank = %d, refuels = %d, journeys = %d\" % (current, tank, refuels, journeys))\n##    if (tank // a >= k):\n##        print(refuels)\n##        return\n        \n##    if current == 0:\n##        if tank >= a + (a-f):\n##            tank -= a\n##        elif tank >= f and b >= a-f:\n##            refuels += 1\n##            tank = b-(a-f)\n##        else:\n##            break\n##        \n##        current = a\n##        \n##    elif current == a:\n##        if tank >= a + f:\n##            tank -= a\n##        elif tank >= a-f and b >= f:\n##            refuels += 1\n##            tank = b-f\n##        else:\n##            break\n##        \n##        current = 0\n##\n##    journeys += 1\n\nif b < f:\n    print(-1)\n    return\n\njourneys = 0\nprevious = 0\nrefuels1 = 0\ntank = b-f\nprint(\"journeys: \", str(journeys), \"previous: \", str(previous), \"refuels1: \", str(refuels1), \"tank: \", str(tank))\nwhile(journeys != k): ## necessary? while(True) ?\n    if previous == 0:\n        if tank >= a-f + a*(k-journeys-1):\n            print(refuels1)\n            return\n        if b >= a-f + a*(k-journeys-1):\n            print(refuels1+1)\n            return\n        if tank >= 2*(a-f):\n            tank -= 2*(a-f)\n        elif b >= 2*(a-f):\n            refuels1 += 1\n            tank = b - 2*(a-f)\n        else:\n            print(-1)\n            return\n        \n        journeys += 1\n        previous = a\n        print(\"journeys: \", str(journeys), \"previous: \", str(previous), \"refuels1: \", str(refuels1), \"tank: \", str(tank))\n        \n    if previous == a:\n        if tank >= f + a*(k-journeys-1):\n            print(refuels1)\n            return\n        if b >= f + a*(k-journeys-1):\n            print(refuels1+1)\n            return\n        if tank >= 2*f:\n            tank -= 2*f\n        elif b >= 2*f:\n            refuels1 += 1\n            tank = b-2*f\n        else:\n            print(-1)\n            return\n        \n        journeys += 1\n        previous = 0\n        print(\"journeys: \", str(journeys), \"previous: \", str(previous), \"refuels1: \", str(refuels1), \"tank: \", str(tank))\n\nif journeys == k:\n    print(refuels1)\nelse:\n    print(-1)\n\n##journeys = 0\n##previous = 0\n##refuels2 = 1\n##tank = b\n##cant2 = False\n##while(journeys != k):\n##    if previous == 0:\n##        if tank >= a-f + a*(k-journeys-1):\n##            break\n##        if tank >= 2*(a-f):\n##            tank -= 2*(a-f)\n##        elif b >= 2*(a-f):\n##            refuels2 += 1\n##            tank = b - 2*(a-f)\n##        else:\n##            cant2 = True\n##            break\n##        \n##        journeys += 1\n##        previous = a\n##        \n##    if previous == a:\n##        if tank >= f + a*(k-journeys-1):\n##            break\n##        if tank >= 2*f:\n##            tank -= 2*f\n##        elif b >= 2*f:\n##            refuels2 += 1\n##            tank = b-2*f\n##        else:\n##            cant2 = True\n##            break\n##        \n##        journeys += 1\n##        previous = 0\n##\n##if cant1 and not cant2:\n##    print(refuels2)\n##elif not cant1 and cant2:\n##    print(refuels1)\n##elif cant1 and cant2:\n##    print(-1)\n##else:\n##    print(min(refuels1, refuels2))\n</ans>", "format_properties": {}}
{"idx": 34, "result": 0, "generated": "<ans>\nfrom math import log2, floor\n\ndef is_power2(num):\n    print(\"is_power2: \", str(num))\n    return num != 0 and ((num & (num - 1)) == 0)\n\n\ndef next_two_pow(val):\n    print(\"next_two_pow: \", str(val))\n    pw=0\n    while 2**pw <= val:\n        pw=+1\n    return pw        \n\nn = int(input())\nprint(\"n: \", str(n))\narr=[int(x) for x in input().split()]\nprint(\"arr: \", str(arr))\n\nwin_idx =-1\nprint(\"win_idx: \", str(win_idx))\nselected=[]\n\nfor i in range(1,n+1):\n    val = arr[i-1]\n    print(\"val: \", str(val))\n    if win_idx ==-1:\n       if  val == -1: \n           win_idx =i\n           print(\"win_idx: \", str(win_idx))\n    else:\n         if is_power2(i):\n             selected.append(val)\n             selected.sort()\n             print(\"selected: \", str(selected))\n         else:\n             if len(selected) > 0 and val < selected[-1]:\n                 selected.pop()\n                 selected.append(val)\n                 selected.sort()\n                 print(\"selected: \", str(selected))\n\nprint(sum(selected))\n\n\n# if arr[n-1] ==-1:\n#     print(0)\n# else:\n#     win_idx =-1\n#     for i in range(0,n):\n#         if arr[i] == -1:\n#             win_idx =i\n#             break\n# \n#     crt_pow=int(floor(log2(n)))\n#     stop_pow=next_two_pow(win_idx)\n#     total=0\n#     taken= set()\n#     while crt_pow > stop_pow:\n#         two_p = 2**crt_pow\n#         mn = 10**9 + 1\n#         mn_idx = -1\n#         for i in range(two_p - 1, n):\n#             if i!=win_idx and i not in taken and  arr[i] < mn:\n#                 mn =arr[i]\n#                 mn_idx=i\n#         crt_pow -=1        \n#         taken.add(mn_idx)\n#         total+=mn\n#     print(total)    \n</ans>", "format_properties": {}}
{"idx": 36, "result": 0, "generated": "<ans>\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nn = I()\nprint(\"n: \", str(n))\nA = readInts()\nprint(\"A: \", str(A))\nB = readInts()\nprint(\"B: \", str(B))\nans = 0\nfor i in range(n):\n    v = B[i]\n    # kill = A[i] + A[i+1]\n    nya = min(v, A[i])\n    print(\"nya: \", str(nya))\n    A[i] -= nya\n    v -= nya\n    ans += nya\n    nya = min(A[i+1], v)\n    print(\"nya: \", str(nya))\n    ans += nya\n    A[i+1] -= nya\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 35, "result": 0, "generated": "<ans>\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n\ndef go():\n    n = int(input())\n    print(\"n: \", str(n))\n    # n, h, l, r = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(\"a: \", str(a))\n    e = {i: set() for i in range(n)}\n    print(\"e: \", str(e))\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u, v = u - 1, v - 1\n        e[u].add(v)\n        e[v].add(u)\n    ranks = [len(e[i]) for i in range(n)]\n    print(\"ranks: \", str(ranks))\n    leafs = [i for i in range(n) if ranks[i] == 1]\n    print(\"leafs: \", str(leafs))\n    index = 0\n    vs = {i: {} for i in range(n)}\n    print(\"vs: \", str(vs))\n    done = set()\n    while index < len(leafs):\n        cur = leafs[index]\n        mysum = sum(vs[cur].values())\n\n        if a[cur] == 0:\n            mysum -= 1\n        else:\n            mysum += 1\n\n        for i in e[cur] - done:\n            vs[i][cur] = max(mysum, 0)\n            ranks[i] -= 1\n            if ranks[i] == 1:\n                leafs.append(i)\n        done.add(cur)\n        index += 1\n\n    sums = [0] * n\n    que = [ranks.index(0)]\n    done = set()\n    index = 0\n    while index < len(que):\n        cur = que[index]\n\n        mysum = sum(vs[cur].values())\n\n        if a[cur] == 0:\n            mysum -= 1\n        else:\n            mysum += 1\n\n        sums[cur] = mysum\n\n        for i in e[cur] - done:\n            vs[i][cur] = max(mysum - vs[cur][i], 0)\n            que.append(i)\n\n        done.add(cur)\n        index += 1\n\n    return ' '.join(map(str,sums))\n\n\n# t = int(input())\nfor _ in range(1):\n    print(go())\n</ans>", "format_properties": {}}
{"idx": 37, "result": 0, "generated": "<ans>\ndef solve(s,t):\n    hash_s = [False] * 256\n    print(\"hash_s: \", str(hash_s))\n    hash_t = [False] * 256\n    print(\"hash_t: \", str(hash_t))\n    arr = []\n    n = len(s)\n    print(\"n: \", str(n))\n    for c in s:\n        hash_s[ord(c)] = True\n    print(\"hash_s: \", str(hash_s))\n    for c in t:\n        hash_t[ord(c)] = True\n    print(\"hash_t: \", str(hash_t))\n    for i in range(256):\n        if not hash_s[i] and hash_t[i]:\n            print(-1)\n            return\n    rev = s[::-1]\n    print(\"rev: \", str(rev))\n    i,j = 0,0\n    while i < len(t):\n        flag = True\n        temp = t[i]\n        j = i + 1\n        while j < len(t):\n            temp += t[j]\n            if temp not in s and temp not in rev:\n                flag = False\n                break\n            j += 1\n        if flag:\n            x = s.find(temp)\n            if x != -1:\n                arr.append((x + 1,x + len(temp)))\n                # print('1',x + 1,x + len(temp))\n            else:\n                y = rev.find(temp)\n                arr.append((n - y,n - y - len(temp) + 1))\n                # print('2',n - y,n - y - len(temp) + 1)\n        else:\n            x = s.find(temp[:-1])\n            if x != -1:\n                arr.append((x + 1,x + len(temp) - 1))\n                # print('3',x + 1,x + len(temp) - 1)\n            else:\n                x = rev.find(temp[:-1])\n                arr.append((n - x,n - x - len(temp) + 2))\n                # print('4',n - x,n - x - len(temp) + 2)\n        i = j\n    print(\"arr: \", str(arr))\n    print(len(arr))\n    for x,y in arr:\n        print(x,y)\n\ns = input()\nt = input()\n\nsolve(s,t)\n</ans>", "format_properties": {}}
{"idx": 33, "result": 0, "generated": "<ans>\n\"\"\"\nCodeforces Contest Good Bye 2014 Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n\"\"\"\n\n################################################### SOLUTION\n\ndef main():\n    print(\"n: \", str(n))\n    n, = read()\n    print(\"p: \", str(p))\n    p = read()\n    dsu = DSU()\n    print(\"dsu: \", str(dsu))\n    for i in range(n):\n        a = read(0)\n        print(\"a: \", str(a))\n        dsu.make()\n        for j in range(i):\n            if a[j] == \"1\":\n                dsu.union(j, i)\n    used = [0] * n\n    print(\"used: \", str(used))\n    res = [0] * n\n    print(\"res: \", str(res))\n    for i in range(n):\n        if not used[i]:\n            pr = dsu.find(i)\n            indices = []\n            elements = []\n            for j in range(n):\n                if dsu.find(j) == pr:\n                    used[j] = 1\n                    indices.append(j)\n                    elements.append(p[j])\n            elements.sort()\n            for i,e in zip(indices, elements):\n                res[i] = e\n    write(res)\n\n#################################################### HELPERS\n\nclass DSU(object):\n    \"\"\"\n    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.\n\n    Methods:\n    make(): add a new element and returns its index\n    find(x): return representative of x\n    union(x, y): merge the sets containing x and y\n\n    Not to be used publicly:\n    _parent: a list of ints for the parent of each vertex, used internally; call find instead\n    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case\n    __init__(): called when initialization, initialize DSU to be empty\n    __str__(): return a readable string description of the DSU; meant to be printed while debugging\n    \"\"\"\n\n    def __init__(self):\n        self._parent = []\n        self._rank = []\n\n    def make(self):\n        i = len(self._parent)\n        self._parent.append(i)\n        self._rank.append(0)\n        return i\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr == yr: return\n        if self._rank[xr] < self._rank[yr]:\n            self._parent[xr] = yr\n        elif self._rank[yr] < self._rank[xr]:\n            self._parent[yr] = xr\n        else:\n            self._parent[yr] = xr\n            self._rank[xr] += 1\n\n    def __str__(self):\n        s = \"DSU\\n\"\n        for i in range(len(self._parent)):\n            s += str(i) + \" in set \" + str(self.find(i)) + \" with rank \" + str(self._rank[self.find(i)]) + \"\\n\"\n        return s\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())\n</ans>", "format_properties": {}}
{"idx": 38, "result": 0, "generated": "<ans>\nfrom itertools import chain\nimport sys\n\ndef main():\n    N = int(input())\n    # TLEs were caused mostly by slow input (1s+)\n    # S = list(input() for _ in range(N))\n    S = sys.stdin.read().split('\\n')\n    print((solve(S)))\n\ndef get_count(args):\n    s, result = args # messy input to work with map.\n    cum_sum = 0\n    for c in s:\n        if c == ')':\n            cum_sum -= 1\n        else:\n            cum_sum += 1\n        result[0] = max(result[0], -cum_sum)\n    result[1] = result[0] + cum_sum\n    return result\n\n# Made-up name, don't remember what to call this. Radix-ish\ndef silly_sort(array, value_min, value_max, get_value):\n    if len(array) == 0:\n        return\n    cache = [None for _ in range(value_max - value_min + 1)]\n    for elem in array:\n        # Assume elem[0] is the value\n        value = get_value(elem) - value_min\n        if cache[value] is None:\n            cache[value] = []\n        cache[value].append(elem)\n    for values in cache:\n        if values is None:\n            continue\n        for value in values:\n            yield value\n\ndef solve(S):\n    counts = [[0,0] for _ in range(len(S))]\n    print(\"counts: \", str(counts))\n    counts = list(map(get_count, list(zip(S,counts))))\n    print(\"counts: \", str(counts))\n    first_group = []\n    second_group = []\n    min_first_group = float('inf')\n    max_first_group = 0\n    min_second_group = float('inf')\n    max_second_group = 0\n\n    for c in counts:\n        if c[0] - c[1] <= 0:\n            first_group.append(c)\n            max_first_group = max(max_first_group, c[0])\n            min_first_group = min(min_first_group, c[0])\n        else:\n            second_group.append(c)\n            max_second_group = max(max_second_group, c[1])\n            min_second_group = min(min_second_group, c[1])\n    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])\n    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))\n    print(\"first_group: \", str(first_group))\n    print(\"second_group: \", str(second_group))\n\n    order = chain(first_group, second_group)\n\n    cum_sum = 0\n    for c in order:\n        cum_sum -= c[0]\n        if cum_sum < 0:\n            return 'No'\n        cum_sum += c[1]\n    if cum_sum == 0:\n        return 'Yes'\n    return 'No'\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 39, "result": 0, "generated": "<ans>\nimport math\nfrom functools import reduce\nclass SegmentTree():\n    def __init__(self, L, function = lambda x,y: x+y):\n        self.function = function\n        N = self.size = len(L)\n        M = 1 << N.bit_length()\n        self.margin = 2*M - N\n        self.L = [None for i in range(self.margin)] + L\n        for i in range(M-1, 0, -1):\n            x, y = self.L[i<<1], self.L[i<<1|1]\n            self.L[i] = None if x is None or y is None else function(x, y)\n        print(\"L: \", str(self.L))\n    def modify(self, pos, value):\n        p = pos + self.margin\n        self.L[p] = value \n        print(\"pos: \", str(pos), \"value: \", str(value))\n        while p > 1:\n            x, y = self.L[p], self.L[p^1]\n            if p&1: x, y = y, x\n            self.L[p>>1] = None if x is None or y is None else self.function(x, y)\n            p>>=1\n    def query(self, left, right):\n        l, r = left + self.margin, right + self.margin\n        stack = []\n        void = True\n        while l < r:\n            if l&1:\n                if void:\n                    result = self.L[l]\n                    void = False\n                else:\n                    result = self.function(result, self.L[l])\n                l+=1\n            if r&1:\n                r-=1\n                stack.append(self.L[r])\n            l>>=1\n            r>>=1\n        init = stack.pop() if void else result\n        return reduce(self.function, reversed(stack), init)\n\nn = int(input())\npies, index, first_equal = [0]*n, [0]*n, [0]*n\nprint(\"pies: \", str(pies), \"index: \", str(index), \"first_equal: \", str(first_equal))\nfor i in range(n):\n    r, h = [int(x) for x in input().split()]\n    pies[i] = r*r*h\ns_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))\nprint(\"s_pies: \", str(s_pies))\nfor i in range(n): index[s_pies[i][0]] = i\nprint(\"index: \", str(index))\nfor i in range(1, n):\n    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]\nprint(\"first_equal: \", str(first_equal))\ntowers = SegmentTree([0]*(n+1), max)\nprint(\"towers.L: \", str(towers.L))\nfor j, pie in enumerate(pies):\n    i, k = index[j], first_equal[j]\n    q = towers.query(0, k+1)\n    towers.modify(i+1, q + pie)\nprint(\"towers.L: \", str(towers.L))\nprint(math.pi * towers.query(0, n+1))\n</ans>", "format_properties": {}}
{"idx": 40, "result": 0, "generated": "<ans>\n# returns answer to the subproblem with interval range [start, end],\n# but with a total of \"extra\" additional stuff on the end\n# that must be deleted last.\nmemo = {}\nprint(\"memo: \", str(memo))\ndef f(dat, rewards, start, end, extra):\n    curr = (start, end, extra)\n    print(\"curr: \", str(curr))\n    if curr in memo:\n        return memo[curr]\n    \n    if start > end:\n        return 0\n    if start == end:\n        memo[curr] = rewards[dat[start] + extra]\n        print(\"dat[start]: \", str(dat[start]), \"extra: \", str(extra), \"rewards[dat[start] + extra]: \", str(rewards[dat[start] + extra]))\n        return memo[curr]\n    \n    # test all possible \"cut points\".\n    # \"cut\" is the earliest index to die in the same deletion as \"end\".\n    out = 0\n    for cut in range(end, start-1, -2):\n        if cut == end:\n            # in this case, we're deleting the last interval right away.\n            out_curr = rewards[dat[cut] + extra]\n            out_curr += f(dat, rewards, start, cut-1, 0)\n        else:\n            # split into 2 pieces:\n            # 1) slots [start, cut] plus [end + extra]\n            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).\n            out_curr = f(dat, rewards, start, cut, extra + dat[end])\n            out_curr += f(dat, rewards, cut+1, end-1, 0)\n        \n        out = max(out, out_curr)\n    \n    memo[curr] = out\n    print(\"curr: \", str(curr), \"out: \", str(out))\n    return memo[curr]\n\ndef solve(dat_str, rewards_orig):\n    # break into intervals.\n    dat = []\n    pos = 0\n    print(\"dat: \", str(dat))\n    while pos < len(dat_str):\n        end = pos\n        while end < len(dat_str) and dat_str[pos] == dat_str[end]:\n            end += 1\n\n        dat.append(end - pos)\n        pos = end\n    \n    # compute the highest-value way to remove a run of size k.\n    # (google translated from C++ thinking)\n    rewards = [0, rewards_orig[0]]\n    print(\"rewards: \", str(rewards))\n    for k in range(2, len(rewards_orig) + 1):\n        # print(\n        #     \"{}: {}\".format(\n        #         k,\n        #         [\n        #             rewards[k-j] + rewards_orig[j-1]\n        #             for j in range(1, k+1)\n        #         ]\n        #     )\n        # )\n        rewards.append(\n            max(\n                rewards[k-j] + rewards_orig[j-1]\n                for j in range(1, k+1)\n            )\n        )\n        print(\"k: \", str(k), \"rewards: \", str(rewards))\n    \n    # print(\"dat: {}\".format(dat))\n    # print(\"rewards: {}\".format(rewards))\n    \n    return f(dat, rewards, 0, len(dat)-1, 0)\n\n# get the integer\nint_dummy = input()\n# get the string\ndat_str = input().strip()\n# get the array\nrewards_input = input().strip().split()\nrewards_ints = [int(x) for x in rewards_input]\n\n# print(dat_str)\n# print(rewards_ints)\n\nprint((\n    solve(\n        dat_str,\n        rewards_ints,\n    )\n))\n\n\n# dat_test = \"10101\"\n# rewards_test = [3, 10, 15, 15, 15]\n# print(solve(dat_test, rewards_test))\n</ans>", "format_properties": {}}
{"idx": 42, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import deque\n\nt=1\nprint(\"t: \", str(t))\nfor _ in range(int(input())):\n    n=int(input())\n    print(\"n: \", str(n))\n    val=set([0,2*10**5+1])\n    print(\"val: \", str(val))\n    seg=[(0,2*10**5+1)]\n    print(\"seg: \", str(seg))\n    for i in range(n):\n        l,r=map(int,input().split())\n        print(\"l, r: \", str(l), str(r))\n        val.add(l)\n        val.add(r)\n        seg.append((l,r))\n    val=list(val)\n    val.sort()\n    print(\"val: \", str(val))\n    comp={i:e+1 for e,i in enumerate(val)}\n    print(\"comp: \", str(comp))\n    for i in range(n+1):\n        l,r=seg[i]\n        seg[i]=(comp[l],comp[r])\n        print(\"seg[i]: \", str(seg[i]))\n\n    deg=[0]*(n+1)\n    print(\"deg: \", str(deg))\n    out=[[] for i in range(n+1)]\n    print(\"out: \", str(out))\n    for i in range(n+1):\n        for j in range(i+1,n+1):\n            l,r=seg[i]\n            L,R=seg[j]\n            if L<=l and r<=R:\n                out[j].append(i)\n                deg[i]+=1\n            elif l<=L and R<=r:\n                out[i].append(j)\n                deg[j]+=1\n    print(\"deg: \", str(deg))\n    print(\"out: \", str(out))\n\n    ans=[0]\n    deq=deque(ans)\n    print(\"ans: \", str(ans))\n    print(\"deq: \", str(deq))\n\n    while deq:\n        v=deq.popleft()\n        for nv in out[v]:\n            deg[nv]-=1\n            if deg[nv]==0:\n                deq.append(nv)\n                ans.append(nv)\n        print(\"ans: \", str(ans))\n        print(\"deq: \", str(deq))\n\n    dp=[0]*(n+1)\n    print(\"dp: \", str(dp))\n\n    def solve(v):\n        query=[[] for i in range(2*n+3)]\n        for nv in out[v]:l,r=seg[nv];query[r].append((l,dp[nv]))\n        subdp=[0]*(2*n+3)\n        for i in range(1,2*n+3):\n            res=subdp[i-1]\n            for l,val in query[i]:test=subdp[l-1]+val;res=max(test,res)\n            subdp[i]=res\n\n        dp[v]=subdp[-1]+1\n\n    for v in ans[::-1]:solve(v)\n    print(\"dp: \", str(dp))\n\n    print(dp[0]-1)\n</ans>", "format_properties": {}}
{"idx": 44, "result": 0, "generated": "<ans>\ndef gcd(a,b):\n    while b:\n        a, b = b, a%b\n    return a\n\nn = int(input())\nprint(\"n: \", str(n))\nP = [[int(x) for x in input().split()] for _ in range(n)]\nprint(\"P: \", str(P))\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n    print(\"x: \", str(x), \"y: \", str(y), \"dx: \", str(dx), \"dy: \", str(dy))\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nprint(\"L: \", str(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n    print(\"dx: \", str(dx), \"dy: \", str(dy), \"C[dx,dy]: \", str(C[dx,dy]))\n\nss = sum(C.values())\nprint(\"ss: \", str(ss))\n\nfor x in C.values():\n    res += (ss-x)*x\n    print(\"x: \", str(x), \"res: \", str(res))\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)\n</ans>", "format_properties": {}}
{"idx": 43, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\narr=list(map(int,input().split()))\nprint(\"arr: \", str(arr))\ndict1={}\nfor i in range(2*n):\n\ttry:\n\t\tdict1[arr[i]].append(i+1)\n\t\tdict1[arr[i]].sort()\n\texcept:\n\t\tKeyError\n\t\tdict1[arr[i]]=[i+1]\nprint(\"dict1: \", str(dict1))\nans=0\ncurr1=1\ncurr2=1\nfor i in range(1,n+1):\n\tif(i==1):\n\t\tans+=(dict1[i][0]-curr1)\n\t\tans+=(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]>curr1 and dict1[i][0]>curr2):\n\t\tans+=(dict1[i][0]-curr1)\n\t\tans+=(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][1]<curr1<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]<curr1 and curr1<dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]<curr1 and dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(curr1<dict1[i][0]<dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telse:\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\nprint(\"ans: \", str(ans))\nprint(\"curr1: \", str(curr1))\nprint(\"curr2: \", str(curr2))\nprint(\"dict1: \", str(dict1))\nprint(\"arr: \", str(arr))\nprint(\"n: \", str(n))\n</ans>", "format_properties": {}}
{"idx": 45, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nA=[list(map(int,input().split())) for i in range(n)]\nprint(\"A: \", str(A))\n\nfor i in range(m):\n    #\u4e00\u884c\u76ee\u3092i-1\u307e\u30670\u306b\u3059\u308b\n\n    ANSR=[0]*n\n    ANSC=[0]*m\n\n    for j in range(i):\n        if A[0][j]==1:\n            ANSC[j]=1\n\n    for j in range(i,m):\n        if A[0][j]==0:\n            ANSC[j]=1\n\n    for r in range(1,n):\n        B=set()\n        for c in range(m):\n            if ANSC[c]==0:\n                B.add(A[r][c])\n            else:\n                B.add(1-A[r][c])\n\n        if len(B)>=2:\n            break\n        if max(B)==0:\n            ANSR[r]=1\n\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str,ANSR)))\n        print(\"\".join(map(str,ANSC)))\n        return\n\nANSR=[0]*n\nANSC=[0]*m\n\nfor j in range(m):\n    if A[0][j]==1:\n        ANSC[j]=1\n\nflag=0\nfor r in range(1,n):\n    if flag==0:\n        B=[]\n        for c in range(m):\n            if ANSC[c]==0:\n                B.append(A[r][c])\n            else:\n                B.append(1-A[r][c])\n\n        if max(B)==0:\n            continue\n        elif min(B)==1:\n            ANSR[r]=1\n            continue\n        else:\n            OI=B.index(1)\n            if min(B[OI:])==1:\n                flag=1\n                continue\n\n            OO=B.index(0)\n            if max(B[OO:])==0:\n                flag=1\n                ANSR[r]=1\n                continue\n\n            else:\n                print(\"NO\")\n                return\n\n    else:\n\n        B=set()\n        for c in range(m):\n            if ANSC[c]==0:\n                B.add(A[r][c])\n            else:\n                B.add(1-A[r][c])\n\n        if len(B)>=2:\n            break\n        if max(B)==0:\n            ANSR[r]=1\n\nelse:\n    print(\"YES\")\n    print(\"\".join(map(str,ANSR)))\n    print(\"\".join(map(str,ANSC)))\n    return\n\nprint(\"NO\")\n</ans>", "format_properties": {}}
{"idx": 41, "result": 0, "generated": "<ans>\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass RAQ_RMQ():\n    def __init__(self, n, inf=2**31-1):\n        print(\"n: \", str(n), \"inf: \", str(inf))\n        self.n0 = 1<<(n-1).bit_length()\n        self.INF = inf\n        self.data = [0]*(2*self.n0)\n        self.lazy = [0]*(2*self.n0)\n\n    def getIndex(self, l, r):\n        l += self.n0; r += self.n0\n        lm = (l // (l & -l)) >> 1\n        rm = (r // (r & -r)) >> 1\n        while l < r:\n            if r <= rm:\n                yield r\n            if l <= lm:\n                yield l\n            l >>= 1; r >>= 1\n        while l:\n            yield l\n            l >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if not v:\n                continue\n            self.lazy[2*i-1] += v; self.lazy[2*i] += v\n            self.data[2*i-1] += v; self.data[2*i] += v\n            self.lazy[i-1] = 0\n\n    def update(self, l, r, x):\n        print(\"l: \", str(l), \"r: \", str(r), \"x: \", str(x))\n        *ids, = self.getIndex(l, r)\n\n        l += self.n0; r += self.n0\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.lazy[r-1] += x; self.data[r-1] += x\n            if l & 1:\n                self.lazy[l-1] += x; self.data[l-1] += x\n                l += 1\n            l >>= 1; r >>= 1\n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]\n\n    def query(self, l, r):\n        self.propagates(*self.getIndex(l, r))\n        l += self.n0; r += self.n0\n\n        s = self.INF\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = min(s, self.data[r-1])\n            if l & 1:\n                s = min(s, self.data[l-1])\n                l += 1\n            l >>= 1; r >>= 1\n        return s\n\nn,m,k = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\nl = [0]*(n+1)\nnow = k\npoint = [0]*n\nfor i in range(n):\n    print(\"i: \", str(i))\n    a,b,c = map(int, input().split())\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    point[i] = c\n    now = now-a\n    l[i] = now\n    now += b+a\n    print(\"now: \", str(now))\nl[n] = now\nprint(\"l: \", str(l))\n\nRMQ = RAQ_RMQ(n+1)\nfor i in range(n+1):\n    print(\"i: \", str(i))\n    RMQ.update(i,i+1,l[i])\n\nportal = list(range(n))\nfor i in range(m):\n    print(\"i: \", str(i))\n    u,v = map(int, input().split())\n    print(\"u: \", str(u), \"v: \", str(v))\n    u,v = u-1, v-1\n    if portal[v]<u:\n        portal[v] = u\n    print(\"portal: \", str(portal))\n\nif RMQ.query(0, n+1) < 0:\n    print(-1)\n    return\n\nheap = [(-point[i], -portal[i]) for i in range(n)]\nfrom heapq import heapify, heappop\nheapify(heap)\n\nans = 0\nwhile heap:\n    print(\"heap: \", str(heap))\n    p,i = heappop(heap)\n    p,i = -p,-i\n    print(\"p: \", str(p), \"i: \", str(i))\n    if RMQ.query(i+1, n+1)>0:\n        ans += p\n        RMQ.update(i+1, n+1, -1)\n\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 50, "result": 0, "generated": "<ans>\na = input()\nprint(\"a: \", str(a))\nans=[]\nt=''\nqoute =0\nspace =0\nstart =1 if a[0]=='\"' else 0\nfor i in range(len(a)):\n    v= a[i]\n    if start:\n        if t=='':\n            if v=='\"':\n                qoute+=1\n                t = '<'\n            elif v==' ':\n                pass\n            else:\n                space+=1\n                t='<'+v\n        elif qoute>0:\n            if v =='\"':\n                t+='>'\n                qoute=0\n                ans.append(t)\n                t=''\n                start=0\n            else:\n                t+=v\n        else:\n            if v ==' ':\n                if t!='<':\n                    t+='>'\n                    ans.append(t)\n                    t=''\n                    start=0\n            else:\n                t+=v\n    else:\n        if v==' ':\n            start=1\n        elif v=='\"':\n            start=1\n            t='<'\n            qoute=1\n        else:\n            t='<'+v\n            start=1\nif t!='':\n    t+='>'\n    ans.append(t)\nfor v in ans:\n    print(v)\n</ans>", "format_properties": {}}
{"idx": 48, "result": 0, "generated": "<ans>\nn, k = list(map(int, input().split()))\nprint(\"n: \", str(n), \"k: \", str(k))\np  = {}\nprint(\"p: \", str(p))\nnp = {}\nprint(\"np: \", str(np))\npair    = []\nprint(\"pair: \", str(pair))\nused    = {}\nprint(\"used: \", str(used))\nrev_d   = {}\nprint(\"rev_d: \", str(rev_d))\n\ndef push(d, s, v):\n    if s not in d:\n        d[s] = []\n    d[s].append(v)\n    print(\"d: \", str(d))\n\ndef is_pal(s):\n    n = len(s)\n    flg=True\n    for i in range(n//2):\n        if s[i] != s[n-1-i]:\n            flg = False\n            break\n    return flg        \n\ndef rev(s):\n    return s[::-1]\n\nfor _ in range(n):\n    s, val = input().split()\n    val    = int(val)\n    print(\"s: \", str(s), \"val: \", str(val))\n    \n    if is_pal(s):\n        push(p, s, val)\n    else:\n        push(np, s, val)\n        \n        if s not in rev_d:\n            rev_d[s] = rev(s)\n            print(\"rev_d: \", str(rev_d))\n\nfor k, v in list(p.items()):\n    p[k] = sorted(v, reverse=True)\n    print(\"p: \", str(p))\n        \nfor k, v in list(np.items()):\n    np[k] = sorted(v, reverse=True)\n    print(\"np: \", str(np))\n    \nfor s in np:\n    if s not in used and rev_d[s] in np:\n        pair.append([s, rev_d[s]])\n        used[s] = True\n        used[rev_d[s]] = True\n        print(\"pair: \", str(pair))\n        print(\"used: \", str(used))\n        \nmax_remain = 0\nminus = 0\nmax_S = 0\n\nfor v_arr in list(p.values()):\n    n = len(v_arr)\n    for i in range(0, n, 2):\n        if i+1==n:\n            if v_arr[i] > 0:\n                max_remain = max(max_remain, v_arr[i]) \n        else:\n            if v_arr[i] + v_arr[i+1] >= 0:\n                max_S += v_arr[i] + v_arr[i+1]\n                \n                if v_arr[i+1] < 0:\n                    minus = min(minus, v_arr[i+1])\n            else:\n                if v_arr[i] > 0:\n                    max_remain = max(max_remain, v_arr[i]) \n\nfor [u, v] in pair:\n    n = min(len(np[u]), len(np[v]))\n        \n    for x, y in  zip(np[u][:n], np[v][:n]):\n        if x+y > 0:\n            max_S += x+y\n            \nprint(max(max_S+max_remain, max_S-minus))            \n</ans>", "format_properties": {}}
{"idx": 49, "result": 0, "generated": "<ans>\n\"\"\"\ndef grundy(a,k): #\u77f3 a \u500b\u3001\u6700\u5927 x//k \u307e\u3067\u3068\u308c\u308b\n    #print(a,k)\n    if a < k:\n        return 0\n    q = a//k\n    r = (a-q*k)%(q+1)\n    if r==0:\n        return a//k\n    v = (a-q*k)//(q+1) + 1\n    #print(a,k,q,v)\n    return grundy(a-(q+1)*v,k)\n\"\"\"\ndef grundy(a,k): #\u77f3 a \u500b\u3001\u6700\u5927 x//k \u307e\u3067\u3068\u308c\u308b\n    #print(a,k)\n    if a < k:\n        return 0\n    q = a//k\n    r = (a-q*k)%(q+1)\n    if r==0:\n        return a//k\n    v = (a-q*k)//(q+1) + 1\n    #print(a,k,q,v)\n    return grundy(a-(q+1)*v,k)\n\n\"\"\"\nK = 10\nN = 50\nV = 5\nfor k in range(V,V+1):\n    a = [0]*N\n    for i in range(1,N):\n        s = set()\n        for j in range(1,1+i//k):\n            s.add(a[i-j])\n        for j in range(N):\n            if j not in s:\n                a[i] = j\n                break\n    \n    #print(k,a)\n    #for i in range(N//V):\n    #    print(a[i*V:(i+1)*V])\n\n    \n    b = [grundy(i,k) for i in range(N)]\n    print(a)\n    print(b)\n    assert a==b\n\"\"\"\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\nsys.setrecursionlimit(10**8)\n\nn, = list(map(int,readline().split()))\nprint(\"n: \", str(n))\ng = 0\nprint(\"g: \", str(g))\nfor _ in range(n):\n    a,k = list(map(int,readline().split()))\n    print(\"a: \", str(a), \"k: \", str(k))\n    g ^= grundy(a,k)\n    print(\"g: \", str(g))\nif g:\n    print(\"Takahashi\")\nelse:\n    print(\"Aoki\")\n</ans>", "format_properties": {}}
{"idx": 51, "result": 0, "generated": "<ans>\ndef main1():\n    buf = input()\n    buflist = buf.split()\n    print(\"n: \", str(n), \"M: \", str(M))\n    n = int(buflist[0])\n    M = int(buflist[1])\n    buf = input()\n    buflist = buf.split()\n    print(\"t: \", str(t))\n    t = list(map(int, buflist))\n    student = []\n    minimum = []\n    for i in range(n):\n        count = 0\n        pointer = 0\n        while pointer < i:\n            if count + student[pointer] <= M - t[i]:\n                count += student[pointer]\n                pointer += 1\n            else:\n                break\n        minimum.append(i - pointer)\n        student.append(t[i])\n        print(\"student: \", str(student))\n        student.sort()\n    print(' '.join(list(map(str, minimum))))\n\ndef main2():\n    buf = input()\n    buflist = buf.split()\n    print(\"n: \", str(n), \"M: \", str(M))\n    n = int(buflist[0])\n    M = int(buflist[1])\n    buf = input()\n    buflist = buf.split()\n    print(\"t: \", str(t))\n    t = list(map(int, buflist))\n    bucket = []\n    for i in range(101):\n        bucket.append(0)\n    print(\"bucket: \", str(bucket))\n    minimum = []\n    for i in range(n):\n        target = M - t[i]\n        count = 0\n        subtotal = 0\n        for j in range(1, 101):\n            if subtotal + bucket[j] * j > target:\n                count += (target - subtotal) // j\n                break\n            else:\n                count += bucket[j]\n                subtotal += bucket[j] * j\n        minimum.append(i - count)\n        bucket[t[i]] += 1\n        print(\"bucket: \", str(bucket))\n    print(' '.join(list(map(str, minimum))))\n\ndef __starting_point():\n    #main1() # for C1\n    main2() # for C2\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 47, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\n\nORDA = 97\nprint(\"ORDA: \", str(ORDA))\ndef ii(): return int(input())\nprint(\"ii: \", str(ii))\ndef mi(): return list(map(int, input().split()))\nprint(\"mi: \", str(mi))\ndef li(): return list(map(int, input().split()))\nprint(\"li: \", str(li))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\nprint(\"lcm: \", str(lcm))\ndef revn(n): return str(n)[::-1]\nprint(\"revn: \", str(revn))\ndef dd(): return collections.defaultdict(int)\nprint(\"dd: \", str(dd()))\ndef ddl(): return collections.defaultdict(list)\nprint(\"ddl: \", str(ddl()))\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\nprint(\"sieve: \", str(sieve))\ndef divs(n, start=2):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\nprint(\"divs: \", str(divs))\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\nprint(\"divn: \", str(divn))\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\nprint(\"prime: \", str(prime))\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\nprint(\"convn: \", str(convn))\ndef cdiv(n, k): return n // k + (n % k != 0)\nprint(\"cdiv: \", str(cdiv))\n\n\nfor _ in range(ii()):\n    print(\"ii: \", str(ii()))\n    n = ii()\n    print(\"n: \", str(n))\n    a = li()\n    print(\"a: \", str(a))\n    if n == 1 and a[0] & 1:\n        print(\"1: \", str(1))\n        print(\"-1: \", str(-1))\n    else:\n        for i in range(n):\n            print(\"i: \", str(i))\n            if a[i] % 2 == 0:\n                print(\"1: \", str(1))\n                print(i + 1)\n                break\n        else:\n            print(\"2: \", str(2))\n            print(\"1: \", str(1))\n            print(\"2: \", str(2))\n</ans>", "format_properties": {}}
{"idx": 53, "result": 0, "generated": "<ans>\n#template\nimport sys\nsys.setrecursionlimit(10**9)\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nread_int = lambda: int(readline())\nread_ints = lambda: map(int,readline().split())\nread_ints_list = lambda: list(map(int,readline().split()))\nread_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))\nread_strs_list = lambda: list(map(str,readline().rstrip().split()))\nread_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))\n\ndef read_allints_grid(w):\n    grid = map(int,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\ndef read_allstrs_grid(w):\n    grid = map(str,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\n#import\n# from copy import deepcopy\n# from decimal import Decimal\n# from math import ceil,floor\n# from collections import deque,Counter\n# from heapq import heapify,heappop,heappush\n# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement\n# from bisect import bisect_left,bisect_right\n\n#solution\ndef sol():\n    return None\ndef GCD(a:int,b:int)->int:\n    '''\n    \u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\u306b\u3088\u308b\u6700\u5927\u516c\u7d04\u6570/O(log min(a,b))\n    '''\n    if b==0:\n        return a\n    else:\n        return GCD(b,a%b)\n\ndef GCD_multi(vec:list)->int:\n    '''\n    \u6570\u5217\u306e\u8981\u7d20\u306e\u6700\u5927\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b/O(N log(a'))\n    '''\n    l = vec[0]\n    for i in range(len(vec)-1):\n        l = GCD(l,vec[i+1])\n        print(\"l: \", str(l))\n    return l\n\ndef main():\n    #input data\n    n = read_int()\n    print(\"n: \", str(n))\n    A = read_ints_list()\n    print(\"A: \", str(A))\n    #solve\n    print(GCD_multi(A))\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 52, "result": 0, "generated": "<ans>\nimport itertools\nfrom collections import deque,defaultdict,Counter\nfrom itertools import accumulate\nimport bisect\nfrom heapq import heappop,heappush,heapify\nimport math\nfrom copy import deepcopy\nimport queue\n#import numpy as np\n# sympy as syp(\u7d20\u56e0\u6570\u5206\u89e3\u3068\u304b)\nMod = 1000000007\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1] \nfor i in range(2, 10**5 + 1):\n    fact.append((fact[-1] * i) % Mod)\n    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)\n    factinv.append((factinv[-1] * inv[-1]) % Mod)\n    \nprint(\"Mod: \", str(Mod))\nprint(\"fact: \", str(fact))\nprint(\"factinv: \", str(factinv))\nprint(\"inv: \", str(inv))\n    \ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n - r] % p\n    \ndef sieve_of_eratosthenes(n):\n    if not isinstance(n,int):\n        raise TypeError(\"n is not int\")\n    if n<2:\n        raise ValueError(\"n is not effective\")\n    prime = [1]*(n+1)\n    for i in range(2,int(math.sqrt(n))+1):\n        if prime[i] == 1:\n            for j in range(2*i,n+1):\n                if j%i == 0:\n                    prime[j] = 0\n    res = []\n    for i in range(2,n+1):\n        if prime[i] == 1:\n            res.append(i)\n    return res\n\n \nclass UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n+1)]\n        self.rank = [0 for i in range(n+1)]\n        print(\"parent: \", str(self.parent))\n        print(\"rank: \", str(self.rank))\n    \n    def findroot(self,x):\n        if x == self.parent[x]:\n            return x\n        else:\n            y = self.parent[x]\n            y = self.findroot(self.parent[x])\n            return y\n    \n    def union(self,x,y):\n        px = self.findroot(x)\n        py = self.findroot(y)\n        if px < py:\n            self.parent[y] = px\n        else:\n            self.parent[px] = py\n        print(\"parent: \", str(self.parent))\n    \n    def same_group_or_no(self,x,y):\n        return self.findroot(x) == self.findroot(y)\ndef pow_k(x, n):\n\n    if n == 0:\n        return 1\n\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K *= x\n        x *= x\n        n //= 2\n\n    return K * x\ndef main():  #startline-------------------------------------------\n    n = int(input())\n    print(\"n: \", str(n))\n    a = list(map(int, input().split()))\n    print(\"a: \", str(a))\n    d = defaultdict(int)\n    print(\"d: \", str(d))\n    ans = 0\n    for i in range(n):\n        l = i - a[i]\n        ans += d[l]\n        d[a[i] + i] += 1\n        print(\"d: \", str(d))\n        \n    print(\"ans: \", str(ans))\ndef __starting_point():\n    main() #endline===============================================\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 46, "result": 0, "generated": "<ans>\n\"\"\"Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I\"\"\"\n# from fractions import Fraction\n\n\n# def convert_to_fractions(poly):\n#     \"\"\"convert polygon vertex to fractional type\"\"\"\n#     poly_frac = []\n#     for x, y, z in poly:\n#         vertex = (Fraction(x),\n#                   Fraction(y),\n#                   Fraction(z))\n#         poly_frac.append(vertex)\n#     return poly_frac\n\n\ndef convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    print(\"poly_float: \", str(poly_float))\n    return poly_float\n\n\ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n\n\ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n\ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n\n\ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n\n\ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n\n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n\n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n\n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n\n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n\n    return u_list\n\n\ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n\n\ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n\n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n\n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n\n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n\n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n\n\ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n\n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    b = convert_to_float(b)\n\n    a_norm = poly_normal(a)\n    b_norm = poly_normal(b)\n\n    common_dir = cross_product(a_norm, b_norm)\n    if not any(common_dir):\n        return False\n\n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n\n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n\n\ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n\n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n\n    b_len, = [int(num) for num in input().split()]\n\n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n\n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n\n\ndef __starting_point():\n    run_from_console()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 55, "result": 0, "generated": "<ans>\nH,W=map(int,input().split())\nprint(\"H: \", str(H), \"W: \", str(W))\nList = [list(input()) for i in range(H)]\nprint(\"List: \", str(List))\nres = \"Yes\"\nprint(\"res: \", str(res))\nflag = True\nprint(\"flag: \", str(flag))\n\ndef checkAround(ListX,i,j):\n  if i == 0 and j ==0:\n    if ListX[i+1][j] == \"#\" or ListX[i][j+1] == \"#\":\n      return True\n    else: \n      return False\n  elif i == 0 and j !=0 and j != W-1:\n    if ListX[i+1][j] == \"#\" or ListX[i][j-1] == \"#\" or ListX[i][j+1] == \"#\":\n      return True\n    else: \n      return False\n  elif i == 0 and j == W-1:\n    if ListX[i+1][j] == \"#\" or ListX[i][j-1] == \"#\":\n      return True\n    else: \n      return False\n  elif i != 0 and i != H-1 and j == 0:\n    if ListX[i+1][j] == \"#\" or ListX[i-1][j] == \"#\" or ListX[i][j+1] == \"#\":\n      return True\n    else: \n      return False\n  elif i == H-1 and j == W-1:\n    if ListX[i-1][j] == \"#\" or ListX[i][j-1] == \"#\":\n      return True\n    else: \n      return False\n  elif i == H-1 and j !=0 and j != W-1:\n    if ListX[i-1][j] == \"#\" or ListX[i][j+1] == \"#\" or ListX[i][j-1] == \"#\":\n      return True\n    else: \n      return False\n  elif i == H-1 and j == 0:\n    if ListX[i-1][j] == \"#\" or ListX[i][j-1] == \"#\":\n      return True\n    else: \n      return False\n  elif i != 0 and i != H-1 and j == W-1:\n    if ListX[i+1][j] == \"#\" or ListX[i-1][j] == \"#\" or ListX[i][j-1] == \"#\":\n      return True\n    else: \n      return False\n  else:\n    if ListX[i+1][j] == \"#\" or ListX[i-1][j] == \"#\" or ListX[i][j-1] == \"#\" or ListX[i][j+1] == \"#\":\n      return True\n    else: \n      return False\n\nfor k in range(H):\n  for l in range(W):\n    if List[k][l] == \".\":\n      pass\n    else:\n      flag = checkAround(List,k,l)\n      if not flag:\n        res = \"No\"\n        break\n  if not flag:\n    break\nprint(\"res: \", str(res))\n</ans>", "format_properties": {}}
{"idx": 54, "result": 0, "generated": "<ans>\n__author__ = \"Ryabchun Vladimir\"\n\n\nclass Stack:\n    \"\"\"\n    This is a stack class. There is 5 Procedures we can do with stack:\n    1. Push - we add one element at the end of the stack\n    2. Pop - we remove last element from the stack and return it\n    3. Last - We return last element but don't remove it\n    4. len() - returns the length of stack(we don't use len() because it's too\n    slow).\n    5. Clear - remove all elements from stack\n    \"\"\"\n    def __init__(self, element=None):\n        \"\"\"\n        self.length - length of the stack. When we append an element we increase it(length) by 1\n        __stack - this is our stack. Because we can't get any elements from the stack except the last one\n        we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,\n        but we mustn't do it).\n        :param element: Can be any type\n        \"\"\"\n        print(\"self, element: \", str(self), str(element))\n        self.length = 0\n        if element is None:\n            self.__stack = []\n        else:\n            self.__stack = []\n            for el in element:\n                self.__stack.append(el)\n                self.length += 1\n\n    def push(self, element):\n        \"\"\"\n        This function adds an element at the end of the stack.\n        When we append an element we increase self.length by 1.\n        :param element: Can be any type\n        :return: NoneType\n        \"\"\"\n        print(\"self, element: \", str(self), str(element))\n        self.__stack.append(element)\n        self.length += 1\n\n    def pop(self):\n        \"\"\"\n        This function removes an element from the end of the stack and\n        returns it's value.\n        When we append an element we decrease self.length by 1.\n        :return: Last element from the stack\n        \"\"\"\n        if self.length == 0:\n            raise IndexError(\"Stack is empty\")\n        else:\n            self.length -= 1\n            return self.__stack.pop()\n\n    def last(self):\n        \"\"\"\n        This function just returns an element from the end of the stack\n        but it doesn't remove it.\n        :return: Last element from the stack\n        \"\"\"\n        if self.length == 0:\n            raise IndexError(\"Stack is empty\")\n        else:\n            return self.__stack[-1]\n\n    def __len__(self):\n        \"\"\"\n        This function returns the length of the stack.\n        :return: self.length(int)\n        \"\"\"\n        return self.length\n\n    def clear(self):\n        \"\"\"\n        Clears the stack.\n        :return: NoneType\n        \"\"\"\n        print(\"self: \", str(self))\n        self.__stack = []\n\nn = int(input())\nsnekovik = Stack()\nprint(\"snekovik: \", str(snekovik))\nwrong_snaks = set()\nthe_biggest_snek = n\nsneks = list(map(int, input().split()))\nfor i in sneks:\n    printing = []\n    if i == the_biggest_snek:\n        snekovik.push(i)\n        printing.append(i)\n        the_biggest_snek -= 1\n        while the_biggest_snek in wrong_snaks:\n            snekovik.push(the_biggest_snek)\n            wrong_snaks.remove(the_biggest_snek)\n            printing.append(the_biggest_snek)\n            the_biggest_snek -= 1\n    else:\n        wrong_snaks.add(i)\n    print(*printing)\n</ans>", "format_properties": {}}
{"idx": 59, "result": 0, "generated": "<ans>\nimport sys\n\nMOD = (int)(1e9+7)\n\ndef add(a, b):\n\ta += b\n\tif a >= MOD: a -= MOD\n\treturn a\n\t\ndef mul(a, b):\n\treturn (a * b) % MOD\n\nclass fenwickTree:\n\tdef __init__(self, max_val):\n\t\tself.max_val = max_val + 5\n\t\tself.tree = [0] * self.max_val\n\t\n\tdef update(self, idx, value):\n\t\tidx += 1\n\t\tprint(\"tree: \", str(self.tree), \"idx: \", str(idx), \"value: \", str(value))\n\t\twhile idx < self.max_val:\n\t\t\tself.tree[idx] = add(self.tree[idx], value)\n\t\t\tidx += (idx & (-idx))\n\t\n\tdef read(self, idx):\n\t\tidx += 1\n\t\tprint(\"tree: \", str(self.tree), \"idx: \", str(idx))\n\t\tres = 0\n\t\twhile idx > 0:\n\t\t\tres = add(res, self.tree[idx])\n\t\t\tidx -= (idx & (-idx))\n\t\treturn res\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn = inp[0]\nprint(\"n: \", str(n))\na = []\nfor i in range(1, n + 1):\n\ta.append(inp[i])\n\tprint(\"a: \", str(a))\n\t\nsorted_array = sorted(a)\nprint(\"sorted_array: \", str(sorted_array))\ndict = {}\nfor i in range(n):\n\tdict[sorted_array[i]] = i\n\tprint(\"dict: \", str(dict))\n\t\nfactor = [0] * n\nfor i in range(0, n):\n\tfactor[i] = mul(i + 1, n - i)\n\tprint(\"factor: \", str(factor))\n\t\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n\tleft_tree.update(element_idx, i + 1)\n\tprint(\"factor: \", str(factor))\n\t\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n\tright_tree.update(element_idx, n - i)\n\tprint(\"factor: \", str(factor))\n\nans = 0\nfor i in range(n):\n\tans = add(ans, mul(a[i], factor[i]))\nprint(\"ans: \", str(ans))\nprint(\"factor: \", str(factor))\nprint(\"a: \", str(a))\n</ans>", "format_properties": {}}
{"idx": 60, "result": 0, "generated": "<ans>\nimport sys \ninput = lambda: sys.stdin.readline().strip()\n\ndef f(A, r, c, l):\n  print(\"l, r, c: \", str(l), str(r), str(c))\n  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]\n  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]\n\n  #print(r, c, x,y,z,l, q,w,e)\n  if x != y and y != z and e >= l and  w == q == l:\n    return (l, z, y, x)\n  else:\n    return 0\n  \n  \n\n\n\nr, c = list(map(int, input().split()))\nprint(\"r, c: \", str(r), str(c))\ns = \"\"\nfor i in range(r):\n  s += input()\n\narr = []\nnarr = [[0]*r for i in range(c)]\nprint(\"arr: \", str(arr))\nprint(\"narr: \", str(narr))\nfor i in range(c):\n  arr.append(s[i:r*c:c])\n\nr, c = c, r \n\nlength_str = [ [0] * c for i in range(r) ]\nprint(\"length_str: \", str(length_str))\nfor i in range(r):\n  for j in range(c):\n    if j == 0:\n      length_str[i][j] = (1, arr[i][j])\n    elif arr[i][j-1] == arr[i][j]:\n      length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])\n    else:\n      length_str[i][j] = (1, arr[i][j])\n\nfor i in range(r):\n  for j in range(c):\n    l, _ = length_str[i][j] \n    if j - l*3 + 1 < 0:\n      continue \n    else:\n      narr[i][j] = f(length_str, i, j, l)\n      \n\n\n\n\n#for i in narr:\n#  print(i)\n\ndp =[ [0] * c for i in range(r) ]\nprint(\"dp: \", str(dp))\nfor j in range(c):\n  cnt = 1\n  for i in range(r):\n    if narr[i][j] == 0:\n      cnt = 1\n      continue \n    else:\n      if i == 0:\n        dp[i][j] = 1\n\n      elif narr[i][j] == narr[i-1][j]:\n        cnt += 1\n        dp[i][j] = cnt\n        dp[i-1][j] = 0\n\n      else:\n        cnt = 1\n        dp[i][j] = 1 \n\nans = 0\nfor i in dp:\n  for j in i:\n    ans += ((j)*(j+1))//2\n\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 58, "result": 0, "generated": "<ans>\nimport sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nclass UnionFind:\n\n    def __init__(self, n: int):\n        self._n = n\n        self._parents = [i for i in range(n)]\n        self._size = [1 for _ in range(n)]\n        print(\"n: \", str(n), \"_parents: \", str(self._parents), \"_size: \", str(self._size))\n\n    def unite(self, x: int, y: int) -> None:\n        px = self.find(x)\n        py = self.find(y)\n        print(\"px: \", str(px), \"py: \", str(py))\n        # \u4e00\u81f4\u3057\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u30ea\u30f3\u30af\u3092\u3064\u3051\u308b\n        if px != py:\n            self._link(px, py)\n\n    def _link(self, x: int, y: int):\n        if self._size[x] < self._size[y]:\n            self._parents[x] = y\n            self._size[y] += self._size[x]\n        else:\n            self._parents[y] = x\n            self._size[x] += self._size[y]\n\n    def same(self, x: int, y: int) -> bool:\n        px = self.find(x)\n        py = self.find(y)\n        print(\"px: \", str(px), \"py: \", str(py))\n        return px == py\n\n    def find(self, x: int) -> int:\n        if self._parents[x] == x:\n            return x\n\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x: int):\n        return self._size[self.find(self._parents[x])]\n        print(\"self._size[self.find(self._parents[x])]: \", str(self._size[self.find(self._parents[x])]))\n\nN, K, L = map(int, input().split())\nprint(\"N: \", str(N), \"K: \", str(K), \"L: \", str(L))\n\nroad = UnionFind(N + 1)\nprint(\"road: \", str(road))\nrail = UnionFind(N + 1)\nprint(\"rail: \", str(rail))\nshare = UnionFind(N + 1)\nprint(\"share: \", str(share))\n\nroads = [list(map(int, input().split())) for _ in range(K)]\nprint(\"roads: \", str(roads))\nrails = [list(map(int, input().split())) for _ in range(L)]\nprint(\"rails: \", str(rails))\n\nfor i in range(K):\n    p, q = roads[i]\n    print(\"p: \", str(p), \"q: \", str(q))\n    road.unite(p, q)\n\nfor i in range(L):\n    r, s = rails[i]\n    print(\"r: \", str(r), \"s: \", str(s))\n    rail.unite(r, s)\n\nm = {}\n\nfor i in range(1, N + 1):\n    cnt = m.get((road.find(i), rail.find(i)), 0)\n    m[(road.find(i), rail.find(i))] = cnt + 1\n    print(\"i: \", str(i), \"cnt: \", str(cnt), \"m: \", str(m))\n\nans = [0] * N\nfor i in range(N):\n    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]\n    print(\"i: \", str(i), \"ans[i]: \", str(ans[i]), \"m: \", str(m))\n\nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 56, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import defaultdict\n\nclass MaxFlow(object):\n    def __init__(self):\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\n        print(\"edges: \", str(self.edges))\n\n    def add_edge(self, u, v, capacity=float('inf')):\n        self.edges[u][v] = capacity\n        print(\"u: \", str(u), \"v: \", str(v), \"capacity: \", str(capacity))\n\n    def bfs(self, s, t):\n        open_q = [s]\n\n        visited = set()\n        parent = dict()\n        while open_q:\n            close_q = []\n            for node in open_q:\n                for v, capacity in list(self.edges[node].items()):\n                    if v not in visited and capacity > 0:\n                        close_q.append(v)\n                        parent[v] = node\n                        visited.add(v)\n                        if v == t:\n                            result = []\n                            n2 = v\n                            n1 = node\n                            while n1 != s:\n                                result.append((n1, n2))\n                                n2 = n1\n                                n1 = parent[n1]\n                            result.append((n1, n2))\n                            return result\n\n            open_q = close_q\n\n        return None\n\n    def solve(self, s, t):\n        flow = 0\n        route = self.bfs(s, t)\n        while route is not None:\n            new_flow = float('inf')\n            for _, (n1, n2) in enumerate(route):\n                new_flow = min(new_flow, self.edges[n1][n2])\n            for _, (n1, n2) in enumerate(route):\n                self.edges[n1][n2] -= new_flow\n                self.edges[n2][n1] += new_flow\n            flow += new_flow\n\n            route = self.bfs(s, t)\n\n        return flow\n\n    def __str__(self):\n        result = \"{ \"\n        for k, v in list(self.edges.items()):\n            result += str(k) + \":\" + str(dict(v)) + \", \"\n        result += \"}\"\n        return result\n\n\ndef main():\n    (n, m) = tuple([int(x) for x in input().split()])\n    r = []\n    xs = set()\n    ys = set()\n    for i in range(m):\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\n        r.append((x1, y1, x2, y2))\n        xs.add(x1)\n        xs.add(x2 + 1)\n        ys.add(y1)\n        ys.add(y2 + 1)\n\n    xx = sorted(xs)\n    yy = sorted(ys)\n    xsize = len(xs)\n    ysize = len(ys)\n    grid = []\n    for i in range(ysize):\n        grid.append([False] * xsize)\n\n    for rect in r:\n        x1 = rect[0]\n        y1 = rect[1]\n        x2 = rect[2]\n        y2 = rect[3]\n        for i, y in enumerate(yy):\n            for j, x in enumerate(xx):\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\n                    grid[i][j] = True\n\n    f = MaxFlow()\n    for i in range(len(yy)):\n        for j in range(len(xx)):\n            if grid[i][j]:\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\n    for i in range(len(yy) - 1):\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\n    for i in range(len(xx) - 1):\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\n\n    # print(xx)\n    # print(yy)\n    # print(f)\n    print(f.solve(0, len(xx) + len(yy) + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 62, "result": 0, "generated": "<ans>\ndef _3():\n    from collections import defaultdict\n\n    def can_pair(s1, s2):\n        l = []\n        for c1, c2 in zip(s1, s2):\n            c = sorted([c1, c2])\n            if c in l:\n                l.remove(c)\n            else:\n                l.append(c)\n\n        if len(s1) % 2 == 0:\n            return len(l) == 0\n        else:\n            return len(l) == 1 and l[0][0] == l[0][1]\n\n    def pair_graph(s1, s2):\n        N = len(s1)\n        G = np.zeros([N, N])\n        for i in range(N):\n            for j in range(i+1, N):\n                if s1[i] == s2[j] and s1[j] == s2[i]:\n                    G[i, j] = 1\n                    G[j, i] = 1\n        return G\n\n    import numpy as np\n    H, W = list(map(int, input().split(' ')))\n    print(\"H: \", str(H), \"W: \", str(W))\n    S = []\n    d = defaultdict(list)\n\n    for h in range(H):\n        s = input()\n        S.append(s)\n        print(\"s: \", str(s))\n        d[''.join(sorted(S))].append(h)\n\n    already_paired = np.zeros(H)\n\n    Gs = []\n\n    for i in range(H):\n        if already_paired[i]:\n            continue\n\n        for j in range(i+1, H):\n            if already_paired[j]:\n                continue\n\n            if can_pair(S[i], S[j]):\n                already_paired[i] = 1\n                already_paired[j] = 1\n                G = pair_graph(S[i], S[j])\n                Gs.append(G)\n                print(\"G: \", str(G))\n                break\n\n    if already_paired.sum() < H - 1:\n        print('NO')\n        return\n\n    elif already_paired.sum() == H - 1:\n        for i in range(H):\n            if already_paired[i] == 0:\n                G = pair_graph(S[i], S[i])\n                Gs.append(G)\n                print(\"G: \", str(G))\n                break\n\n    G = np.array(Gs).sum(axis=0) // len(Gs)\n\n    def is_perfect_matching(G):\n        N = len(G)\n        if N == 1:\n            return True\n\n        for i in range(N):\n            for j in range(i+1, N):\n                if G[i, j] == 1:\n                    l = list(range(N))\n                    l.remove(i)\n                    l.remove(j)\n                    if len(l) == 0:\n                        return True\n                    if is_perfect_matching(G[l][:, l]):\n                        return True\n        return False\n\n    if is_perfect_matching(G):\n        print('YES')\n    else:\n        print('NO')\n\ndef __starting_point():\n    _3()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 57, "result": 0, "generated": "<ans>\n\"\"\"\n#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\n\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\nMOD = 10**9+7\n\n\n\"\"\"\nEach edge goes from parent U to child V\nEdge appears on S_V * (N - S_V) paths\n\nFor each path of length L, (L + (-L)%K)/K\n\n\nL%K 0, 1, 2, 3, 4\n(K - L%K)%K K K-1 K-2 ...\n0 K-1 K-2 ...\n\n\"\"\"\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef solve():\n    N, K = getInts()\n    print(\"N: \", str(N), \"K: \", str(K))\n    graph = dd(set)\n    for i in range(N-1):\n        A, B = getInts()\n        print(\"A: \", str(A), \"B: \", str(B))\n        graph[A].add(B)\n        graph[B].add(A)\n    dp_count = [[0 for j in range(5)] for i in range(N+1)]\n    dp_total = [0 for j in range(N+1)]\n    nonlocal ans\n    ans = 0\n    @bootstrap\n    def dfs(node,parent,depth):\n        nonlocal ans\n        dp_count[node][depth % K] = 1\n        dp_total[node] = 1\n        for neigh in graph[node]:\n            if neigh != parent:\n                yield dfs(neigh,node,depth+1)\n                for i in range(K):\n                    for j in range(K):\n                        diff = (i+j-2*depth)%K\n                        req = (-diff)%K\n                        ans += req * dp_count[node][i] * dp_count[neigh][j]\n                for i in range(K):\n                    dp_count[node][i] += dp_count[neigh][i]\n                dp_total[node] += dp_total[neigh]\n        ans += dp_total[node] * (N - dp_total[node])\n        yield\n    dfs(1,-1,0)\n    return ans//K\n    \n    \nprint(solve())\n</ans>", "format_properties": {}}
{"idx": 61, "result": 0, "generated": "<ans>\nfrom random import random\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 6)\n\n\nclass TreapNode:\n    _value = None\n    _priority = None\n    _count = None\n    _left = None\n    _right = None\n\n    def __init__(self, value):\n        self._value = value\n        self._priority = random()\n        self._count = 1\n        print(\"value: \", str(value), \"priority: \", str(self._priority), \"count: \", str(self._count))\n\n\ndef treap_rotate_right(n):\n    l = n._left\n    n._left = l._right\n    l._right = n\n    return l\n\n\ndef treap_rotate_left(n):\n    r = n._right\n    n._right = r._left\n    r._left = n\n    return r\n\n\ndef treap_insert(n, v):\n    if n is None:\n        return TreapNode(v)\n    if n._value == v:\n        n._count += 1\n        return n\n    if n._value > v:\n        n._left = treap_insert(n._left, v)\n        if n._priority > n._left._priority:\n            n = treap_rotate_right(n)\n    else:\n        n._right = treap_insert(n._right, v)\n        if n._priority > n._right._priority:\n            n = treap_rotate_left(n)\n    return n\n\n\ndef treap_delete(n, v):\n    if n is None:\n        raise Exception('no nodes')\n    if n._value > v:\n        n._left = treap_delete(n._left, v)\n        return n\n    if n._value < v:\n        n._right = treap_delete(n._right, v)\n        return n\n\n    # n._value == v\n    if n._count > 1:\n        n._count -= 1\n        return n\n\n    if n._left is None and n._right is None:\n        return None\n\n    if n._left is None:\n        n = treap_rotate_left(n)\n    elif n._right is None:\n        n = treap_rotate_right(n)\n    else:\n        # n._left is not None and n._right is not None\n        if n._left._priority < n._right._priority:\n            n = treap_rotate_right(n)\n        else:\n            n = treap_rotate_left(n)\n    return treap_delete(n, v)\n\n\ndef treap_size(n):\n    if n is None:\n        return 0\n    return n._count + treap_size(n._left) + treap_size(n._right)\n\n\ndef treap_str(n):\n    if n is None:\n        return \"\"\n    result = []\n    if n._left is not None:\n        result.append(treap_str(n._left))\n    result.append(\"%d:%d\" % (n._value, n._count))\n    if n._right is not None:\n        result.append(treap_str(n._right))\n    return ' '.join(result)\n\n\ndef treap_search(n, v):\n    # v \u672a\u6e80\u3067\u6700\u5927\u306e\u30ce\u30fc\u30c9\u3092\u691c\u7d22\u3059\u308b. v \u672a\u6e80\u306e\u30ce\u30fc\u30c9\u304c\u306a\u3051\u308c\u3070 None \u3092\u8fd4\u3059\n    if n is None:\n        return None\n    if n._value >= v:\n        if n._left is None:\n            return None\n        return treap_search(n._left, v)\n    # n._value < v\n    if n._right is None:\n        return n\n    r = treap_search(n._right, v)\n    if r is None:\n        return n\n    return r\n\n\nclass Treap:\n    _root = None\n    _size = 0\n\n    def insert(self, v):\n        self._root = treap_insert(self._root, v)\n        self._size += 1\n\n    def delete(self, v):\n        self._root = treap_delete(self._root, v)\n        self._size -= 1\n\n    def __len__(self):\n        return self._size\n\n    def __str__(self):\n        return treap_str(self._root)\n\n    def search(self, v):\n        return treap_search(self._root, v)\n\n\nN = int(input())\nprint(\"N: \", str(N))\nA = [int(input()) for _ in range(N)]\nprint(\"A: \", str(A))\nt = Treap()\nfor a in A:\n    n = t.search(a)\n    if n is not None:\n        print(\"delete: \", str(a))\n        t.delete(n._value)\n    print(\"insert: \", str(a))\n    t.insert(a)\nprint((len(t)))\n</ans>", "format_properties": {}}
{"idx": 21, "result": 0, "generated": "<ans>\nimport math\nimport bisect\nimport itertools\nimport sys\nI=lambda : sys.stdin.readline()\nmod=10**9 +7\n'''fact=[1]*100001\nifact=[1]*100001\nfor i in range(1,100001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n    \ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\n    \ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2   \n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n    \ndef is_prime(num):\n    if num == 1: return False\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n    \n  \ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n    \ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s    \n    \ndef modu(a,n):\n    if a%n==0:\n        return n\n    return a%n\n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfor i in range(1):\n    n,k=map(int,input().split())\n    print(\"n: \", str(n), \"k: \", str(k))\n    a=list(map(int,input().split()))\n    print(\"a: \", str(a))\n    s=input()\n    print(\"s: \", str(s))\n    c=1;b=[]\n    for i in range(1,n):\n        if s[i-1]==s[i]:\n            c+=1\n            f=True\n        else:\n            b.append(c)\n            c=1\n            f=False\n    if True:\n        b.append(c)\n    #print(b) \n    ans=0\n    su=0\n    for i in b:\n        c=a[su:min(su+i,10**9)]\n        print(\"c: \", str(c))\n        c.sort(reverse=True)\n        c=c[:min(i,k)]\n        su+=i\n        ans+=sum(c)\n        \n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \", str(a))\n    print(\"s: \", str(s))\n    print(\"n: \", str(n))\n    print(\"k: \", str(k))\n    print(\"c: \", str(c))\n    print(\"ans: \", str(ans))\n    print(\"su: \", str(su))\n    print(\"b: \", str(b))\n    print(\"a: \",", "format_properties": {}}
{"idx": 63, "result": 0, "generated": "<ans>\nimport sys\nreadline = sys.stdin.readline\n\ndef accumulate2d(X):\n    N = len(X)\n    M = len(X[0])\n    \n    for i in range(0, N):\n        for j in range(1, M):\n            X[i][j] += X[i][j-1]\n    \n    for j in range(0, M):\n        for i in range(1, N):\n            X[i][j] += X[i-1][j]\n    \n    return X\n\nN, M, Q = map(int, readline().split())\nprint(\"N: \", str(N), \"M: \", str(M), \"Q: \", str(Q))\ntable = [None]*100\ntable[ord('R')] = 0\ntable[ord('G')] = 1\ntable[ord('B')] = 2\ntable[ord('Y')] = 3\nprint(\"table: \", str(table))\nINF = 10**3\nD = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]\nprint(\"D: \", str(D))\nG = [[0]*M for _ in range(N)]\nprint(\"G: \", str(G))\nBS = 25\ncandi = []\ngeta = M\nfor i in range(N-1):\n    for j in range(M-1):\n        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:\n            G[i][j] = 1\n            nh, nw = i, j\n            while True:\n                k = G[nh][nw]\n                fh, fw = nh-k, nw-k\n                k2 = 2*(k+1)\n                kh = k+1\n                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:\n                    break\n                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\\\n                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\\\n                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\\\n                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\\\n                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\\\n                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\\\n                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\\\n                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):\n                    break\n                G[nh][nw] += 1\n            if G[nh][nw] > BS:\n                candi.append((nh, nw))\n\n \nGnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]\nfor h in range(N):\n    for w in range(M):\n        if G[h][w] > 0:\n            for k in range(1, min(BS, G[h][w])+1):\n                Gnum[k][h][w] = 1\nprint(\"Gnum: \", str(Gnum))\nGnum = [None] + [accumulate2d(g) for g in Gnum[1:]]\nprint(\"Gnum: \", str(Gnum))\n\nAns = [None]*Q\nfor qu in range(Q):\n    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())\n    print(\"h1: \", str(h1), \"w1: \", str(w1), \"h2: \", str(h2), \"w2: \", str(w2))\n    res = 0\n    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):\n        hs, ws = h1+k-1, w1+k-1\n        he, we = h2-k, w2-k\n        if hs <= he and ws <= we:\n            cnt = Gnum[k][he][we]\n            if hs:\n                cnt -= Gnum[k][hs-1][we]\n            if ws:\n                cnt -= Gnum[k][he][ws-1]\n            if hs and ws:\n                cnt += Gnum[k][hs-1][ws-1]\n            if cnt:\n                res = k\n                break\n    \n    for nh, nw in candi:\n        if h1 <= nh <= h2 and w1 <= nw <= w2:\n            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))\n    Ans[qu] = 4*res**2\nprint(' '.join(map(str, Ans)))\n</ans>", "format_properties": {}}
{"idx": 71, "result": 0, "generated": "<ans>\nimport math\nimport bisect\nimport sys\n\nprint(\"q: \", str(q))\npc= c1(1e18+1)\nprint(\"pc: \", str(pc))\npca=list(pc)\npca.sort()\nprint(\"pca: \", str(pca))\n\ndef flrt(exp,x):\n    l=max(0,math.floor(x**(1/exp))-3)\n    \n    r= math.floor(x**(1/exp))+3\n    while l<r:\n        mid=(l+r)//2\n        if mid**exp<=x:\n            l=mid+1\n        else: \n            r=mid\n    return l-1\n   \n    \ndef c1(r):\n    ans=set()\n    pr = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    for i in pr:\n        x=2\n        while x**i <= r:\n            val=x**i\n            b2=flrt(2,val)\n            b3=flrt(3,val)\n            if b2**2 != val and b3**3 != val:\n                ans.add(val)\n            x+=1\n    return ans\n    \ndef solve(r, pc):\n    if r==0:\n        return 0\n    \n    a=[2,3]\n    ans=0\n    for i in range(1,2**len(a)):\n        tot=0\n        mult=1\n        for j,x in enumerate(a):\n            if i&(1<<j):\n                mult*=x\n                tot+=1\n        d=  flrt(mult,r)      \n        ans+= d if tot%2 else -d\n        \n    return ans + bisect.bisect_right(pc,r)    \n       \n    lp=0 \n    rp=len(pc)\n    while lp<rp:\n        mid = (lp+rp)//2\n        if pc[mid] <= r:\n            lp = mid+1\n        else:\n            rp = mid\n        \n    \n    return ans + lp\nfor i in range(q):\n    l,r = [int(x) for x in sys.stdin.readline().split()]\n    print(\"l: \", str(l), \"r: \", str(r))\n    ans=solve(r,pca)-solve(l-1,pca)\n    sys.stdout.write(str(ans)+'\\n')\n</ans>", "format_properties": {}}
{"idx": 69, "result": 0, "generated": "<ans>\nfrom collections import deque\nimport math\n    \ndef dfs(edges, s):\n    stack = deque([s])\n    used  = {s}\n    print(\"stack: \", str(stack), \"used: \", str(used))\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y not in used:\n                used.add(y)\n                stack.append(y)\n    return used\n\n\ndef bfs(edges, s):\n    queue = deque([s])\n    used  = {s}\n    print(\"queue: \", str(queue), \"used: \", str(used))\n    while queue:\n        x = queue.popleft()\n        for y in edges[x]:\n            if y in used:\n                continue\n            used.add(y)\n            queue.append(y)\n    return used\n    \n\ndef bellman(dist):  #\u8ca0\u8fba\u304c\u3042\u308b\u30b1\u30fc\u30b9\u3067\u306e\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\u30a2\u30eb\u30b4\u3002\n    cost = [float(\"inf\")] * n\n    cost[0] = 0\n    for _ in range(n): #\u9802\u70b9\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n        updated = False\n        for u,v,c in dist: #\u8fba\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n            if cost[u] + c < cost[v]:\n                cost[v] = cost[u] + c\n                updated = True                \n    #\u53ce\u675f\u3057\u306a\u3044\u5834\u5408\u306f\u8ca0\u9589\u8def\u304c\u3042\u308b\u305f\u3081\u7121\u9650\u306b\u5c0f\u3055\u304f\u3067\u304d\u308b\u3002\n    if updated==True:\n        return -1\n    else:\n        return max(0, cost[n-1]*-1)    \n        \n\nn,m,p = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m), \"p: \", str(p))\ndist  = []\nedge1 = [[] for _ in range(n)]\nedge2 = [[] for _ in range(n)]  # rev_edge\nfor _ in range(m):\n    u,v,c = map(int, input().split())\n    u -= 1\n    v -= 1\n    dist.append((u,v,(c-p)*-1))\n    edge1[u].append(v)\n    edge2[v].append(u)    \n    print(\"u: \", str(u), \"v: \", str(v), \"c: \", str(c))\n    \nuse = dfs(edge1, 0) & dfs(edge2, n-1)\nprint(\"use: \", str(use))\ndist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]\nprint(\"dist2: \", str(dist2))\nprint(bellman(dist2))\n</ans>", "format_properties": {}}
{"idx": 72, "result": 0, "generated": "<ans>\n'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd \nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input()\ndef mi():return list(map(int,input().split()))\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\n\n\n\n\ndef solve():\n    \n    n,m,w=mi()\n    print(\"n: \", str(n), \"m: \", str(m), \"w: \", str(w))\n    a=li()\n    print(\"a: \", str(a))\n    def fessible(mid):\n        \n        b=[0]*n\n        moves=0\n        if(a[0]<mid):\n            b[0]+=(mid-a[0])\n            if(w<n):\n                b[w]-=(mid-a[0])\n            moves+=(mid-a[0])\n            if(moves>m):\n                return 0\n        for i in range(1,n):\n            b[i]+=b[i-1]\n            x=a[i]+b[i]\n            if(x<mid):\n                b[i]+=(mid-x)\n                if(i+w<n):\n                    b[i+w]-=(mid-x)\n                moves+=(mid-x)\n            if(moves>m):\n                return 0\n        return 1\n            \n        \n    \n    l=1\n    r=1e10\n    while(l<=r):\n        mid=l+(r-l)//2\n        if(fessible(mid)):\n            l=mid+1\n            ans=mid\n        else:\n            r=mid-1\n    print(int(ans))\n        \n    \n    \n    \n        \n        \n        \n        \ndef __starting_point():\n    solve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 65, "result": 0, "generated": "<ans>\na = list(map(int,input().split()))\nprint(\"a: \", str(a))\nb = [0,0,0,0,0];\nprint(\"b: \", str(b))\nc = [0,0,0,0,0];\nprint(\"c: \", str(c))\nipt = [];\nprint(\"ipt: \", str(ipt))\nans = [];\nprint(\"ans: \", str(ans))\nd = {\"S\" : 0,\"M\" : 1, \"L\" : 2, \"XL\" : 3, \"XXL\" : 4, \"XXXL\" : 5}\nprint(\"d: \", str(d))\nn = int(input())\nprint(\"n: \", str(n))\n\nfor i in range(1,n+1) :\n    j = input()\n    print(\"j: \", str(j))\n    ipt.append(j)\n    print(\"ipt: \", str(ipt))\n    ans.append(j)\n    print(\"ans: \", str(ans))\n    if j.find(',') == -1 :\n        a[d[j]] -= 1\n        print(\"a: \", str(a))\n    else :\n        b[d[j[0:j.find(',')]]] += 1\n        print(\"b: \", str(b))\n\nans = False;\n\nfor i in range(0,6) :\n    if (a[i] < 0) and ans == False:\n        ans = True\n    elif i < 5:\n        if i==0 :\n            if b[i] > a[i] :\n                c[i] = b[i] - a[i];\n                b[i] -= a[i];\n                a[i] = 0;\n                print(\"b: \", str(b))\n                print(\"c: \", str(c))\n                print(\"a: \", str(a))\n            else :\n                c[i] = 0;\n                a[i] -= b[i];\n                b[i] = 0;\n                print(\"b: \", str(b))\n                print(\"c: \", str(c))\n                print(\"a: \", str(a))\n                \n        else :\n            if b[i-1] > 0 :\n                if b[i-1] > a[i] :\n                    ans = True\n                else :\n                    a[i] -= b[i-1];\n                    print(\"a: \", str(a))\n            if b[i] > a[i] :\n                c[i] = b[i] - a[i];\n                b[i] -= a[i];\n                a[i] = 0;\n                print(\"b: \", str(b))\n                print(\"c: \", str(c))\n                print(\"a: \", str(a))\n            else :\n                c[i] = 0;\n                a[i] -= b[i];\n                b[i] = 0;\n                print(\"b: \", str(b))\n                print(\"c: \", str(c))\n                print(\"a: \", str(a))\n    elif i==5 :\n        if a[i] < b[i-1]:\n            ans = True\n                \nif ans == True :\n    print(\"NO\");\n\nelse :\n    print(\"YES\")\n    for i in ipt :\n        if i.find(',') == -1 :\n            print(i)\n        else :\n            tmp = i[0:i.find(',')];\n            if (c[d[tmp]] > 0) :\n                print(i[i.find(',')+1:])\n                c[d[tmp]] -= 1\n                print(\"c: \", str(c))\n            else :\n                print(tmp)\n</ans>", "format_properties": {}}
{"idx": 66, "result": 0, "generated": "<ans>\nn, m = list(map(int, input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nA = list(map(int, input().split()))\nprint(\"A: \", str(A))\nif n > 300:\n    lst = []\n    print(\"lst: \", str(lst))\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n        print(\"lst: \", str(lst))\n    answer = 0\n    answer_1 = []\n    print(\"answer: \", str(answer), \"answer_1: \", str(answer_1))\n    m300 = [[-1, -10**6]]\n    print(\"m300: \", str(m300))\n    for i in range(max(0, m-1)):\n        m300.append([-1, -10**6])\n        print(\"m300: \", str(m300))\n    for u in range(n):\n        if A[u] > min(m300)[1]:\n            m300[m300.index(min(m300))] = [u, A[u]]\n            print(\"m300: \", str(m300))\n    for i, mi in m300:\n        B = A.copy()\n        print(\"B: \", str(B))\n        kek = []\n        print(\"kek: \", str(kek))\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                print(\"kek: \", str(kek))\n                for q in range(a - 1, b):\n                    B[q] -= 1\n                    print(\"B: \", str(B))\n        elem = max(B)\n        if answer < elem - mi:\n            answer = elem - mi\n            answer_1 = kek.copy()\n            print(\"answer: \", str(answer), \"answer_1: \", str(answer_1))\n    print(answer)\n    print(len(answer_1))\n    print(' '.join(map(str, answer_1)))\nelse:\n    lst = []\n    print(\"lst: \", str(lst))\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n        print(\"lst: \", str(lst))\n    answer = 0\n    answer_1 = []\n    print(\"answer: \", str(answer), \"answer_1: \", str(answer_1))\n    for i in range(n):\n        B = A.copy()\n        print(\"B: \", str(B))\n        kek = []\n        print(\"kek: \", str(kek))\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                print(\"kek: \", str(kek))\n                for q in range(a - 1, b):\n                    B[q] -= 1\n                    print(\"B: \", str(B))\n        elem = max(B)\n        if answer < elem - B[i]:\n            answer = elem - B[i]\n            answer_1 = kek.copy()\n            print(\"answer: \", str(answer), \"answer_1: \", str(answer_1))\n    print(answer)\n    print(len(answer_1))\n    print(' '.join(map(str, answer_1)))\n</ans>", "format_properties": {}}
{"idx": 64, "result": 0, "generated": "<ans>\n# problem http://codeforces.com/contest/1100/problem/E\nimport copy\nimport sys\n\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        print(\"visited: \", str(visited), \"path: \", str(path))\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        print(\"visited: \", str(visited), \"path: \", str(path))\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in list(w.items()):\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines): #range(1, m + 1):\n        u, v, c = list(map(int, line.split()))\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in list(w.keys()):\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in list(w_tmp.keys()):\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n        # c_m = max(c, c_m)\n\n    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        return\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) / 2)\n            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))\n\n\n\n\n\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 70, "result": 0, "generated": "<ans>\nimport math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        print(\"Nodes: \", str(Nodes), \"is_directed: \", str(is_directed))\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n \n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        print(\"u: \", str(u), \"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n    \n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n\n#####swap function#####\ndef swap(a,b):\n    temp=a\n    a=b\n    b=temp\n    return a,b\n\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n\n#####all the prime factors of a number#####\ndef factors(n):\n    d={}\n    while(n%2==0):\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n        n/=2\n    for i in range(3,int(n**0.5)+1,2):\n        while(n%i==0):\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n            n/=i\n    n=int(n)\n    if n>1:\n        d[n]=1\n    return d\n\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    return (a*b)//gcd(a,b)\n\n#####function that return all the letters#####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n\n#####quadratic roots#####\ndef qdrt(a,b,c):\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####permutations#####\ndef permutation(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(n-r+1,n+1):\n        ans*=i\n    return ans\n\n#####combinations#####\ndef combination(n,r):\n    if n<r:\n        return 0\n    ans=1\n    for i in range(r):\n        ans*=(n-i)\n    div=1\n    for i in range(2,r+1):\n        div*=i\n    return ans//div\n        \n#####taking an array/list as input#####\ndef arinp():\n    ls=list(map(int,input().split()))\n    return ls\n\n#####taking multiple inputs#####\ndef mult_inp():\n    return list(map(int,input().split()))\n\n#####Main function starts from here#####\ndef main():\n    n,m=mult_inp()\n    print((combination(n,2)+combination(m,2)))\ndef __starting_point():\n    main()\n    \n\n    \n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 67, "result": 0, "generated": "<ans>\nimport math\nprint(\"import math: \", str(math))\nimport sys\nprint(\"import sys: \", str(sys))\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        print(\"Nodes: \", str(Nodes), \"is_directed: \", str(is_directed))\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        print(\"u: \", str(u), \"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    print(\"n: \", str(n))\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n#####swap function#####\ndef swap(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    temp=a\n    a=b\n    b=temp\n    return a,b\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    print(\"n: \", str(n))\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    if b==0:\n        return a\n    return gcd(b,a%b)\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    return (a*b)//gcd(a,b)\n#####function that return all the letters#####\ndef alphabates():\n    print(\"returning all the letters\")\n    return \"abcdefghijklmnopqrstuvwxyz\"\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    print(\"ls: \", str(ls), \"n: \", str(n), \"flag: \", str(flag))\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n#####quadratic#####\ndef qdrt(a,b,c):\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####taking an array/list as input#####\ndef inp():\n    print(\"taking an array/list as input\")\n    ls=list(map(int,input().split()))\n    return ls\n#####taking multiple inputs#####\ndef mult_inp():\n    print(\"taking multiple inputs\")\n    return list(map(int,input().split()))\n#####Main function starts from here#####\nn=int(input())\nprint(\"n: \", str(n))\nd={}\nwhile(n%2==0):\n    if 2 in d:\n        d[2]+=1\n    else:\n        d[2]=1\n    n/=2\nfor i in range(3,int(n**0.5)+1,2):\n    while(n%i==0):\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\n        n/=i\nn=int(n)\nif n>1:\n    d[n]=1\nn=1\nprint(\"d: \", str(d), \"n: \", str(n))\nans=0\nfor i in d:\n    c=-2*d[i]\n    a=b=1\n    ls=qdrt(a,b,c)\n    if ls[0]>=0:\n        ans+=ls[0]\n    elif ls[1]>=0:\n        ans+=ls[1]\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 76, "result": 0, "generated": "<ans>\ndef indeksTurun(a):\n\tfor x in range(len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\treturn x+1\n\t\t\tpass\n\t\tpass\n\treturn -1\n\tpass\n\ndef menaik(a,i1):\n\tfor x in range(i1,len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\treturn False\n\t\t\tpass\n\t\tpass\n\treturn True\n\tpass\n\na=input()\nprint(\"a: \", str(a))\na=list(map(int,input().split(\" \")))\nprint(\"a: \", str(a))\n\nif len(a) == 1:\n\tprint (\"yes\")\n\tprint (\"1 1\")\nelse:\n\treversed_indeks1=-1\n\tfor x in range(len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\treversed_indeks1=x\n\t\t\tbreak\n\t\t\tpass\n\t\tpass\n\tprint(\"reversed_indeks1: \", str(reversed_indeks1))\n\tif reversed_indeks1 == -1:\n\t\tprint (\"yes\")\n\t\tprint (\"1 1\")\n\telse:\n\t\treversed_indeks2=len(a)-1\n\t\tfor x in range(reversed_indeks1,len(a)-1):\n\t\t\tif a[x] < a[x+1]:\n\t\t\t\treversed_indeks2=x\n\t\t\t\tbreak\n\t\tprint(\"reversed_indeks2: \", str(reversed_indeks2))\n\t\tasc=True\n\t\tif reversed_indeks2 != len(a)-1:\n\t\t\tasc=menaik(a,reversed_indeks2+1)\n\t\tprint(\"asc: \", str(asc))\n\t\tif asc:\n\t\t\tkiri=True\n\t\t\tkanan=True\n\t\t\tif reversed_indeks1 != 0:\n\t\t\t\tif a[reversed_indeks2] < a[reversed_indeks1-1]:\n\t\t\t\t\tkiri=False\n\t\t\t\t\tpass\n\t\t\tif reversed_indeks2 != len(a)-1:\n\t\t\t\tif a[reversed_indeks1] > a[reversed_indeks2+1]:\n\t\t\t\t\tkanan=False\n\t\t\t\t\tpass\n\t\t\t\tpass\n\t\t\t\tpass\n\t\t\tprint(\"kiri: \", str(kiri))\n\t\t\tprint(\"kanan: \", str(kanan))\n\t\t\tif kiri and kanan:\n\t\t\t\tprint (\"yes\")\n\t\t\t\tprint (\"%d %d\"%(reversed_indeks1+1,reversed_indeks2+1))\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tprint (\"no\")\n\t\telse:\n\t\t\tprint (\"no\")\n\t\t\tpass\n\tpass\n</ans>", "format_properties": {}}
{"idx": 75, "result": 0, "generated": "<ans>\nfrom copy import deepcopy\nn, k, m, a = [int(i) for i in input().split()]\nprint(\"n: \", str(n), \"k: \", str(k), \"m: \", str(m), \"a: \", str(a))\ncn = [0] * (n + 1)\nprint(\"cn: \", str(cn))\nlast = [-1] * (n + 1)\nprint(\"last: \", str(last))\nv = [int(i) for i in input().split()]\nprint(\"v: \", str(v))\n\nfor i in range(len(v)):\n    last[v[i]] = i\n    cn[v[i]] += 1\n    print(\"v[\", i, \"]: \", str(v[i]), \"last[\", v[i], \"]: \", str(last[v[i]]), \"cn[\", v[i], \"]: \", str(cn[v[i]]))\n\ncn1 = deepcopy(cn)\nprint(\"cn1: \", str(cn1))\nlast1 = deepcopy(last)\nprint(\"last1: \", str(last1))\n\nfor i in range(1, n + 1):\n    cn = deepcopy(cn1)\n    print(\"cn: \", str(cn))\n    last = deepcopy(last1)\n    print(\"last: \", str(last))\n    res = [i1 for i1 in range(1, n + 1)]\n    res.sort(key=lambda x: (cn[x], -last[x]), reverse=True)\n    # print(res)\n    \n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        j1 = j + 1\n        lft = m - a\n        while j1 < n and lft:\n            pls = min(lft, cn[i] - cn[res[j1]] + 1)\n            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)\n            last[res[j1]] = m\n            lft -= pls\n            j1 += 1\n\n    \n    res.sort(key=lambda x: (cn[x], -last[x]), reverse=True)\n    sans = 0\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n\n    if sans == 1:\n        print(1, end=' ')\n        continue\n    \n    cn = deepcopy(cn1)\n    print(\"cn: \", str(cn))\n    last = deepcopy(last1)\n    print(\"last: \", str(last))\n\n    if m - a:\n        cn[i] += m - a\n        last[i] = m - 1\n        print(\"i: \", str(i), \"cn[\", i, \"]: \", str(cn[i]), \"last[\", i, \"]: \", str(last[i]))\n\n    res.sort(key=lambda x: (cn[x], 0 - last[x]), reverse=True)\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n    \n    if sans:\n        print(2, end=' ')\n    else:\n        print(3, end=' ')\n</ans>", "format_properties": {}}
{"idx": 77, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(1919810)\n\ndef dfs(i):\n    if i == 2 * n + 1:\n        nonlocal ans\n        ans = \"Yes\"\n        return\n    if ans == \"No\":\n        if y[i] == 0:\n            for k in range(1, n):\n                if ok(k, i):\n                    dfs(i + 2 * k)\n        else:\n            if ok(y[i], i):\n                dfs(i + 2 * y[i])\n    return\n\ndef ok(k, i):\n    if k + i >= 2 * n + 1:\n        return 0\n    f = 1\n    for l in range(k):\n        if k + i + l >= 2 * n + 1:\n            f = 0\n            break\n        if x[i + l] == 2 or x[k + i + l] == 1:\n            f = 0\n            break\n        if not (y[i + l] == 0 or y[i + l] == k):\n            f = 0\n            break\n        if not z[i + l] == z[k + i + l] and min(z[i + l], z[k + i + l]) >= 1:\n            f = 0\n            break\n    return f\n\nn = int(input())\nprint(\"n: \", str(n))\nans = \"Yes\"\nprint(\"ans: \", str(ans))\nx = [0] * (2 * n + 2)\nprint(\"x: \", str(x))\ny = [0] * (2 * n + 2)\nprint(\"y: \", str(y))\nz = [0] * (2 * n + 2)\nprint(\"z: \", str(z))\nfor i in range(1, n + 1):\n    a, b = map(int, input().split())\n    print(\"a: \", str(a), \"b: \", str(b))\n    if a >= b and not (a == -1 or b == -1):\n        ans = \"No\"\n        print(\"ans: \", str(ans))\n    if not (x[a] == 0 and x[b] == 0):\n        ans = \"No\"\n        print(\"ans: \", str(ans))\n    if not a == -1:\n        x[a] = 1\n        z[a] = i\n        print(\"x: \", str(x), \"z: \", str(z))\n    if not b == -1:\n        x[b] = 2\n        z[b] = i\n        print(\"x: \", str(x), \"z: \", str(z))\n    if not (a == -1 or b == -1):\n        y[a] = b - a\n        print(\"y: \", str(y))\nif ans == \"No\":\n    print(ans)\n    return\nans = \"No\"\nprint(\"ans: \", str(ans))\ndfs(1)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 78, "result": 0, "generated": "<ans>\nn, m = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m))\n\nt = [0] * (n + 1)\nprint(\"t: \", str(t))\np = [0] * (n + 1)\nprint(\"p: \", str(p))\nq = [[] for i in range(n + 1)] \nprint(\"q: \", str(q))\n\ndef f(x):\n    for i in q[x]:\n        u, v = i[0], i[1]\n        if t[u] and t[v]: continue\n        if t[u] and not t[v]:\n            t[v] = 7 - t[x] - t[u]\n            for j in q[v]:\n                p[j[0]] |= t[v]\n                p[j[1]] |= t[v]\n            #f(u)\n            f(v)\n        elif not t[u] and t[v]:\n            t[u] = 7 - t[x] - t[v]\n            for j in q[u]:\n                p[j[0]] |= t[u]\n                p[j[1]] |= t[u]\n            f(u)\n            #f(v)\n        else:\n            for k in [1, 2, 4]:                \n                t[u], t[v] = k, 7 - t[x] - k\n                if not (p[u] & t[u] or p[v] & t[v]): break                    \n            \n            for j in q[v]:\n                p[j[0]] |= t[v]\n                p[j[1]] |= t[v]                \n            for j in q[u]:\n                p[j[0]] |= t[u]\n                p[j[1]] |= t[u]\n            f(u)\n            f(v)\n\nif m == 49999:\n    for j in range(m):\n        a, b, c = map(int, input().split())\n        x = t[a] | t[b] | t[c]\n        for i in (a, b, c):\n            if not t[i]:\n                if not x & 1: t[i] = 1; x += 1;\n                elif not x & 2: t[i] = 2; x += 2;\n                else: t[i] = 4\nelse:           \n    for i in range(m):\n        a, b, c = map(int, input().split())\n\n        q[a].append((b, c))\n        q[b].append((a, c))\n        q[c].append((a, b))\n        \n    for x in range(1, n + 1):\n        if not t[x]:\n            t[x] = 1\n            for j in q[x]:\n                p[j[0]] |= 1\n                p[j[1]] |= 1\n            f(x)\n        \np = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}\nprint(''.join(p[x] for x in t[1:]))\n</ans>", "format_properties": {}}
{"idx": 79, "result": 0, "generated": "<ans>\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright (c) 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\ndef good(nums):\n    for num in nums:\n        if nums[num] > 1:\n            return True\n    return False\n\nn = int(input())\nprint(\"n: \", str(n))\n\na = [int(i) for i in input().split()]\nprint(\"a: \", str(a))\n\ns = []\nprint(\"s: \", str(s))\n\nl, r = 0, 0\nprint(\"l: \", str(l), \"r: \", str(r))\n\nnums = {}\nprint(\"nums: \", str(nums))\n\nfor i in range(n):\n    num = a[i]\n    print(\"num: \", str(num))\n    if num in nums:\n        break\n    else:\n        nums[num] = True\nelse:\n    print(-1)\n    return\n\nnums = {}\nprint(\"nums: \", str(nums))\n\nwhile r < n:\n    while r < n:\n        num = a[r]\n        print(\"num: \", str(num))\n        if num in nums:\n            r += 1\n            break\n        else:\n            nums[num] = True\n\n        r += 1\n\n    r -= 1\n\n    s.append([l, r])\n    print(\"s: \", str(s))\n    r += 1\n    l = r\n\n    nums = {}\n    print(\"nums: \", str(nums))\n\nlength = len(s)\nprint(\"length: \", str(length))\n\nlast = s[length-1]\nprint(\"last: \", str(last))\n\nfor i in range(last[0], last[1]+1):\n    num = a[i]\n    print(\"num: \", str(num))\n    if num in nums:\n        print(length)\n        break\n    else:\n        nums[num] = True\nelse:\n    s.pop()\n    print(\"s: \", str(s))\n    s[length-2][1] = n-1\n    print(\"s: \", str(s))\n    print(length-1)\n\nfor st in s:\n    for c in st:\n        print(c+1, end=\" \")\n    print()\n</ans>", "format_properties": {}}
{"idx": 81, "result": 0, "generated": "<ans>\ndef dist(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n    \nx0, y0, a1, a2, b1, b2 = list(map(int, input().split()))\nprint(\"x0: \", str(x0), \"y0: \", str(y0), \"a1: \", str(a1), \"a2: \", str(a2), \"b1: \", str(b1), \"b2: \", str(b2))\nxs, ys, t = list(map(int, input().split()))\nprint(\"xs: \", str(xs), \"ys: \", str(ys), \"t: \", str(t))\narr = []\narr.append((x0, y0))\nnow1 = x0\nnow2 = y0\nprint(\"now1: \", str(now1), \"now2: \", str(now2))\nwhile (1):\n    now1 = a1 * now1 + b1\n    now2 = a2 * now2 + b2\n    if (now1 < xs or now2 < ys):\n        arr.append((now1, now2))\n        continue\n    #print(now1, now2)\n    arr.append((now1, now2))\n    if (dist(now1, now2, xs, ys) > t):\n        break\nans = 0\nN = len(arr)\nfor i in range(N):\n    need = dist(arr[i][0], arr[i][1], xs, ys)\n    if (need > t):\n        continue\n    left = t - need\n    now = 1\n    flag = 1\n    now1 = arr[i][0]\n    now2 = arr[i][1]\n    for j in range(i - 1, -1, -1):\n        d = dist(now1, now2, arr[j][0], arr[j][1])\n        if (d > left):\n            flag = 0\n            break\n        left -= d\n        now1 = arr[j][0]\n        now2 = arr[j][1]\n        now += 1\n    if (not flag):\n        ans = max(ans, now)\n        continue\n    for j in range(i + 1, N):\n        d = dist(now1, now2, arr[j][0], arr[j][1])\n        if (d > left):\n            break\n        left -= d\n        now1 = arr[j][0]\n        now2 = arr[j][1]\n        now += 1\n    ans = max(ans, now)\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 82, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\n\n\"\"\"\ncreated by shhuan at 2017/10/6 22:19\n\n\"\"\"\n\nt0 = time.time()\nprint(\"t0: \", str(t0))\na, b, c = list(map(int, input().split()))\nprint(\"a, b, c: \", str(a), str(b), str(c))\n\ndef ct(a, b):\n    if a > b:\n        a, b = b, a\n    L=998244353\n    s=1\n    sx=1\n    for k in range(1,a+1):\n        s = s*(a+1-k)*(b+1-k)//k\n        sx += s % L\n    return sx\n\nL=998244353\nprint(\"L: \", str(L))\n\nprint(ct(a,b)*ct(a,c)*ct(b,c)%L)\n\n# print(time.time()-t0)\n\n# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]\n# for i in range(1, MAXN):\n#     p[i][0] = 1\n#     for j in range(1, i+1):\n#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD\n# print(time.time() - t0)\n# pre = [0] * MAXN\n# pre[0] = 1\n# for i in range(1, MAXN):\n#     pre[i] = (i*pre[i-1]) % MOD\n#\n#\n# def solve(x, y):\n#     ans = 0\n#     for k in range(min(x, y)+1):\n#         d = pre[k]\n#         d = (d*p[x][k]) % MOD\n#         d = (d*p[y][k]) % MOD\n#         ans = (ans+d) % MOD\n#\n#     return ans\n#\n# ans = 1\n# ans = (ans * solve(a, b)) % MOD\n# print(\"ans: \", str(ans))\n# ans = (ans * solve(b, c)) % MOD\n# print(\"ans: \", str(ans))\n# ans = (ans * solve(a, c)) % MOD\n# print(\"ans: \", str(ans))\n# print(ans)\n#\n# print(time.time() - t0)\n</ans>", "format_properties": {}}
{"idx": 80, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\nprint(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n\nG0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nG1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nG2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\n\nprint(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n\nfor x in range(1,6):\n    for y in range(1,6):\n        for z in range(1,6):\n            \n            for i in range(1,5500):\n                s=G0[x][y][z][max(0,i-x)]\n                t=G1[x][y][z][max(0,i-y)]\n                u=G2[x][y][z][max(0,i-z)]\n\n                for j in range(5):\n                    if j==s or j==t or j==u:\n                        continue\n                    else:\n                        G0[x][y][z][i]=j\n                        print(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n                        break\n\n                for j in range(5):\n                    if j==s or j==u:\n                        continue\n                    else:\n                        G1[x][y][z][i]=j\n                        print(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n                        break\n\n                for j in range(5):\n                    if j==s or j==t:\n                        continue\n                    else:\n                        G2[x][y][z][i]=j\n                        print(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n                        break\n\nimport math\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\nt=int(input())\nfor tests in range(t):\n    n,x,y,z=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n    A=[]\n    for a in B:\n        if a<=5400:\n            A.append(a)\n        else:\n            A.append(a%2520+2520)\n\n    XOR=0\n\n    for a in A:\n        XOR^=G0[x][y][z][a]\n        print(\"G0: \", str(G0), \"G1: \", str(G1), \"G2: \", str(G2))\n\n    ANS=0\n    for a in A:\n        k=XOR^G0[x][y][z][a]\n\n        if G0[x][y][z][max(0,a-x)]==k:\n            ANS+=1\n\n        if G1[x][y][z][max(0,a-y)]==k:\n            ANS+=1\n\n        if G2[x][y][z][max(0,a-z)]==k:\n            ANS+=1\n\n    print(ANS)\n</ans>", "format_properties": {}}
{"idx": 86, "result": 0, "generated": "<ans>\n#n, m = map(int, input().split())\nn = int(input())\nprint(\"n: \", str(n))\n\ns = input()\nprint(\"s: \", str(s))\n\nans = int(n * (n - 1) / 2)\nprint(\"ans: \", str(ans))\nc = 0\nprint(\"c: \", str(c))\n\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\n\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\n\ns = s[::-1]\n\nc = 0\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\n\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\n\nc = 0\nif s[0] == 'A':\n    c += 1\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    elif c >= 1:\n        ans -= 1\n        c = 0\n\nc = 0\nif s[0] == 'B':\n    c += 1\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    elif c >= 1:\n        ans -= 1\n        c = 0\n\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 83, "result": 0, "generated": "<ans>\nimport sys\nfrom functools import reduce\n\nprint(\"zz: \", str(zz))\nsys.setrecursionlimit(10**5)\nif zz:\n\tprint(\"input: \", str(input))\nelse:\t\n\tprint(\"sys.stdin: \", str(sys.stdin))\n\tprint(\"sys.stdout: \", str(sys.stdout))\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\nprint(\"fori: \", str(fori))\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\tprint(\"d: \", str(d), \"c: \", str(c), \"x: \", str(x))\n\td[c]=d[c]+x if c in d else x\ndef ii():\n\treturn input().rstrip()\t\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tlist(map(int,input().split()))\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\nuu=t\n\t\t\t\t\ndef can(val):\n\tp=val;c=0\n\tfor i in range(n):\n\t\tc+=abs(a[i]-p)\n\t\tp+=1\n\treturn c\t\n\nwhile t>0:\n\tt-=1\n\tprint(\"n: \", str(n))\n\tn=fi()\n\tprint(\"a: \", str(a))\n\ta=li()\n\tl=-2*max(a)\n\tr=2*max(a)\n\tmini=10**18\n\twhile l<=r:\n\t\tlmid=l+(r-l)//3\n\t\trmid=r-(r-l)//3\n\t\tp1=can(lmid)\n\t\tp2=can(rmid)\n\t\tmini=min([mini,p1,p2])\n\t\tif p1>=p2:\n\t\t\tl=lmid+1\n\t\telse:\n\t\t\tr=rmid-1\n\tprint(\"mini: \", str(mini))\t\t\t\n\tprint(\"mini: \", str(mini))\t\t\t\n</ans>", "format_properties": {}}
{"idx": 84, "result": 0, "generated": "<ans>\ndef local_right_to_global(test, local_right):\n    print(\"test: \", str(test), \"local_right: \", str(local_right))\n    return(len(test) + local_right)\n    \ndef local_left_to_global(test, local_left):\n    print(\"test: \", str(test), \"local_left: \", str(local_left))\n    return(local_left)\n\ndef check_left(test, template, good_symbols):\n    print(\"test: \", str(test), \"template: \", str(template), \"good_symbols: \", str(good_symbols))\n    left_idx = -1\n    for symbol in template:\n        left_idx += 1\n        if symbol == '*':\n            return(local_left_to_global(test, left_idx))\n        try:\n            if test[left_idx] != template[left_idx]:\n                if template[left_idx] != '?':\n                    return('NO')\n                elif test[left_idx] not in good_symbols:\n                    return('NO')\n        except:\n            return('NO')\n\ndef check_right(test, template, good_symbols):\n    print(\"test: \", str(test), \"template: \", str(template), \"good_symbols: \", str(good_symbols))\n    right_idx = 0\n    for symbol in reversed(template):\n        right_idx -= 1\n        if symbol == '*':\n            return(local_right_to_global(test, right_idx))\n        try:\n            if test[right_idx] != template[right_idx]:\n                if template[right_idx] != '?':\n                    return('NO')\n                elif test[right_idx] not in good_symbols:\n                    return('NO')            \n        except:\n            return('NO')\n    \ngood_symbols = set(list(input()))\nprint(\"good_symbols: \", str(good_symbols))\ntemplate = input()\nprint(\"template: \", str(template))\ntests_nr = int(input())\nprint(\"tests_nr: \", str(tests_nr))\ntests = []\nfor _ in range(tests_nr):\n    tests.append(input())\n    print(\"tests: \", str(tests))\n    \nabaca = '*' not in template\nfor test in tests:\n    if abaca:\n        print(\"test: \", str(test))\n        pos = -1\n        flag = True\n        if len(test) != len(template):\n            print('NO')\n            continue\n        for symbol in template:\n            pos += 1\n            try:\n                if test[pos] != template[pos]:\n                    if template[pos] != '?':\n                        print('NO')\n                        flag = False\n                        break\n                    elif test[pos] not in good_symbols:\n                        print('NO')\n                        flag = False\n                        break\n            except:\n                print('NO')\n                flag = False\n                break\n        if flag:\n            print('YES')\n        continue\n    left_idx = check_left(test, template, good_symbols)\n    right_idx = check_right(test, template, good_symbols)\n    # print(left_idx, right_idx)\n    if left_idx == 'NO':\n        print('NO')\n    elif right_idx == 'NO':\n        print('NO')\n    else:\n        print(\"left_idx: \", str(left_idx), \"right_idx: \", str(right_idx))\n        if right_idx < left_idx - 1:\n            print('NO')\n            continue\n        flag = True\n        for pos in range(left_idx, right_idx + 1):\n            if test[pos] in good_symbols:\n                print('NO')\n                flag = False\n                break\n        if flag:\n            print('YES')\n</ans>", "format_properties": {}}
{"idx": 85, "result": 0, "generated": "<ans>\nn = int(input())\nprint(\"n: \", str(n))\nx0, y0 = map(int, input().split())\nprint(\"x0, y0: \", str(x0), str(y0))\nNord = 10 ** 9 + 1\nfNord = '-'\nEast = 10 ** 9 + 1\nfEast = '-'\nSouth = -10 ** 9 - 1\nfSouth = '-'\nWest = -10 ** 9 - 1\nfWest = '-'\n\nNE = 10 ** 9 + 1\nfNE = '-'\nNW = 10 ** 9 + 1\nfNW = '-'\nSE = -10 ** 9 - 1\nfSE = '-'\nSW = -10 ** 9 - 1\nfSW = '-'\n\nfor i in range(n):\n    f, x, y = input().split()\n    x = int(x)\n    y = int(y)\n    print(\"f, x, y: \", str(f), str(x), str(y))\n    if x == x0:\n        if y0 < y < Nord:\n            fNord = f\n            Nord = y\n            print(\"fNord, Nord: \", str(fNord), str(Nord))\n        elif y0 > y > South:\n            fSouth = f\n            South = y\n            print(\"fSouth, South: \", str(fSouth), str(South))\n    if y == y0:\n        if x0 < x < East:\n            fEast = f\n            East = x\n            print(\"fEast, East: \", str(fEast), str(East))\n        elif x0 > x > West:\n            fWest = f\n            West = x\n            print(\"fWest, West: \", str(fWest), str(West))\n            \n    if x + y == x0 + y0:\n        if y0 < y < NW:\n            fNW = f\n            NW = y\n            print(\"fNW, NW: \", str(fNW), str(NW))\n        elif y0 > y > SE:\n            fSE = f\n            SE = y\n            print(\"fSE, SE: \", str(fSE), str(SE))\n    if x - y == x0 - y0:\n        if y0 < y < NE:\n            fNE = f\n            NE = y\n            print(\"fNE, NE: \", str(fNE), str(NE))\n        elif y0 > y > SW:\n            fSW = f\n            SW = y\n            print(\"fSW, SW: \", str(fSW), str(SW))\nans  = False\nif fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':\n    ans = True\nif fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':\n    ans = True\nif fSW == 'B' or fSE == 'B' or fNW == 'B' or fNE == 'B':\n    ans = True\nif fNord == 'R' or fSouth == 'R' or fWest == 'R' or fEast == 'R':\n    ans = True\n\n#print(fSW, fSE, fNW, fNE) \n#print(fNord, fSouth, fWest, fEast)\nprint('YES' if ans else 'NO')\n</ans>", "format_properties": {}}
{"idx": 74, "result": 0, "generated": "<ans>\nfrom collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    print(\"visited[numbers_of_attacked_cities[0]]: \", str(visited[numbers_of_attacked_cities[0]]))\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    print(\"stack: \", str(stack))\n    while len(stack)>0:\n        v=stack.pop()\n        print(\"v: \", str(v))\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)    \n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    print(\"visited[numbers_of_attacked_cities[0]]: \", str(visited[numbers_of_attacked_cities[0]]))\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    print(\"stack: \", str(stack))\n    while len(stack)>0:\n        v=stack.pop()\n        print(\"v: \", str(v))\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    print(\"visited[numbers_of_attacked_cities[0]]: \", str(visited[numbers_of_attacked_cities[0]]))\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    print(\"stack: \", str(stack))\n    Distance_Root(numbers_of_attacked_cities[0])\n    print(\"Distance_Root(numbers_of_attacked_cities[0]): \", str(Distance_Root(numbers_of_attacked_cities[0])))\n    while len(stack)>0:\n        v=stack.pop()\n        print(\"v: \", str(v))\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\nprint(\"pi: \", str(pi))\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\nprint(\"count_attacked_cities_subtree: \", str(count_attacked_cities_subtree))\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\nprint(\"attacked_city: \", str(attacked_city))\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\nprint(\"important_cities: \", str(important_cities))\n\nadjacents_list=[[] for x in range(n)]\nprint(\"adjacents_list: \", str(adjacents_list))\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\nprint(\"numbers_of_attacked_cities: \", str(numbers_of_attacked_cities))\n\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\nprint(\"attacked_city: \", str(attacked_city))\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\nprint(\"adjacents_list: \", str(adjacents_list))\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\nprint(\"pi: \", str(pi))\n\n#alturas\nheights1=[0 for x in range(n)]\nheights2=[0 for x in range(n)]\nprint(\"heights1: \", str(heights1))\nprint(\"heights2: \", str(heights2))\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\ndistances2=[0 for x in range(n)]\nprint(\"distances1: \", str(distances1))\nprint(\"distances2: \", str(distances2))\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))\n</ans>", "format_properties": {}}
{"idx": 88, "result": 0, "generated": "<ans>\ndef dp(ind, max_covered):\n\tmax_covered = min(m, max_covered)\n\n\tif ind not in cache:\n\t\tcache[ind] = {}\n\n\td = cache[ind]\n\tif max_covered in d:\n\t\treturn d[max_covered]\n\n\tans = blah(ind, max_covered)\n\n\td[max_covered] = ans\n\treturn ans\n\n\n# path = {}\n\nclass Node:\n\tdef __init__(self, key, val, next=None):\n\t\tself.key = key\n\t\tself.val = val\n\t\tself.next = next\n\ndef blah(ind, max_covered):\n\tx, s = antenna[ind]\n\t# key = (ind, max_covered)\n\n\tif max_covered >= m:\n\t\t# path[key] = Node(key, 0)\n\t\treturn 0\n\n\tif ind == len(antenna) - 1:\n\t\tif max_covered < x - s - 1:\n\t\t\tleft_needed = x - s - (max_covered + 1)\n\t\t\tright_needed = max(m - (x + s), 0)\n\t\t\tans = max(left_needed, right_needed)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\t\telse:\n\t\t\tright_boundary = max(max_covered, x + s)\n\t\t\tans = max(0, m - right_boundary)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\n\tif max_covered < x - s - 1:\n\t\tnum_needed = x - s - (max_covered + 1)\n\t\tnew_boundary = min(x + s + num_needed, m)\n\t\tuse_i = num_needed + dp(ind + 1, new_boundary)\n\t\tdont_use_i = dp(ind + 1, max_covered)\n\n\t\t# if use_i < dont_use_i:\n\t\t# \tpath[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])\n\t\t# else:\n\t\t# \tpath[key] = Node(key, 0, path[(ind + 1, max_covered)])\n\n\t\treturn min(use_i, dont_use_i)\n\telse:\n\t\tnew_boundary = min(max(max_covered, x + s), m)\n\t\tans = dp(ind + 1, new_boundary)\n\t\t# path[key] = Node(key, 0, path[(ind + 1, new_boundary)])\n\t\treturn ans\n\nimport sys\n\ncache = {}\n\nn, m = [int(x) for x in sys.stdin.readline().split(\" \")]\nprint(\"n: \", str(n), \"m: \", str(m))\n\nantenna = []\n\nfor i in range(n):\n\tx, s = [int(x) for x in sys.stdin.readline().split(\" \")]\n\tprint(\"x: \", str(x), \"s: \", str(s))\n\tantenna.append((x, s))\n\nantenna.sort(key=lambda a: a[0])\n\nprint(\"antenna: \", str(antenna))\n\nprint(dp(0, 0))\n</ans>", "format_properties": {}}
{"idx": 90, "result": 0, "generated": "<ans>\n#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\ndprint(\"N: \", str(N))\nre = 1\ndprint(\"re: \", str(re))\nmc = 1\ndprint(\"mc: \", str(mc))\nzc = []\ndprint(\"zc: \", str(zc))\nfor i in range(2, 10000):\n    if N%i != 0 : continue\n    re *= i\n    dprint(\"re: \", str(re))\n    c = 0\n    while N%i==0:\n        N//=i\n        c+=1\n    dprint(\"c: \", str(c))\n    zc.append(c)\n    dprint(\"zc: \", str(zc))\nif N>1:\n    re*=N\n    dprint(\"re: \", str(re))\n    zc.append(1)\n    dprint(\"zc: \", str(zc))\nif zc:\n    mc = max(zc)\n    dprint(\"mc: \", str(mc))\nt =1 \ndprint(\"t: \", str(t))\nfor i in range(100):\n    if mc<=t:\n        break\n    t*=2\n    dprint(\"t: \", str(t))\ndprint(t)\ndprint(zc)\ng = i\nfor x in zc:\n    if x<t:\n        g+=1\n        break\n    dprint(\"x: \", str(x))\n    dprint(\"g: \", str(g))\nprint(re,g)\n</ans>", "format_properties": {}}
{"idx": 87, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\n\n\nclass CantException(Exception):\n    pass\n\n\ndef odd_v(value):\n    return 1 if value % 2 == 1 else -1\n\n\nchange_idx = 1\n\nacceptable = {-1: set(), 1: set()}\n\n\ndef change(card_values, oddv, m):\n    nonlocal change_idx\n\n    if acceptable[oddv]:\n        res = acceptable[oddv].pop()\n        card_values.add(res)\n        print(\"X: \", str(res), \"Y: \", str(card_values))\n        return res\n\n    change_idx_start = change_idx\n\n    while change_idx in card_values or odd_v(change_idx) != oddv:\n        if change_idx not in card_values:\n            acceptable[odd_v(change_idx)].add(change_idx)\n        change_idx += 1\n        if change_idx > m:\n            change_idx = 1\n        if change_idx == change_idx_start:\n            raise CantException()\n\n    res = change_idx\n    card_values.add(res)\n    print(\"X: \", str(res), \"Y: \", str(card_values))\n    change_idx += 1\n    if change_idx > m:\n        change_idx = 1\n    return res\n\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    cards = list(map(int, input().split()))\n\n    odd_balance = 0\n    card_values = set()\n    indices_to_be_changed = set()\n\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n        if c in card_values:\n            indices_to_be_changed.add(i)\n        card_values.add(c)\n        print(\"X: \", str(i), \"Y: \", str(c))\n\n    # print(\"indices to be changed: \", indices_to_be_changed)\n    change_count = len(indices_to_be_changed)\n\n    for i in indices_to_be_changed:\n        if odd_v(cards[i]) * odd_balance <= 0:\n            #print(\"Changing \", cards[i])\n            cards[i] = change(card_values, odd_v(cards[i]), m)\n            #print(\"Changed to \", cards[i])\n        else:\n            #print(\"For teh balance changing \", cards[i])\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, - odd_v(cards[i]), m)\n            #print(\"Changed to \", cards[i])\n\n    #print(\"current odd balance:\", odd_balance)\n    for i in range(len(cards)):\n        if odd_balance == 0:\n            break\n        if odd_v(cards[i]) * odd_balance > 0:\n            # print(\"gonna change\")\n            change_count += 1\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, -odd_v(cards[i]), m)\n\n    odd_balance = 0\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n    if odd_balance != 0:\n        print(odd_balance)\n        print(\"WTFFFFF\")\n\n    return change_count, cards\n\n\ndef __starting_point():\n    try:\n        change_cnt, cards = solve()\n        print(change_cnt)\n        print(\" \".join(map(str, cards)))\n    except CantException:\n        print(\"-1\")\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 91, "result": 0, "generated": "<ans>\n#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=1000000007\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\nn,m,o=value()\nprint(\"n,m,o: \", str(n), str(m), str(o))\nfor i in range(n):\n    input()\n    print(\"input: \", str(i))\nprint(m*(m-1)//2)\nfor i in range(1,m+1):\n    for j in range(i+1,m+1):\n        if(o==0):\n            print(i,j)\n        else:\n            print(m-i+1,m-j+1)\n</ans>", "format_properties": {}}
{"idx": 89, "result": 0, "generated": "<ans>\nimport math;\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u043f\u043e \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c \u0446\u0435\u043d\u0442\u0440\u0430, \u0443\u0433\u043b\u0443, \u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0446\u0435\u043d\u0442\u0440\u0430\ndef getCoordinate(gx, gy, alpha, x, y):\n    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);\n    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);\n    return x1, y1\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0443\u0433\u043b\u0430, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0442\u043e\u0447\u043a\u0443 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438 x, y,\n#\u0447\u0442\u043e\u0431\u044b \u043e\u043d\u0430 \u043e\u043a\u0430\u0437\u0430\u043b\u0430\u0441\u044c \u043f\u0440\u044f\u043c\u043e \u043d\u0430\u0434 gx, gy\ndef getAngle(gx, gy, x, y):\n    x=x-gx;\n    y=y-gy;\n    cos=x/math.sqrt(x**2+y**2);\n    alpha=math.acos(cos);\n    if y<0:\n        alpha=-alpha;\n    return math.pi/2-alpha;\nn, q = list(map(int, input().split(' ')));\nprint(\"n: \", str(n), \"q: \", str(q))\nx=[0]*n;\ny=[0]*n;\nprint(\"x: \", str(x), \"y: \", str(y))\nfor i in range(n):\n    x[i], y[i]=list(map(int, input().split(' ')));\n    print(\"x[\", i, \"]: \", str(x[i]), \"y[\", i, \"]: \", str(y[i]))\nr=[0]*q;\nf=[0]*q;\nt=[0]*q;\nv=[0]*q;\nprint(\"r: \", str(r), \"f: \", str(f), \"t: \", str(t), \"v: \", str(v))\nfor i in range(q):\n    l=list(map(int, input().split(' ')));\n    r[i]=l[0];\n    if r[i]==1:\n        f[i]=l[1]-1;\n        t[i]=l[2]-1;\n    else:\n        v[i]=l[1]-1;\n    print(\"r[\", i, \"]: \", str(r[i]), \"f[\", i, \"]: \", str(f[i]), \"t[\", i, \"]: \", str(t[i]), \"v[\", i, \"]: \", str(v[i]))\ngx=0;\ngy=0;\ns=0;\nprint(\"gx: \", str(gx), \"gy: \", str(gy), \"s: \", str(s))\nfor i in range(n):\n    ip=i+1;\n    if ip==n:\n        ip=0;\n    ds=x[i]*y[ip]-x[ip]*y[i];\n    s+=ds;\n    gx+=(x[i]+x[ip])*ds;\n    gy+=(y[i]+y[ip])*ds;\n    print(\"ds: \", str(ds), \"gx: \", str(gx), \"gy: \", str(gy))\ns/=2;\ngx/=6*s;\ngy/=6*s;\nprint(\"s: \", str(s), \"gx: \", str(gx), \"gy: \", str(gy))\nangles=[0]*n;\nprint(\"angles: \", str(angles))\nfor i in range(n):\n    angles[i]=getAngle(gx, gy, x[i], y[i]);\n    print(\"angles[\", i, \"]: \", str(angles[i]))\nfor i in range(n):\n    x[i]-=gx;\n    y[i]-=gy;\n    print(\"x[\", i, \"]: \", str(x[i]), \"y[\", i, \"]: \", str(y[i]))\nalpha=0;\nprint('pos',gx, gy, alpha);\n#\u0412\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u0435\u043a \u0431\u0443\u0434\u0435\u043c \u043f\u043e \u0446\u0435\u043d\u0442\u0440\u0443 \u043c\u0430\u0441\u0441 \u0438 \u0443\u0433\u043b\u0443\n#\u0423\u0433\u043e\u043b - \u043f\u043e\u0432\u043e\u0440\u043e\u0442 \u043f\u0440\u043e\u0442\u0438\u0432 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u0432\u043e\u043a\u0440\u0443\u0433 \u0446\u0435\u043d\u0442\u0440\u0430 \u043c\u0430\u0441\u0441\nfix={0, 1}\nprint(\"fix: \", str(fix))\nfor i in range(q):\n    if r[i]==2:\n        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);\n        print(\"%.6f %.6f\"%(currX, currY))\n    else:\n        if len(fix)==2:\n            fix.remove(f[i]);\n            print(\"fix: \", str(fix))\n        #print('remove',f[i])\n        #j - \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0432 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0435\n        for j in fix:\n            #print(j);\n            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);\n            #print('fix:', currX, currY)\n            #dalpha=getAngle(gx, gy, currX, currY);\n            #alpha+=dalpha;\n            alpha=angles[j];\n            #\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b g, \u043d\u0443\u043d\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0435\u0435 \u043d\u0430 \u0443\u0433\u043e\u043b\n            #dalpha \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e currX, currY\n            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);\n            print(\"currX: \", str(currX), \"currY: \", str(currY), \"gx: \", str(gx), \"gy: \", str(gy))\n        fix.add(t[i]);\n        print(\"fix: \", str(fix))\n</ans>", "format_properties": {}}
{"idx": 95, "result": 0, "generated": "<ans>\nfrom queue import Queue\nimport sys\n#sys.stdin = open('input.txt')\n\nn, m, k = [int(x) for x in input().split(' ')]\n\nif k&1:\n  print('IMPOSSIBLE')\n  return\n\ns = [None]*n\nprint(\"s: \", str(s))\nfor i in range(n):\n  s[i] = [None]*m\n  print(\"s[i]: \", str(s[i]))\n  t = input()\n  for j in range(m):\n    s[i][j] = t[j]\n    if t[j] == 'X': x, y = j, i\n\ndef bfs(x, y):\n  res = [[10000000]*m for i in range(n)]\n  if s[y][x] == '*': return res\n  q = Queue()\n  q.put((x, y))\n  step = 0\n\n  def add(x, y):\n    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return\n    q.put((x, y))\n    res[y][x] = step+1\n\n  res[y][x] = step\n\n  while not q.empty():\n    x, y = q.get()\n    step = res[y][x]\n    #print('-')\n    if y < n-1: add(x, y+1) #D\n    if x > 0: add(x-1, y)   #L\n    if x < m-1: add(x+1, y) #R\n    if y > 0: add(x, y-1)   #U\n  return res\n\nres = bfs(x, y)\nprint(\"res: \", str(res))\n\n\npath = []\nadd = lambda s: path.append(s)\nfor i in range(k):\n  step = k-i\n  #print(step, (y, x), k-i)\n  if y < n-1 and res[y+1][x] <= step: #D\n    add('D')\n    y = y+1\n  elif x > 0 and res[y][x-1] <= step: #L\n    add('L')\n    x = x-1\n  elif x < m-1 and res[y][x+1] <= step: #R\n    add('R')\n    x = x+1\n  elif y > 0 and res[y-1][x] <= step: #U\n    add('U')\n    y = y-1\n  else:\n    print('IMPOSSIBLE')\n    return\n\nprint(str.join('', path))\n</ans>", "format_properties": {}}
{"idx": 97, "result": 0, "generated": "<ans>\n#\n#\n#\n# \u7b11\u3048\u3001\u541b\u304c\u597d\u304d\u306a\u3088\u3046\u306b\u3002\n#                         \u7b11\u3044\u306f\u4e16\u754c\u3092\u6551\u3046\u3002\n#                                           \u3042\u306a\u305f\u304c\u7b11\u3063\u3066\u304f\u308c\u308b\u306a\u3089\u3002\n#\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\n# \u6574\u6570\u304b\u5224\u5b9a\u3059\u308b\n# nanka.is_integer()\n# ref https://atcoder.jp/contests/abc133/tasks/abc133_b\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\ndef f(n):\n    return int(math.ceil(n-0.5))\nN,K = readInts()\nprint(\"N: \", str(N), \"K: \", str(K))\ndef calc(n):\n    if n <= 0 or n > 2*N:\n        return 0\n    else:\n        return min(n-1, 2*N-n+1)\nans = 0\nfor AB in range(2*N+1):\n    #print(AB,calc(AB),AB-K, calc(K-AB))\n    ans += calc(AB) * calc(AB-K)\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 92, "result": 0, "generated": "<ans>\ndef solve1(a, n):  \n    left=[]\n    st=[]\n    i=0\n    while i<(n):\n        if not st:\n            left.append(-1)\n            st.append(i)\n            print(\"left: \", str(left), \"st: \", str(st))\n        elif st and a[i]<a[st[-1]]:\n            left.append(st[-1])\n            st.append(i)\n            print(\"left: \", str(left), \"st: \", str(st))\n        else:\n            while st and a[i]>a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                left.append(-1)\n                print(\"left: \", str(left), \"st: \", str(st))\n            else:\n                left.append(st[-1])\n                st.append(i)\n                print(\"left: \", str(left), \"st: \", str(st))\n                \n        i+=1\n    right=[]\n    st=[]\n    i=n-1\n    while i>(-1):\n        if not st:\n            right.append(n)\n            st.append(i)\n            print(\"right: \", str(right), \"st: \", str(st))\n        elif st and a[i]<a[st[-1]]:\n            right.append(st[-1])\n            st.append(i)\n            print(\"right: \", str(right), \"st: \", str(st))\n        else:\n            while st and a[i]>=a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                right.append(n)\n                print(\"right: \", str(right), \"st: \", str(st))\n            else:\n                right.append(st[-1])\n                st.append(i)\n                print(\"right: \", str(right), \"st: \", str(st))\n                \n        i-=1\n    right=right[::-1]\n    c=0\n    for i in range(len(left)):\n        x=(right[i]-i)*(i-left[i])*a[i]\n        # print(x)\n        if x==0:\n            c+=a[i]\n        else:\n            c+=x\n    # print(c)\n    # print(a)\n    # print(left)\n    # print(right)\n            \n    return c\n\n    \n\n            \ndef solve2(a, n): \n    left=[]\n    st=[]\n    i=0\n    while i<(n):\n        if not st:\n            left.append(-1)\n            st.append(i)\n            print(\"left: \", str(left), \"st: \", str(st))\n        elif st and a[i]>a[st[-1]]:\n            left.append(st[-1])\n            st.append(i)\n            print(\"left: \", str(left), \"st: \", str(st))\n        else:\n            while st and a[i]<a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                left.append(-1)\n                print(\"left: \", str(left), \"st: \", str(st))\n            else:\n                left.append(st[-1])\n                st.append(i)\n                print(\"left: \", str(left), \"st: \", str(st))\n                \n    right=[]\n    st=[]\n    i=n-1\n    while i>(-1):\n        if not st:\n            right.append(n)\n            st.append(i)\n            print(\"right: \", str(right), \"st: \", str(st))\n        elif st and a[i]>a[st[-1]]:\n            right.append(st[-1])\n            st.append(i)\n            print(\"right: \", str(right), \"st: \", str(st))\n        else:\n            while st and a[i]<=a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                right.append(n)\n                print(\"right: \", str(right), \"st: \", str(st))\n            else:\n                right.append(st[-1])\n                st.append(i)\n                print(\"right: \", str(right), \"st: \", str(st))\n                \n        i-=1\n    right=right[::-1]\n    # print(right)\n    c=0\n    for i in range(len(left)):\n        x=(right[i]-i)*(i-left[i])*a[i]\n        # print(x)\n        if x==0:\n            c+=a[i]\n        else:\n            c+=x\n    # print(c)\n    # print(a)\n    # print(left)\n    # print(right)\n            \n    return c\n\n\n\nn=int(input())\narr=[int(x) for x in input().split()]\n# solve2(arr,n)\n# print(solve1(arr,n))\n# print(solve2(arr,n))\n# print()\n# (solve2(arr,n))\n\nprint(solve1(arr,n)-solve2(arr,n))\n</ans>", "format_properties": {}}
{"idx": 73, "result": 0, "generated": "<ans>\n#!/bin/pypy3\nfrom itertools import*\nfrom timeit import*\nfrom typing import Optional\n\nS=lambda x:sum(map(int,str(x)))\n\ndef ceil_s_divisible_a(x:int,a:int) -> Optional[int]:\n\tprint(\"x: \", str(x), \"a: \", str(a))\n\tz=S(x)%a\n\tif z:\n\t\tz=a-z\n\t\ttail=[]\n\t\tx=list(str(x))\n\t\twhile x:\n\t\t\tdigit=x.pop()\n\t\t\tdiff=min(z,9-int(digit))\n\t\t\tz-=diff\n\t\t\ttail.append(str(int(digit)+diff))\n\t\t\tif z==0:break\n\t\telse:\n\t\t\treturn ceil_s_divisible_a(10**len(tail),a)\n\t\tx=''.join(x) + ''.join(reversed(tail))\n\n\tassert S(x)%a==0\n\tx=int(x)\n\treturn x\n\ndef smooth25(a):\n\ta=int(bin(a).rstrip('0'),2)\n\twhile a%5==0: a//=5\n\treturn a==1\n\ndef solve(a):\n\tprint(\"a: \", str(a))\n\tfor first in range(1,60): # 120\n\t\tq=str((first*10**3000+a-1) // a) # 5000\n\t\tfor s1 in range(1,200):\n\t\t\ti=1\n\t\t\ts2=int(q[0])\n\t\t\twhile i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1\n\t\t\tfor len1 in range(i,min(i+10,len(q))):\n\t\t\t\tsmall=int(q[:len1])\n\t\t\t\tfor z in range(4): # 10\n\t\t\t\t\tsmall=ceil_s_divisible_a(small,a)\n\t\t\t\t\tif S(small*a)*a==S(small):\n\t\t\t\t\t\treturn small\n\t\t\t\t\tsmall+=1\n\n\treturn None\n\ndef powform(x:int)->str:\n\tprint(\"x: \", str(x))\n\ts=str(x)\n\ttry:\n\t\ti=s.find('00000')\n\t\treturn f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'\n\texcept IndexError:\n\t\treturn str(x)\n\nif 0:\n\t#for a in (a for a in range(2,1000)):\n\tfor a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:\n\t#for a in [32]:\n\n\t\tdef work():\n\t\t\tnonlocal x\n\t\t\tx=solve(a)\n\n\t\tt=timeit(work,number=1)\n\t\tif t>0.5 or x==None:\n\t\t\tif x!=None:\n\t\t\t\tprint(a,t,'>>',powform(a*x))\n\t\t\telse:\n\t\t\t\tprint(a,t,'>> ?????')\n\n\t#print(solve(int(input())))\n\n\nspecial='''\n660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340\n803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614\n912 0.5136937369998122 >> 3 * 10 ** 1825 + 240\n918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104\n582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116\n612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348\n495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305\n927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003\n636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004\n531 0.5475810970001476 >> 2 * 10 ** 2140 + 439\n64 0.5633312410000144 >> ?????\n200 0.5639609099998779 >> ?????\n100 0.565854023000611 >> ?????\n125 0.5663040710005589 >> ?????\n160 0.5668467480008985 >> ?????\n800 0.5676178080002501 >> ?????\n128 0.5676772269998764 >> ?????\n80 0.5682811480000964 >> ?????\n256 0.5685735130000467 >> ?????\n250 0.5691464900000938 >> ?????\n512 0.569266141999833 >> ?????\n32 0.5692826909998985 >> ?????\n50 0.5692834940000466 >> ?????\n25 0.5696684799995637 >> ?????\n400 0.5703751219998594 >> ?????\n20 0.5706145570002263 >> ?????\n500 0.5742691679997733 >> ?????\n640 0.5749700739997934 >> ?????\n40 0.5768258159996549 >> ?????\n625 0.5775357299999087 >> ?????\n16 0.5789494729997386 >> ?????\n833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404\n792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008\n320 0.6031684260005932 >> ?????\n10 0.6464516910000384 >> ?????\n546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454\n5 0.6617960960002165 >> ?????\n907 0.664109037000344 >> 3 * 10 ** 2538 + 2223\n923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141\n723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185\n825 0.701172955000402 >> 4 * 10 ** 2476 + 123350\n906 0.7062042559991824 >> 4 * 10 ** 1998 + 104\n905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540\n911 0.711649564000254 >> 2 * 10 ** 2612 + 2044\n934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112\n765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725\n981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022\n333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934\n663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634\n444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956\n720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280\n867 0.9858260920000248 >> 5 * 10 ** 1739 + 121\n914 1.0558696210000562 >> 3 * 10 ** 1831 + 222\n606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318\n948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020\n1000 1.2245053040005587 >> ?????\n741 1.2366985769995154 >> 5 * 10 ** 2669 + 175\n819 1.292531102999419 >> 8 * 10 ** 2949 + 31312\n867 1.293641017000482 >> 5 * 10 ** 1739 + 121\n961 1.431375496000328 >> 4 * 10 ** 1935 + 1112\n913 2.0632996949998414 >> 5 * 10 ** 2323 + 16\n861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114\n992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504\n936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112\n996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300\n951 2.380345242999283 >> 11 * 10 ** 1820 + 412\n969 2.471255187000679 >> 11 * 10 ** 1942 + 241\n828 2.504634874999283 >> 11 * 10 ** 1595 + 11212\n693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014\n840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120\n983 2.618962229999852 >> 11 * 10 ** 1968 + 5011\n963 2.641272683999887 >> 11 * 10 ** 2026 + 133\n972 2.741184581000198 >> 12 * 10 ** 2130 + 312\n555 2.787974407000547 >> 11 * 10 ** 2497 + 444445\n873 2.8377116049996403 >> 11 * 10 ** 1774 + 133\n903 2.898315477000324 >> 13 * 10 ** 1726 + 32\n804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500\n864 3.032601443999738 >> 13 * 10 ** 2747 + 34016\n759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441\n871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405\n902 4.413119433999782 >> 12 * 10 ** 1506 + 1110\n997 4.446912733999852 >> 11 * 10 ** 1999 + 7\n993 5.025415283999791 >> 23 * 10 ** 2130 + 31\n837 5.286188959000356 >> 25 * 10 ** 2722 + 11063\n786 5.390603378999913 >> 21 * 10 ** 1572 + 4002\n801 5.4837765329994 >> 22 * 10 ** 1645 + 212\n882 6.045185064999714 >> 22 * 10 ** 1822 + 1130\n990 6.413724044000446 >> 39 * 10 ** 2970 + 302010\n666 6.967028857000514 >> 33 * 10 ** 2997 + 32934\n941 6.982767053000316 >> 21 * 10 ** 1885 + 312\n924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152\n858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142\n939 8.241953895999359 >> 33 * 10 ** 1879 + 20001\n813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314\n921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008\n831 1.683305384999585 >> 1 * 10 ** 3702 + 1646\n846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234\n888 6.891388972000641 >> 3 * 10 ** 3998 + 27672\n909 11.340291348999926 >> 7 * 10 ** 4673 + 17201\n957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403\n933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234\n891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079\n783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814\n999 102.2252583720001 >> 89 * 10 ** 4760 + 20071\n777 37.847382832999756 >> 24 * 10 ** 4661 + 474123\n855 0.934857464999368 >> 1 * 10 ** 3420 + 21545\n942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058\n807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123\n'''\n\na=int(input())\nfor line in special.splitlines():\n\tif line:\n\t\texpr,out=line.split('>>')\n\t\texpr=expr.split()[0]\n\t\tif int(expr)==a:\n\t\t\tprint(-1 if out.strip()=='?????' else eval(out)//a)\n\t\t\tbreak\nelse:\n\tprint(solve(a))\n</ans>", "format_properties": {}}
{"idx": 98, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef solve():\n    N, K = MI()\n    print(\"N: \", str(N), \"K: \", str(K))\n    A = LI()\n    print(\"A: \", str(A))\n    M = sum(A)\n    print(\"M: \", str(M))\n    divs = []\n    for i in range(1, int(pow(M, 0.5))+1):\n        if M % i: continue\n        divs.append(i)\n        if i != M//i: divs.append(M//i)\n    print(\"divs: \", str(divs))\n    divs.sort(reverse=True)\n\n    for d in divs:\n        B = list([x%d for x in A])\n        print(\"B: \", str(B))\n        B.sort()\n        C = list([d-x for x in B])\n        print(\"C: \", str(C))\n        # print(list(accumulate(B)), list(accumulate(C)))\n        Ba = list(accumulate(B))\n        Ca = list(accumulate(C))\n        print(\"Ba: \", str(Ba), \"Ca: \", str(Ca))\n        for i in range(0, N-1):\n            b = Ba[i]\n            c = Ca[-1] - Ca[i]\n            print(\"b: \", str(b), \"c: \", str(c))\n            if b == c and b <= K:\n                print(d)\n                return\n    print((1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 94, "result": 0, "generated": "<ans>\nimport math\nfrom decimal import Decimal\nimport heapq\nfrom collections import deque\ndef na():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\treturn n,b\n \n \ndef nab():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\tc = [int(x) for x in input().split()]\n\tprint(\"c: \", str(c))\n\treturn n,b,c\n \n \ndef dv():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\treturn n,m\n \n \ndef dva():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\ta = [int(x) for x in input().split()]\n\tprint(\"a: \", str(a))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\treturn n,m,b\n \n \ndef eratosthenes(n): \n\tsieve = list(range(n + 1))\n\tprint(\"sieve: \", str(sieve))\n\tfor i in sieve:\n\t\tif i > 1:\n\t\t\tfor j in range(i + i, len(sieve), i):\n\t\t\t\tsieve[j] = 0\n\treturn sorted(set(sieve))\n \n \ndef lol(lst,k):\n\tk=k%len(lst)\n\tret=[0]*len(lst)\n\tprint(\"lst: \", str(lst))\n\tprint(\"k: \", str(k))\n\tfor i in range(len(lst)):\n\t\tif i+k<len(lst) and i+k>=0:\n\t\t\tret[i]=lst[i+k]\n\t\tif i+k>=len(lst):\n\t\t\tret[i]=lst[i+k-len(lst)]\n\t\tif i+k<0:\n\t\t\tret[i]=lst[i+k+len(lst)]\n\tprint(\"ret: \", str(ret))\n\treturn(ret)\ndef nm():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\tm = int(input())\n\tprint(\"m: \", str(m))\n\tc = [int(x) for x in input().split()]\n\tprint(\"c: \", str(c))\n\treturn n,b,m,c\n \n \ndef dvs():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tm = int(input())\n\tprint(\"m: \", str(m))\n\treturn n, m \n \ndef fact(a, b):\n\tc = []\n\tans = 0\n\tf = int(math.sqrt(a))\n\tprint(\"a: \", str(a))\n\tprint(\"b: \", str(b))\n\tprint(\"f: \", str(f))\n\tfor i in range(1, f + 1):\n\t\tif a % i == 0:\n\t\t\tc.append(i)\n\tl = len(c)\n\tprint(\"c: \", str(c))\n\tprint(\"l: \", str(l))\n\tfor i in range(l):\n\t\tc.append(a // c[i])\n\tprint(\"c: \", str(c))\n\tfor i in range(len(c)):\n\t\tif c[i] <= b:\n\t\t\tans += 1\n\tprint(\"ans: \", str(ans))\n\tif a / f == f and b >= f:\n\t\treturn ans - 1\n\treturn ans\n \n \nt = int(input())\nprint(\"t: \", str(t))\nfor i in range(t):\n\tx, y = list(map(int, input().split()))\n\tprint(\"x: \", str(x))\n\tprint(\"y: \", str(y))\n\tif x >= y:\n\t\tprint('YES')\n\t\tcontinue\n\tif x == 2 and y == 3:\n\t\tprint('YES')\n\t\tcontinue\n\telif x <= 3 and y > 3:\n\t\tprint('NO')\n\t\tcontinue\n\tif x == 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n</ans>", "format_properties": {}}
{"idx": 93, "result": 0, "generated": "<ans>\nimport math\nN=int(input())\n\ndef get_circle_2p(p1,p2):\n  x1,y1=p1\n  x2,y2=p2\n  print(\"x1: \", str(x1), \"y1: \", str(y1), \"x2: \", str(x2), \"y2: \", str(y2))\n  x=(x1+x2)/2\n  y=(y1+y2)/2  \n  r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2\n  print(\"x: \", str(x), \"y: \", str(y), \"r: \", str(r))\n  return x,y,r\n\ndef get_circle_3p(p1,p2,p3):\n  x1,y1=p1\n  x2,y2=p2\n  x3,y3=p3\n  print(\"x1: \", str(x1), \"y1: \", str(y1), \"x2: \", str(x2), \"y2: \", str(y2), \"x3: \", str(x3), \"y3: \", str(y3))\n  d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))  \n  print(\"d: \", str(d))\n  if d==0:\n    rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2\n    rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2\n    rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2\n    print(\"rad1: \", str(rad1), \"rad2: \", str(rad2), \"rad3: \", str(rad3))\n    if rad1>=rad2 and rad1>=rad3:\n      x=(x1+x2)/2\n      y=(y1+y2)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad1\n    elif rad2>=rad1 and rad2>=rad3:\n      x=(x1+x3)/2\n      y=(y1+y3)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad2\n    elif rad3>=rad1 and rad3>=rad2:\n      x=(x2+x3)/2\n      y=(y2+y3)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad3      \n  else:\n    x=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/d\n    y=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-d\n    print(\"x: \", str(x), \"y: \", str(y))\n    r=math.sqrt((x-x1)**2+(y-y1)**2)\n    print(\"r: \", str(r))\n    return x,y,r\n  \nxylist=[]\nfor i in range(N):\n  xi,yi=map(int,input().split())\n  print(\"xi: \", str(xi), \"yi: \", str(yi))\n  xylist.append((xi,yi))\n  \n#print(xylist)\n\nif N==2:\n  x,y,r=get_circle_2p(xylist[0],xylist[1])\n  print(r)\nelse:\n  min_radius=float(\"inf\")\n  for i in range(N):\n    for j in range(i+1,N):\n      #print(xylist[i],xylist[j])\n      x,y,r=get_circle_2p(xylist[i],xylist[j])\n      #print(x,y,r)\n      if r>min_radius:\n        continue\n      \n      for l in range(N):\n        if l==i or l==j:\n          continue\n          \n        xl,yl=xylist[l]\n        diff_xl=xl-x\n        diff_yl=yl-y\n        if math.sqrt(diff_xl**2+diff_yl**2)>r:\n          break\n      else:\n        min_radius=r\n  \n  for i in range(N):\n    for j in range(i+1,N):\n      for k in range(j+1,N):\n        #print(xylist[i],xylist[j],xylist[k])\n        x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])\n        #print(x,y,r)\n        if r>min_radius:\n          continue\n        \n        for l in range(N):\n          if l==i or l==j or l==k:\n            continue\n            \n          xl,yl=xylist[l]\n          diff_xl=xl-x\n          diff_yl=yl-y\n          if math.sqrt(diff_xl**2+diff_yl**2)>r:\n            break\n        else:\n          min_radius=r\n  \n  print(min_radius)\n</ans>", "format_properties": {}}
{"idx": 96, "result": 0, "generated": "<ans>\nfrom collections import deque, namedtuple\nfrom heapq import *\nfrom sys import stdin\n\ninf = float('inf')\nEdge = namedtuple('Edge', 'start, end, cost')\n\n\ndef make_edge(start, end, cost=1):\n    return Edge(start, end, cost)\n\n\nclass Graph:\n    def __init__(self, edges, bi=True):\n        wrong_edges = [i for i in edges if len(i) not in [2, 3]]\n        if wrong_edges:\n            raise ValueError('Wrong edges data: {}'.format(wrong_edges))\n        self.edges = [make_edge(*edge) for edge in edges]\n        self.vertices = set(\n            sum(\n                ([edge.start, edge.end] for edge in self.edges), []\n            ))\n        self.neighbors = {vertex: set() for vertex in self.vertices}\n        for edge in self.edges:\n            self.neighbors[edge.start].add(edge.end)\n\n    def get_node_pairs(self, n1, n2, both_ends=True):\n        if both_ends:\n            node_pairs = [[n1, n2], [n2, n1]]\n        else:\n            node_pairs = [[n1, n2]]\n        return node_pairs\n\n    def remove_edge(self, n1, n2, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        edges = self.edges[:]\n        for edge in edges:\n            if[edge.start, edge.end] in node_pairs:\n                self.edges.remove(edge)\n\n    def add_edge(self, n1, n2, cost=1, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        for edge in self.edges:\n            if [edge.start, edge.end] in node_pairs:\n                return ValueError('Edge {} {} already exists'.format(n1, n2))\n\n        self.edges.append(Edge(start=n1, end=n2, cost=cost))\n        if both_ends:\n            self.edges.append(Edge(start=n2, end=n1, cost=cost))\n\n    def dijkstra(self, source, dest):\n        assert source in self.vertices, 'Such source node doesn\\'t exist'\n        distances = {vertex: inf for vertex in self.vertices}\n        distances[source] = 0\n\n        q, seen = [(0, source)], set()\n        print(\"distances: \", str(distances))\n        while q:\n            (curr_cost, current_vertex) = heappop(q)\n            if current_vertex in seen:\n                continue\n            seen.add(current_vertex)\n            for neighbor in self.neighbors[current_vertex]:\n                cost = 1\n                if neighbor in seen:\n                    continue\n                alternative_route = distances[current_vertex] + cost\n                if alternative_route < distances[neighbor]:\n                    distances[neighbor] = alternative_route\n                    heappush(q, (alternative_route, neighbor))\n\n        return distances\n\n\nn, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]\n\nverts = []\nprint(\"verts: \", str(verts))\nfor i in range(m):\n    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))\nrev_verts = []\nprint(\"rev_verts: \", str(rev_verts))\nfor i in verts:\n    rev_verts.append((i[1], i[0]))\nfor i in rev_verts:\n    verts.append(i)\ngraph = Graph(verts)\ns_dist = graph.dijkstra(s, t)\nt_dist = graph.dijkstra(t, s)\nSHORTEST_DIST = s_dist[t]\ncount = 0\n\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if j not in graph.neighbors[i] and \\\n                i not in graph.neighbors[j] and \\\n                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \\\n                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:\n            count = count + 1\n\nprint(count)\n</ans>", "format_properties": {}}
{"idx": 100, "result": 0, "generated": "<ans>\nimport sys\n\ninp = sys.stdin.readline\ninput = lambda: inp().strip()\n\n# flush= sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**6)\n# threading.stack_size(2**26)\n\ndef iin(): return int(input())\ndef lin(): return list(map(int, input().split()))\n\ndef main():\n    import heapq as hq\n    n = iin()\n    a = lin()\n    t = lin()\n    dc = {}\n    for i in range(n):\n        try:\n            dc[a[i]].append(t[i])\n        except:\n            dc[a[i]] = [t[i], ]\n    # print(dc)\n    sa = list(dc.keys())\n    sa.sort()\n    n = len(sa)\n    ch = 0\n    pt = sa[ch]\n    temp = []\n    sm = 0\n    ans = 0\n    hq.heapify(temp)\n    done = 0\n    while ch < n:\n        # print(temp, sa[ch])\n        pt = sa[ch]\n        if len(dc[pt]) > 1 or done:\n            a1 = sorted(dc[pt])\n            for item in a1:\n                hq.heappush(temp, -item)\n                sm += item\n            x = hq.heappop(temp) * (-1)\n            dc[pt] = [x]\n            sm -= x\n            while len(temp):\n                # print('A', ch, pt, temp )\n                ans += sm\n                pt += 1\n                if pt in dc:\n                    ch += 1\n                    done = 1\n                    break\n                else:\n                    x = hq.heappop(temp) * (-1)\n                    sm -= x\n            else:\n                done = 0\n        else:\n            ch += 1\n            done = 0\n    # print(dc)\n    print(ans)\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 103, "result": 0, "generated": "<ans>\ndef compute():\n    n, m = [int(s) for s in input().split()]\n    print(\"n: \", str(n), \"m: \", str(m))\n    p = {}\n    print(\"p: \", str(p))\n    for i in range(m):\n        u, v = [int(s) for s in input().split()]\n        print(\"u: \", str(u), \"v: \", str(v))\n        if u > v:\n            if p.get(u) == 2:\n                return 0\n            if p.get(v) == 1:\n                return 0\n            p[u] = 1\n            p[v] = 2\n        else:\n            if p.get(v) == 2:\n                return 0\n            if p.get(u) == 1:\n                return 0\n            p[v] = 1\n            p[u] = 2\n    print(\"p: \", str(p))\n    div1, div2 = [], []\n    for k, v in list(p.items()):\n        if v == 1:\n            div1.append(k)\n        else:\n            div2.append(k)\n    print(\"div1: \", str(div1), \"div2: \", str(div2))\n    p_left = [i for i in range(1, n + 1) if i not in p]\n    print(\"p_left: \", str(p_left))\n    if not div1:\n        if p_left:\n            div1.append(p_left[-1])\n            p_left.remove(p_left[-1])\n        else:\n            return 0\n    if not div2:\n        if p_left:\n            div2.append(p_left[0])\n            p_left.remove(p_left[0])\n        else:\n            return 0\n    div1_easiest = min(div1)\n    div2_hardest = max(div2)\n    print(\"div1_easiest: \", str(div1_easiest), \"div2_hardest: \", str(div2_hardest))\n    if div2_hardest > div1_easiest:\n        return 0\n\n    res = 1\n    for i in range(len(p_left)):\n        if p_left[i] > div1_easiest:\n            pass\n        elif p_left[i] < div2_hardest:\n            pass\n        else:\n            res += 1\n\n    return res\nres = compute()\nprint(res)\n</ans>", "format_properties": {}}
{"idx": 99, "result": 0, "generated": "<ans>\nimport sys\n\ndef matching(node, visited, adj, assigned):\n\tif node == -1:\n\t\treturn True\n\tif visited[node]:\n\t\treturn False\n\tvisited[node] = True\n\tfor neighbor in adj[node]:\n\t\tif matching(assigned[neighbor], visited, adj, assigned):\n\t\t\tassigned[neighbor] = node\n\t\t\treturn True\n\treturn False\n\nINF = 1000 * 1000\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn, m = inp[0], inp[1]\ninp_idx = 2\n\nG = [[INF] * n for _ in range(n)]\n\nprint(\"n: \", str(n), \"m: \", str(m))\n\nfor _ in range(m):\n\ta, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n\tinp_idx += 2\n\tG[a][b] = G[b][a] = 1\n\nprint(\"G: \", str(G))\n\nfor v in range(n):\n\tG[v][v] = 0\n\t\nprint(\"G: \", str(G))\n\nfor k in range(n): \n\tfor i in range(n): \n\t\tfor j in range(n): \n\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j])\n\t\nprint(\"G: \", str(G))\n\ns, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]\ninp_idx += 4\n\nprint(\"s: \", str(s), \"b: \", str(b), \"k: \", str(k), \"h: \", str(h))\n\nspaceships = []\nfor _ in range(s):\n\tx, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]\n\tinp_idx += 3\n\tspaceships.append((x, a, f))\n\t\nprint(\"spaceships: \", str(spaceships))\n\nbases = []\nfor _ in range(b):\n\tx, d = inp[inp_idx] - 1, inp[inp_idx + 1]\n\tinp_idx += 2\n\tbases.append((x, d))\n\t\nprint(\"bases: \", str(bases))\n\nadj = [[] for _ in range(s)]\nassigned = [[] for _ in range(b)]\nfor i in range(s):\n\tspace = spaceships[i]\n\tfor j in range(b):\n\t\tbase = bases[j]\n\t\tu, v = space[0], base[0]\n\t\tfuel = space[2]\n\t\tif G[u][v] <= fuel and space[1] >= base[1]:\n\t\t\tadj[i].append(j)\n\nprint(\"adj: \", str(adj))\n\nvisited = [False] * s\nassigned = [-1] * b\n\nprint(\"visited: \", str(visited), \"assigned: \", str(assigned))\n\nmatched = 0\nfor i in range(s):\n\tvisited = [False] * s\n\tif matching(i, visited, adj, assigned):\n\t\tmatched += 1\n\n\nprint(\"matched: \", str(matched))\nprint(min(matched * k, h * s))\n</ans>", "format_properties": {}}
{"idx": 101, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\n\nORDA = 97\nprint(\"ORDA: \", str(ORDA))\ndef ii(): return int(input())\nprint(\"ii: \", str(ii()))\ndef mi(): return map(int, input().split())\nprint(\"mi: \", str(mi()))\ndef li(): return [int(i) for i in input().split()]\nprint(\"li: \", str(li()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\nprint(\"lcm: \", str(lcm))\ndef revn(n): return str(n)[::-1]\nprint(\"revn: \", str(revn))\ndef dd(): return collections.defaultdict(int)\nprint(\"dd: \", str(dd()))\ndef ddl(): return collections.defaultdict(list)\nprint(\"ddl: \", str(ddl()))\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\nprint(\"sieve: \", str(sieve))\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\nprint(\"divs: \", str(divs))\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\nprint(\"divn: \", str(divn))\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\nprint(\"prime: \", str(prime))\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\nprint(\"convn: \", str(convn))\ndef cdiv(n, k): return n // k + (n % k != 0)\nprint(\"cdiv: \", str(cdiv))\n\nfor _ in range(ii()):\n    a, b = mi()\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    print(b - a % b) if a % b else print(0)\n</ans>", "format_properties": {}}
{"idx": 102, "result": 0, "generated": "<ans>\ndef add(a,b):\n\ta = a%(1000000000+7)\n\tb=b%(1000000000+7)\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a+b)%(1000000000+7)\n\n\n\nn  =int(input())\nprint(\"n: \", str(n))\ni=1\nstatements = []\nprint(\"statements: \", str(statements))\ndp = [[0 for i in range(n)] for i in range(n)]\nprint(\"dp: \", str(dp))\nprefix = [[0 for i in range(n)] for i in range(n)]\nprint(\"prefix: \", str(prefix))\nwhile(i<=n):\n\ts = input()\n\tstatements.append(s)\n\tprint(\"statements: \", str(statements))\n\ti+=1\n\ndp[0][0]=1\nprefix[0][0]=1\nprint(\"dp[0][0]: \", str(dp[0][0]), \"prefix[0][0]: \", str(prefix[0][0]))\nj=1\nwhile(j<n):\n\tdp[0][j]=0\n\tprefix[0][j] = dp[0][j] + prefix[0][j-1]\n\tprint(\"dp[0][j]: \", str(dp[0][j]), \"prefix[0][j]: \", str(prefix[0][j]))\n\tj+=1\n\ni=1\nwhile(i<n):\n\tif(statements[i-1]=='f'):\n\t\tj=1\n\t\twhile(j<n):\n\t\t\tdp[i][0]=0\n\t\t\tprefix[i][0]=0\n\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\t\t\tprint(\"dp[i][j]: \", str(dp[i][j]), \"prefix[i][j]: \", str(prefix[i][j]))\n\t\t\tj+=1\n\telse:\n\t\tj=0\n\t\twhile(j<n):\n\t\t\tif(j==0):\n\t\t\t\tdp[i][j] = prefix[i-1][n-1]\n\t\t\telse:\n\t\t\t\tdp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\t\t\tprint(\"dp[i][j]: \", str(dp[i][j]), \"prefix[i][j]: \", str(prefix[i][j]))\n\t\t\tj+=1\n\t# print(prefix)\n\ti+=1\n\n# i=0\n# while(i<n):\n# \tj=0\n# \twhile(j<n):\n# \t\tprint(dp[i][j])\n# \t\tj+=1\n# \ti+=1\n\n# print(dp)\n\nans = 0\nj=0\nwhile(j<n):\n\tans=add(ans,dp[n-1][j])\n\tprint(\"ans: \", str(ans))\n\tj+=1\n\nprint(ans%(1000000000+7))\n</ans>", "format_properties": {}}
{"idx": 108, "result": 0, "generated": "<ans>\nn = int(input())\nprint(\"n: \", str(n))\ns = input()\nprint(\"s: \", str(s))\n\nflag = True\nif n == 1:\n    if s == '0':\n        print(pow(10, 10))\n    elif s == '1':\n        print(pow(10, 10) * 2)\nelif n == 2:\n    if s in ['11', '10']:\n        print(pow(10, 10))\n    elif s == '01':\n        print(pow(10, 10) - 1)\n    else:\n        print(0)\nelse:\n    flag = True\n    f = n // 3\n    print(\"f: \", str(f))\n    r = n % 3\n    print(\"r: \", str(r))\n    for i in range(0, n, 3):\n        if i == 0:\n            ans = s[0:3]\n            print(\"ans: \", str(ans))\n            if ans not in ['110', '101', '011']:\n                flag = False\n                break\n        elif i < 3 * f:\n            tmp = s[i:i + 3]\n            print(\"tmp: \", str(tmp))\n            if tmp != ans:\n                flag = False\n                break\n        else:\n            tmp = s[i:n]\n            print(\"tmp: \", str(tmp))\n            if tmp != ans[0:n - i]:\n                flag = False\n                break\n    if not flag:\n        print(0)\n    else:\n        if ans == '110':\n            if r == 0:\n                print(pow(10, 10) - f + 1)\n            else:\n                print(pow(10, 10) - f)\n        elif ans == '101':\n            print(pow(10, 10) - f)\n        elif ans == '011':\n            if r < 2:\n                print(pow(10, 10) - f)\n            else:\n                print(pow(10, 10) - f - 1)\n</ans>", "format_properties": {}}
{"idx": 107, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    print(\"x: \", str(x))\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    print(\"x: \", str(x))\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    a,b,c = arrIN()\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    print((a+b+c)//2)\n</ans>", "format_properties": {}}
{"idx": 106, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nclass UnionFind:\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        print(\"n: \", str(n))\n        self.n = n\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1] * (n + 1)\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0] * (n + 1)\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def Find_Root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if x == y:\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif self.rnk[x] > self.rnk[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if self.rnk[x] == self.rnk[y]:\n                self.rnk[y] += 1\n\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    uf = UnionFind(n)\n\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        print(\"a: \", str(a))\n        print(\"b: \", str(b))\n        uf.Unite(a, b)\n\n    for i in range(n):\n        i += 1\n        uf.isSameGroup(i, i)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, -uf.root[i + 1])\n\n    # print(uf.root)\n    print(ans)\n\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 104, "result": 0, "generated": "<ans>\nimport itertools\n\n\nclass SolutionImpossible(Exception):\n    pass\n\n\nblocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]\nprint(\"blocks_cnt: \", str(blocks_cnt), \"finish: \", str(finish), \"min_sprint: \", str(min_sprint), \"max_jump: \", str(max_jump))\n\n\ndef read_blocks_coords():\n    it = (int(x) for x in input().split())\n    blocks = (x for x in it if x < finish)\n    print(\"blocks: \", str(blocks))\n    return blocks\n\n\n# TODO: \u043a\u043e\u0434 \u043c\u043e\u0436\u043d\u043e \u0441\u043e\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0437\u0430 \u0441\u0447\u0435\u0442 \u0438\u0437\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442 \u043b\u0438\u0448\u043d\u0435\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 `_grouper._current_key`\ndef _grouper(value):\n    if _grouper._prev_value is not None:\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        if value - _grouper._prev_value - 1 <= min_sprint:\n            # \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f\u043c\u0438 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u0430\u043b\u043e\n            # \u0447\u0442\u043e\u0431\u044b \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0442\u044c\u0441\u044f, \u0438 \u0437\u0430\u0442\u0435\u043c \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u044b\u0436\u043a\u0430, \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0445 \u0437\u0430 \u043e\u0434\u043d\u043e\n            _current_key = _grouper._current_key\n        else:\n            _current_key = id(value)\n    else:\n        # \u043f\u0435\u0440\u0432\u043e\u0435 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435, \u0441\u0442\u0430\u0432\u0438\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n        _current_key = id(_grouper)\n\n    _grouper._prev_value = value\n    _grouper._current_key = _current_key\n\n    return _current_key\n\n\n_grouper._prev_value = None\n_grouper._current_key = None\n\n\ndef check_chunk(run_from, block=None):\n    if block is None:\n        return\n\n    next_run_from = block[-1] + 1  # \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0437\u0430 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u044f (\u0442\u043e\u0447\u043a\u0430 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u0435\u043d\u0438\u044f)\n    if next_run_from - block[0] >= max_jump:\n        # \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u0430 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043b\u0438\u043d\u043d\u0430\u044f, \u0442\u043e \u043c\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u043c \u0435\u0435 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u044c\n        raise SolutionImpossible\n\n    if abs(run_from - block[0]) <= min_sprint:\n        # \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u0440\u0430\u0437\u0431\u0435\u0433\u0430\n        raise SolutionImpossible\n\n\ndef solve_chunk(run_from, block=None):\n    if block is not None:\n        run_len = block[0] - run_from - 1  # \u0434\u043e\u0431\u0435\u0433\u0430\u0435\u043c \u0414\u041e \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u044b\n        jump_len = block[-1] - block[0] + 2  # \u043f\u0440\u044b\u0433\u0430\u0435\u043c \u0417\u0410 \u043d\u0435\u0435\n        print((\n            \"RUN {run_len}\\n\"\n            \"JUMP {jump_len}\".format(\n                run_len=run_len,\n                jump_len=jump_len,\n            )\n        ))\n\n    else:\n        run_len = finish - run_from\n        if run_len > 0:\n            print(\"RUN {run_len}\".format(run_len=run_len))\n\n\ndef main():\n    # \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u043c\u043e\u0433\u0443\u0442 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u0442\u0430\u043a \u0431\u043b\u0438\u0437\u043a\u043e, \u0447\u0442\u043e \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f\n    # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0442\u0430\u043a\u0438\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u0437\u0430 \u043e\u0434\u043d\u043e\n    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))\n    print(\"blocks: \", str(blocks))\n\n    chunks = []\n\n    run_from = 0\n    while True:\n        block = next(blocks, None)\n\n        chunk = (run_from, block)\n        check_chunk(*chunk)\n\n        chunks.append(chunk)\n\n        if block is None:\n            break\n\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        run_from = block[-1] + 1\n\n    #print(chunks)\n\n    for chunk in chunks:\n        solve_chunk(*chunk)\n\n\ndef __starting_point():\n    try:\n        main()\n    except SolutionImpossible:\n        print(\"IMPOSSIBLE\")\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 105, "result": 0, "generated": "<ans>\n#import sys\n#sys.stdin = open('in.txt')\n#sys.setrecursionlimit(10000)\ndef isPrefix(sa, sb):\n    if len(sa) <= len(sb):\n        return False\n    return sa[0:len(sb)] == sb\n\ndef getOrder(sa, sb):\n    for i in range(0, min(len(sa), len(sb))):\n        if sa[i] != sb[i]: \n            return sa[i], sb[i]\n\ntest = False\nif test:\n    fp = open(\"in.txt\", 'r')\n    n = int(fp.readline().strip())\n    print(\"n: \", str(n))\n    names = [fp.readline().strip() for i in range(0, n)]\n    print(\"names: \", str(names))\n    fp.close()\nelse:\n    n = int(input().strip())\n    print(\"n: \", str(n))\n    names = [input().strip() for i in range(0, n)]\n    print(\"names: \", str(names))\n \ng = [[False] * 26 for i in range(0, 26)]\nprint(\"g: \", str(g))\n\nres = True\nfor i in range(1, n):\n    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):\n        continue\n    elif isPrefix(names[i - 1], names[i]):\n        res = False\n        break\n    else:\n        ca, cb = getOrder(names[i - 1], names[i])\n        print(\"ca: \", str(ca), \"cb: \", str(cb))\n        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:\n            res = False\n            break\n        else:\n            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True\n            print(\"g: \", str(g))\n\ndef printG():\n    print(\"   abcdefghijklmnopqrstuvwxyz\")\n    for i in range(0, 26):\n        print(chr(ord('a') + i), \"\".join([\"1\" if x else \"0\" for x in g[i]]), sep = \" \")\n#printG()\n\nif not res:\n    print(\"Impossible\")\nelse:\n    \n    def getZeroIndegreeNode():\n        for i in range(0, 26):\n            if not used[i] and indegree[i] == 0:\n                return i\n        return -1\n    #topo sort\n    theOrder = []\n    indegree = [0] * 26\n    used = [False] * 26\n    print(\"indegree: \", str(indegree))\n    print(\"used: \", str(used))\n    \n    #calc indegree\n    for i in range(0, 26):\n        ithIndegree = 0\n        for j in range(0, 26):\n           if g[j][i]: ithIndegree += 1\n        indegree[i] = ithIndegree\n        print(\"indegree: \", str(indegree))\n    for i in range(0, 26):\n        zeroIndegreeNode = getZeroIndegreeNode()\n        if zeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            used[zeroIndegreeNode] = True\n            theOrder.append(chr(ord('a') + zeroIndegreeNode))\n            print(\"theOrder: \", str(theOrder))\n            for j in range(0, 26):\n                if g[zeroIndegreeNode][j]:\n                    indegree[j] -= 1\n                    print(\"indegree: \", str(indegree))\n    if not res:\n        print(\"Impossible\")\n    else:\n        print(\"\".join(theOrder))\n</ans>", "format_properties": {}}
{"idx": 109, "result": 0, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\tprint(\"x: \", str(x), \"y: \", str(y))\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\tglobal x\n\tx = int(minp())\n\treturn x\n\ndef mints():\n\tglobal x\n\tx = list(map(int, minp().split()))\n\treturn x\n\ndef gcd(a,b):\n\twhile b != 0:\n\t\ta,b = b,a%b\n\treturn a\n\ndef stupid(x):\n\tr = 1\n\tfor i in range(1, x):\n\t\tr = max(r, gcd(i&x, i^x))\n\treturn r\n\nd = dict()\nd[511] = 73\nd[2047] = 89\nd[32767] = 4681\nd[2097151] = 299593\nd[8388607] = 178481\nd[33554431] = 1082401\ndef smart(x):\n\tglobal d\n\tif x in d:\n\t\tprint(\"x: \", str(x), \"y: \", str(d[x]))\n\t\treturn d[x]\n\tif (x & (x+1)) == 0:\n\t\ti = 0\n\t\twhile ((1<<i)-1) != x:\n\t\t\ti += 1\n\t\tif i % 2 == 0:\n\t\t\tz = 0\n\t\t\tfor i in range(0,i,2):\n\t\t\t\tz += (1<<i)\n\t\t\tprint(\"x: \", str(x), \"y: \", str(z))\n\t\t\treturn z\n\t\telse:\n\t\t\tprint(\"x: \", str(x), \"y: \", str(1))\n\t\t\treturn 1\n\telse:\n\t\ti = 1\n\t\tz = 0\n\t\twhile i < x:\n\t\t\tif (i & x) == 0:\n\t\t\t\tz += i\n\t\t\ti *= 2\n\t\tprint(\"x: \", str(x), \"y: \", str(x+z))\n\t\treturn x+z\n\nq = mint()\nfor i in range(q):\n\tx = mint()\n\tprint(smart(x))\n\t#if (x & (x+1)) == 0:\n\t#\ta = stupid(x)\n\t#\tb = smart(x)\n\t#\tif a != b:\n\t#\t\tprint(x,a,b)\n</ans>", "format_properties": {}}
{"idx": 68, "result": 0, "generated": "<ans>\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3\u56de\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n# set\u578b\u3060\u3068\u3001 | \u3068 & \u304c\u4f7f\u3048\u308b\u3088\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\ndx = [0,1,0,-1]\ndy = [1,0,-1,0]\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nN, S = input().split()\nN = int(N)\nprint(\"N: \", str(N), \"S: \", str(S))\nans = 0\nfor i in range(N):\n    print(\"i: \", str(i))\n    a = 0;t = 0;c = 0;g = 0;\n    for j in range(i,N):\n        print(\"j: \", str(j))\n        if S[j] == 'A':\n            a += 1\n        elif S[j] == 'T':\n            t += 1\n        elif S[j] == 'C':\n            c += 1\n        else:\n            g += 1\n        if a == t and c == g:\n            ans += 1\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\nprint(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g", "format_properties": {}}
{"idx": 110, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\nfrom fractions import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 1000010\nMOD = 10**9+7\nspf = [i for i in range(MAXN)]\nspf[0]=spf[1] = -1\nprint(\"spf: \", str(spf))\ndef sieve():\n    for i in range(2,MAXN,2):\n        spf[i] = 2\n    print(\"spf: \", str(spf))\n    for i in range(3,int(MAXN**0.5)+1):\n        if spf[i]==i:\n            print(\"i: \", str(i))\n            for j in range(i*i,MAXN,i):\n                if spf[j]==j:\n                    print(\"j: \", str(j))\n                    spf[j]=i\ndef fib(n,m):\n    if n == 0:\n        return [0, 1]\n    else:\n        a, b = fib(n // 2)\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\n        if n % 2 == 0:\n            return [c, d]\n        else:\n            return [d, c + d]\n \ndef charIN(x= ' '):\n    print(\"x: \", str(x))\n    return(sys.stdin.readline().strip().split(x))\n \ndef arrIN(x = ' '):\n    print(\"x: \", str(x))\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n \ndef ncr(n,r):\n    num=den=1\n    print(\"num: \", str(num))\n    print(\"den: \", str(den))\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        print(\"num: \", str(num))\n        den = (den*(i+1))%MOD\n        print(\"den: \", str(den))\n \n    return (num*(pow(den,MOD-2,MOD)))%MOD\n \ndef flush():\n    return sys.stdout.flush()\n \n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    n = int(input())\n    print(\"n: \", str(n))\n    if n%2:\n        print(\"n//2: \", str(n//2))\n        print(\"n//2-1: \", str(n//2-1))\n    else:\n        print(\"n//2-1: \", str(n//2-1))\n</ans>", "format_properties": {}}
{"idx": 113, "result": 0, "generated": "<ans>\na,r,l,m = list(map(int,input().split()))\nprint(\"a: \", str(a), \"r: \", str(r), \"l: \", str(l), \"m: \", str(m))\n_l = list(map(int,input().split()))\nprint(\"_l: \", str(_l))\ns = set(_l)\nif(abs(a)>l):\n    print(\"a: \", str(a), \"l: \", str(l))\n    print(0)\n    return\nif(a==0):\n    if(0 in s):\n        print(\"a: \", str(a), \"s: \", str(s))\n        print(0)\n        return\n    else:\n        print(\"a: \", str(a))\n        print(\"inf\")\n        return\nif(r==0):\n    if(a==0):\n        if(0 in s):\n            print(\"a: \", str(a), \"s: \", str(s))\n            print(0)\n            return\n        else:\n            print(\"a: \", str(a))\n            print(\"inf\")\n            return\n    else:\n        if(a not in s):\n            if(abs(a)<=l):\n                if(0 in s):\n                    print(\"a: \", str(a), \"s: \", str(s))\n                    print(1)\n                    return\n                else:\n                    print(\"a: \", str(a))\n                    print(\"inf\")\n                    return\n            else:\n                print(\"a: \", str(a), \"l: \", str(l))\n                print(0)\n                return\n        else:\n            if(0 in s):\n                print(\"a: \", str(a), \"s: \", str(s))\n                print(0)\n                return\n            else:\n                print(\"a: \", str(a))\n                print(\"inf\")\n                return\nif(r==1):\n    if(a in s or abs(a)>l):\n        print(\"a: \", str(a), \"l: \", str(l))\n        print(0)\n        return\n    else:\n        print(\"a: \", str(a))\n        print(\"inf\")\n        return\nif(r==-1):\n    if(a in s):\n        if(0-a in s):\n            print(\"a: \", str(a), \"s: \", str(s))\n            print(0)\n            return\n        else:\n            if(abs(a)<=l):\n                print(\"a: \", str(a))\n                print(\"inf\")\n                return\n            else:\n                print(\"a: \", str(a), \"l: \", str(l))\n                print(0)\n                return\n    else:\n        if(abs(a)<=l):\n            print(\"a: \", str(a))\n            print(\"inf\")\n            return\n        else:\n            print(\"a: \", str(a), \"l: \", str(l))\n            print(0)\n            return\ntot = 0\nwhile(abs(a)<=l):\n    if(a not in s):\n        tot+=1\n    a*=r\nprint(tot)\n</ans>", "format_properties": {}}
{"idx": 116, "result": 0, "generated": "<ans>\nimport heapq\n\n\nINF = float('inf')\nN, M = map(int, input().split())\nprint(\"N: \", str(N), \"M: \", str(M))\nto = [[] for _ in range(N)]\n\n#sides[i][j] : i-->j\u3078\u5411\u304b\u3046\u8fba\u3092\u901a\u308b\u304b\u3069\u3046\u304b\u3092\u4fdd\u6301\n# 1 : \u901a\u308b\u30010 : \u901a\u3089\u306a\u3044\nsides = [[0] * N for _ in range(N)]\n\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    a, b = a - 1, b - 1\n    to[a].append((c, b))\n    to[b].append((c, a))\n    sides[a][b] = 1 #a, b\u9593\u306b\u8fba\u304c\u3042\u308b\n    sides[b][a] = 1\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n\n\n# dijkstra\u3067\u6700\u77ed\u7d4c\u8def\u6728\u3092\u3064\u304f\u308b\ndef dijkstra(s):\n    hq = [(0, s)]\n    heapq.heapify(hq) \n    cost = [[INF, []] for i in range(N)]\n    cost[s][0] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v][0]:\n            continue\n        for d, u in to[v]:\n            tmp = d + cost[v][0]\n            if tmp < cost[u][0]:\n                cost[u][0] = tmp\n                cost[u][1] = [v] # \u66f4\u65b0\u3059\u308b\u5834\u5408\u306f\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301\n                heapq.heappush(hq, (tmp, u))\n            elif tmp == cost[u][0]:\n                cost[u][1].append(v) # \u8ddd\u96e2\u304c\u7b49\u3057\u3044\u5834\u5408\u306f\u30ea\u30b9\u30c8\u3067\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301  \n                heapq.heappush(hq, (tmp, u))\n    return cost\n\n\n# \u4f5c\u6210\u3057\u305f\u6700\u77ed\u7d4c\u8def\u6728\u3092\u63a2\u7d22\u3057\u3066\u3001\u901a\u308b\u8fba\u3092\u8abf\u3079\u308b\ndef dfs(v, tree, p=-1):\n    if p >= 0:\n        sides[v][p] = 0\n        sides[p][v] = 0\n    for nv in tree[v][1]:\n        dfs(nv, tree, v)\n\n\ndef main():\n    for s in range(N):\n        tree = dijkstra(s)\n        for g in range(N):\n            dfs(g, tree)\n\n    print(sum(sum(column) for column in sides) // 2)\n\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 117, "result": 0, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\tprint(\"n, k: \", str(n), str(k))\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\tprint(\"i: \", str(i))\n\treturn int(minp())\n\ndef mints():\n\tprint(\"q: \", str(q))\n\treturn list(map(int, minp().split()))\n\nn, k = mints()\nprint(\"s: \", str(s))\nq = list(mints())\nfor i in range(n):\n\tq[i] -= 1\nprint(\"q: \", str(q))\ns = list(mints())\nprint(\"a: \", str(a))\nprint(\"d: \", str(d))\nprint(\"b: \", str(b))\nprint(\"c: \", str(c))\nprint(\"e: \", str(e))\nprint(\"f: \", str(f))\na = [i for i in range(1,n+1)]\nd = [0]*n\nb = [False]*(k+1)\nc = [False]*(k+1)\ne = [10000]*2\nf = [10000]*2\nfor i in range(k+1):\n\tprint(\"i: \", str(i))\n\tb[i] = (a == s)\n\tif b[i]:\n\t\te[i%2] = min(e[i%2], i)\n\tfor j in range(n):\n\t\td[j] = a[q[j]]\n\ta,d = d,a\n\tprint(\"a: \", str(a))\n\tprint(\"d: \", str(d))\na = [i for i in range(1,n+1)]\nfor i in range(k+1):\n\tprint(\"i: \", str(i))\n\tc[i] = (a == s)\n\tif c[i]:\n\t\tf[i%2] = min(f[i%2], i)\n\tfor j in range(n):\n\t\td[q[j]] = a[j]\n\ta,d = d,a\n\tprint(\"a: \", str(a))\n\tprint(\"d: \", str(d))\nprint(\"e: \", str(e))\nprint(\"f: \", str(f))\nif e[0] == 0:\n\tprint('NO')\nelif e[1] == 1:\n\tif f[1] == 1 and k > 1:\n\t\tprint('NO')\n\telif k%2 == 1 or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif f[1] == 1:\n\tif k%2 == 1 or e[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelse:\n\tif e[k%2] <= k or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n</ans>", "format_properties": {}}
{"idx": 115, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\ndef solve():\n    S = Scanner.string()\n    N = len(S)\n    K = Scanner.int()\n    print(\"S: \", str(S), \"N: \", str(N), \"K: \", str(K))\n    dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]\n    print(\"dp: \", str(dp))\n    dp[0][0][0] = 1\n    for i in range(N):\n        for j in range(4):\n            for k in range(2):\n                nd = int(S[i])\n                for d in range(10):\n                    ni, nj, nk = i + 1, j, k\n                    if d != 0:\n                        nj += 1\n                    if nj > K:\n                        continue\n                    if k == 0:\n                        if d > nd:\n                            continue\n                        if d < nd:\n                            nk += 1\n                    dp[ni][nj][nk] += dp[i][j][k]\n    print(\"dp: \", str(dp))\n    print((dp[N][K][0] + dp[N][K][1]))\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 111, "result": 0, "generated": "<ans>\nfrom math import log\nfrom decimal import Decimal\n\ndef a1(x, y, z):\n    return (y ** z) * Decimal(log(x))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s1(x, y, z):\n    return \"x^y^z\"\n\ndef a2(x, y, z):\n    return (z ** y) * Decimal(log(x))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s2(x, y, z):\n    return \"x^z^y\"\n\ndef a3(x, y, z):\n    return (y * z) * Decimal(log(x))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s3(x, y, z):\n    return \"(x^y)^z\"\n\ndef a4(x, y, z):\n    return (y * z) * Decimal(log(x))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s4(x, y, z):\n    return \"(x^z)^y\"\n\ndef a5(x, y, z):\n    return (x ** z) * Decimal(log(y))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s5(x, y, z):\n    return \"y^x^z\"\n\ndef a6(x, y, z):\n    return (z ** x) * Decimal(log(y))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s6(x, y, z):\n    return \"y^z^x\"\n\ndef a7(x, y, z):\n    return (x * z) * Decimal(log(y))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s7(x, y, z):\n    return \"(y^x)^z\"\n\ndef a8(x, y, z):\n    return (z * x) * Decimal(log(y))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s8(x, y, z):\n    return \"(y^z)^x\"\n\ndef a9(x, y, z):\n    return (x ** y) * Decimal(log(z))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s9(x, y, z):\n    return \"z^x^y\"\n\ndef a10(x, y, z):\n    return (y ** x) * Decimal(log(z))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s10(x, y, z):\n    return \"z^y^x\"\n\ndef a11(x, y, z):\n    return (x * y) * Decimal(log(z))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s11(x, y, z):\n    return \"(z^x)^y\"\n\ndef a12(x, y, z):\n    return (y * x) * Decimal(log(z))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\ndef s12(x, y, z):\n    return \"(z^y)^x\"\n\nx, y, z = list(map(Decimal, input().split()))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n\nans = s1(x, y, z)\na = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]\ns = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]\nmax = a1(x, y, z)\nfor i in range (12):\n    if max < a[i](x, y, z):\n        ans = s[i](x, y, z)\n        max = a[i](x, y, z)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 114, "result": 0, "generated": "<ans>\nimport datetime\nimport sys\nimport copy\nimport functools\nimport collections\nimport itertools\n\nclass Solution:\n    def __init__(self):\n        self.N = 0\n        self.boards = None\n\n    def test(self):\n        pass\n\n    def readInput(self):\n        print(\"N: \", str(self.N), \"boards: \", str(self.boards))\n        self.N = int(input())\n        self.boards = []\n        print(\"boards: \", str(self.boards))\n        for i in range(self.N):\n            self.boards.append(list(input()))\n\n    def readMockInput(self):\n        pass\n\n    def solve(self):\n        N = self.N\n        impossibleMoves = set()\n        chesses = list()\n        notAttacked = list()\n        # record all impossible moves\n        for r in range(N):\n            for c in range(N):\n                if self.boards[r][c] == 'o':\n                    chesses.append((r, c))\n                elif self.boards[r][c] == '.':\n                    notAttacked.append((r, c))\n        # print(chesses)\n        # print(notAttacked)\n        for r, c in chesses:\n            for i, j in notAttacked:\n                impossibleMoves.add((i-r, j-c))\n        # print(impossibleMoves)\n\n        # check whether there are any conflicts\n        # reboard = [['.' for c in range(N)] for r in range(N)]\n        # for r, c in chesses:\n        #     reboard[r][c] = 'o'\n\n        startTime = datetime.datetime.now()\n\n        for i in range(N):\n            for j in range(N):\n                if self.boards[i][j] == 'o':\n                    continue\n                for r, c in chesses:\n                    if (i-r, j-c) not in impossibleMoves:\n                        if self.boards[i][j] == '.':\n                            print('NO')\n                            return\n                        self.boards[i][j] = 'v'\n        print(\"boards: \", str(self.boards))\n\n        # for r, c in chesses:\n        #     for i in range(-N+1, N):\n        #         for j in range(-N+1, N):\n        #             # much faster than 2 for\n        #             if (i, j) not in impossibleMoves:\n        #                 nr = r + i\n        #                 nc = c + j\n        #                 if 0 <= nr < N and 0 <= nc < N and self.boards[nr][nc] != 'o':\n        #                     # reboard[nr][nc] = 'x'\n        #\n        #                     if self.boards[nr][nc] == '.':\n        #                         print('NO')\n        #                         return\n        #                     self.boards[nr][nc] = 'v'\n        if sum([row.count('x') for row in self.boards]) > 0:\n            print('NO')\n            return\n        # for r in range(N):\n        #     for c in range(N):\n        #         if self.boards[r][c] != reboard[r][c]:\n        #             print('NO')\n        #             return\n        sys.stderr.write('Check Cost: {}\\n'.format(datetime.datetime.now()-startTime))\n\n\n\n        rn = 2*N-1\n        res = [['.' for c in range(rn)] for r in range(rn)]\n        res[N-1][N-1] = 'o'\n        for i in range(-N+1, N):\n            for j in range(-N+1, N):\n                if not (i == 0 and j == 0) and (i, j) not in impossibleMoves:\n                    res[i+N-1][j+N-1] = 'x'\n        print('YES')\n        for row in res:\n            print(''.join(row))\n\n\n\nsolution = Solution()\nsolution.readInput()\nstartTime = datetime.datetime.now()\nsolution.solve()\nsys.stderr.write('Time Cost:{}\\n'.format(datetime.datetime.now() - startTime))\n</ans>", "format_properties": {}}
{"idx": 118, "result": 0, "generated": "<ans>\nimport sys\nimport os\nimport time\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\nimport random\nimport string\n\nprint(\"sys: \", str(sys))\nprint(\"os: \", str(os))\nprint(\"time: \", str(time))\nprint(\"collections: \", str(collections))\nprint(\"Counter: \", str(Counter))\nprint(\"deque: \", str(deque))\nprint(\"itertools: \", str(itertools))\nprint(\"math: \", str(math))\nprint(\"timeit: \", str(timeit))\nprint(\"random: \", str(random))\nprint(\"string: \", str(string))\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\nprint(\"n: \", str(n))\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\nprint(\"start: \", str(start))\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\nprint(\"n: \", str(n))\nprint(\"primes: \", str(primes))\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return default, default\n    else:\n        return left, right\n\nprint(\"d: \", str(d))\nprint(\"x: \", str(x))\nprint(\"default: \", str(default))\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' ', end='\\n'): print(sep.join(map(str, a)), end=end)\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n########################################################################################################################\n# input = sys.stdin.readline\n\nfor _ in range(ii()):\n    n, m = mi()\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    if n == 1:\n        print(\"0\")\n    elif n == 2:\n        print(\"m\")\n    else:\n        print(\"2*m\")\n</ans>", "format_properties": {}}
{"idx": 119, "result": 0, "generated": "<ans>\nfrom random import randint\n\ndef factMod(n, mod):\n    res = 1\n    for i in range(2, n+1):\n        res = (res * i) % mod\n    print(\"res: \", str(res), \"n: \", str(n))\n    return res\n\ndef powMod(n, p, mod):\n    res = 1\n\n    while p > 0:\n        if p % 2 == 1:\n            res = (res * n) % mod\n        \n        p //= 2\n        n = (n * n) % mod\n\n    print(\"res: \", str(res), \"n: \", str(n))\n    return res\n\ndef invMod(n, mod):\n    return powMod(n, mod - 2, mod)\n\n#t = 6\n#print(invMod(t, 97))\n#print( (invMod(t, 97) * t) % 97 )\n#return\n\ndef CnkMod(n, k, mod):\n    return (\n        factMod(n, mod) *\n        invMod(factMod(k, mod) * factMod(n-k, mod), mod)\n    ) % mod\n\ndef computeCnksMod(N, mod):\n    res = [[0] * (N+1) for i in range(N+1)]\n    res[0][0] = 1\n    print(\"res: \", str(res), \"N: \", str(N))\n    for n in range(1, N+1):\n        res[n][0] = res[n-1][0]\n        print(\"res[n][0]: \", str(res[n][0]), \"n: \", str(n))\n        for k in range(1, n+1):\n            res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod\n\n    print(\"res: \", str(res), \"N: \", str(N))\n    return res\n\nmagic = 998244353\n\nn = int(input()) + 1\nprint(\"n: \", str(n))\naa = [1] + [int(s)+1 for s in input().split(' ')]\nprint(\"aa: \", str(aa))\n#aa = [1] + [randint(0, 999) for i in range(1000)]\n#n = len(aa)\n\ncnks = computeCnksMod(n, magic)\n\n#print('aa:', aa)\n\nd = [0] * (n + 1)\nd[n] = 1\nprint(\"d: \", str(d), \"n: \", str(n))\n\nfor i in reversed(list(range(n))):\n    if i != 0 and aa[i] < 2:\n        continue\n    \n    cur = 0\n\n    tosel = aa[i] - 1\n    print(\"tosel: \", str(tosel), \"i: \", str(i))\n    for j in range(i + tosel + 1, n + 1):\n        avail = j - i - 1\n        #cur = (cur + CnkMod(avail, tosel, magic) * d[j]) % magic\n        cur = (cur + cnks[avail][tosel] * d[j]) % magic\n        print(\"cur: \", str(cur), \"j: \", str(j))\n    \n    d[i] = cur\n    print(\"d[i]: \", str(d[i]), \"i: \", str(i))\n\n#print(d)\nprint(\"d: \", str(d))\nprint(d[0] - 1)\n</ans>", "format_properties": {}}
{"idx": 122, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10000)\n\n#file = open(\"btest\", \"r\")\n#f = lambda:file.readline()\nf = lambda:input()\n\nn,m = list(map(int, f().split()))\n\nprint(\"n, m: \", str(n), str(m))\n\nmatrix = []\n\nprint(\"matrix: \", str(matrix))\n\ndisco = [[0 for _ in range(m)] for _ in range(n)]\n\nprint(\"disco: \", str(disco))\n\nfor i in range(n):\n    matrix.append(f())\n\nprint(\"matrix: \", str(matrix))\n\ndef valid_node(i, j):\n    return 0 <= i < n and 0 <= j < m\n\ndef dfs(i, j, p, k, cc = 0):\n    if disco[i][j] == k:\n        return True\n    \n    disco[i][j] = k\n\n    res = False\n    dd = [[0,1], [1,0], [-1,0], [0,-1]]\n    for d in dd:\n        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\n            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:\n                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)\n\n    return res\n\nok = False\nk = 1\nfor i in range(n):\n    for j in range(m):\n        if disco[i][j] == 0:\n            ok = ok or dfs(i, j, [i, j], k)\n            k += 1\n\nif ok:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n</ans>", "format_properties": {}}
{"idx": 120, "result": 0, "generated": "<ans>\nfrom math import sin\ndef mp():  return list(map(int,input().split()))\ndef lt():  return list(map(int,input().split()))\ndef pt(x):  print(x)\ndef ip():  return input()\ndef it():  return int(input())\ndef sl(x):  return [t for t in x]\ndef spl(x): return x.split()\ndef aj(liste, item): liste.append(item)\ndef bin(x):  return \"{0:b}\".format(x)\ndef listring(l): return ' '.join([str(x) for x in l])\ndef ptlist(l): print(' '.join([str(x) for x in l]))\n\nn = it()\nstep = lt()\ndict = {}\nprint(\"n: \", str(n), \"step: \", str(step), \"dict: \", str(dict))\ndef explosion(start,s,d):\n    (i,j) = start\n    t = s+1\n    if d == 0:\n        for k in range(j+1,j+t):\n            dict[(i,k)] = True\n        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)\n    if d == 1:\n        for k in range(1,t):\n            dict[(i+k,j+k)] = True\n        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)\n    if d == 2:\n        for k in range(1,t):\n            dict[(i+k,j)] = True\n        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)\n    if d == 3:\n        for k in range(1,t):\n            dict[(i+k,j-k)] = True\n        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)\n    if d == 4:\n        for k in range(1,t):\n            dict[(i,j-k)] = True\n        return ((i,j-t+1),(d+7)%8),((i,j-t+1),(d+1)%8)\n    if d == 5:\n        for k in range(1,t):\n            dict[(i-k,j-k)] = True\n        return ((i-t+1,j-t+1),(d+7)%8),((i-t+1,j-t+1),(d+1)%8)\n    if d == 6:\n        for k in range(1,t):\n            dict[(i-k,j)] = True\n        return ((i-t+1,j),(d+7)%8),((i-t+1,j),(d+1)%8)\n    if d == 7:\n        for k in range(1,t):\n            dict[(i-k,j+k)] = True\n        return ((i-t+1,j+t-1),(d+7)%8),((i-t+1,j+t-1),(d+1)%8)\n            \nstart = [((0,0),0)]\nfor i in range(n):\n    l = []\n    for p,q in start:\n        a,b = explosion(p,step[i],q)\n        l.append(a)\n        l.append(b)\n    start = set(l)\n    print(\"start: \", str(start))\npt(len(dict))\n        \n</ans>", "format_properties": {}}
{"idx": 124, "result": 0, "generated": "<ans>\nMOD = 998244353\n\ndef pop_count(x) :\n    ans = 0\n    while (x > 0) :\n        ans = ans + x % 2\n        x = x // 2\n    return ans\n\ndef check(x, k) :\n    mask = 0\n    nx = int(x)\n    while (nx > 0) :\n        mask = mask | (1 << (nx % 10))\n        nx = nx // 10\n    if (pop_count(mask) <= k) :\n        return x\n    return 0\n\npop = []\np10 = []\nf = [[0 for j in range(1 << 10)] for i in range(20)]\nw = [[0 for j in range(1 << 10)] for i in range(20)]\ndef prepare() : \n    print(\"p10: \", str(p10))\n    p10.append(1)\n    for i in range(20) :\n        p10.append(p10[i] * 10 % MOD)\n    print(\"p10: \", str(p10))\n    for i in range(1 << 10) :\n        pop.append(pop_count(i))\n    print(\"pop: \", str(pop))\n    w[0][0] = 1\n    for i in range(1, 20) :\n        for j in range(1 << 10) :\n            for use in range(10) : \n                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD\n                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD\n    print(\"f: \", str(f))\n    print(\"w: \", str(w))\n\ndef solve(x, k) :\n    sx = [int(d) for d in str(x)] \n    n = len(sx) \n    ans = 0\n    for i in range(1, n) :\n        for use in range(1, 10) :\n            for mask in range(1 << 10) : \n                if (pop[(1 << use) | mask] <= k) :\n                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD\n    cmask = 0\n    csum = 0\n    for i in range(n) :\n        cdig = sx[i]\n        for use in range(cdig) : \n            if (i == 0 and use == 0) :\n                continue\n            nmask = cmask | (1 << use)\n            for mask in range(1 << 10) : \n                if (pop[nmask | mask] <= k) :\n                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD\n        cmask |= 1 << cdig\n        csum = (10 * csum + cdig) % MOD\n    return ans\n\nprepare()\nl, r, k = list(map(int, input().split()))\nans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 126, "result": 0, "generated": "<ans>\n__author__ = 'Michael Ilyin'\n\nimport math\n\n# debug = True\ndebug = False\n\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))\n\n\ndef get_y(x1, y1, x2, y2, x):\n    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1\n\nif debug:\n    with open(\"input.txt\", \"r\") as inp:\n        firstLine = inp.readline()\n        secondLine = inp.readline()\n        thirdLine = inp.readline()\n        fourthLine = inp.readline()\nelse:\n    firstLine = input()\n    secondLine = input()\n    thirdLine = input()\n    fourthLine = input()\n\nfirst = firstLine.split()\nn = float(first[0])\nm = float(first[1])\na = float(first[2])\nb = float(first[3])\n\nprint(\"n: \", str(n), \"m: \", str(m), \"a: \", str(a), \"b: \", str(b))\n\nA = [float(x) for x in secondLine.split()]\nB = [float(x) for x in thirdLine.split()]\nL = [float(x) for x in fourthLine.split()]\n\nprint(\"A: \", str(A), \"B: \", str(B), \"L: \", str(L))\n\noptimalLen = float(\"inf\")\noptimalBIdx = -1\nfor i, bi in enumerate(B):\n    d = dist(0, 0, b, bi) + L[i]\n    if d <= optimalLen:\n        optimalLen = d\n        optimalBIdx = i\n\nprint(\"optimalBIdx: \", str(optimalBIdx), \"optimalLen: \", str(optimalLen))\n\nintersectY = get_y(0, 0, b, B[optimalBIdx], a)\n\nprint(\"intersectY: \", str(intersectY))\n\npointDist = float(\"inf\")\noptimalAIdx = -1\nfor i, ai in enumerate(A):\n    d = dist(a, ai, a, intersectY)\n    if d < pointDist:\n        pointDist = d\n        optimalAIdx = i\n\nprint(\"optimalAIdx: \", str(optimalAIdx), \"pointDist: \", str(pointDist))\n\noptimalLen = float(\"inf\")\noptimalBIdx = -1\nfor i, bi in enumerate(B):\n    d = dist(a, A[optimalAIdx], b, bi) + L[i]\n    if d <= optimalLen:\n        optimalLen = d\n        optimalBIdx = i\n\nprint(\"optimalAIdx: \", str(optimalAIdx + 1), \"optimalBIdx: \", str(optimalBIdx + 1))\n</ans>", "format_properties": {}}
{"idx": 125, "result": 0, "generated": "<ans>\ndef main():\n    N, M = (int(i) for i in input().split())\n\n    print(\"N: \", str(N), \"M: \", str(M))\n    par = [i for i in range(N)]\n    print(\"par: \", str(par))\n    size = [1 for i in range(N)]\n    print(\"size: \", str(size))\n\n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            size[x] = size[par[x]]\n            return par[x]\n\n    def same(x, y):\n        return find(x) == find(y)\n\n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if size[x] < size[y]:\n            x, y = y, x\n        size[x] += size[y]\n        par[y] = x\n\n    def get_size(x):\n        return size[find(x)]\n\n    G = [[] for _ in range(N)]\n    print(\"G: \", str(G))\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        print(\"a: \", str(a), \"b: \", str(b))\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n        print(\"G: \", str(G))\n        union(a-1, b-1)\n        print(\"par: \", str(par))\n        print(\"size: \", str(size))\n\n    S = [False]*4\n    print(\"S: \", str(S))\n    for i in range(N):\n        S[min(3, get_size(i))] = True\n        if S[3]:\n            break\n    t = 0\n    if S[3]:\n        t = 1\n    elif S[2]:\n        t = 2\n    else:\n        t = 3\n\n    print(\"t: \", str(t))\n    color = [-1]*N\n\n    def dfs(s):\n        stack = [s]\n        color[s] = 0\n        b = 1\n        w = 0\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if color[u] != -1:\n                    if color[u] == color[v]:\n                        return False, b*w\n                    continue\n                color[u] = color[v] ^ 1\n                if color[u] == 0:\n                    b += 1\n                else:\n                    w += 1\n                stack.append(u)\n        return True, b*(b-1)//2 + w*(w-1)//2\n\n    is_bipartite, _ = dfs(0)\n    if is_bipartite:\n        w = 0\n        if t == 3:\n            w = N*(N-1)*(N-2)//3//2\n        elif t == 2:\n            used = [False]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) == 2:\n                    w += (N-2)\n                    used[find(i)] = True\n        elif t == 1:\n            used = [False]*N\n            color = [-1]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) >= 3:\n                    _, ways = dfs(i)\n                    w += ways\n                    used[find(i)] = True\n        print(t, w)\n    else:\n        print(0, 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 127, "result": 0, "generated": "<ans>\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\n# M = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nn = val()\nl = li()\nl1 = l[:]\nl2 = l[:]\nprint(\"n: \", str(n), \"l: \", str(l))\ni = 0\nl1 = sorted(list(set(l1)))\nprint(\"l1: \", str(l1))\ndoit = tot1 = 0\ncn = Counter(l1)\nl = l1[:]\nprint(\"cn: \", str(cn))\nwhile i < len(l1):\n    if cn[l[i] - 1] > 0:\n        cn[l[i]] -= 1\n        cn[l[i] - 1] += 1\n        l[i] -= 1\n        i += 1\n    else:\n        cn[l[i]] -= 1\n        cn[l[i] + 1] += 1\n        l[i] += 1\n        if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2\n        else:i += 1\n# print(cn)\ntot1 = sum(1 for i in cn if cn[i])\n\n# print(l1)\n\n\n\ni = 0\n\ncnt = Counter(l2)\nl2 = sorted(l2)\nprint(\"l2: \", str(l2))\nprint(\"cnt: \", str(cnt))\nl = l2[:]\nfor i in range(n):\n    if cnt[l[i] - 1] == 0:\n        cnt[l[i] - 1] += 1\n        cnt[l[i]] -= 1\n        l[i] -= 1\n    elif cnt[l[i]] > 1:\n        cnt[l[i] + 1] += 1\n        cnt[l[i]] -= 1\n        l[i] += 1\nprint(\"cnt: \", str(cnt))\ntot2 = sum(1 for i in cnt if cnt[i])\n\n\n\nprint(tot1,tot2)\n</ans>", "format_properties": {}}
{"idx": 123, "result": 1, "generated": "<ans>\nD = {\n0: 0,\n100: 1423,\n200: 4006,\n300: 10171,\n400: 12223,\n500: 18010,\n600: 22231,\n700: 30520,\n800: 40150,\n900: 51121,\n1000: 100036,\n1100: 102034,\n1200: 106030,\n1300: 112024,\n1400: 120232,\n1500: 126100,\n1600: 140230,\n1700: 170101,\n1800: 202105,\n1900: 210322,\n2000: 220033,\n2100: 230410,\n2200: 261100,\n2300: 303130,\n2400: 313300,\n2500: 333100,\n2600: 402400,\n2700: 421210,\n2800: 504010,\n2900: 602020,\n3000: 1000027,\n3100: 1002025,\n3200: 1006021,\n3300: 1012015,\n3400: 1020223,\n3500: 1026010,\n3600: 1040221,\n3700: 1070020,\n3800: 1102060,\n3900: 1110313,\n4000: 1120024,\n4100: 1130401,\n4200: 1161010,\n4300: 1203121,\n4400: 1213210,\n4500: 1233010,\n4600: 1302310,\n4700: 1321201,\n4800: 1404001,\n4900: 1502011,\n5000: 2000008,\n5100: 2002312,\n5200: 2010700,\n5300: 2020222,\n5400: 2031211,\n5500: 2100052,\n5600: 2104111,\n5700: 2120014,\n5800: 2141002,\n5900: 2204011,\n6000: 2230003,\n6100: 2310202,\n6200: 2410102,\n6300: 3000151,\n6400: 3005101,\n6500: 3020131,\n6600: 3042100,\n6700: 3106000,\n6800: 3130210,\n6900: 3211021,\n7000: 3311020,\n7100: 4000330,\n7200: 4012012,\n7300: 4100203,\n7400: 4130002,\n7500: 4301200,\n7600: 5010031,\n7700: 5103100,\n7800: 6000121,\n7900: 6200020,\n8000: 9010000,\n8100: 10001710,\n8200: 10005310,\n8300: 10011601,\n8400: 10020151,\n8500: 10025101,\n8600: 10040131,\n8700: 10062100,\n8800: 10102024,\n8900: 10110232,\n9000: 10116100,\n9100: 10130230,\n9200: 10160101,\n9300: 10203031,\n9400: 10213102,\n9500: 10232101,\n9600: 10302202,\n9700: 10321030,\n9800: 10403020,\n9900: 10501201,\n10000: 10800100}\n\nk = int(input())\nprint(\"k: \", str(k))\nstart = k - k%100\nprint(\"start: \", str(start))\ni = D[start]\nprint(\"i: \", str(i))\nj = start\nprint(\"j: \", str(j))\n\nwhile j < k:\n    i += 1\n    print(\"i: \", str(i))\n    if sum(int(d) for d in str(i))==10:\n        j += 1\n        print(\"j: \", str(j))\nprint(i)\n</ans>", "format_properties": {}}
{"idx": 121, "result": 0, "generated": "<ans>\nfrom heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom functools import *\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\nprint(\"from heapq import heappush,heappop,heapify: \", str(from heapq import heappush,heappop,heapify))\nprint(\"from collections import deque,defaultdict,Counter: \", str(from collections import deque,defaultdict,Counter))\nprint(\"import itertools: \", str(import itertools))\nprint(\"from functools import *: \", str(from functools import *))\nprint(\"from itertools import permutations,combinations,groupby: \", str(from itertools import permutations,combinations,groupby))\nprint(\"import sys: \", str(import sys))\nprint(\"import bisect: \", str(import bisect))\nprint(\"import string: \", str(import string))\nprint(\"import math: \", str(import math))\nprint(\"import time: \", str(import time))\nprint(\"import random: \", str(import random))\ndef Golf():\n    print(\"def Golf(): \", str(Golf))\n    *a,=map(int,open(0))\ndef S_():\n    print(\"def S_(): \", str(S_))\n    return input()\ndef IS():\n    print(\"def IS(): \", str(IS))\n    return input().split()\ndef LS():\n    print(\"def LS(): \", str(LS))\n    return [i for i in input().split()]\ndef I():\n    print(\"def I(): \", str(I))\n    return int(input())\ndef MI():\n    print(\"def MI(): \", str(MI))\n    return map(int,input().split())\ndef LI():\n    print(\"def LI(): \", str(LI))\n    return [int(i) for i in input().split()]\ndef LI_():\n    print(\"def LI_(): \", str(LI_))\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    print(\"def NI(n): \", str(NI(n)))\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    print(\"def NI_(n): \", str(NI_(n)))\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    print(\"def StoI(): \", str(StoI))\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    print(\"def ItoS(nn): \", str(ItoS(nn)))\n    return chr(nn+97)\ndef LtoS(ls):\n    print(\"def LtoS(ls): \", str(LtoS(ls)))\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    print(\"def GI(V,E,Directed=False,index=0): \", str(GI(V,E,Directed,index)))\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\n    print(\"def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}): \", str(GGI(h,w,search,replacement_of_found,mp_def)))\n    mp=[1]*(w+2)\n    found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[1]+[mp_def[j] for j in s]+[1]\n    mp+=[1]*(w+2)\n    return h+2,w+2,mp,found\ndef bit_combination(k,n=2):\n    print(\"def bit_combination(k,n=2): \", str(bit_combination(k,n)))\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    print(\"def show(*inp,end='\\n'): \", str(show(*inp,end)))\n    if show_flg:\n        print(*inp,end=end)\nYN=['YES','NO']\nYn=['Yes','No']\n\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\n#ts=time.time()\n#sys.setrecursionlimit(10**7)\ninput=lambda: sys.stdin.readline().rstrip()\n \ndef ran_input():\n    print(\"def ran_input(): \", str(ran_input))\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\nn=I()\nm=LI()\ntot=0\nfor i in range(n):\n    l,r=[],[]\n    \n    tmp=m[i]\n    p=m[i]\n    \n    # right\n    for j in range(i+1,n):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        r+=[p]\n    \n    p=m[i]\n    # left\n    for j in range(i-1,-1,-1):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        l+=[p]\n    \n    if tmp>tot:\n        tot=tmp\n        ans=l[::-1]+[m[i]]+r\n        \nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 112, "result": 0, "generated": "<ans>\ns = input()\nprint(\"s: \", str(s))\n\ncur_len = 1\na = []\nchar = []\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]: cur_len += 1\n    else:\n      a.append(cur_len)\n      char.append(s[i-1])\n      cur_len = 1\n      \na.append(cur_len)\nchar.append(s[len(s)-1])\n\nans = 0\nwhile len(a) > 1:\n    n = len(a)\n    inner_min = 100000000\n    for i in range(1,n-1):\n        if a[i] < inner_min: inner_min = a[i]\n        \n    k = min(a[0], a[n-1],(inner_min + 1)//2)\n    #print(\"a: \", a, \"; k = \", k)\n    b = []\n    new_char = []\n    for i in range(n):\n        if i == 0 or i == n-1:\n            if a[i] > k:\n                b.append(a[i]-k)\n                new_char.append(char[i])\n        else:\n            if a[i] > 2*k:\n                b.append(a[i] - 2*k)\n                new_char.append(char[i])\n##    print(b)\n    ans += k\n    if len(b) > 1:\n        c = [0]*n\n        newnew_char = [new_char[0]]\n        count = 0\n    \n        for i in range(0,len(b)-1):\n            c[count] += b[i]\n            if new_char[i] == new_char[i+1]: continue\n            else:\n                count += 1\n                newnew_char.append(new_char[i+1])\n        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]\n        else:\n            #count += 1\n            newnew_char.append(new_char[i+1])\n            c[count] = b[len(b)-1]\n        a = c[:count+1]\n        char = newnew_char[:]\n    else:\n        a = b[:]\nprint(\"a: \", str(a), \"; char: \", str(char))\nprint(\"ans: \", str(ans))\nprint(\"b: \", str(b), \"; new_char: \", str(new_char))\nprint(\"c: \", str(c), \"; newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"n: \", str(n))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint(\"k: \", str(k))\nprint(\"ans: \", str(ans))\nprint(\"a: \", str(a))\nprint(\"char: \", str(char))\nprint(\"b: \", str(b))\nprint(\"new_char: \", str(new_char))\nprint(\"c: \", str(c))\nprint(\"newnew_char: \", str(newnew_char))\nprint(\"count: \", str(count))\nprint(\"n: \", str(n))\nprint(\"inner_min: \", str(inner_min))\nprint", "format_properties": {}}
{"idx": 133, "result": 0, "generated": "<ans>\nimport sys\nn=int(input())\nprint(\"n: \", str(n))\na=list(map(int,input().split()))\nprint(\"a: \", str(a))\nheight=n\nprint(\"height: \", str(height))\nans=[]\nlast3=-1\nfail=0\nused=-1\nfor i in range(n):\n    if a[i]==3:\n        if height==n:\n            ans.append((n-height+1,i+1))\n            height-=1\n        else:\n            ans.append((n+1-(height+1),i+1))\n            ans.append((n+1-height,i+1))\n            height-=1\n        last3=i\n        print(\"last3: \", str(last3))\nif last3==n-1:\n    print(-1)\n    return\nif last3>-1:\n    flag=0\n    for i in range(last3,n):\n        if a[i]==2:\n            flag=1\n            ans.append((n+1-(height+1),i+1))\n            height-=1\n            break\n    if flag==0:\n        flag2=0\n        for i in range(last3,n):\n            if a[i]==1:\n                ans.append((n+1-(height+1),i+1))\n                height-=1\n                flag2=1\n                used=i\n                break\n        if flag2==0:\n            print(-1)\n            return\n    print(\"flag: \", str(flag))\n    print(\"flag2: \", str(flag2))\n    print(\"used: \", str(used))\nones=[]\nif used==-1:\n    height-=1\n    print(\"height: \", str(height))\nfor i in range(n-1,-1,-1):\n    if a[i]==1 and i!=used:\n        ones.append(i)\n    if a[i]==2:\n        if len(ones)==0:\n            print(-1)\n            return\n        k=ones.pop()\n        ans.append((n+1-(height+1),i+1))\n        ans.append((n+1-(height+1),k+1))\n        height-=1\n        print(\"height: \", str(height))\nif used>-1:\n    ones.append(used)\nfor i in ones:\n    ans.append((n+1-(height+1),i+1))\n    height-=1\nprint(\"height: \", str(height))\nprint(len(ans))\nfor x,y in ans:\n    print(x,y)\n</ans>", "format_properties": {}}
{"idx": 131, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\nMOD = int(1e09) + 7\nINF = int(1e15)\n\n\ndef solve():\n    N = Scanner.int()\n    print(\"N: \", str(N))\n    A = [0 for _ in range(N)]\n    print(\"A: \", str(A))\n    B = [0 for _ in range(N)]\n    print(\"B: \", str(B))\n    for i in range(N):\n        A[i], B[i] = Scanner.map_int()\n        print(\"A[{}]: {}, B[{}]: {}\".format(i, A[i], i, B[i]))\n    A.sort()\n    print(\"A: \", str(A))\n    B.sort()\n    print(\"B: \", str(B))\n    if N % 2 == 0:\n        mA = A[N // 2] + A[N // 2 - 1]\n        mB = B[N // 2] + B[N // 2 - 1]\n        print((mB - mA + 1))\n    else:\n        mA = A[N // 2]\n        mB = B[N // 2]\n        print((mB - mA + 1))\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 135, "result": 0, "generated": "<ans>\nfrom fractions import gcd\nprint(\"gcd: \", str(gcd))\nfrom itertools import combinations,permutations,accumulate, product \nprint(\"combinations,permutations,accumulate,product: \", str(combinations), str(permutations), str(accumulate), str(product))\nfrom collections import deque,defaultdict,Counter\nprint(\"deque,defaultdict,Counter: \", str(deque), str(defaultdict), str(Counter))\nimport decimal\nprint(\"decimal: \", str(decimal))\nimport re\nprint(\"re: \", str(re))\nimport math\nprint(\"math: \", str(math))\nimport bisect\nprint(\"bisect: \", str(bisect))\nimport heapq\nprint(\"heapq: \", str(heapq))\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nprint(\"sys: \", str(sys))\nsys.setrecursionlimit(10000000)\nprint(\"sys.setrecursionlimit: \", str(sys.setrecursionlimit))\nmod = 10**9 + 7\nprint(\"mod: \", str(mod))\n#mod = 9982443453\n#mod = 998244353\nfrom sys import stdin\nprint(\"from sys import stdin: \", str(stdin))\nreadline = stdin.readline\nprint(\"readline: \", str(readline))\ndef readInts():\n  print(\"readInts: \", str(readInts))\n  return list(map(int,readline().split()))\ndef readTuples():\n    print(\"readTuples: \", str(readTuples))\n    return tuple(map(int,readline().split()))\ndef I():\n  print(\"I: \", str(I))\n  return int(readline())\nn = I()\nprint(\"n: \", str(n))\ns = input()\nprint(\"s: \", str(s))\nans = \"\"\nprv = None\nprint(\"prv: \", str(prv))\nfor i in range(n):\n    if i == 0:\n        prv = s[i]\n        print(\"prv: \", str(prv))\n        ans += s[i]\n        continue\n    if s[i] == prv:\n        continue\n    else:\n        prv = s[i]\n        print(\"prv: \", str(prv))\n        ans += s[i]\nprint(\"ans: \", str(ans))\nprint((len(ans)))\n</ans>", "format_properties": {}}
{"idx": 130, "result": 0, "generated": "<ans>\nimport math\nfrom fractions import gcd\n\ndef primes(limit):\n    print(\"limit: \", str(limit))\n    Ans=[]\n    C=[True]*(limit+1)\n    L=list(range(2,limit+1))\n    for item in L:\n        if(C[item]):\n            print(\"item: \", str(item))\n            i=2\n            while(item*i<=limit):\n                C[item*i]=False\n                print(\"item*i: \", str(item*i))\n                i+=1\n    for item in L:\n        if(C[item]):\n            print(\"item: \", str(item))\n            Ans+=[item]\n    return Ans\n\n\na,b=list(map(int,input().split()))\nprint(\"a: \", str(a), \"b: \", str(b))\naa=a\nbb=b\nA=[]\nB=[]\n\np=primes(int(math.sqrt(10**9)))\n\nfor i in range(len(p)):\n    if(p[i]>a):\n        break\n    while(a%p[i]==0):\n        A.append(p[i])\n        a//=p[i]\n        print(\"A: \", str(A), \"a: \", str(a))\nif(a!=1):\n    A.append(a)\n    print(\"A: \", str(A), \"a: \", str(a))\n\nfor i in range(len(p)):\n    if(p[i]>b):\n        break\n    while(b%p[i]==0):\n        B.append(p[i])\n        b//=p[i]\n        print(\"B: \", str(B), \"b: \", str(b))\nif(b!=1):\n    B.append(b)\n    print(\"B: \", str(B), \"b: \", str(b))\n\nif(aa==1 and bb==1):\n    print(0)\n\nelif(aa==1):\n    Done=True\n    for item in B:\n        if(item>5):\n            Done=False\n            break\n    if(Done):\n        print(len(B))\n    else:\n        print(-1)\nelif(bb==1):\n    Done=True\n    for item in A:\n        if(item>5):\n            Done=False\n            break\n    if(Done):\n        print(len(A))\n    else:\n        print(-1)\n\nelse:\n\n    B.sort()\n    A.sort()\n    Done=True\n    ind=0\n    ans=0\n    while(A!=B):\n        if(ind>=len(A) and ind>=len(B)):\n            Done=False\n            break\n        elif(ind>=len(A)):\n            if(B[-1]>5):\n                Done=False\n                break\n            else:\n                ans+=len(B)-ind\n                break\n        elif(ind>=len(B)):\n            if(A[-1]>5):\n                Done=False\n                break\n            else:\n                ans+=len(A)-ind\n                break\n        if(A[ind]==B[ind]):\n            ind+=1\n            continue\n        \n        if(A[ind]<B[ind]):\n            if(A[ind]>5):\n                Done=False\n                break\n            else:\n                ans+=1\n                A.pop(ind)\n        else:\n            if(B[ind]>5):\n                Done=False\n                break\n            else:\n                ans+=1\n                B.pop(ind)\n    if(Done):\n        print(ans)\n    else:\n        print(-1)\n</ans>", "format_properties": {}}
{"idx": 136, "result": 0, "generated": "<ans>\nimport sys\n\nn = int(sys.stdin.readline().split()[0])\n\nclass Polynomial:\n    def __init__(self, coef):\n        print(\"coef: \", str(coef))\n        first_nonzero = False\n        index = len(coef) - 1\n        while not first_nonzero:\n            if not coef[index] == 0:\n                first_nonzero = True\n            else:\n                if index == 0:\n                    first_nonzero = True\n                else:\n                    index -= 1\n        self.degree = index\n        self.coef = [coef[j] for j in range(index + 1)]\n    def multiply_by_x(self):\n        new_coef = [0]\n        for j in range(self.degree + 1):\n            new_coef.append(self.coef[j])\n        return Polynomial(new_coef)\n    def minus(self):\n        new_coef = [-self.coef[j] for j in range(self.degree + 1)]\n        return Polynomial(new_coef)\n    def add(self, other):\n        other_coef = other.coef\n        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]\n        m = min(self.degree, other.degree)\n        M = max(self.degree, other.degree)\n        if self.degree > other.degree:\n            bigger_poly = self\n        else:\n            bigger_poly = other\n        for j in range(m + 1):\n            new_coef[j] = self.coef[j] + other.coef[j]\n        for j in range(m + 1, M+1):\n            new_coef[j] = bigger_poly.coef[j]\n            \n        return Polynomial(new_coef) \n    def is_legal(self):\n        result = True\n        bools = [None for j in range(self.degree + 1)]\n        bools[self.degree] = self.coef[self.degree] == 1\n        for j in range(self.degree):\n            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1\n        for j in range(self.degree + 1):\n            result = result and bools[j]\n        return result\n    def print(self):\n        output = \"\"\n        for j in range(self.degree + 1):\n            output += str(self.coef[j]) + \" \"\n        print(output)\n            \n        \n\nf = []\n\nf.append(Polynomial([1]))\nprint(\"f[0]: \", str(f[0].coef))\nf.append(Polynomial([0, 1]))\nprint(\"f[1]: \", str(f[1].coef))\n\nfor j in range(2, 151):\n    xf = f[j-1].multiply_by_x()\n    t_1 = xf.add(f[j - 2])\n    t_2 = xf.add(f[j - 2].minus())\n    if t_1.is_legal():\n        f.append(t_1)\n        print(\"t_1: \", str(t_1.coef))\n    elif t_2.is_legal():\n        f.append(t_2)\n        print(\"t_2: \", str(t_2.coef))\n    #print(\":(\")\n\n\nprint(f[n].degree)\nf[n].print()\nprint(f[n-1].degree)\nf[n-1].print()\n\n#for j in range(len(f)):\n    #f[j].print()\n\n</ans>", "format_properties": {}}
{"idx": 128, "result": 0, "generated": "<ans>\nimport sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    N = I()\n    if N == 0:\n        print(0)\n        return\n    if N < 0:\n        N = -N\n        D = defaultdict(int)\n        index = 0\n        print(\"N: \", str(N), \"D: \", str(D), \"index: \", str(index))\n        while N >= 1:\n            #bit\u30d5\u30e9\u30b0\u304c\u305f\u3063\u3066\u3044\u305f\u3089\n            if N & 1 == 1:\n                #2\u306e\u500d\u6570\u306e\u5834\u5408D[index]\u3068D[index+1]\u306b1\u3092\u8db3\u3059\n                if index % 2 == 0:\n                    D[index] += 1\n                    D[index+1] += 1\n                else:\n                    D[index] += 1\n            else:\n                D[index] = D[index]\n            N = N>>1\n            index += 1\n    else:\n        D = defaultdict(int)\n        if N & 1 == 1:\n            D[0] = 1\n        else:\n            D[0] = 0\n        index = 1\n        N = N >> 1\n        print(\"N: \", str(N), \"D: \", str(D), \"index: \", str(index))\n        while N >= 1:\n            #bit\u30d5\u30e9\u30b0\u304c\u305f\u3063\u3066\u3044\u305f\u3089\n            if N & 1 == 1:\n                #2\u306e\u500d\u6570\u306e\u5834\u5408D[index]\u3068D[index+1]\u306b1\u3092\u8db3\u3059\n                if index % 2 == 1:\n                    D[index] += 1\n                    D[index+1] += 1\n                else:\n                    D[index] += 1\n            else:\n                D[index] = D[index]\n            N = N>>1\n            index += 1\n            \n            \n    index = 0\n    while True:\n        if not index in D.keys():\n            break\n        if D[index] <= 1:\n            pass\n        else:\n            temp = D[index]\n            D[index] = temp % 2\n            D[index+1] += (temp // 2)\n            D[index+2] += (temp // 2)\n            if D[index+1] >= D[index+2] * 2:\n                temp = D[index+2]\n                D[index+2] -= temp\n                D[index+1] -= temp * 2\n        index += 1\n    res = True\n\n    for i in reversed(D.values()):\n        if res and i == 1:\n            res = False\n        if not res:\n            print(i, end=\"\")\n    print()\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 137, "result": 0, "generated": "<ans>\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n        print(\"n_max: \", str(n_max), \"mod: \", str(mod))\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\nmod = 998244353\nK, N = map(int, input().split())\ncomb = Combination(10000, mod=mod)\nprint(\"K: \", str(K), \"N: \", str(N))\ndef C(n, r):\n    if n<r or r<0:\n        return 0\n    else:\n        return comb(n, r)\ndef H(n, r):\n    return C(n+r-1, r)\nL = []\nfor i in range(2, 2*K+1, 2):\n    ans = 0\n    M = i//2\n    b = 1\n    for j, a in enumerate(range(M, K)):\n        if M-j<0:\n            break\n        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b\n        #print((j, a), C(M, j) , H(N, K-a), b, pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b)\n        ans %= mod\n        b = -b\n    print(\"ans: \", str(ans))\n    if i == K+1:\n        break\n    elif i == K:\n        print(\"ans: \", str(ans))\n        print(\"ans: \", str(ans))\n        break\n    L.append(ans)\n    print(\"ans: \", str(ans))\n    L.append(ans)\n\nprint(*L[::-1], sep=\"\\n\")\n</ans>", "format_properties": {}}
{"idx": 132, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\na=list(map(int,input().split()))\nprint(\"a: \", str(a))\n\nc=[0]*1001\nprint(\"c: \", str(c))\n\nfor i in range (len(a)):\n\tc[a[i]]+=1\nprint(\"c: \", str(c))\n\nsym=0\nsin=0\nprint(\"sym: \", str(sym), \"sin: \", str(sin))\n\nfor i in range (1001):\n\tsym+=(c[i]//4)\n\tif(c[i]%2==1):\n\t\tsin+=1\nprint(\"sym: \", str(sym), \"sin: \", str(sin))\n\nif(n%2==0 and sym==((n*n)//4)):\n\tmat= [([0]*(n//2)) for i in range (n//2)]\n\tprint(\"mat: \", str(mat))\n\tar=[]\n\tfor i in range (1001):\n\t\twhile(c[i]>=4):\n\t\t\tar.append(i)\n\t\t\tc[i]-=4\n\tprint(\"ar: \", str(ar))\n\tk=0\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tmat[i][j]=ar[k]\n\t\t\tk+=1\n\tprint(\"mat: \", str(mat))\n\n\tnewm=[([0]*n) for i in range (n)]\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tnewm[i][j]=mat[i][j]\n\t\t\tnewm[n-i-1][j]=mat[i][j]\n\t\t\tnewm[n-i-1][n-j-1]=mat[i][j]\n\t\t\tnewm[i][n-j-1]=mat[i][j]\n\tprint(\"newm: \", str(newm))\n\tprint(\"YES\")\n\tfor i in range (n):\n\t\tfor j in range (n):\n\t\t\tprint(newm[i][j],end=\" \")\n\t\tprint()\n\n\t\nelif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):\n\tmat= [([0]*(n//2)) for i in range (n//2)]\n\tprint(\"mat: \", str(mat))\n\tar=[]\n\tfor i in range (1001):\n\t\twhile(c[i]>=4):\n\t\t\tar.append(i)\n\t\t\tc[i]-=4\n\tprint(\"ar: \", str(ar))\n\tk=0\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tmat[i][j]=ar[k]\n\t\t\tar.pop(k)\n\tprint(\"mat: \", str(mat))\n\n\tnewm=[([0]*n) for i in range (n)]\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tnewm[i][j]=mat[i][j]\n\t\t\tnewm[n-i-1][j]=mat[i][j]\n\t\t\tnewm[n-i-1][n-j-1]=mat[i][j]\n\t\t\tnewm[i][n-j-1]=mat[i][j]\n\tprint(\"newm: \", str(newm))\n\tna=len(ar)\n\tar2=[]\n\tfor i in range (na):\n\t\tar2.append(ar[i])\n\t\tar2.append(ar[i])\n\tprint(\"ar2: \", str(ar2))\n\tfor i in range (1001):\n\t\twhile(c[i]>=2):\n\t\t\tar2.append(i)\n\t\t\tc[i]-=2\n\tprint(\"ar2: \", str(ar2))\n\tfor i in range (n//2):\n\t\tnewm[n//2 ][i]=ar2[0]\n\t\tnewm[n//2 ][n-i-1]=ar2[0]\n\t\tar2.pop(0)\n\t\tnewm[i][n//2 ]=ar2[0]\n\t\tnewm[n-i-1][n//2 ]=ar2[0]\n\t\tar2.pop(0)\n\tprint(\"newm: \", str(newm))\n\tfor i in range (1001):\n\t\tif(c[i]==1):\n\t\t\tnewm[n//2][n//2]=i\n\tprint(\"newm: \", str(newm))\n\tprint(\"YES\")\n\tfor i in range (n):\n\t\tfor j in range (n):\n\t\t\tprint(newm[i][j],end=\" \")\n\t\tprint()\n\nelse:\n\tprint(\"NO\")\n</ans>", "format_properties": {}}
{"idx": 129, "result": 0, "generated": "<ans>\nn, k = map(int, input().split())\nprint(\"n: \", str(n), \"k: \", str(k))\nXY = [list(map(int, input().split())) for _ in range(n)]\nprint(\"XY: \", str(XY))\nXY.sort(key=lambda x: x[0])\nXY = [xy + [x] for x, xy in enumerate(XY)]\nXY.sort(key=lambda x: x[1])\nXY = [xy + [y] for y, xy in enumerate(XY)]\nprint(\"XY: \", str(XY))\n\ngr = [[0] * n for _ in range(n)]\nprint(\"gr: \", str(gr))\nfor _, _, i, j in XY:\n  gr[i][j] = 1\n  print(\"gr: \", str(gr))\n\nrui = [[0] * (n + 1) for _ in range(n + 1)]\nprint(\"rui: \", str(rui))\nfor i in range(n):\n  for j in range(n):\n    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]\n    print(\"rui: \", str(rui))\n\n# XY\u306e2\u70b9,3\u70b9,4\u70b9\u3092\u7dcf\u5f53\u305f\u308a\nans = 10 ** 21\nfor i in range(n - 1):\n  for j in range(i + 1, n):\n    x = [XY[m][0] for m in [i, j]]\n    y = [XY[m][1] for m in [i, j]]\n    ii = [XY[m][2] for m in [i, j]]\n    jj = [XY[m][3] for m in [i, j]]\n    innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                + rui[min(ii)][min(jj)] \\\n                - rui[min(ii)][max(jj) + 1] \\\n                - rui[max(ii) + 1][min(jj)]\n    if innerPoints >= k:\n      area = (max(x) - min(x)) * (max(y) - min(y)) \n      if area < ans:\n        ans = area\n\nif n > 2:\n  for i in range(n - 2):\n    for j in range(i + 1, n - 1):\n      for l in range(j + 1, n):\n        x = [XY[m][0] for m in [i, j, l]]\n        y = [XY[m][1] for m in [i, j, l]]\n        ii = [XY[m][2] for m in [i, j, l]]\n        jj = [XY[m][3] for m in [i, j, l]]\n        innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                    + rui[min(ii)][min(jj)] \\\n                    - rui[min(ii)][max(jj) + 1] \\\n                    - rui[max(ii) + 1][min(jj)]\n        if innerPoints >= k:\n          area = (max(x) - min(x)) * (max(y) - min(y)) \n          if area < ans:\n            ans = area\n\nif n > 3:\n  for i in range(n - 3):\n    for j in range(i + 1, n - 2):\n      for l in range(j + 1, n - 1):\n        for o in range(l + 1, n):\n          x = [XY[m][0] for m in [i, j, o, l]]\n          y = [XY[m][1] for m in [i, j, o, l]]\n          ii = [XY[m][2] for m in [i, j, o, l]]\n          jj = [XY[m][3] for m in [i, j, o, l]]\n          innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                      + rui[min(ii)][min(jj)] \\\n                      - rui[min(ii)][max(jj) + 1] \\\n                      - rui[max(ii) + 1][min(jj)]\n          if innerPoints >= k:\n            area = (max(x) - min(x)) * (max(y) - min(y)) \n            if area < ans:\n              ans = area\n\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 138, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport random\nprint(\"n, k, x: \", str(n), str(k), str(x))\nn, k, x = map(int, input().split())\nprint(\"n, k, x: \", str(n), str(k), str(x))\nprint(\"a: \", str(a))\na = list(map(int, input().split()))\nans = 0\nif n == 1:\n    print(\"ans: \", str(ans))\n    return\nfor i in range(0, n - 1):   \n    if a[i] == a[i + 1] == x:\n        l = i    \n        while l >= 0 and a[i] == a[l]:\n            l -= 1\n        r = i + 1\n        while r < n and a[r] == x:\n            r += 1\n        while (1):\n            if l == -1 or r == n:\n                break\n            if a[l] != a[r]:\n                break\n            if l == 0 and r == n - 1:\n                break\n            if l == 0:\n                if a[0] == a[r + 1]:\n                    while r < n and a[r] == a[0]:\n                        r += 1\n                    l -= 1\n                    continue\n                else:\n                    break\n            if r == n - 1:\n                if a[n - 1] == a[l - 1]:\n                    while l >= 0 and a[l] == a[n - 1]:\n                        l -= 1\n                    r += 1\n                    continue\n                else:\n                    break\n            if a[l] == a[r + 1] or a[l - 1] == a[r]:\n                t = a[l]\n                while l >= 0 and a[l] == t:\n                    l -= 1\n                while r < n and a[r] == t:\n                    r += 1\n            else:\n                break\n        ans = max(ans, r - l - 1)     \nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 140, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(4100000)\nprint(\"sys: \", str(sys))\nimport math\nprint(\"math: \", str(math))\nimport fractions\nprint(\"fractions: \", str(fractions))\n\n\n'''\n1\u884c\u306eint\nN, K = map(int, input().split())\nprint(\"N: \", str(N), \"K: \", str(K))\n\n1\u884c\u306estring\nS, T = input().split()\nprint(\"S: \", str(S), \"T: \", str(T))\n\n1\u884c\u306e\u6574\u6570\u914d\u5217\nP = list(map(int,input().split()))\nprint(\"P: \", str(P))\n\n\u8907\u6570\u884c2\u6570\u5024\nx = []\ny = []\nfor i in range(5):\n    x1,y1=[int(i) for i in input().split()]\n    x.append(x1)\n    y.append(y1)\nprint(\"x: \", str(x), \"y: \", str(y))\n\n'''\n\n\nS = input()\nprint(\"S: \", str(S))\n\n\ncheck = len(S)-1\n\nwhile(check >= 0):\n\n    if S[check] == \"r\":\n        if S[check-2] == \"m\":\n            remove = S[check-6: check+1]\n            if remove == \"dreamer\":\n                check -= 7\n            else:\n                print(\"NO\")\n                return\n\n\n        elif S[check-2] == \"s\":\n            remove = S[check-5: check+1]\n            \n            if remove == \"eraser\":\n                check -= 6\n            else:\n                print(\"NO\")\n                return\n\n        else:\n            print(\"NO\")\n            return\n\n    elif S[check] == \"e\":\n        remove = S[check-4: check+1]\n            \n        if remove == \"erase\":\n            check -= 5\n        else:\n            print(\"NO\")\n            return\n\n    elif S[check] == \"m\":\n        remove = S[check-4: check+1]\n            \n        if remove == \"dream\":\n            check -= 5\n        else:\n            print(\"NO\")\n            return\n\n    else:\n        print(\"NO\")\n        return\n\n\nprint(\"YES\")\n</ans>", "format_properties": {}}
{"idx": 141, "result": 0, "generated": "<ans>\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n + 1\n        self.parents = [-1] * self.n\n        print(\"n: \", str(n), \"parents: \", str(self.parents))\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n        # TODO \u6839\u3092\u8fd4\u3059\n        return x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nfrom collections import defaultdict\ndef main():\n    N, M = list(map(int, input().split()))\n    print(\"N: \", str(N), \"M: \", str(M))\n    A = list(map(int, input().split()))\n    print(\"A: \", str(A))\n    B = list(map(int, input().split()))\n    print(\"B: \", str(B))\n    A.append(0)\n    B.append(0)\n    print(\"A: \", str(A), \"B: \", str(B))\n    uf = UnionFind(N+1)\n    for _ in range(M):\n        c, d = list(map(int,input().split()))\n        print(\"c: \", str(c), \"d: \", str(d))\n        uf.union(c, d)\n    A_sums = defaultdict(int)\n    B_sums = defaultdict(int)\n    for i in range(1, N+1):\n        x = uf.find(i)\n        A_sums[x] += A[i-1]\n        B_sums[x] += B[i-1]\n    for a, b in zip(list(A_sums.values()), list(B_sums.values())):\n        if a != b:\n            print('No')\n            return\n    print('Yes')\n\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 144, "result": 0, "generated": "<ans>\nfrom array import array\ninf = (1 << 30)\n\ndef main():\n    (n,k) = [int(x) for x in input().split(' ')]\n    print(\"n: \", str(n), \"k: \", str(k))\n    Matrix = []\n    print(\"Matrix: \", str(Matrix))\n    for i in range(n):\n        Matrix.append(array('b',[ord(x) for x in input()]))\n        print(\"Matrix[{}]: \".format(i), str(Matrix[i]))\n    dp = [array('l', [inf for j in range(n)]) for i in range(n)]\n    print(\"dp: \", str(dp))\n    direct = [[ord('d') for j in range(n)] for i in range(n)]\n    print(\"direct: \", str(direct))\n    opt = \"\"\n    for s in range (2 * n - 1):\n        opchar = chr(ord('z') + 1)\n        print(\"opchar: \", str(opchar))\n        positions = []\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(i > 0 and j > 0):\n                    if(dp[i-1][j] < dp[i][j-1]):\n                        dp[i][j] = dp[i-1][j]\n                        direct[i][j] = 'l'\n                    else:\n                       dp[i][j] = dp[i][j-1]\n                       direct[i][j] = 'd'\n                elif i > 0:\n                    dp[i][j] = dp[i-1][j]\n                    direct[i][j] = 'l'\n                elif j > 0:\n                    dp[i][j] = dp[i][j-1]\n                    direct[i][j] = 'd'\n                else:\n                    dp[i][j] = 0\n                    direct[i][j] = 'e'\n                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):\n                    dp[i][j]+=1\n                    Matrix[i][j] = ord('a')\n                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):\n                     opchar = chr(Matrix[i][j])\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(Matrix[i][j] is not ord(opchar)):\n                    dp[i][j] = inf\n    ans = \"\"\n    a,b = (n-1,n-1)\n    while(direct[a][b] is not 'e'):\n        ans += chr(Matrix[a][b])\n        if(direct[a][b] is 'l'):\n            a-=1\n        else:\n            b-=1\n    ans += chr(Matrix[0][0])\n    print(ans[::-1])\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 139, "result": 0, "generated": "<ans>\nka, kb = 0, 0\nprint(\"ka: \", str(ka), \"kb: \", str(kb))\n\ndef g(a, b):\n    nonlocal ka, kb\n    if a == b:\n        return\n    if abs(a - b) == 2:\n        if a == 1:\n            ka += 1\n        else:\n            kb += 1\n    else:\n        if a > b:\n            ka += 1\n        else:\n            kb += 1\n    print(\"ka: \", str(ka), \"kb: \", str(kb))\n\ndef main():\n    nonlocal ka, kb\n    k, a, b = list(map(int, input().split()))\n    print(\"k: \", str(k), \"a: \", str(a), \"b: \", str(b))\n    aa = [[] for i in [1, 1, 1]]\n    print(\"aa: \", str(aa))\n    bb = [[] for i in [1, 1, 1]]\n    print(\"bb: \", str(bb))\n    aa[0] = list(map(int, input().split()))\n    print(\"aa[0]: \", str(aa[0]))\n    aa[1] = list(map(int, input().split()))\n    print(\"aa[1]: \", str(aa[1]))\n    aa[2] = list(map(int, input().split()))\n    print(\"aa[2]: \", str(aa[2]))\n    bb[0] = list(map(int, input().split()))\n    print(\"bb[0]: \", str(bb[0]))\n    bb[1] = list(map(int, input().split()))\n    print(\"bb[1]: \", str(bb[1]))\n    bb[2] = list(map(int, input().split()))\n    print(\"bb[2]: \", str(bb[2]))\n    x = a\n    y = b\n    print(\"x: \", str(x), \"y: \", str(y))\n    o = 1\n    c = [[x, y]]\n    print(\"c: \", str(c))\n    d = [[0, 0]]\n    print(\"d: \", str(d))\n    g(x, y)\n    print(\"ka: \", str(ka), \"kb: \", str(kb))\n    if k == 1:\n        return\n    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n    print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n    while [x, y] not in c:\n        o += 1\n        c += [[x, y]]\n        print(\"c: \", str(c))\n        d += [[ka, kb]]\n        print(\"d: \", str(d))\n        g(x, y)\n        print(\"ka: \", str(ka), \"kb: \", str(kb))\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n        if o == k:\n            return\n    ind = c.index([x, y])\n    dka = ka - d[ind][0]\n    dkb = kb - d[ind][1]\n    delta = o - ind\n    kk = (k - ind) // delta - 1\n    print(\"dka: \", str(dka), \"dkb: \", str(dkb), \"delta: \", str(delta))\n    ka += kk * dka\n    kb += kk * dkb\n    print(\"ka: \", str(ka), \"kb: \", str(kb))\n    o += kk * delta\n    print(\"o: \", str(o))\n    while o != k:\n        o += 1\n        g(x, y)\n        print(\"ka: \", str(ka), \"kb: \", str(kb))\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n\nmain()\nprint(\"ka: \", str(ka), \"kb: \", str(kb))\n</ans>", "format_properties": {}}
{"idx": 147, "result": 0, "generated": "<ans>\nimport sys\nfrom functools import lru_cache\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, K, *A = list(map(int, read().split()))\n    print(\"N: \", str(N), \"K: \", str(K), \"A: \", str(A))\n\n    K = list(map(int, f'{K:>040b}'))\n    print(\"K: \", str(K))\n    A2 = [list(map(int, f'{a:>040b}')) for a in A]\n    print(\"A2: \", str(A2))\n    B = [0] * 40\n    for a in A2:\n        for i, bit in enumerate(a):\n            B[i] += bit\n    print(\"B: \", str(B))\n    for i in range(40):\n        if B[i] == N - B[i]:\n            B[i] = 2\n        elif B[i] < N - B[i]:\n            B[i] = 1\n        else:\n            B[i] = 0\n\n    @lru_cache(maxsize=None)\n    def rec(i, x, smaller):\n        if i == 40:\n            ans = 0\n            for a in A:\n                ans += x ^ a\n            return ans\n        elif smaller:\n            if B[i] == 2:\n                return rec(i + 1, (x << 1), True)\n            else:\n                return rec(i + 1, (x << 1) + B[i], True)\n        else:\n            if B[i] == 2:\n                if K[i] == 0:\n                    return rec(i + 1, (x << 1), False)\n                else:\n                    return rec(i + 1, (x << 1), True)\n            elif K[i] == B[i]:\n                return rec(i + 1, (x << 1) + K[i], False)\n            elif K[i] < B[i]:\n                return rec(i + 1, (x << 1) + K[i], False)\n            else:\n                return rec(i + 1, (x << 1) + B[i], True)\n\n    print((rec(0, 0, False)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 148, "result": 0, "generated": "<ans>\n#\n# abc069 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3\n1 10 100\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"4\n1 2 3 4\"\"\"\n        output = \"\"\"No\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"3\n1 4 1\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_4(self):\n        input = \"\"\"2\n1 1\"\"\"\n        output = \"\"\"No\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_5(self):\n        input = \"\"\"6\n2 7 1 8 2 8\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N = int(input())\n    print(\"N: \", str(N))\n    A = list(map(int, input().split()))\n    print(\"A: \", str(A))\n    Q = 0\n    E = 0\n    O = 0\n    for a in A:\n        if a % 4 == 0:\n            Q += 1\n        elif a % 2 == 0:\n            E += 1\n        else:\n            O += 1\n    print(\"Q: \", str(Q), \"E: \", str(E), \"O: \", str(O))\n    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 145, "result": 0, "generated": "<ans>\nimport sys\n\ncases = False\n\n# Pre-defined function\n# Begin\ndef fast_pow(a:int, b:int):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res *= a\n        a *= a\n        b >>= 1\n    return res\n\ndef c2(n):\n    return n * (n-1) // 2\n\ndef get():\n    return list(map(int, input().split()))\n\ndef bits(n: int):\n    return list(bin(n)).count('1')\n\ndef main(test_case = False):\n    n = int(input()) if test_case else 1\n    for _ in range(n):\n        test()\n\ndef flush():\n    sys.stdout.flush()\n\ndef parr(arr):\n    print(*arr, sep=' ')\n\ndef gcd(a, b):\n    while b:\n        if b % a == 0:\n            break\n        tmp = a\n        a = b % a\n        b = tmp\n    return a\n\ndef ext_gcd(a: int, b: int):\n    if (b == 0):\n        return [a, [1, 0]]\n \n    res = ext_gcd(b, a % b)\n    g = res[0]\n    x1 = res[1][0]\n    y1 = res[1][1]\n    x = y1\n    y = x1 - y1 * (a // b)\n \n    return [g, [x, y]]\n\n# End\n\nb = []\np = []\nn = m = a = 0\n \ndef check(cnt):\n    if cnt == 0:\n        return True\n    x = b[-cnt:]\n    y = p[:cnt]\n    s = a\n    i = 0\n    while i < cnt and s >= 0:\n        s -= max(0, y[i]-x[i])\n        i += 1\n    return s >= 0\n \ndef test():\n    nonlocal n, m, a, b, p\n    print(\"n, m, a, b, p: \", str(n), str(m), str(a), str(b), str(p))\n    n, m, a = get()\n    print(\"n, m, a: \", str(n), str(m), str(a))\n    b = sorted(get())\n    print(\"b: \", str(b))\n    p = sorted(get())\n    print(\"p: \", str(p))\n \n    left = 0\n    right = min(n, m)\n \n    ans = -1\n \n    while left <= right:\n        mid = (left + right) // 2\n        if check(mid):\n            ans = max(ans, mid)\n            left = mid + 1\n        else:\n            right = mid - 1\n \n    if ans == -1:\n        print(0, 0)\n        return\n \n    # print(ans)\n \n    t = 0\n    x = b[-ans:]\n    y = p[:ans]\n    i = 0\n    while i < ans:\n        t += min(x[i], y[i])\n        a -= max(0, y[i]-x[i])\n        i += 1\n    print(ans, max(0, t-a)) \n\nmain(cases)\n</ans>", "format_properties": {}}
{"idx": 146, "result": 1, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nla=[]\nprint(\"la: \", str(la))\nle=[]\nprint(\"le: \", str(le))\nli=[]\nprint(\"li: \", str(li))\nlo=[]\nprint(\"lo: \", str(lo))\nlu=[]\nprint(\"lu: \", str(lu))\nans=[]\nprint(\"ans: \", str(ans))\nd1={}\nprint(\"d1: \", str(d1))\nfor i in range(n):\n    s=input()\n    print(\"s: \", str(s))\n    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')\n    print(\"x: \", str(x))\n    if x>0:\n        for c in s[::-1]:\n            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':\n                break\n        print(\"c: \", str(c))\n        if (x,c) in d1:\n            d1[(x,c)].append(s)\n        else :\n            d1[(x,c)]=[s]\n        print(\"d1: \", str(d1))\nd2={}\nprint(\"d2: \", str(d2))\npairs1=[]\nprint(\"pairs1: \", str(pairs1))\npairs2=[]\nprint(\"pairs2: \", str(pairs2))\nfor k in d1:\n    if len(d1[k])%2==1:\n        if k[0] in d2:\n            d2[k[0]].append(d1[k][0])\n        else :\n            d2[k[0]]=[d1[k][0]]\n        print(\"d2: \", str(d2))\n        for i in range(1,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\n        print(\"pairs1: \", str(pairs1))\n    else :\n        for i in range(0,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\n        print(\"pairs1: \", str(pairs1))\nfor k in d2:\n    if len(d2[k])>1:\n        if len(d2[k])%2==1:\n            d2[k].pop()\n        print(\"d2: \", str(d2))\n        for i in range(0,len(d2[k]),2):\n            pairs2.append((d2[k][i],d2[k][i+1]))\n        print(\"pairs2: \", str(pairs2))\nif len(pairs1)<len(pairs2):\n    print(len(pairs1))\n    for i in range(len(pairs1)):\n        print(pairs2[i][0],pairs1[i][0])\n        print(pairs2[i][1],pairs1[i][1])\nelse :\n    print(len(pairs2)+(len(pairs1)-len(pairs2))//2)\n    for i in range(len(pairs2)):\n        print(pairs2[i][0],pairs1[i][0])\n        print(pairs2[i][1],pairs1[i][1])\n    for j in range(len(pairs2),len(pairs1),2):\n        if j==len(pairs1)-1:\n            break\n        else :\n            print(pairs1[j][0],pairs1[j+1][0])\n            print(pairs1[j][1],pairs1[j+1][1])\n</ans>", "format_properties": {}}
{"idx": 149, "result": 0, "generated": "<ans>\nimport sys\nprint(\"import sys: \", str(sys))\ninput = sys.stdin.readline\nprint(\"input: \", str(input))\nenum = enumerate\nprint(\"enum: \", str(enum))\ninf = 1001001001\nprint(\"inf: \", str(inf))\n\nimport collections\nprint(\"collections: \", str(collections))\nimport random\nprint(\"random: \", str(random))\n\ndef linput(ty=int, cvt=list):\n\treturn cvt(list(map(ty,input().split())))\nprint(\"linput: \", str(linput))\n\ndef vinput(rep=1, ty=int, cvt=list):\n\treturn cvt(ty(input().rstrip()) for _ in \"*\"*rep)\nprint(\"vinput: \", str(vinput))\n\ndef gcd(a: int, b: int):\n\twhile b: a, b = b, a%b\n\treturn a\nprint(\"gcd: \", str(gcd))\n\ndef lcm(a: int, b: int):\n\treturn a * b // gcd(a, b)\nprint(\"lcm: \", str(lcm))\n\ndef dist(x1,y1,x2,y2):\n\treturn abs(x1-x2)+abs(y1-y2)\nprint(\"dist: \", str(dist))\n\n#vD = [chr(ord(\"a\")+i) for i in range(26)]\nprint(\"#vD: \", str(\"#vD\"))\n\ndef ran():\n\tvRan = [random.randint(1, 10),\n\t        random.randint(0, 10),\n\t        random.randint(1, 100)]\n\tprint(\"vRan: \", str(vRan))\n\treturn vRan\n\ndef bye(res):\n\tsT = \"No Yes\".split()\n\tprint((sT[res]))\n\t#return\nprint(\"bye: \", str(bye))\n\ndef sol_n(a,b,c):\n\tres = 0\n\tcnt = 0\n\twhile cnt<c:\n\t\tres += 1\n\t\tcnt += a\n\t\tif res%7==0:\n\t\t\tcnt += b\n\treturn res\nprint(\"sol_n: \", str(sol_n))\n\ndef sol(a,b,c):\n\t#a,b,c = linput()\n\t### 3 6 9 12 15\n\t### 1 2 3 4  5\n\t\n\tres = 0\n\tL = -(-a//c)\n\tR = (b//c)\n\tres = R-L+1\n\t\n\treturn res\nprint(\"sol: \", str(sol))\n\ndef deb():\n\t#vI = linput()\n\tvI = ran()\n\t#print(vI)\n\tI = sol_n(*vI)\n\tJ = sol(*vI)\n\tif 1:#I!=J:\n\t\tprint((vI, I, J))\nprint(\"deb: \", str(deb))\n\ndef main():\n\tvI = linput()\n\tprint((sol(*vI)))\nprint(\"main: \", str(main))\n\ndef __starting_point():\n\t#for _ in \"*\"*1000:\n\t#\tdeb()\n\tmain()\nprint(\"__starting_point: \", str(__starting_point()))\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 142, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout\n\nk = int(stdin.readline())\nprint(\"k: \", str(k))\n\nn, m = list(map(int, stdin.readline().split()))\nprint(\"n, m: \", str(n), str(m))\n\nleft, right, down, up = [], [], [], []\nprint(\"left, right, down, up: \", str(left), str(right), str(down), str(up))\n\ncoordinates = []\nprint(\"coordinates: \", str(coordinates))\n\nfor i in range(k):\n    x1, y1, x2, y2 = list(map(int, stdin.readline().split()))\n    print(\"x1, y1, x2, y2: \", str(x1), str(y1), str(x2), str(y2))\n    if x1 == x2:\n        if y1 < y2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    else:\n        if x1 < x2:\n            coordinates.append((x1, y1, x2, y2, i))\n        else:\n            coordinates.append((x2, y2, x1, y1, i))\n    left.append(coordinates[-1])\n    right.append(coordinates[-1])\n    up.append(coordinates[-1])\n    down.append(coordinates[-1])\n\nleft.sort(key=lambda x: (x[0], x[2]))\ndown.sort(key=lambda x: (x[1], x[3]))\n\nchallengers = [[], [], [], []]\ncntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))\nprint(\"cntl, cntr, cntd, cntu: \", str(cntl), str(cntr), str(cntd), str(cntu))\nlabel = 1\n\nif cntl or not cntl:\n    for i in range(cntl, -1, -1):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])\n        else:\n            break\n    for i in range(cntl + 1, k):\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:\n            label = 0\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n            challengers[0].append(left[i][-1])\n        else:\n            break\n\nif cntr or not cntr:\n    for i in range(k - 1 - cntr, k):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n    for i in range(k - 2 - cntr, -1, -1):\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:\n            label = 0\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n            challengers[1].append(left[i][-1])\n        else:\n            break\n\nif cntd or not cntd:\n    for i in range(cntd, -1, -1):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])\n        else:\n            break\n    for i in range(cntd + 1, k):\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:\n            label = 0\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n            challengers[2].append(down[i][-1])\n        else:\n            break\n\nif cntu or not cntu:\n    for i in range(k - 1 - cntu, k):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n    for i in range(k - 2 - cntu, -1, -1):\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:\n            label = 0\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n            challengers[3].append(down[i][-1])\n        else:\n            break\n\nans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])\n\nif not len(ans) or not label:\n    stdout.write('-1')\nelse:\n    stdout.write(str(list(ans)[0] + 1))\n</ans>", "format_properties": {}}
{"idx": 153, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\n\nINF = float(\"inf\")\n\n\ndef solve(N: int, X: int, D: int):\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N+1))\n        return\n\n    if D < 0:\n        X = X + (N-1)*D\n        D = abs(D)\n\n    segs = defaultdict(list)\n    for k in range(N+1):\n        L = k*(k-1)//2\n        R = k*N - k*(k+1)//2\n        Ck = k*X + D*L\n        Rk = R-L\n        seg = (Ck//D, Ck//D+Rk+1)\n        s = Ck % D\n        segs[s].append(seg)\n\n    tot = 0\n    for k in segs:\n        event = defaultdict(int)\n        for l, r in segs[k]:\n            event[l] += 1\n            event[r] -= 1\n\n        curr = 0\n        pre = -1\n        for k in sorted(event.keys()):\n            if curr > 0:\n                tot += k - pre\n            curr += event[k]\n            pre = k\n    print(tot)\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    print(\"N: \", str(N))\n    X = int(next(tokens))  # type: int\n    print(\"X: \", str(X))\n    D = int(next(tokens))  # type: int\n    print(\"D: \", str(D))\n    solve(N, X, D)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 150, "result": 0, "generated": "<ans>\nfrom math import sqrt, pow, log, log2, log10, exp\nprint(\"sqrt: \", str(sqrt), \"pow: \", str(pow), \"log: \", str(log), \"log2: \", str(log2), \"log10: \", str(log10), \"exp: \", str(exp))\nfrom copy import deepcopy\nprint(\"deepcopy: \", str(deepcopy))\nfrom fractions import gcd\nprint(\"gcd: \", str(gcd))\n\n\ndef read_ints():\n    return list(map(int, input().split()))\nprint(\"read_ints: \", str(read_ints))\n\n\ndef read_int():\n    return read_ints()[0]\nprint(\"read_int: \", str(read_int))\n\n\ndef read_floats():\n    return list(map(float, input().split()))\nprint(\"read_floats: \", str(read_floats))\n\n\ndef read_float():\n    return read_floats()[0]\nprint(\"read_float: \", str(read_float))\n\n\ndef format_list(l):\n    return ' '.join(list(map(str, l)))\nprint(\"format_list: \", str(format_list))\n\n\ndef one_dim_array(n, value=0):\n    return [deepcopy(value) for x in range(n)]\nprint(\"one_dim_array: \", str(one_dim_array))\n\n\ndef two_dim_array(n, m, value=0):\n    return [[deepcopy(value) for x in range(m)] for x in range(n)]\nprint(\"two_dim_array: \", str(two_dim_array))\n\n\ndef is_prime(n):\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, sqrt(n) + 1):\n        if n % i == 0:\n            return False\n    return True\nprint(\"is_prime: \", str(is_prime))\n\n\ndef max_len_sublist(l, f):\n    start, max_length, length = 0, 0, 0\n    for i in range(1, len(l)):\n        if f(l[i], l[i - 1]):\n            length += 1\n        else:\n            if max_length < length:\n                start = i - length\n                max_length = length\n            length = 0\n    return start, max_length\nprint(\"max_len_sublist: \", str(max_len_sublist))\n\n\ndef tf_to_yn(b):\n    return 'YES' if b else 'NO'\nprint(\"tf_to_yn: \", str(tf_to_yn))\n\n\ndef longest_non_descent_subsequence(s, restore_sequence=False):\n    d = one_dim_array(len(s), 0)\n    for i in range(len(s)):\n        possible = [d[j] + 1 if s[j] <= s[i] else 1 for j in range(i)]\n        d[i] = 1 if len(possible) == 0 else max(possible)\n\n    if not restore_sequence:\n        return d[-1] if len(d) != 0 else 0\nprint(\"longest_non_descent_subsequence: \", str(longest_non_descent_subsequence))\n\n\nl = read_int()\np = read_int()\nq = read_int()\nt = l / (p + q)\nprint(t*p)\n</ans>", "format_properties": {}}
{"idx": 152, "result": 0, "generated": "<ans>\n# NOT MY CODE\n# https://codeforces.com/contest/919/submission/80857731\n \nfrom types import GeneratorType\n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        to = f(*args, **kwargs)\n        if stack:\n            return to\n        else:\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        return to\n                    to = stack[-1].send(to)\n    return wrappedfunc\n \nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\n \nn,m=list(map(int,input().split()))\ns=input()\nd=dd(list)\nlol=0\nprint(\"n: \", str(n), \"m: \", str(m), \"s: \", str(s))\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    print(\"u: \", str(u), \"v: \", str(v))\n    if(u==v):\n        lol=1\n        print(-1)\n        return\n    d[u].append(v)\nprint(\"d: \", str(d))\nvis=[0]*(n+1)\nrvis=[0]*(n+1)\ncou=[0]\ndp=[dd(int) for i in range(n+1)]\nmx=[0]\nh=[0]\n#print(d)\n@bootstrap\ndef dfs(u):\n    if(h[0]==1):\n        yield\n    vis[u]=1\n    rvis[u]=1\n    for i in d[u]:\n        if(h[0]==1):\n            yield\n        if(vis[i]==0):\n            yield dfs(i)\n            if(h[0]==1):\n                yield            \n        elif(rvis[i]==True):\n            h[0]=1\n            yield\n    rvis[u]=0\n    if(h[0]==1):\n        yield\n    for i in d[u]:\n        for j in dp[i]:\n            dp[u][j]=max(dp[u][j],dp[i][j])\n            mx[0]=max(mx[0],dp[u][j])\n    dp[u][s[u-1]]+=1\n    #print(u,dp[u])\n    mx[0]=max(mx[0],dp[u][s[u-1]])\n    yield\n#print(dp)\nfor i in range(1,n+1):\n    if(vis[i]==0):\n        cou=[0]\n        dfs(i)\nif(h[0]):\n    print(-1)\nelse:\n    print(mx[0])\n</ans>", "format_properties": {}}
{"idx": 143, "result": 0, "generated": "<ans>\nimport math\nprint(\"import math: \", str(math))\nimport sys\nprint(\"import sys: \", str(sys))\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self,Nodes,is_directed=False):\n        print(\"self: \", str(self), \"Nodes: \", str(Nodes), \"is_directed: \", str(is_directed))\n        self.nodes=Nodes\n        self.adj_list={}\n        self.is_directed=is_directed\n        for node in self.nodes:\n            self.adj_list[node]=[]\n            \n    def add_edge(self,u,v):\n        print(\"self: \", str(self), \"u: \", str(u), \"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed==False:\n            self.adj_list[v].append(u)\n \n    def print_graph(self):\n        for node in self.nodes:\n            print((node,\"->\",self.adj_list[node]))\n \n    def degree_node(self,node):\n        return len(self.adj_list[node])\n \n    def dfsUTIL(self,v,visited,parents=[]):\n        #print(v,end=\" \")\n        visited[v]=True\n        for i in self.adj_list[v]:\n            if visited[i]==False:\n                self.dfsUTIL(i,visited,parents)\n                parents.append(i)        \n    \n    def dfs(self,v):\n        visited=[False]*(max(self.adj_list)+1)\n        parents=[v]\n        self.dfsUTIL(v,visited,parents)\n        return len(parents)\n        \n#####sorting a dictionary by the values#####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))\n    \n##### naive method for testing prime or not O(n^.5)#####\ndef is_prime(n):\n    print(\"n: \", str(n))\n    if n==1:\n        return 0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\n\n#####swap function#####\ndef swap(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    temp=a\n    a=b\n    b=temp\n    return a,b\n\n#####Primes till Nth O(n)#####\ndef seive_primes(n):\n    print(\"n: \", str(n))\n    flag=[0]*(n+10)\n    flag[1]=flag[0]=1\n    i=2\n    while i*i<=n+1:\n        if flag[i]==0:\n            j=i*i\n            while j<=n+1:\n                flag[j]=1\n                j+=i\n        i+=1\n    return flag\n\n#####all the prime factors of a number#####\ndef factors(n):\n    print(\"n: \", str(n))\n    d={}\n    while(n%2==0):\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n        n/=2\n    for i in range(3,int(n**0.5)+1,2):\n        while(n%i==0):\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n            n/=i\n    n=int(n)\n    if n>1:\n        d[n]=1\n    return d\n\n#####greatest common divisor of two numbers#####\ndef gcd(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\n#####least common multiplyer of two numbers#####\ndef lcm(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    return (a*b)//gcd(a,b)\n\n#####function that return all the letters#####\ndef alphabates():\n    print(\"return: \", str(alphabates()))\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n#####binary search O(logN)#####\ndef binary_search(ls,n,flag):\n    print(\"ls: \", str(ls), \"n: \", str(n), \"flag: \", str(flag))\n    low=0\n    hi=n-1\n    while(low<=hi):\n        mid=(low+hi)//2\n        if ls[mid]==flag:\n            return mid\n        elif ls[mid]>flag:\n            hi=mid-1\n        else:\n            low=mid+1\n    return -1\n\n#####quadratic roots#####\ndef qdrt(a,b,c):\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    chk=b*b-4*a*c\n    if chk>=0:\n        ans1=(-b+chk**0.5)/(2*a)\n        ans2=(-b-chk**0.5)/(2*a)\n        return [int(ans1),int(ans2)]\n    return -1\n#####permutations#####\ndef permutation(n,r):\n    print(\"n: \", str(n), \"r: \", str(r))\n    if n<r:\n        return 0\n    ans=1\n    for i in range(n-r+1,n+1):\n        ans*=i\n    return ans\n\n#####combinations#####\ndef combination(n,r):\n    print(\"n: \", str(n), \"r: \", str(r))\n    if n<r:\n        return 0\n    ans=1\n    for i in range(r):\n        ans*=(n-i)\n    div=1\n    for i in range(2,r+1):\n        div*=i\n    return ans//div\n        \n#####taking an array/list as input#####\ndef arinp():\n    print(\"input: \", str(arinp()))\n    ls=list(map(int,input().split()))\n    return ls\n\n#####taking multiple inputs#####\ndef mult_inp():\n    print(\"input: \", str(mult_inp()))\n    return list(map(int,input().split()))\n\n#####Main function starts from here#####\ndef main():\n    print(\"input: \", str(s))\n    s=input()\n    n=len(s)\n    if s==s[::-1] and s[:n//2]==s[n//2+1:]:\n        print('Yes')\n    else:\n        print('No')\ndef __starting_point():\n    main()\n    \n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 155, "result": 0, "generated": "<ans>\n# E\nN = int(input())\nprint(\"N: \", str(N))\nP_list = list(map(int, input().split()))\nprint(\"P_list: \", str(P_list))\nX_list = list(map(int, input().split()))\nprint(\"X_list: \", str(X_list))\n\n# graph\nchild_list = [[] for _ in range(N+1)]\nprint(\"child_list: \", str(child_list))\nfor i in range(2, N+1):\n    child_list[P_list[i-2]].append(i)\n    # print(\"i: \", str(i), \"child_list[P_list[i-2]]: \", str(child_list[P_list[i-2]]))\n\n# from root\n# minimize local total weight\n\ncolor1 = [0]+X_list\nprint(\"color1: \", str(color1))\ncolor2 = [0]*(N+1)\nprint(\"color2: \", str(color2))\n\n# solve knapsack\ndef solve_knapsack(L, M):\n    min_acc = sum([min(color1[j], color2[j]) for j in L])\n    if min_acc > M:\n        return -1\n    else:\n        add_can = M - min_acc\n        add_set = set([0])\n        for j in L:\n            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])\n            add_set_ = set(add_set)\n            for s in add_set:\n                if s + add_j <= add_can:\n                    add_set_.add(s + add_j)\n            add_set = add_set_\n        \n        total = sum([color1[j]+color2[j] for j in L])\n        return total - max(add_set) - min_acc\n\nres = \"POSSIBLE\"\n\nfor i in range(N, 0, -1):\n    if len(child_list[i]) == 0:\n        pass\n    elif len(child_list[i]) == 1:\n        j = child_list[i][0]\n        if min(color1[j], color2[j]) > X_list[i-1]:\n            res = \"IMPOSSIBLE\"\n            break\n        elif max(color1[j], color2[j]) > X_list[i-1]:\n            color2[i] = max(color1[j], color2[j])\n        else:\n            color2[i] = min(color1[j], color2[j])\n    else:\n        c2 = solve_knapsack(child_list[i], X_list[i-1])\n        if c2 < 0:\n            res = \"IMPOSSIBLE\"\n            break\n        else:\n            color2[i] = c2\n    \nprint(res)\n</ans>", "format_properties": {}}
{"idx": 156, "result": 0, "generated": "<ans>\ndef prime_factor(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            while n % i == 0:\n                n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    print(\"factors: \", str(factors))\n    return factors\n\n\ndef divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    print(\"divisors: \", str(divisors))\n    return divisors\n\n\ndef mebius(n):\n    res = {}\n    primes = prime_factor(n)\n    m = len(primes)\n    for i in range(1 << m):\n        mu = 1\n        d = 1\n        for j in range(m):\n            if i >> j & 1:\n                mu *= -1\n                d *= primes[j]\n        res[d] = mu\n    print(\"res: \", str(res))\n    return res\n\n\nmod = 10**9+7\nN, K = list(map(int, input().split()))\ndiv = divisors(N)\n\nans = 0\n\nfor x in div:\n    div2 = divisors(x)\n    mu = mebius(x)\n    cnt = 0\n    for y in list(mu.keys()):\n        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]\n    if x % 2 == 0:\n        cnt *= pow(2, mod-2, mod)\n    ans += x*cnt\n    ans %= mod\n\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 134, "result": 0, "generated": "<ans>\n__author__ = 'zhan'\n\nimport time\n[a1, b1] = [int(i) for i in input().split()]\n[a2, b2] = [int(i) for i in input().split()]\n\nt0 = time.time()\nq1 = [[a1, b1, 0]]\nq2 = [[a2, b2, 0]]\ntested1 = []\ntested2 = []\ntested_total1 = []\ntested_total2 = []\n\n\ndef equal(t, q):\n    lo = 0\n    hi = len(q)\n    while True:\n        if lo >= hi:\n            return False\n        m = (lo + hi) // 2\n        p = q[m]\n        temp = p[0] * p[1]\n        if t == temp:\n            return [p[0], p[1], p[2]]\n        if t < temp:\n            lo = m + 1\n        elif t > temp:\n            hi = m\n\n\ndef found(key, a):\n    lo = 0\n    hi = len(a)\n    while True:\n        if lo >= hi:\n            return False\n        m = (lo + hi) // 2\n        p = a[m]\n        if key[0] == p[0] and key[1] == p[1]:\n            return True\n        if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:\n            lo = m + 1\n        if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:\n            hi = m\n\n\nwhile True:\n    if len(q1) > 0 and len(q2) > 0:\n        total1 = q1[0][0] * q1[0][1]\n        total2 = q2[0][0] * q2[0][1]\n        if total1 > total2:\n            ans = equal(total1, q2)\n            if ans:\n                print(str(ans[2] + q1[0][2]) + \"\\n\" + str(q1[0][0]) + \" \" + str(q1[0][1]) + \"\\n\" + str(ans[0]) + \" \" + str(ans[1]))\n            else:\n                if not(q1[0][0] & 1):\n                    tt = [q1[0][0] // 2, q1[0][1], q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q1[0][0] % 3 == 0:\n                    tt = [q1[0][0] // 3 * 2, q1[0][1], q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if not(q1[0][1] & 1):\n                    tt = [q1[0][0], q1[0][1] // 2, q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q1[0][1] % 3 == 0:\n                    tt = [q1[0][0], q1[0][1] // 3 * 2, q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                q1.pop(0)\n                q1.sort(key=lambda x: x[0]*x[1], reverse=True)\n                #tested1.sort(key=lambda x: (x[0], x[1]), reverse=True)\n\n        elif total1 < total2:\n            ans = equal(total2, q1)\n            if ans:\n                print(str(ans[2] + q2[0][2]) + \"\\n\" + str(ans[0]) + \" \" + str(ans[1]) + \"\\n\" + str(q2[0][0]) + \" \" + str(q2[0][1]))\n                break\n            else:\n                if not(q2[0][0] & 1):\n                    tt = [q2[0][0] // 2, q2[0][1], q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q2[0][0] % 3 == 0:\n                    tt = [q2[0][0] // 3 * 2, q2[0][1], q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if not(q2[0][1] & 1):\n                    tt = [q2[0][0], q2[0][1] // 2, q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q2[0][1] % 3 == 0:\n                    tt = [q2[0][0], q2[0][1] // 3 * 2, q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                q2.pop(0)\n                q2.sort(key=lambda x: x[0]*x[1], reverse=True)\n                #tested2.sort(key=lambda x: (x[0], x[1]), reverse=True)\n\n        else:\n            print(str(q1[0][2] + q2[0][2]) + \"\\n\" + str(q1[0][0]) + \" \" + str(q1[0][1]) + \"\\n\" + str(q2[0][0]) + \" \" + str(q2[0][1]))\n            break\n    else:\n        print(-1)\n        break\n\nt1 = time.time()\n#print(t1-t0)\n</ans>", "format_properties": {}}
{"idx": 160, "result": 0, "generated": "<ans>\n# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\nfrom itertools import product, accumulate, combinations, product\n#import bisect\n#import numpy as np\n#from copy import deepcopy\n#from collections import deque\n#from decimal import Decimal\n#from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\n\ndef run():\n    N = int(input())\n    nines = [9 ** i for i in range(1, 10) if 9 ** i <= N]\n    sixes = [6 ** i for i in range(1, 10) if 6 ** i <= N][::-1]\n    L = len(nines)\n    #print(nines, sixes)\n    min_ans = INF\n    for K in product(list(range(9)), repeat = L):\n        #print(K, '----------------')\n        ans = 0\n        s = 0\n        for k, x in zip(K, nines):\n            if k:\n                ans += k\n                s += x * k\n        #print(ans, s)\n\n        if s > N:continue\n        resid = N - s\n        #print(resid)\n        for six in sixes:\n            #print(resid)\n            tmp = resid // six\n            if tmp:\n                ans += tmp\n                resid -= six * tmp\n        #print(resid, ans)\n        #if resid >= 6:\n        #    print(resid)\n        ans += resid\n        min_ans = min(min_ans,ans)\n\n    print(min_ans)\n\ndef __starting_point():\n    run()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 154, "result": 0, "generated": "<ans>\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\nprint(\"n: \", str(n))\np = list(map(int, input().split()))\nprint(\"p: \", str(p))\nodd = (n+1)//2\nprint(\"odd: \", str(odd))\neven = n-odd\nprint(\"even: \", str(even))\nfor i in p:\n    if i:\n        if i%2 == 0:\n            even -= 1\n            print(\"even -= 1: \", str(even))\n        else:\n            odd -= 1\n            print(\"odd -= 1: \", str(odd))\n    else:\n        print(\"p[i] = 1: \", str(p[i]))\n\nif even == 0:\n    p = [i if i else 1 for i in p]\n    print(\"p: \", str(p))\nif odd*even == 0:\n    ans = 0\n    prev = p[0]\n    print(\"ans: \", str(ans))\n    print(\"prev: \", str(prev))\n    for pi in p:\n        ans += (pi+prev)%2\n        prev = pi\n        print(\"ans += (pi+prev)%2: \", str(ans))\n        print(\"prev = pi: \", str(prev))\n    print(ans)\n    return\n\nDP = [[float(\"inf\")]*(even+1) for i in range(2)]\nprint(\"DP: \", str(DP))\nfor i in range(n):\n    nxt = [[float(\"inf\")]*(even+1) for i in range(2)]\n    if i == 0:\n        if p[i]:\n            if p[i]%2 == 0:\n                nxt[0][0] = 0\n                print(\"nxt[0][0] = 0: \", str(nxt[0][0]))\n            else:\n                nxt[1][0] = 0\n                print(\"nxt[1][0] = 0: \", str(nxt[1][0]))\n        else:\n            nxt[0][1] = 0\n            nxt[1][0] = 0\n            print(\"nxt[0][1] = 0: \", str(nxt[0][1]))\n            print(\"nxt[1][0] = 0: \", str(nxt[1][0]))\n    else:\n        if p[i]:\n            if p[i]%2 == 0:\n                for j in range(even+1):\n                    nxt[0][j] = min(DP[0][j], DP[1][j]+1)\n                    print(\"nxt[0][j] = min(DP[0][j], DP[1][j]+1): \", str(nxt[0][j]))\n            else:\n                for j in range(even+1):\n                    nxt[1][j] = min(DP[0][j]+1, DP[1][j])\n                    print(\"nxt[1][j] = min(DP[0][j]+1, DP[1][j]): \", str(nxt[1][j]))\n        else:\n            for j in range(1, even+1):\n                nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)\n                print(\"nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1): \", str(nxt[0][j]))\n            for j in range(even+1):\n                nxt[1][j] = min(DP[0][j]+1, DP[1][j])\n                print(\"nxt[1][j] = min(DP[0][j]+1, DP[1][j]): \", str(nxt[1][j]))\n    DP = nxt\n    print(\"DP = nxt: \", str(DP))\nprint(min(DP[0][-1], DP[1][-1]))\n</ans>", "format_properties": {}}
{"idx": 151, "result": 0, "generated": "<ans>\nz=[int(p) for p in input().split()]\nprint(\"z: \", str(z))\nm=z[2]\nprint(\"m: \", str(m))\nlst=[]\nprint(\"lst: \", str(lst))\nlst.append(z[0])\nprint(\"lst: \", str(lst))\nlst.append(z[1])\nprint(\"lst: \", str(lst))\ntempi=min(lst)\nprint(\"tempi: \", str(tempi))\ntempa=max(lst)\nprint(\"tempa: \", str(tempa))\ncount=0\nprint(\"count: \", str(count))\nfibo=[]\nprint(\"fibo: \", str(fibo))\n\nn=1000000000000000000\nprint(\"n: \", str(n))\ndef fib(n):\n        print(\"fibo: \", str(fibo))\n        a, b = 0, 1\n        print(\"a: \", str(a))\n        print(\"b: \", str(b))\n        while b < n:\n                print(\"b: \", str(b))\n                fibo.append(b)\n                print(\"fibo: \", str(fibo))\n                a, b = b, a+b\n                print(\"a: \", str(a))\n                print(\"b: \", str(b))\n\ndef add(m):\n        print(\"m: \", str(m))\n        n=10**18\n        print(\"n: \", str(n))\n        tempi=min(lst)\n        print(\"tempi: \", str(tempi))\n        tempa=max(lst)\n        print(\"tempa: \", str(tempa))\n        count=0\n        print(\"count: \", str(count))\n        if(tempi>0 and tempa>0 and m>tempa):\n                print(\"tempi: \", str(tempi))\n                print(\"tempa: \", str(tempa))\n                print(\"m: \", str(m))\n                fib(n)\n                print(\"fibo: \", str(fibo))\n                for p in range(1,len(fibo)+1):\n                        print(\"p: \", str(p))\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                print(\"count: \", str(count))\n                                count+=p\n                                print(\"count: \", str(count))\n                                return count\n        elif(tempi==0 or tempa==0):\n                print(\"tempi: \", str(tempi))\n                print(\"tempa: \", str(tempa))\n                print(\"m: \", str(m))\n                count=1\n                print(\"count: \", str(count))\n                fib(n)\n                print(\"fibo: \", str(fibo))\n                tempi=tempa+(tempi)\n                print(\"tempi: \", str(tempi))\n                for p in range(1,len(fibo)):\n                        print(\"p: \", str(p))\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                print(\"count: \", str(count))\n                                count+=p\n                                print(\"count: \", str(count))\n                                return count\n\n        elif(tempi<0 and tempa>0):\n                print(\"tempi: \", str(tempi))\n                print(\"tempa: \", str(tempa))\n                print(\"m: \", str(m))\n                val=(-(tempi)//tempa)+1\n                print(\"val: \", str(val))\n                count=val\n                print(\"count: \", str(count))\n                tempi=tempi+(val*tempa)\n                print(\"tempi: \", str(tempi))\n                fib(n)\n                print(\"fibo: \", str(fibo))\n                for p in range(1,len(fibo)):\n                        print(\"p: \", str(p))\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                print(\"count: \", str(count))\n                                count+=p\n                                print(\"count: \", str(count))\n                                return count\n\nif(tempi>0 and tempa>0 and m>tempa):\n        cou=add(m)\n        print(cou)\n\nelif(tempi>0 and tempa>0 and m<=tempa):\n        print(0)\n\nelif(tempi==0 ):\n        if(tempi==0 and tempa==0 and m>0):\n                print(-1)\n        elif(tempi==0 and tempa==0 and m<=0):\n                print(0)\n        elif(tempa==0 and tempi<0 and m>0):\n                print(-1)\n                \n        else:\n                cou=add(m)\n                print(cou)\nelif(tempi<0 and tempa>0):\n        if(m<=tempa):\n                print(0)\n        else:\n                cou=add(m)\n                print(cou)\nelif(tempi<0 and tempa==0):\n        if(m>0):\n                print(-1)\n        else:\n                print(0)\nelif(tempi<0 and tempa<0):\n        if(m>=0):\n                print(-1)\n        elif(m<0 and m<=tempa):\n                print(0)\n        elif(m<0 and m>tempa):\n                print(-1)\n\n</ans>", "format_properties": {}}
{"idx": 158, "result": 0, "generated": "<ans>\ndef increasing(arr):\n    n = len(arr)\n    for i in range(n-1):\n        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:\n            print(\"arr: \", str(arr))\n            return False\n\n    print(\"arr: \", str(arr))\n    return True\n\ndef getFacts(n,mod):\n    facts = [1]*n\n    print(\"facts: \", str(facts))\n    for i in range(1,n):\n        facts[i] = facts[i-1]*i\n        facts[i] %= mod\n\n    print(\"facts: \", str(facts))\n    return facts\n\ndef solve(arr1,arr2,n,mod):\n    facts = getFacts(4*10**5+1,mod)\n    total = facts[n]\n    print(\"total: \", str(total))\n    dist1 = {}\n    for i in arr1:\n        if i[0] not in list(dist1.keys()):\n            dist1[i[0]] = 1\n            print(\"dist1: \", str(dist1))\n        else:\n            dist1[i[0]] += 1\n            print(\"dist1: \", str(dist1))\n\n    dist2 = {}\n    for i in arr2:\n        if i[0] not in list(dist2.keys()):\n            dist2[i[0]] = 1\n            print(\"dist2: \", str(dist2))\n        else:\n            dist2[i[0]] += 1\n            print(\"dist2: \", str(dist2))\n\n    count = 1\n    for i in dist1:\n        count *= facts[dist1[i]]\n        count = count%mod\n\n    total -= count\n    count = 1\n    \n    for i in dist2:\n        count *= facts[dist2[i]]\n        count = count%mod\n\n    #print(count)\n    total -= count\n\n    arr1.sort()\n    if increasing(arr1):\n        count = 1\n    else:\n        count = 0\n    print(\"arr1: \", str(arr1))\n    dist3 = {}\n    for i in arr1:\n        if i not in list(dist3.keys()):\n            dist3[i] = 1\n            print(\"dist3: \", str(dist3))\n        else:\n            dist3[i] += 1\n            print(\"dist3: \", str(dist3))\n        \n    for i in dist3:\n        count *= facts[dist3[i]]\n        count = count%mod\n\n    #print(count,total)\n    total += count\n    total = total%mod\n    print(\"total: \", str(total))\n    \n\ndef main():\n    mod = 998244353\n    n = int(input())\n    first = []\n    second = []\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        first.append((a,b))\n        second.append((b,a))\n    \n    solve(first,second,n,mod)\n\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 161, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\n# from operator import itemgetter\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\nfrom collections import deque\n# import math\n# from functools import reduce\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().rstrip().split()))\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n# BEGIN CUT HERE\n\n\nclass BIT:\n    def __init__(self, x, d=0):\n        if isinstance(x, int):\n            self.size = x\n            self.tree = [d for _ in range(self.size + 1)]\n        elif isinstance(x, list):\n            self.size = len(x)\n            self.tree = [d for _ in range(self.size + 1)]\n            self.build(x)\n        else:\n            raise TypeError\n\n    def build(self, arr):\n        if not isinstance(arr, list):\n            raise TypeError\n        for num, x in enumerate(arr):\n            self.add0(num, x)\n\n    def sum(self, i):\n        s = self.tree[0]\n        while i > 0:\n            s += self.tree[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, a):\n        if(i == 0):\n            return\n        while (i <= self.size):\n            self.tree[i] += a\n            i += (i & -i)\n\n    def bisect_left(self, w):\n        if w <= 0:\n            return 0\n        x = 0\n        r = 1\n        while (r < self.size):\n            r <<= 1\n        k = r\n        while (k > 0):\n            if x + k <= self.size and self.tree[x + k] < w:\n                w -= self.tree[x + k]\n                x += k\n            k >>= 1\n        return x + 1\n\n    def query(self, l, r):\n        return self.sum(r - 1) - self.sum(l - 1)\n\n    def sum0(self, i):\n        return self.sum(i + 1)\n\n    def add0(self, i, a):\n        self.add(i + 1, a)\n\n    def query0(self, l, r):\n        return self.sum(r) - self.sum(l)\n\n    def __getitem__(self, item):\n        _tmp = item.indices(self.size + 1)\n        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]\n\n    def __str__(self):\n        return str(self[1:self.size + 1])\n\n# END CUT\n\n\ndef main():\n    n = ii()\n    print(\"n: \", str(n))\n    a = lmi()\n    print(\"a: \", str(a))\n    q = ii()\n    print(\"q: \", str(q))\n    bit = BIT(a)\n    print(\"bit: \", str(bit))\n    # print(bit)\n    for i in range(q):\n        l, r = mi()\n        print(\"l: \", str(l))\n        print(\"r: \", str(r))\n        a = bit.query(l, r+1)\n        print(\"a: \", str(a))\n        print((a-a % 10)//10)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 167, "result": 0, "generated": "<ans>\nimport sys\nimport random\nfrom math import *\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef finput():\n    return float(input())\n\ndef tinput():\n    return input().split()\n\ndef linput():\n    return list(input())\n\ndef rinput():\n    return map(int, tinput())\n\ndef fiinput():\n    return map(float, tinput())\n\ndef rlinput():\n    return list(map(int, input().split()))\n\ndef trinput():\n    return tuple(rinput())\n\ndef srlinput():\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    if fl:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\ndef YESNO(fl):\n    if fl:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ndef main():\n    x, y, n = rinput()\n    print(\"x: \", str(x), \"y: \", str(y), \"n: \", str(n))\n    res = n - y\n    print(\"res: \", str(res))\n    print(x * (res // x) + y)\n\nfor inytd in range(iinput()):\n    print(\"inytd: \", str(inytd))\n    main()\n</ans>", "format_properties": {}}
{"idx": 159, "result": 0, "generated": "<ans>\nimport sys\n\n#\u7e26k\u3001\u6a2ak\u306e\u30de\u30b9\u306b\u79fb\u52d5\u3055\u305b\u3066\u8003\u3048\u308b\nn, k = map(int, sys.stdin.readline().strip().split())\nprint(\"n: \", str(n), \"k: \", str(k))\nx = []\ny = []\nmx = []\nmy = []\nprint(\"x: \", str(x), \"y: \", str(y), \"mx: \", str(mx), \"my: \", str(my))\nfor _ in range(n):\n    xx, yy, c = sys.stdin.readline().strip().split()\n    xx = int(xx)\n    yy = int(yy)\n    print(\"xx: \", str(xx), \"yy: \", str(yy), \"c: \", str(c))\n    if c == 'W':\n        xx += k\n    xx %= 2 * k\n    yy %= 2 * k\n    print(\"xx: \", str(xx), \"yy: \", str(yy))\n    if xx >= k:\n        if yy >= k:\n            x.append(xx - k)\n            y.append(yy - k)\n            print(\"x: \", str(x), \"y: \", str(y))\n        else:\n            mx.append(xx - k)\n            my.append(yy)\n            print(\"mx: \", str(mx), \"my: \", str(my))\n    else:\n        if yy >= k:\n            mx.append(xx)\n            my.append(yy - k)\n            print(\"mx: \", str(mx), \"my: \", str(my))\n        else:\n            x.append(xx)\n            y.append(yy)\n            print(\"x: \", str(x), \"y: \", str(y))\n\ngraph = [[0 for _ in range(k)] for __ in range(k)]\nprint(\"graph: \", str(graph))\n\n#\u7d2f\u7a4d\u548c\n#lx + lmx = n\nlx = len(x)\nprint(\"lx: \", str(lx))\ngraph[0][0] += lx\nprint(\"graph[0][0]: \", str(graph[0][0]))\nfor i in range(lx):\n    graph[x[i]][0] -= 1\n    graph[0][y[i]] -= 1\n    graph[x[i]][y[i]] += 2\n    print(\"graph[x[i]][0]: \", str(graph[x[i]][0]), \"graph[0][y[i]]: \", str(graph[0][y[i]]), \"graph[x[i]][y[i]]: \", str(graph[x[i]][y[i]]))\n\nlmx = len(mx)\nprint(\"lmx: \", str(lmx))\ngraph[0][0] -= lmx\nprint(\"graph[0][0]: \", str(graph[0][0]))\nfor i in range(lmx):\n    graph[mx[i]][0] += 1\n    graph[0][my[i]] += 1\n    graph[mx[i]][my[i]] -= 2\n    print(\"graph[mx[i]][0]: \", str(graph[mx[i]][0]), \"graph[0][my[i]]: \", str(graph[0][my[i]]), \"graph[mx[i]][my[i]]: \", str(graph[mx[i]][my[i]]))\n\nfor i in graph:\n    for j in range(k-1):\n        i[j+1] += i[j]\n        print(\"i[j+1]: \", str(i[j+1]), \"i[j]: \", str(i[j]))\n\nfor i in range(k):\n    for j in range(k-1):\n        graph[j+1][i] += graph[j][i]\n        print(\"graph[j+1][i]: \", str(graph[j+1][i]), \"graph[j][i]: \", str(graph[j][i]))\n\n#\u6700\u5927\u5024\u3001\u6700\u5c0f\u5024\u3092\u53d6\u5f97\nbig = max([max(i) for i in graph]) + lmx\nsmall = min([min(i) for i in graph]) - lx\n\nif big + small >= 0:\n    print(big)\nelse:\n    print(-small)\n</ans>", "format_properties": {}}
{"idx": 164, "result": 0, "generated": "<ans>\nfrom sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= (ans%10 + 1%10) % 10\n                \n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n    \n        \n    \nn,m=mp()\nprint(\"n: \", str(n), \"m: \", str(m))\nl=[st() for i in range(n)]\nprint(\"l: \", str(l))\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            print(\"i: \", str(i), \"j: \", str(j), \"val: \", str(val))\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            print(\"i: \", str(i), \"j: \", str(j))\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            print(\"A: \", str(A), \"B: \", str(B))\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n                \n            \nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n            \n                        \n                \n            \n\n</ans>", "format_properties": {}}
{"idx": 165, "result": 0, "generated": "<ans>\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nn,l,r = li()\nprint(\"n: \", str(n), \"l: \", str(l), \"r: \", str(r))\norig = r\nl -= 1\nr -= l\n\ncurrleft = 0\ncurs = n - 1\nprint(\"currleft: \", str(currleft), \"curs: \", str(curs))\nwhile curs and currleft + 2*curs <= l:\n    currleft += 2*curs\n    curs -= 1\nstart = n - curs\nprint(\"start: \", str(start))\nans = []\nhead = start\nl -= currleft\n\nlast = head + 1\nhalf = 0\nwhile l:\n    half = 1\n    start = last\n    last += 1\n    l -= 1\n    if not l:break\n    half = 0\n    start = head\n    l -= 1\n\nif half:\n    ans.append(start)\n    if last == n + 1:\n        head += 1\n        last = head + 1\n    start = head\n    r -= 1\n\nwhile r:\n    ans.append(start)\n    r -= 1\n    if not r:break\n    start = last\n    ans.append(start)\n    last += 1\n    if last == n + 1:\n        head += 1\n        last = head + 1\n    r -= 1\n    start = head\n    \nif orig == n*(n-1) + 1:\n    ans[-1] = 1\n\nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 163, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nfrom sys import stdin\nfrom bisect import bisect_left, bisect_right\n    \nINF = int(1e9)\n\ndef find(par, a):\n    if par[a] == a:\n        print(\"a: \", str(a))\n        return a\n    par[a] = find(par, par[a])\n    print(\"a: \", str(a), \"par[a]: \", str(par[a]))\n    return par[a]\n\ndef union(par, rnk, a, b):\n    a = find(par,a)\n    b = find(par,b)\n    if a==b:\n        return\n    \n    if rnk[a]<rnk[b]:\n        par[a] = b\n    else:\n        par[b] = a\n        if rnk[a]==rnk[b]:\n            rnk[a] += 1\n    \ndef solve():\n    n, m, k = map(int, stdin.readline().split())\n    print(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\n    cnts = list(map(int, stdin.readline().split()))\n    print(\"cnts: \", str(cnts))\n    for i in range(1,k):\n        cnts[i] += cnts[i-1]\n    \n    group = list(range(n))\n    rnk = [0 for i in range(n)]\n    adj = [[INF for j in range(k)] for i in range(k)]\n    for i in range(m):\n        u, v, x = map(int, stdin.readline().split())\n        print(\"u: \", str(u), \"v: \", str(v), \"x: \", str(x))\n        if x==0:\n            union(group, rnk, u-1, v-1)\n        tu = bisect_left(cnts, u)\n        tv = bisect_left(cnts, v)\n        adj[tu][tv] = min(adj[tu][tv], x)\n        adj[tv][tu] = min(adj[tv][tu], x)\n    \n    p = 0\n    for i in range(k):\n        cur = group[p]\n        while p<cnts[i]:\n            if group[p]!=cur:\n                print(\"No\")\n                return\n            p += 1\n    print(\"Yes\")\n    \n    for p in range(k):\n        cur = group[p]\n        print(\"cur: \", str(cur))\n        while p<cnts[i]:\n            if group[p]!=cur:\n                print(\"No\")\n                return\n            p += 1\n    for i in range(k):\n        cur = group[i]\n        print(\"cur: \", str(cur))\n        while i<cnts[i]:\n            if group[i]!=cur:\n                print(\"No\")\n                return\n            i += 1\n    print(\"Yes\")\n    \n    for p in range(k):\n        for i in range(k):\n            for j in range(k):\n                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])\n    \n    for i in range(k):\n        adj[i][i] = 0\n        for j in range(k):\n            if adj[i][j] == INF:\n                adj[i][j] = -1\n    \n    for i in range(k):\n        print(' '.join(map(lambda x: str(x), adj[i])))\n    \n    \nsolve()\n</ans>", "format_properties": {}}
{"idx": 168, "result": 0, "generated": "<ans>\ndef bitmake(digit):#bit\u6587\u5b57\u5217\u751f\u6210\uff08\u53d6\u308a\u6271\u3044\u6ce8\u610f\uff09\n    bit_list =list()\n\n    for i in range(2 ** digit):\n        bit = []\n        for j in range(digit):  # \u3053\u306e\u30eb\u30fc\u30d7\u304c\u4e00\u756a\u306e\u30dd\u30a4\u30f3\u30c8\n            if ((i >> j) & 1):  # \u9806\u306b\u53f3\u306b\u30b7\u30d5\u30c8\u3055\u305b\u6700\u4e0b\u4f4dbit\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\n                bit.append(j)\n        bit_list.append(bit)\n    return bit_list\nh,w,k = list(map(int,input().split()))\nprint(\"h: \", str(h), \"w: \", str(w), \"k: \", str(k))\ngrid = [\"\"]*h\nfor i in range(h):\n    grid[i] = list(map(str,input()))\n# print(grid)\n\nbit_list = bitmake(h+w)\n# print(bit_list)\nblackh = [0]*h#\u6a2a\nblackw = [0]*w#\u7e26\nblacksum = 0\nfor i in range(h):\n    for j in range(w):\n        if(grid[i][j] == \"#\"):\n            blackh[i]+=1\n            blackw[j]+=1\n            grid[i][j] = 1\n            blacksum += 1\n        else:\n            grid[i][j] = 0\n# print(blackh,blackw)\nans = 0\nfor i in range(2**(h+w)):\n    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1\n    remove = 0\n    hight = []\n    width = []\n    for j in range(len(bit)):\n        l = bit[j]\n        if(l <= h-1):\n            remove += blackh[l]\n            hight.append(l)\n        else:\n            ind = l - h\n            remove += blackw[ind]\n            width.append(ind)\n    # print(hight,width)\n    rid = 0\n    for j in range(len(hight)):\n        for l in range(len(width)):\n            if(grid[hight[j]][width[l]] == 1):\n                rid += 1\n    \n    if((blacksum - remove) + rid == k):\n        # print(blacksum,remove,rid,\"___\",blacksum-remove+rid)  \n        ans += 1\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 162, "result": 0, "generated": "<ans>\n\"\"\"Problem B - Bus of Characters.\n\nhttp://codeforces.com/contest/982/problem/B\n\nIn the Bus of Characters there are `n` rows of seat, each having `2` seats.\nThe width of both seats in the `i`-th row is `w_i` centimeters. All integers\n`w_i` are distinct.\n\nInitially the bus is empty. On each of `2n` stops one passenger enters the\nbus. There are two types of passengers:\n\n- an introvert always chooses a row where both seats are empty. Among these\nrows he chooses the one with the smallest seats width and takes one of the\nseats in it;\n\n- an extrovert always chooses a row where exactly one seat is occupied (by an\nintrovert). Among these rows he chooses the one with the largest seats width\nand takes the vacant place in it.\n\nYou are given the seats width in each row and the order the passengers enter\nthe bus. Determine which row each passenger will take.\n\nInput:\n\nThe first line contains a single integer `n` (`1 <= n <= 200\\,000`) \u2014 the\nnumber of rows in the bus.\n\nThe second line contains the sequence of integers `w_1, w_2, ..., w_n` (`1 <=\nw_i <= 10^{9}`), where `w_i` is the width of each of the seats in the `i`-th\nrow. It is guaranteed that all `w_i` are distinct.\n\nThe third line contains a string of length `2n`, consisting of digits '0' and\n'1' \u2014 the description of the order the passengers enter the bus. If the `j`-th\ncharacter is '0', then the passenger that enters the bus on the `j`-th stop is\nan introvert. If the `j`-th character is '1', the the passenger that enters the\nbus on the `j`-th stop is an extrovert. It is guaranteed that the number of\nextroverts equals the number of introverts (i. e. both numbers equal `n`), and\nfor each extrovert there always is a suitable row.\n\nOutput:\n\nPrint `2n` integers \u2014 the rows the passengers will take. The order of\npassengers should be the same as in input.\n\n\"\"\"\nimport logging\nimport collections\n\n\nfmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'\nformatter = logging.Formatter(fmt)\n\nch = logging.StreamHandler()\nch.setLevel(logging.NOTSET)\nch.setFormatter(formatter)\n\nlogger = logging.getLogger('bus_of_characters')\nlogger.setLevel(logging.NOTSET)\nlogger.addHandler(ch)\n\n\ndef solve(w, s):\n    free = collections.deque()\n    used = collections.deque()\n\n    for w in sorted(enumerate(w), key=lambda x: x[1]):\n        print(\"w: \", str(w))\n        free.append([w[0] + 1, w[1]])\n    \n    ids = [-1] * len(s)\n\n    order = []\n    for pid, p in enumerate(s):\n        logger.debug('pid: %s', pid)\n        if p == '0':\n            print(\"p: \", str(p))\n            taken = free.popleft(), \n            used.appendleft(taken)\n            # order.append(pid, taken[0])\n        else:\n            logger.debug('used %s', used)\n            print(\"p: \", str(p))\n            taken = used.popleft()\n        #order.append([pid, taken[0]])\n        print(\"taken: \", str(taken))\n        ids[pid] = taken[0]\n\n    return [x for x, y in ids]\n\n\n\ndef main():\n    n = int(input().strip())\n    print(\"n: \", str(n))\n    w = [int(x) for x in input().strip().split()]\n    print(\"w: \", str(w))\n    s = input().strip()\n\n    result = solve(w, s)\n    print(' '.join(map(str, result)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 157, "result": 0, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\nn = int(minp())\nm = [None]*n\nk = [None]*3\ndp = [None]*3\ndp[0] = [None]*(n*n)\ndp[1] = [None]*(n*n)\ndp[2] = [None]*(n*n)\npath = [None]*(n*n)\nprint(\"n: \", str(n))\nfor i in range(n):\n\tm[i] = list(map(int, minp().split()))\n\tprint(\"m[{}]: \".format(i), str(m[i]))\n\tfor j in range(n):\n\t\tpath[m[i][j]-1] = (i,j)\nprint(\"path: \", str(path))\nfor z in range(3):\n\tk_ = [None]*n\n\tprint(\"k[{}]: \".format(z), str(k[z]))\n\tfor i in range(n):\n\t\tkk = [None]*n\n\t\tprint(\"k[{}][{}]: \".format(z,i), str(kk))\n\t\tfor j in range(n):\n\t\t\tkkk_ = [None]*3\n\t\t\tprint(\"k[{}][{}][{}]: \".format(z,i,j), str(kkk_))\n\t\t\tfor zz in range(3):\n\t\t\t\tkkk = [None]*n\n\t\t\t\tprint(\"k[{}][{}][{}][{}]: \".format(z,i,j,zz), str(kkk))\n\t\t\t\tfor w in range(n):\n\t\t\t\t\tkkk[w] = [(1000000,0)]*n\n\t\t\t\tkkk_[zz] = kkk\n\t\t\tkk[j] = kkk_\n\t\tk_[i] = kk\n\tk[z] = k_\n\nq = [0]*(10*n*n)\nqr = 0\nkm = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\nsm = [(1,1),(1,-1),(-1,1),(-1,-1)]\nlm = [(0,1),(0,-1),(-1,0),(1,0)]\nmm = [km,sm,lm]\nprint(\"km: \", str(km))\nprint(\"sm: \", str(sm))\nprint(\"lm: \", str(lm))\nprint(\"mm: \", str(mm))\nfor z in range(3):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\t#print('========')\n\t\t\tql = 0\n\t\t\tqr = 1\n\t\t\tq[0] = (z, i, j, (0,0))\n\t\t\tkc = k[z][i][j]\n\t\t\tkc[z][i][j] = (0, 0)\n\t\t\twhile ql < qr:\n\t\t\t\tt, x, y, dd = q[ql]\n\t\t\t\t#print(t,x,y,dd)\n\t\t\t\td = kc[t][x][y]\n\t\t\t\tql += 1\n\t\t\t\tif d != dd:\n\t\t\t\t\tcontinue\n\t\t\t\tdd = (d[0]+1, d[1]+1)\n\t\t\t\tfor tt in range(3):\n\t\t\t\t\tif t != tt and kc[tt][x][y] > dd:\n\t\t\t\t\t\tkc[tt][x][y] = dd\n\t\t\t\t\t\tq[qr] = (tt,x,y,dd)\n\t\t\t\t\t\tqr += 1\n\t\t\t\tdd = (d[0]+1,d[1])\n\t\t\t\tif t == 0:\n\t\t\t\t\tfor w in mm[t]:\n\t\t\t\t\t\txx,yy = w[0]+x,w[1]+y\n\t\t\t\t\t\tif xx >= 0 and xx < n and yy >= 0 and yy < n:\n\t\t\t\t\t\t\tif kc[t][xx][yy] > dd:\n\t\t\t\t\t\t\t\tkc[t][xx][yy] = dd\n\t\t\t\t\t\t\t\tq[qr] = (t,xx,yy,dd)\n\t\t\t\t\t\t\t\tqr += 1\n\t\t\t\telse:\n\t\t\t\t\tfor w in mm[t]:\n\t\t\t\t\t\tfor hm in range(n*2):\n\t\t\t\t\t\t\txx,yy = w[0]*hm+x,w[1]*hm+y\n\t\t\t\t\t\t\tif xx >= 0 and xx < n and yy >= 0 and yy < n:\n\t\t\t\t\t\t\t\tif kc[t][xx][yy] > dd:\n\t\t\t\t\t\t\t\t\tkc[t][xx][yy] = dd\n\t\t\t\t\t\t\t\t\tq[qr] = (t,xx,yy,dd)\n\t\t\t\t\t\t\t\t\tqr += 1\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tbreak\ndp[0][0] = (0,0)\ndp[1][0] = (0,0)\ndp[2][0] = (0,0)\nprint(\"dp[0][0]: \", str(dp[0][0]))\nprint(\"dp[1][0]: \", str(dp[1][0]))\nprint(\"dp[2][0]: \", str(dp[2][0]))\nfor i in range(0,n*n-1):\n\tx,y = path[i]\n\txx,yy = path[i+1]\n\tfor z in range(3):\n\t\tfor j in range(3):\n\t\t\tdist = k[j][x][y][z][xx][yy]\n\t\t\tif dp[j][i] != None:\n\t\t\t\tnd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])\n\t\t\t\tif dp[z][i+1] == None:\n\t\t\t\t\tdp[z][i+1] = nd\n\t\t\t\telse:\n\t\t\t\t\tdp[z][i+1] = min(dp[z][i+1],nd)\nfor j in range(n*n-1,n*n):\n\tqq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]\n\tqm = min(qq)\n\t#print(j,qm)\n\tprint(qm[0], qm[1])\n</ans>", "format_properties": {}}
{"idx": 169, "result": 1, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nif (n == 1) :\n print (\"Washington\")\nelif (n == 2):\n print (\"Adams\")\nelif (n == 3):\n print (\"Jefferson\")\nelif (n == 4):\n print (\"Madison\")\nelif (n == 5):\n print (\"Monroe\")\nelif (n == 6):\n print (\"Adams\")\nelif (n == 7):\n print (\"Jackson\")\nelif (n == 8):\n print (\"Van Buren\")\nelif (n == 9):\n print(\"Harrison\")\nelif (n == 10):\n print(\"Tyler\")\nelif (n == 11):\n print(\"Polk\")\nelif (n == 12):\n print(\"Taylor\")\nelif (n == 13):\n print(\"Fillmore\")\nelif (n == 14):\n print(\"Pierce\")\nelif (n == 15):\n print(\"Buchanan\")\nelif (n == 16):\n print (\"Lincoln\")\nelif (n == 17):\n print (\"Johnson\")\nelif (n == 18):\n print (\"Grant\")\nelif (n == 19):\n print (\"Hayes\")\nelif (n == 20):\n print (\"Garfield\")\nelif (n == 21):\n print (\"Arthur\")\nelif (n == 22):\n print (\"Cleveland\")\nelif (n == 23):\n print (\"Harrison\")\nelif (n == 24):\n print (\"Cleveland\")\nelif (n == 25):\n print (\"McKinley\")\nelif (n == 26):\n print (\"Roosevelt\")\nelif (n == 27):\n print (\"Taft\")\nelif (n == 28):\n print (\"Wilson\")\nelif (n == 29):\n print ('Harding')\nelif (n == 30):\n print (\"Coolidge\")\nelif (n == 31):\n print (\"Hoover\")\nelif (n == 32):\n print (\"Roosevelt\")\nelif (n == 33):\n print (\"Truman\")\nelif (n == 34):\n print (\"Eisenhower\")\nelif (n == 35):\n print (\"Kennedy\")\nelif (n == 36):\n print (\"Johnson\")\nelif (n == 37):\n print (\"Nixon\")\nelif n == 38:\n print (\"Ford\")\nelif n == 39:\n print (\"Carter\")\nelif n == 40:\n print (\"Reagan\")\n</ans>", "format_properties": {}}
{"idx": 166, "result": 0, "generated": "<ans>\narray2=input(\"\").split(' ')\nprint(\"array2: \", str(array2))\nsumm=0\nprint(\"summ: \", str(summ))\narray=list()\nprint(\"array: \", str(array))\nfor t in range (0,int(array2[0])):\n    g=input(\"\")\n    array.append(g)\n    print(\"g: \", str(g))\nif (int(array2[1])==0):\n    for b in range (0,int(array2[0])):\n        if '0' in array[b]:\n            summ=summ+1\n       \n\n    print(summ)\nif (int(array2[1])==1):\n    for c in range (0,int(array2[0])):\n        if '0' in array[c] and '1' in array[c]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==2):\n    for d in range (0,int(array2[0])):\n        if '0' in array[d] and '1' in array[d] and '2' in array[d]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==3):\n    for e in range (0,int(array2[0])):\n        if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==4):\n    for f in range (0,int(array2[0])):\n        if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==5):\n    for g in range (0,int(array2[0])):\n        if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==6):\n    for h in range (0,int(array2[0])):\n        if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==7):\n     for i in range (0,int(array2[0])):\n                if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:\n                    summ=summ+1\n     print(summ)\nif (int(array2[1])==8):\n    for j in range (0,int(array2[0])):\n        if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:\n            summ=summ+1\n    print(summ)\nif (int(array2[1])==9):\n    for k in range (0,int(array2[0])):\n        if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:\n            summ=summ+1\n    print(summ)\n</ans>", "format_properties": {}}
{"idx": 173, "result": 0, "generated": "<ans>\nimport math as ma\nimport sys\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\nprint(\"ma: \", str(ma), \"sys: \", str(sys), \"dec: \", str(dec), \"permutations: \", str(permutations))\n\ndef li():\n\treturn list(map(int , input().split()))\n\nprint(\"li: \", str(li))\n\n# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/\ndef modInverse(a , m):\n\tm0 = m\n\ty = 0\n\tx = 1\n\tif (m == 1):\n\t\treturn 0\n\twhile (a > 1):\n\t\tq = a // m\n\t\tt = m\n\t\tm = a % m\n\t\ta = t\n\t\tt = y\n\t\ty = x - q * y\n\t\tx = t\n\tif (x < 0):\n\t\tx = x + m0\n\treturn x\n\nprint(\"modInverse: \", str(modInverse))\n\ndef num():\n\treturn map(int , input().split())\n\nprint(\"num: \", str(num))\n\ndef nu():\n\treturn int(input())\n\nprint(\"nu: \", str(nu))\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\nprint(\"find_gcd: \", str(find_gcd))\n\nn,k=num()\nprint(\"n: \", str(n), \"k: \", str(k))\nh=li()\nprint(\"h: \", str(h))\na=[0]*(max(h)+5)\nmx=max(h)\nmn=min(h)\nfo=True\nfor i in range(1,n):\n\tif(h[i]!=h[i-1]):\n\t\tfo=False\n\t\tbreak\nfor i in range(n):\n\ta[0]+=1\n\ta[h[i]+1]-=1\nfor i in range(1,len(a)):\n\ta[i]=a[i]+a[i-1]\ns=a[mx]\ncc=0\nfl=False\nfor i in range(mx-1,mn,-1):\n\tif(s+a[i]>k):\n\t\tfl=True\n\t\ts=a[i]\n\t\tcc+=1\n\telse:\n\t\tfl=False\n\t\ts+=a[i]\nif(s<=k and fo==False):\n\tcc+=1\nprint(\"cc: \", str(cc))\n</ans>", "format_properties": {}}
{"idx": 179, "result": 0, "generated": "<ans>\nA, B, C, X, Y = map(int, input().split())\nprint(\"A: \", str(A), \"B: \", str(B), \"C: \", str(C), \"X: \", str(X), \"Y: \", str(Y))\nif 2 * C > A + B:\n    print(A * X + B * Y)\nelse:\n    if X > Y:\n        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))\n    else:\n        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))\n</ans>", "format_properties": {}}
{"idx": 171, "result": 1, "generated": "<ans>\nt,sx,sy,ex,ey=map(int,input().split())\nprint(\"t: \", str(t), \"sx: \", str(sx), \"sy: \", str(sy), \"ex: \", str(ex), \"ey: \", str(ey))\nw=input()\nprint(\"w: \", str(w))\nn=len(w)\nprint(\"n: \", str(n))\nw+=\" \"\nprint(\"w: \", str(w))\nans=-1\nprint(\"ans: \", str(ans))\ni=0\nprint(\"i: \", str(i))\ndx=ex-sx\nprint(\"dx: \", str(dx))\ndy=ey-sy\nprint(\"dy: \", str(dy))\nif abs(dx)+abs(dy)>t:\n    pass\nelse:\n    while i<=t and i<n:\n        if dx==0 and dy==0:\n            ans=i\n            print(\"ans: \", str(ans))\n            break\n        if dx>=0 and dy>=0:\n            if ((w[i]!=\"E\" and w[i]!=\"N\") or (dx==0 and w[i]==\"E\") or (dy==0 and w[i]==\"N\")) and i<n:\n                i+=1\n            if dx>0 and w[i]==\"E\" and i<n:\n                i+=1\n                dx-=1\n            if dy>0 and w[i]==\"N\"and i<n:\n                i+=1\n                dy-=1\n        elif dx>=0 and dy<=0:\n            if ((w[i]!=\"E\" and w[i]!=\"S\") or (dx==0 and w[i]==\"E\") or (dy==0 and w[i]==\"S\")) and i<n:\n                i+=1\n            if dx>0 and w[i]==\"E\" and i<n:\n                i+=1\n                dx-=1\n            if dy<0 and w[i]==\"S\" and i<n:\n                i+=1\n                dy+=1\n        elif dx<=0 and dy>=0:\n            if ((w[i]!=\"W\" and w[i]!=\"N\") or (dx==0 and w[i]==\"W\") or (dy==0 and w[i]==\"N\")) and i<n:\n                i+=1\n            if dx<0 and w[i]==\"W\" and i<n:\n                i+=1\n                dx+=1\n            if dy>0 and w[i]==\"N\" and i<n:\n                i+=1\n                dy-=1\n        elif dx<=0 and dy<=0:\n            if ((w[i]!=\"W\" and w[i]!=\"S\") or (dx==0 and w[i]==\"W\") or (dy==0 and w[i]==\"S\")) and i<n:\n                i+=1\n            if dx<0 and w[i]==\"W\" and i<n:\n                i+=1\n                dx+=1\n            if dy<0 and w[i]==\"S\" and i<n:\n                i+=1\n                dy+=1\nif dx==0 and dy==0:\n            ans=i\n            print(\"ans: \", str(ans))\nprint(\"ans: \", str(ans))  \n</ans>", "format_properties": {}}
{"idx": 170, "result": 0, "generated": "<ans>\nimport math\nfrom decimal import Decimal\nimport heapq\ndef na():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\treturn n,b\n \n \ndef nab():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\tc = [int(x) for x in input().split()]\n\tprint(\"c: \", str(c))\n\treturn n,b,c\n \n \ndef dv():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n), \"m: \", str(m))\n\treturn n,m\n \n \ndef dva():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n), \"m: \", str(m))\n\ta = [int(x) for x in input().split()]\n\tprint(\"a: \", str(a))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\treturn n,m,b\n \n \ndef eratosthenes(n): \n\tsieve = list(range(n + 1))\n\tprint(\"sieve: \", str(sieve))\n\tfor i in sieve:\n\t\tif i > 1:\n\t\t\tfor j in range(i + i, len(sieve), i):\n\t\t\t\tsieve[j] = 0\n\tprint(\"sieve: \", str(sieve))\n\treturn sorted(set(sieve))\n \n \ndef lol(lst,k):\n\tk=k%len(lst)\n\tret=[0]*len(lst)\n\tprint(\"ret: \", str(ret))\n\tfor i in range(len(lst)):\n\t\tif i+k<len(lst) and i+k>=0:\n\t\t\tret[i]=lst[i+k]\n\t\tif i+k>=len(lst):\n\t\t\tret[i]=lst[i+k-len(lst)]\n\t\tif i+k<0:\n\t\t\tret[i]=lst[i+k+len(lst)]\n\tprint(\"ret: \", str(ret))\n\treturn(ret)\ndef nm():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tb = [int(x) for x in input().split()]\n\tprint(\"b: \", str(b))\n\tm = int(input())\n\tprint(\"m: \", str(m))\n\tc = [int(x) for x in input().split()]\n\tprint(\"c: \", str(c))\n\treturn n,b,m,c\n \n \ndef dvs():\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\tm = int(input())\n\tprint(\"m: \", str(m))\n\treturn n, m \ndef Factor(n):\n\tAns = []\n\td = 2\n\twhile d * d <= n:\n\t\tif n % d == 0:\n\t\t\tAns.append(d)\n\t\t\tn //= d\n\t\telse:\n\t\t\td += 1\n\tif n > 1:\n\t\tAns.append(n)\n\tprint(\"Ans: \", str(Ans))\n\treturn Ans\n\n\ns = input()\na1 = 'Mike'\na2 = 'Ann'\nif len(s) == 1:\n\tprint(a1)\n\treturn\nprint(a1)\ntc = s[0]\npre = []\nn = len(s)\nfor i in range(1, n):\n\td = min(s[i], tc)\n\tpre.append(d)\n\ttc = d\nfor i in range(1, n):\n\tif pre[i - 1] < s[i]:\n\t\tprint(a2)\n\telse:\n\t\tprint(a1)\n</ans>", "format_properties": {}}
{"idx": 174, "result": 0, "generated": "<ans>\nMOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\nprint(\"MOVS: \", str(MOVS))\ndef check(a):\n    return 0<=a<8\nprint(\"check: \", str(check))\nset1 = set()\nprint(\"set1: \", str(set1))\nset2 = set()\nprint(\"set2: \", str(set2))\ndic1 = dict()\nprint(\"dic1: \", str(dic1))\ndic2 = dict()\nprint(\"dic2: \", str(dic2))\ndef cango1(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check (nx) or not check(ny):\n            continue\n        if (nx,ny) in set1:\n            continue\n        dic1[(nx,ny)]=lap%2\n        set1.add((nx,ny))\n        cango1(matrix,(nx,ny),lap+1)\ndef cango2(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check(nx) or not check(ny):\n            continue\n        if (nx,ny) in set2:\n            continue\n        dic2[(nx,ny)]=lap%2\n        set2.add((nx,ny))\n        cango2(matrix,(nx,ny),lap+1)\nq = int(input())\nprint(\"q: \", str(q))\nfor ww in range(q):\n    matrix = [input().strip() for i in range(8)]\n    print(\"matrix: \", str(matrix))\n    pos = []\n    bad = set()\n    for i in range(8):\n        for j in range(8):\n            if matrix[i][j] == 'K':\n                pos.append((i,j))\n            if matrix[i][j]=='#':\n                bad.add((i,j))\n    print(\"pos: \", str(pos))\n    print(\"bad: \", str(bad))\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\n    print(\"set1: \", str(set1))\n    print(\"set2: \", str(set2))\n    print(\"dic1: \", str(dic1))\n    print(\"dic2: \", str(dic2))\n    cango1(matrix, pos[0],0)\n    cango2(matrix,pos[1],0)\n    if ww!=q-1:\n        input()\n    sec = (set1&set2) - bad\n    for x,y in sec:\n        if dic1[(x,y)]==dic2[(x,y)]:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n</ans>", "format_properties": {}}
{"idx": 172, "result": 0, "generated": "<ans>\ndef __starting_point():\n    inp = input()\n    print(\"inp: \", str(inp))\n    arr = inp.split(' ')\n    print(\"arr: \", str(arr))\n    L = [int(x) for x in arr]\n    print(\"L: \", str(L))\n    ans = [0,0,0]\n    print(\"ans: \", str(ans))\n    s = 0\n    for l in L:\n        s+=l\n    imp = False\n    for l in L:\n        if l>s/2:\n            imp = True\n    if imp:\n        print('Impossible')\n    else:\n##        m = min(L)//2\n##        for i in (0,1,2):\n##            ans[i]+=m\n##            L[i]-=m*2\n####        print(ans)\n        imp = False\n        if L[0]==min(L):\n            if L[1]>L[2]:\n                bonds = L[1]-L[2]\n                ans[0] += bonds\n                L[0]-= bonds\n                L[1] -=bonds\n            else:\n                bonds = L[2]-L[1]\n                ans[2] += bonds\n                L[0] -= bonds\n                L[2] -= bonds\n            if L[0]%2==1:\n                imp = True\n            else:\n                bonds = L[0]//2\n                ans[0] += bonds\n                ans[2] += bonds\n                ans[1] += (L[1]+L[2])//2 - bonds\n        elif L[1]==min(L):\n            if L[0]>L[2]:\n                bonds = L[0]-L[2]\n                ans[0] += bonds\n                L[1]-= bonds\n                L[0] -= bonds\n            else:\n                bonds = L[2]-L[0]\n                ans[1] += bonds\n                L[1] -= bonds\n                L[2] -= bonds \n            if L[1]%2==1:\n                imp = True\n            else:\n                bonds = L[1]//2\n                ans[0] += bonds\n                ans[1] += bonds\n                ans[2] += (L[0]+L[2])//2 - bonds\n\n        else:\n            if L[0]>L[1]:\n                bonds = L[0]-L[1]\n                ans[2] += bonds\n                L[2]-= bonds\n                L[0]-=bonds\n            else:\n                bonds = L[1]-L[0]\n                ans[1] += bonds\n                L[2] -= bonds\n                L[1] -= bonds\n            if L[2]%2==1:\n                imp = True\n            else:\n                bonds = L[2]//2\n                ans[2] += bonds\n                ans[1] += bonds\n                ans[0] += (L[0]+L[1])//2 - bonds\n            \n        for i in ans:\n            if i<0:\n                imp = True\n        if imp:\n            print('Impossible')\n        else:\n            for i in range(3):\n                print(ans[i],end=' ')\n            print()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 175, "result": 0, "generated": "<ans>\n'''input\n3\n0 2 0\n1 0 3\n'''\nfrom sys import stdin\nfrom copy import deepcopy\nfrom collections import deque\n\nprint(\"n: \", str(n))\nprint(\"arr: \", str(arr))\nprint(\"barr: \", str(barr))\nprint(\"op: \", str(op))\n\ndef find_start(pile):\n\tstart = 1\n\tindex = -1\n\n\tfor i in range(len(pile)):\n\t\tif pile[i] == start:\n\t\t\tindex = i\n\t\t\tbreak\n\tlatest = start\n\tif index != -1:\n\t\tflag = True\n\t\tfor i in range(index, len(pile)):\n\t\t\tif pile[i] == latest:\n\t\t\t\tlatest += 1\n\t\t\telse:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\n\t\tif flag:\n\t\t\tstart = latest\n\treturn start\n\n\n# \ndef check_start(num, op):\n\top[0] = 0\n\tnonlocal arr\n\tnonlocal barr\n\n\tmydict = [0] * (n + 1)\n\tfor i in range(len(arr)):\n\t\tmydict[arr[i]] += 1\n\t\t\n\t# print(mydict)\n\tzeroes = mydict[0]\n\n\tpile = deque(barr[:])\n\n\n\t# inserting the zeroes initially\n\tfor i in range(num):\n\t\tif zeroes > 0:\n\t\t\top[0] += 1\n\t\t\tpile.append(0)\n\t\t\tzeroes -= 1\n\t\t\tmydict[0] -= 1\n\t\telse:\n\t\t\treturn False\n\n\t\telement = pile.popleft()\n\n\n\t\t# updating the dictionary\n\t\tmydict[element] += 1\n\t\n\t\t# checking if it is zero\n\t\tif element == 0:\n\t\t\tzeroes += 1\n\t# print(mydict)\n\n\t# inserting the numbers\n\tstart = find_start(barr)\n\t# print(start)\n\tfor i in range(start, n + 1):\n\t\t# print(pile)\n\t\tif mydict[i] > 0:\n\t\t\top[0] += 1\n\t\t\tpile.append(i)\n\t\t\tmydict[i] -= 1\n\t\t\telement = pile.popleft()\n\t\t\tmydict[element] += 1\n\t\telse:\n\t\t\treturn False\n\treturn True\n\n\n# main starts\nn = int(stdin.readline().strip())\nprint(\"n: \", str(n))\narr = list(map(int, stdin.readline().split()))\nprint(\"arr: \", str(arr))\nbarr = list(map(int, stdin.readline().split()))\nprint(\"barr: \", str(barr))\nstart = 0\nend = 2 * n\nop = [0]\nprint(\"op: \", str(op))\n\nif check_start(0, op):\n\tprint(op[0])\n\treturn\n\npos = [0] * (n + 1)\nfor i in range(n):\n\tpos[barr[i]] = i + 1\n\nans = -float('inf')\nfor i in range(1, n + 1):\t\n\tans = max(pos[i] - i  + 1 + n, ans)\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 178, "result": 0, "generated": "<ans>\nimport sys\n\ndef Min(x, y):\n    if x > y:\n        print(\"Min: \", str(x), \"Y: \", str(y))\n        return y\n    else:\n        print(\"Min: \", str(x), \"Y: \", str(y))\n        return x\n\ndef Gcd(x, y):\n    if x == 0:\n        print(\"X: \", str(x), \"Y: \", str(y))\n        return y\n    else:\n        print(\"X: \", str(x), \"Y: \", str(y))\n        return Gcd(y % x, x)\n\ndef Lcm(x, y):\n    print(\"X: \", str(x), \"Y: \", str(y))\n    return x * y // Gcd(x, y)\n\nn = int(input())\nprint(\"n: \", str(n))\na = [int(i) for i in input().split()]\nprint(\"a: \", str(a))\nd = [int(0) for i in range(0, n)]\nprint(\"d: \", str(d))\n\nok = 0\n\ncur = 0\n\nlen = Lcm(7, n)\n\nfor i in range(0, 7 * n):\n    if a[i % n] == 0 :\n        print(i % n + 1)\n        ok = 1\n        break\n    if cur != 6:\n        a[i % n] -= 1\n        d[i % n] += 1\n    cur = (cur + 1) % 7\n\nif ok == 0:\n    k = 10**20\n\n    for i in range(0, n):\n        a[i] += d[i]\n        if d[i] == 0: continue\n        if a[i] % d[i] > 0:\n            k = Min(k, a[i] // d[i])\n        else:\n            k = Min(k, a[i] // d[i] - 1)\n\n    if k == 10**20:\n        k = 0\n\n    for i in range(0, n):\n        a[i] -= k * d[i]\n\n    iter = 0\n    cur = 0\n\n    while True:\n        if a[iter] == 0:\n            print(iter % n + 1)\n            break\n        else:\n            if cur != 6:\n                a[iter] -= 1\n            cur = (cur + 1) % 7\n            iter = (iter + 1) % n\n</ans>", "format_properties": {}}
{"idx": 177, "result": 0, "generated": "<ans>\nimport sys\nimport math\n\ndef ii():\n    return sys.stdin.readline().strip()\n\ndef idata():\n    return [int(x) for x in ii().split()]\n\ndef bfs(graph1, root1):\n    print(\"graph1: \", str(graph1), \"root1: \", str(root1))\n    visited1 = set()\n    queue1 = [[root1, 0]]\n    visited1.add(root1)\n    qw, ver = 0, 1\n    while queue1:\n        vertex1 = queue1[0]\n        queue1 = queue1[1:]\n        for neig1 in graph1[vertex1[0]]:\n            if neig1 not in visited1:\n                visited1.add(neig1)\n                queue1 += [[neig1, vertex1[1] + 1]]\n                if qw < vertex1[1] + 1:\n                    ver, qw = neig1, vertex1[1] + 1\n    return ver, qw\n\ndef dfs(graph, ver):\n    print(\"graph: \", str(graph), \"ver: \", str(ver))\n    used_v = set()\n    depth = [0] * (len(graph) + 1)\n    level = [ver]\n    num_of_level = 0\n    while level:\n        new_level = []\n        for v in level:\n            depth[v] = num_of_level\n            used_v.add(v)\n            for v1 in graph[v]:\n                if v1 not in used_v:\n                    new_level += [v1]\n        level = new_level\n        num_of_level += 1\n    return depth\n\ndef binary_search(array, x):\n    left, right = -1, len(array)\n    while left + 1 != right:\n        middle = (left + right) // 2\n        if array[middle] >= x:\n            right = middle\n        elif array[middle] < x:\n            left = middle\n    return right\n\ndef c_mod(n1, k1, mod1):\n    print(\"n1: \", str(n1), \"k1: \", str(k1), \"mod1: \", str(mod1))\n    num = den = 1\n    for i in range(n1 - k1):\n        num = (num * (n1 - i)) % mod1\n        den = (den * (i + 1)) % mod1\n    return (num * pow(den, mod1 - 2, mod1)) % mod1\n\ndef c(n1, k1):\n    print(\"n1: \", str(n1), \"k1: \", str(k1))\n    num = den = 1\n    for i in range(n1 - k1):\n        num = num * (n1 - i)\n        den = den * (i + 1)\n    return num // den\n\ndef v_sistemu(x, k):\n    print(\"x: \", str(x), \"k: \", str(k))\n    x = int(x)\n    z = ''\n    while x:\n        z += str(x % k)\n        x //= k\n    return z[::-1]\n\ndef iz_sistemi(x, k):\n    print(\"x: \", str(x), \"k: \", str(k))\n    x = str(x)[::-1]\n    ans = 0\n    for i in range(len(x)):\n        ans += int(x[i]) * pow(k, i)\n    return ans\n\ndef solve_of_problem():\n    print(\"n: \", str(n))\n    n = int(ii())\n    ans = 2\n    for i in range(n):\n        print(\"ans: \", str(ans))\n        ans *= 2\n        if n % (ans - 1) == 0:\n            print(n // (ans - 1))\n            return\n    return\n\nfor ______ in range(int(ii())):\n    solve_of_problem()\n</ans>", "format_properties": {}}
{"idx": 183, "result": 0, "generated": "<ans>\n#\n# abc147 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3\n1\n2 1\n1\n1 1\n1\n2 0\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"3\n2\n2 1\n3 0\n2\n3 1\n1 0\n2\n1 1\n2 0\"\"\"\n        output = \"\"\"0\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"2\n1\n2 0\n1\n1 0\"\"\"\n        output = \"\"\"1\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N = int(input())\n    print(\"N: \", str(N))\n    C = []\n    for i in range(N):\n        a = int(input())\n        print(\"a: \", str(a))\n        C.append([list(map(int, input().split())) for j in range(a)])\n\n    ans = 0\n    for bit in range(1 << N):\n        f = True\n        for i in range(N):\n            if bit & (1 << i):\n                for c in C[i]:\n                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:\n                        f = False\n                        break\n        if f == True:\n            ans = max(ans, bin(bit).count(\"1\"))\n    print(\"ans: \", str(ans))\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 184, "result": 0, "generated": "<ans>\n# alpha = \"abcdefghijklmnopqrstuvwxyz\"\nprime = 998244353\nprint(\"prime: \", str(prime))\nt = 1#int(input())\nprint(\"t: \", str(t))\nfrom heapq import heappop, heappush\nfor test in range(t):\n    n = int(input())\n    print(\"n: \", str(n))\n    s = input()\n    # ans = 1\n    # start = 1\n    # cur = s[0]\n    # tmp = 0\n    # while s[start]==cur:\n    #     start+=1\n    #     tmp+=1\n    # end = n-1\n    # tmp = 1\n    # while s[end]==cur:\n    #     end-=1\n    #     tmp+=1\n    grp = []\n    cnt = []\n    tmp = 0\n    cur = s[0]\n    for i in s:\n        if i==cur:\n            tmp+=1\n        else:\n            grp.append(cur)\n            cnt.append(tmp)\n            cur = i\n            tmp = 1\n    grp.append(cur)\n    cnt.append(tmp)\n    if len(grp)==1:\n        print(((n*(n+1))//2)%prime)\n    else:\n        if grp[0]==grp[-1]:\n            ans = ((cnt[0]+1)*(cnt[-1]+1))%prime\n            # print(\"here\", ans)\n            # if cnt[0]+cnt[-1]==n-1:\n            #     ans-=1\n            #     ans = ans%prime\n            print(\"ans: \", str(ans))\n        else:\n            ans = cnt[0]+1+cnt[-1]\n            ans = ans%prime\n            # if cnt[0]+cnt[-1]==n-1:\n            #     ans-=1\n            #     ans = ans%prime\n            print(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 176, "result": 0, "generated": "<ans>\ndef xmax(x, y):\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        self.num = 2**(n-1).bit_length()\n        self.ide_ele = ide_ele\n        self.seg=[self.ide_ele]*2*self.num\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        print(\"X: \", str(k), \"Y: \", str(x))\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n            print(\"X: \", str(k), \"Y: \", str(self.seg[k]))\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        print(\"X: \", str(k), \"Y: \", str(x))\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n            print(\"X: \", str(k), \"Y: \", str(self.seg[k]))\n        \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nX = list(map(int, input().split()))\nprint(\"X: \", str(N), \"Y: \", str(M))\nprint(\"X: \", str(X), \"Y: \", str(M))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\n    print(\"X: \", str(a), \"Y: \", str(b))\n    print(\"X: \", str(X), \"Y: \", str(M))\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])\n</ans>", "format_properties": {}}
{"idx": 182, "result": 0, "generated": "<ans>\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport collections\nimport math\n\ndef isSubSequence(str1,str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0    # Index of str1 \n    i = 0    # Index of str2 \n    while j<m and i<n: \n        if str1[j] == str2[i]:     \n            j = j+1    \n        i = i + 1\n    return j==m\n    \n\nT = int(input())\n \n#A,H,Q = [int(x) for x in stdin.readline().split()] \nfor t in range(T):\n    #N,M = [int(x) for x in stdin.readline().split()]\n    s = input()\n    t = input()\n    p = input()\n    \n    freq_s = {}\n    freq_t = {}\n    freq_p = {}\n    print(\"freq_s: \", str(freq_s), \"freq_t: \", str(freq_t), \"freq_p: \", str(freq_p))\n    for i in range(26):\n        freq_s[chr(97+i)] = 0\n        freq_t[chr(97+i)] = 0\n        freq_p[chr(97+i)] = 0\n        \n    for letter in s:\n        freq_s[letter] += 1\n    print(\"freq_s: \", str(freq_s))\n    for letter in t:\n        freq_t[letter] += 1\n    print(\"freq_t: \", str(freq_t))\n    for letter in p:\n        freq_p[letter] += 1\n    print(\"freq_p: \", str(freq_p))\n    \n    # check s is subsequence of t, if not, print no    \n    sub = isSubSequence(s,t)\n    print(\"sub: \", str(sub))\n    if sub==0:\n        print('NO')\n    else:\n        flag = 0\n        for i in range(26):\n            d = freq_t[chr(97+i)] - freq_s[chr(97+i)]\n            print(\"d: \", str(d))\n            if d>0:\n                #print(chr(97+i))\n                if freq_p[chr(97+i)]<d and flag==0:\n                    print('NO')\n                    flag = 1\n                    \n        if flag==0:\n            print('YES')\n    \n</ans>", "format_properties": {}}
{"idx": 180, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10**9)\nN,M=map(int,input().split())\nprint(\"N: \", str(N), \"M: \", str(M))\n\ndef find_negative_loop(n,w,es):\n  dist=[float(\"inf\")]*n\n  #\u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1]=0\n  print(\"dist: \", str(dist))\n  for i in range(n):\n    for j in range(w):\n      e=es[j]\n      if dist[e[1]]>dist[e[0]]+e[2]:\n        dist[e[1]]=dist[e[0]]+e[2]\n        print(\"dist: \", str(dist))\n        if i==n-1:\n          return True\n  return False\n\ndef shortest_path(s,n,w,es):\n  #s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  #s:\u59cb\u70b9, n:\u9802\u70b9\u6570, w:\u8fba\u306e\u6570, es[i]:[\u8fba\u306e\u59cb\u70b9,\u8fba\u306e\u7d42\u70b9,\u8fba\u306e\u30b3\u30b9\u30c8]\n  dist=[float(\"inf\")]*n\n  #d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s]=0\n  print(\"dist: \", str(dist))\n  while True:\n    update=False\n    for p,q,r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from,to,cost]\n      if dist[p]!=float(\"inf\") and dist[q]>dist[p]+r:\n        dist[q]=dist[p]+r\n        update=True\n        print(\"dist: \", str(dist))\n    if not update:\n      break\n      \n  return dist\n\ngraph=[[] for _ in range(N+1)]\nelist=[]\nfor _ in range(M):\n  a,b,c=map(int,input().split())\n  graph[a].append(b)\n  elist.append((a,b,-c))\n  \n#remove unnecessary vertex and edge\nvisited=[None]*(N+1)\ndef check_reachable(u):\n  visited[u]=True\n  if u==N:\n    reachable[u]=True\n    return True\n  elif reachable[u]!=None:\n    return reachable[u]  \n\n  cnt=0\n  for v in graph[u]:\n    if not visited[v]:\n      ret=check_reachable(v)\n      if ret:\n        cnt+=1\n        \n  if cnt>0:\n    reachable[u]=True\n    return True\n  else:\n    reachable[u]=False\n    return False\n\nreachable=[None]*(N+1)\nfor i in range(1,N+1):\n  if reachable[i]==None:\n    visited=[False]*(N+1)\n    check_reachable(i)\n#print(reachable)\n  \nelist2=[]\nfor a,b,nc in elist:\n  if reachable[b]:\n    elist2.append((a,b,nc))\n  \nM2=len(elist2)\nprint(\"M2: \", str(M2))\nres1=find_negative_loop(N+1,M2,elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2=shortest_path(1,N+1,M2,elist2)\n  print(-res2[N])\n</ans>", "format_properties": {}}
{"idx": 181, "result": 0, "generated": "<ans>\nimport sys\nimport os\nimport time\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\nimport random\nimport string\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\nprint(\"n, k: \", str(n), str(k))\n\ndef sieve(n):\n    print(\"n: \", str(n))\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return default, default\n    else:\n        return left, right\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n########################################################################################################################\n# input = sys.stdin.readline\n\nfor _ in range(ii()):\n    n, k = mi()\n    print(\"n, k: \", str(n), str(k))\n    even = n - 2*(k - 1)\n    print(\"even: \", str(even))\n    odd = n - (k - 1)\n    print(\"odd: \", str(odd))\n    if odd > 0 and odd % 2:\n        res = [1]*(k - 1) + [odd]\n        print('YES')\n        prr(res, ' ')\n    elif even > 0 and even % 2 == 0:\n        res = [2] * (k - 1) + [even]\n        print('YES')\n        prr(res, ' ')\n    else:\n        print('NO')\n</ans>", "format_properties": {}}
{"idx": 188, "result": 0, "generated": "<ans>\nr1=input()\nprint(\"r1: \", str(r1))\nr2=input()\nprint(\"r2: \", str(r2))\nn=len(r1)\nprint(\"n: \", str(n))\nl=[0]\nprint(\"l: \", str(l))\nfor i in range(n):\n\tif r1[i]=='0':\n\t\tif r2[i]=='0':\n\t\t\tl.append(2)\n\t\t\tprint(\"l: \", str(l))\n\t\telse:\n\t\t\tl.append(1)\n\t\t\tprint(\"l: \", str(l))\n\telse:\n\t\tif r2[i]=='X':\n\t\t\tl.append(0)\n\t\t\tprint(\"l: \", str(l))\n\t\telse:\n\t\t\tl.append(-1)\n\t\t\tprint(\"l: \", str(l))\nl.append(0)\nprint(\"l: \", str(l))\ns=len(l)\nprint(\"s: \", str(s))\ncount=0\nprint(\"count: \", str(count))\nu=1\nprint(\"u: \", str(u))\ne=1\nprint(\"e: \", str(e))\nwhile(u<s-1):\n\tif l[u]==2 and e==1:\n\t\tif l[u+1]==2:\n\t\t\te=2\n\t\t\tu=u+1\n\t\t\tcontinue\n\t\telif (l[u+1]==1 or l[u+1]==-1):\n\t\t\tcount=count+1\n\t\t\tu=u+2\n\t\t\tcontinue\n\t\telse:\n\t\t\tu=u+2\n\t\t\tcontinue\n\tif l[u]==2 and e==2:\n\t\tif l[u+1]==2:\n\t\t\tcount=count+2\n\t\t\tu=u+2\n\t\t\te=1\n\t\t\tcontinue\n\t\telse:\n\t\t\tcount=count+1\n\t\t\tu=u+1\n\t\t\te=1\n\t\t\tcontinue\n\tif l[u]==1 or l[u]==-1:\n\t\tif l[u+1]==2:\n\t\t\tcount=count+1\n\t\t\tu=u+2\n\t\t\tcontinue\n\t\telse:\n\t\t\tu=u+1\n\t\t\tcontinue\n\tif l[u]==0:\n\t\tu=u+1\nprint (count)\n</ans>", "format_properties": {}}
{"idx": 189, "result": 0, "generated": "<ans>\nfrom random import seed, randint\nimport sys\nsys.setrecursionlimit(10000)\n\nopr = ['#', '^', '&', '$']\nnamespace = { \"res\" : (False, \"res\") }\nrules = dict()\nlookup = dict()\ncnt = -1\n\ndef get_tag(var):\n    if var in namespace:\n        return namespace[var][1]\n    else:\n        return var\n\nN = int(input())\nfor _ in range(N):\n    lval, rval = input().split('=')\n    for c in opr:\n        if c in rval:\n            arg1, arg2 = list(map(get_tag, rval.split(c)))\n            rule = (arg1, arg2, c)\n            if rule in rules:\n                namespace[lval] = (True, rules[rule])\n            else:\n                cnt += 1\n                namespace[lval] = (True, cnt)\n                rules[rule] = cnt\n                lookup[cnt] = rule\n            print(\"lval: \", str(lval), \"rval: \", str(rval))\n            break\n    else:\n        if rval in namespace:\n            namespace[lval] = namespace[rval]\n        else:\n            namespace[lval] = (False, rval)\n        print(\"lval: \", str(lval), \"rval: \", str(rval))\n\nif namespace[\"res\"] == (False, \"res\"):\n    print(\"0\")\n    return\n\nprogram = []\nmyvars = dict()\n\ndef reserve():\n    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) \n\ndef implement(rule, final):\n    if type(rule) == str:\n        return rule\n    elif rule in myvars:\n        return myvars[rule]\n    else:\n        if final:\n            name = \"res\"\n        else:\n            name = reserve()\n        myvars[rule] = name\n        arg1, arg2, op = lookup[rule]\n        var1, var2 = implement(arg1, False), implement(arg2, False)\n        program.append(name + \"=\" + var1 + op + var2)\n        return name\n\nseed(123)\nif namespace[\"res\"][0]:\n    implement(namespace[\"res\"][1], True)\nelse:\n    program.append(\"res=\" + namespace[\"res\"][1])\nprint(len(program))\nprint(\"\\n\".join(program))\n</ans>", "format_properties": {}}
{"idx": 186, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout \nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nimport math\nfrom fractions import Fraction as frac\nfrom random import random\ncin = stdin.readline\ndef cout(x):\n\tstdout.write(str(x)+'\\n')\ndef var(type = int):\n    return type(stdin.readline())\ndef readline(type = int):\n    return list(map(type,stdin.readline().split()))\ndef readlist(type = int):\n    return list(map(type,stdin.readline().split()))\ndef sorted_indexes(arr):\n    return sorted(list(range(len(arr))),key=arr.__getitem__)\ndef printr(arr):\n    [stdout.write(str(x)+' ')   for x in arr]\n    cout('')\ndef find_lt(a, x):#'Find rightmost value less than x'\n    i = bisect_left(a, x)\n    if i:\n        return a[i-1]\n    raise ValueError\ndef find_gt(a, x):#'Find leftmost value greater than x'\n    i = bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\ndef dist(x,y):\n    return math.sqrt(x*x + y*y)\ndef binary_search(arr, x):\n    i = bisect_left(arr, x)\n    if i == len(arr) or arr[i] != x:\n        return -1\n    return i\n\n# ---------------------Template ends-------------sdpt,sdpt131[Sudipta Banik]---------------------\n\n# mp = [0]*201\n# ops = [0]*201\n# def go(arr,i,j ,dp):\n#     if i==j and ops[i] is None:\n#         return [mp[i],mp[i]]\n#     if i>j:\n#         return [0,0]\n#     if dp[i][j]:\n#         return dp[i][j]\n#     mx = -1000000000\n#     mn = 1000000000\n#     for k in range(i+1,j,2):\n#         if ops[k]:\n#             left = go(arr,i,k-1,dp)\n#             right = go(arr,k+1,j,dp)\n#             mx = max(mx,left[0] + right[0])\n#             mn = min(mn,left[1] + right[1])\n#         else:\n#             left = go(arr,i,k-1,dp)\n#             right = go(arr,k+1,j,dp)\n#             mx = max(mx,left[0] - right[1])\n#             mn = min(mn,left[1] - right[0])\n#     dp[i][j] = [mx,mn]\n#     return [mx,mn]\n\n    \nn , a , b = readline(int)\nprint(\"n: \", str(n), \"a: \", str(a), \"b: \", str(b))\nprice = [a,b]\nprint(\"price: \", str(price))\narr = readlist(int)\nprint(\"arr: \", str(arr))\nhalf = n//2\ncost = 0\nflg = True\nfor i in range(half):\n    if arr[i] == arr[n-1-i] == 2:\n        cost += 2*min(a,b)\n    elif arr[i] ==2 and arr[n-1-i] <= 1:\n        cost += price[arr[n-1-i]]\n    elif arr[i] <= 1 and arr[n-1-i] == 2:\n        cost += price[arr[i]]\n    elif arr[i] != arr[n-1-i]:\n        flg = False\n        break\nif n%2 == 1:\n    if arr[half] == 2:\n        cost += min(a,b)\nif not flg:\n    print(-1)\nelse:\n    print(cost)\n</ans>", "format_properties": {}}
{"idx": 185, "result": 0, "generated": "<ans>\nn, l, r = [int(i) for i in input().split()]\nprint(\"n: \", str(n), \"l: \", str(l), \"r: \", str(r))\n\nnumber_of_zeros = 0\nnumber_of_ones = 0\nnumber_of_twos = 0\nprint(\"number_of_zeros: \", str(number_of_zeros), \"number_of_ones: \", str(number_of_ones), \"number_of_twos: \", str(number_of_twos))\n\nif l%3 == 0:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\nelif l%3 == 1:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3 + 1\nelif l%3 == 2:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    elif r%3 == 2:\n        number_of_zeros = (r-l+1)//3 \n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\nprint(\"number_of_zeros: \", str(number_of_zeros), \"number_of_ones: \", str(number_of_ones), \"number_of_twos: \", str(number_of_twos))\n\ndp = [[-1 for i in range(3)] for j in range(n+1)]\nprint(\"dp: \", str(dp))\n\nMOD = 10**9 + 7\ndp[1][0] = number_of_zeros%MOD\ndp[1][1] = number_of_ones%MOD\ndp[1][2] = number_of_twos%MOD\nprint(\"dp[1][0]: \", str(dp[1][0]), \"dp[1][1]: \", str(dp[1][1]), \"dp[1][2]: \", str(dp[1][2]))\n\nfor i in range(2,n+1):\n    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD\n    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD\n    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD\nprint(\"dp[\", str(i), \"][0]: \", str(dp[i][0]), \"dp[\", str(i), \"][1]: \", str(dp[i][1]), \"dp[\", str(i), \"][2]: \", str(dp[i][2]))\n\nif dp[n][0]!=-1:\n    print(dp[n][0]%MOD)\nelse:\n    print(0)\n</ans>", "format_properties": {}}
{"idx": 191, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\n# def find(a):\n#     if par[a] == a:\n#         return a\n#     par[a] = find(par[a])\n#     return par[a]\n\ndef find(a):\n    upd = []\n    cur = a\n    while par[cur] != cur:\n        upd.append(cur)\n        cur = par[cur]\n    for x in upd:\n        par[x] = cur\n    return cur\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if a == b:\n        return\n    par[a] = b\n\n\ndef mst():\n    ret = []\n    for edge in edges:\n        u, v, w = edge\n        u = find(u)\n        v = find(v)\n        if u != v:\n            union(u, v)\n            ret.append(edge)\n    return ret\n\n\ndef dfs(u, par):\n    for v, w in adj[u]:\n        if v != par:\n            dist[v] = max(dist[u], w)\n            dfs(v, u)\n\ndef bfs(u):\n    visit = [False] * (n+1)\n    from collections import deque\n\n    dq = deque()\n    dq.append(u)\n    visit[u] = True\n    while dq:\n        u = dq.popleft()\n        for v, w in adj[u]:\n            if not visit[v]:\n                dist[v] = max(dist[u], w)\n                dq.append(v)\n                visit[v] = True\n\n\nn, m, k = list(map(int, input().split()))\nprint(\"n, m, k: \", str(n), str(m), str(k))\na = list(map(int, input().split()))\nprint(\"a: \", str(a))\n# n = 50000\n# m = 2 * n\n# k = n\n# a = [i for i in range(1, n+1)]\n# import random\n\npar = [0] * (n+1)\nprint(\"par: \", str(par))\nfor i in range(1, n+1):\n    par[i] = i\nprint(\"par: \", str(par))\nedges = []\n# for i in range(1, n+1):\n#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n#     edges.append(edge)\nfor i in range(m):\n    edge = tuple(map(int, input().split()))\n    edges.append(edge)\nprint(\"edges: \", str(edges))\nedges.sort(key=lambda x: x[2])\nedges = mst()\nprint(\"edges: \", str(edges))\nadj = [list() for i in range(n+1)]\nfor edge in edges:\n    u, v, w = edge\n    adj[u].append((v, w))\n    adj[v].append((u, w))\nprint(\"adj: \", str(adj))\ndist = [0] * (n+1)\n# dfs(a[0], -1)\nbfs(a[0])\nans = 0\nfor x in a:\n    ans = max(ans, dist[x])\nans = [ans] * k\nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 187, "result": 0, "generated": "<ans>\nfrom sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\nclass mint:\n    mod = int(1e9 + 7)\n    def __init__(self, v = 0):\n        if not ((v >= 0) and (v < mint.mod)):\n            v %= mint.mod\n            if v < 0: v += mint.mod\n        self.V = v\n    def __add__(self, other):\n        v = self.V + (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __sub__(self, other):\n        v = self.V - (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __mul__(self, other):\n        v = self.V * (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __floordiv__(self, other):\n        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))\n        return mint(v)\n    def __truediv__(self, other):\n        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))\n        return mint(v)\n    \n    def __eq__(self, other):\n        return self.V == (other.V if isinstance(other, mint) else mint(other).V)\n    def __ne__(self, other):\n        return self.V != (other.V if isinstance(other, mint) else other)\n    def __int__(self): return self.V\n    # right operand\n    def __radd__(self, other):\n        v = (other.V if isinstance(other, mint) else other) + self.V\n        return mint(v)\n    def __rsub__(self, other):\n        v = (other.V if isinstance(other, mint) else other) - self.V\n        return mint(v)\n    def __rmul__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * self.V\n        return mint(v)\n    def __rfloordiv__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)\n        return mint(v)\n    def __rtruediv__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)\n        return mint(v)\n\n    @staticmethod\n    def inv(x):\n        a, _, _ = mint.extGCD(x, mint.mod)\n        return (a + mint.mod) % mint.mod\n    @staticmethod\n    def extGCD(x, y):\n        r0 = x\n        r1 = y\n        a0 = 1\n        a1 = 0\n        b0 = 0\n        b1 = 1\n        while(r1 > 0):\n            q1 = r0 // r1\n            r2 = r0 % r1\n            a2 = a0 - q1 * a1\n            b2 = b0 - q1 * b1\n            r0 = r1; r1 = r2\n            a0 = a1; a1 = a2\n            b0 = b1; b1 = b2\n        c = r0\n        a = a0\n        b = b0       \n        return a, b, c\n    @staticmethod\n    def pow(x, k):\n        x = x.V if isinstance(x, mint) else x\n        return pow(x, k, mint.mod)\n\n    \n    def __str__(self):\n        return str(self.V)\n    def __repr__(self):\n        return str(self.V)\n\ndef main():\n    N = ri()\n    print(\"N: \", str(N))\n    A = ria()\n    print(\"A: \", str(A))\n    A = sorted(A)\n    print(\"A: \", str(A))\n    A = list(reversed(A))\n    print(\"A: \", str(A))\n    Pow2 = [mint(0)] * (N + 1)\n    print(\"Pow2: \", str(Pow2))\n    Pow2[0] = mint(1)\n    print(\"Pow2[0]: \", str(Pow2[0]))\n    for i in range(1,N+1): \n        print(\"Pow2[i]: \", str(Pow2[i]))\n        Pow2[i] = Pow2[i-1] * 2\n    tot = mint(0)\n    for i in range(N):\n        tot += mint(A[i]) * Pow2[N-1]\n        if i > 0: tot += mint(A[i]) * i * Pow2[N-2]\n    print(\"tot: \", str(tot))\n    tot *= Pow2[N]\n    print(\"tot: \", str(tot))\n    print(tot)\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 190, "result": 0, "generated": "<ans>\n''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    a, b, c, d, k = get_tuple()\n    print(\"a, b, c, d, k: \", str(a), str(b), str(c), str(d), str(k))\n    x = (a+c-1)//c\n    y = (b+d-1)//d\n    print(\"x, y: \", str(x), str(y))\n    if x+y<=k:\n        print(x, y)\n    else: print(-1)\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n</ans>", "format_properties": {}}
{"idx": 198, "result": 0, "generated": "<ans>\nfrom math import gcd\n\nm,a,b = list(map(int,input().split()))\nprint(\"m: \", str(m), \"a: \", str(a), \"b: \", str(b))\n\ng = gcd(a,b)\nprint(\"g: \", str(g))\n\nvis = [0]*(a+b+1)\nvis[0] = 1\nprint(\"vis: \", str(vis))\n\nnvis = 1\nprint(\"nvis: \", str(nvis))\n\ncount = 0\nlast = 0\nt = 0\nwhile True:\n    #print(t, vis)\n    if t >= b:\n        #print('back')\n        t -= b\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n    else:\n        t += a\n        if t > m:\n            break\n        if t > last:\n            #print('forward', t - last, 'with', nvis)\n            count += (t - last)*nvis\n            last = t\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n    #print(nvis,count)\n    #print('---')\n\nif t > m:\n    # we're done\n    count += (m - last + 1)*nvis\nelse:\n    def sumto(n):\n        whole = n//g + 1\n        r = whole*(whole+1)//2 * g\n        corr = whole * (g-1 - (n%g))\n        r -= corr\n        return r\n\n    #S = 0\n    #for i in range(last, m+1):\n    #    S += i//g + 1\n    #count += S\n    #assert S == sumto(m) - sumto(last-1)\n\n    count += sumto(m) - sumto(last-1)\n\n#print(vis)\nprint(count)\n</ans>", "format_properties": {}}
{"idx": 192, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\ns1=[int(x) for x in input().split()]\nprint(\"s1: \", str(s1))\ns2=[int(x) for x in input().split()]\nprint(\"s2: \", str(s2))\nS1=sorted(s1)\nprint(\"S1: \", str(S1))\nS2=sorted(s2)\nprint(\"S2: \", str(S2))\nS1=[0]+S1\nprint(\"S1: \", str(S1))\nS2=[0]+S2\nprint(\"S2: \", str(S2))\nS1=S1[::-1]\nprint(\"S1: \", str(S1))\nS2=S2[::-1]\nprint(\"S2: \", str(S2))\npta=0\nprint(\"pta: \", str(pta))\nptb=0\nprint(\"ptb: \", str(ptb))\nsm1=0\nprint(\"sm1: \", str(sm1))\nsm2=0\nprint(\"sm2: \", str(sm2))\nfor j in range(0,(2*n)+1):\n    if(j%2==0):\n        if(S2[ptb]>S1[pta]):\n            ptb=ptb+1\n            print(\"ptb: \", str(ptb))\n        else:\n            sm1=sm1+S1[pta]\n            print(\"sm1: \", str(sm1))\n            pta=pta+1\n            print(\"pta: \", str(pta))\n    else:\n        if(S1[pta]>S2[ptb]):\n            pta=pta+1\n            print(\"pta: \", str(pta))\n        else:\n            sm2=sm2+S2[ptb]\n            print(\"sm2: \", str(sm2))\n            ptb=ptb+1\n            print(\"ptb: \", str(ptb))\n    if(pta==n+1 and ptb==n+1):\n        break\nprint(sm1-sm2)\n</ans>", "format_properties": {}}
{"idx": 194, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nfrom math import *\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    print(\"x: \", str(x))\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    print(\"x: \", str(x))\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    print(\"n: \", str(n), \"k: \", str(k))\n    n,k = arrIN()\n    ans = 0\n    while 1:\n        if n%k==0:\n            n//=k\n            ans+=1\n        else:\n            x = n%k\n            ans+=x\n            n-=x\n        if n==0:\n            print(ans)\n            break\n</ans>", "format_properties": {}}
{"idx": 193, "result": 0, "generated": "<ans>\nimport sys\n# from collections import deque\ninput=sys.stdin.readline\ndef binary_search(org,arr,l,r,n,L,value):\n\tprint(\"org: \", str(org), \"arr: \", str(arr), \"l: \", str(l), \"r: \", str(r), \"n: \", str(n), \"L: \", str(L), \"value: \", str(value))\n\tmid=(l+r)//2\n\t# print(mid,\"ppppp\")\n\tif(mid>0 and arr[mid]-value>=org and arr[mid-1]-value<org):\n\t\treturn mid\n\telif(mid==0 and arr[mid]-value>=org ):\n\t\treturn mid\n\telif(mid==L and arr[mid]-value>=org ):\n\t\treturn mid\n\t\n\telif(mid==n):\n\t\treturn mid\n\n\telif(mid>0 and arr[mid]-value>org and arr[mid-1]-value>=org):\n\t\treturn binary_search(org,arr,l,mid,n,L,value)\n\t\n\telif(arr[mid]-value<org):\n\t\t# print(\"dddddd\")\n\t\treturn binary_search(org,arr,mid+1,r,n,L,value)\n\treturn mid\n\t\n\n\n\n\n\nn=int(input())\nl= list(map(int,input().split())) \nu= list(map(int,input().split())) \nextra=[0]*n\npre=[0]*n\nt=[0]*n\nt[0]=u[0]\nprint(\"t: \", str(t))\nfor i in range(1,n):\n\tt[i]+=t[i-1]+u[i]\n# print(t)\nfor i in range(n):\n\tif(i>0):\n\t\tv=t[i-1]\n\telse:\n\t\tv=0\n\tindex=binary_search(l[i],t,i,n-1,n-1,i,v)\n\t# print(i,index)\n\tif(index>0 and index!=i):\n\t\tvalue=t[index]-t[index-1]\n\t\tremain=l[i]-(t[index-1]-v)\n\telif(index>0 and index==i):\n\t\tvalue=t[index]-t[index-1]\n\t\tremain=l[i]\n\n\n\telse:\n\t\tvalue=t[index]\n\t\tremain=l[i]\n\tif(value>=remain):\n\t\textra[index]+=remain\n\t\t# print(extra[index],\"ooooo\")\n\telif(remain>value):\n\n\t\textra[index]+=value\n\t\t# print(extra[index],\"oooooopp\")\n\tif(i>0 and index>0):\n\t\tpre[i-1]-=1\n\t\tpre[index-1]+=1\n\telif(i==0 and index>0):\n\t\tpre[index-1]+=1\n\telif(i==0 and index==0):\n\t\tcontinue\n\t# print(extra,pre)\n# print(extra,pre)\nfor i in range(n-2,-1,-1):\n\tpre[i]+=pre[i+1]\n# print(extra,pre)\nr=[0]*n\nfor i in range(n):\n\tr[i]=(u[i]*pre[i])+extra[i]\n\t\t\nfor i in r:\n\tprint (i,end=\" \")\n</ans>", "format_properties": {}}
{"idx": 197, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nl=list(map(int,input().split()))\nprint(\"l: \", str(l))\ns=input()\nprint(\"s: \", str(s))\nwater=0\nprint(\"water: \", str(water))\ngrass=0\nprint(\"grass: \", str(grass))\ncgrass=0\nprint(\"cgrass: \", str(cgrass))\ntime=0\nprint(\"time: \", str(time))\nseen=False\nprint(\"seen: \", str(seen))\nfor i in range(n):\n    if s[i]==\"G\":\n        dist=l[i]\n        print(\"dist: \", str(dist))\n        if water>=dist:\n            water-=dist\n            print(\"water: \", str(water))\n            time+=2*dist\n            print(\"time: \", str(time))\n            cgrass+=dist\n            print(\"cgrass: \", str(cgrass))\n        else:\n            dist-=water\n            print(\"dist: \", str(dist))\n            time+=2*water\n            print(\"time: \", str(time))\n            water=0\n            print(\"water: \", str(water))\n            time+=3*dist\n            print(\"time: \", str(time))\n            grass+=dist\n            print(\"grass: \", str(grass))\n    elif s[i]==\"W\":\n        water+=l[i]\n        print(\"water: \", str(water))\n        time+=2*l[i]\n        print(\"time: \", str(time))\n        seen=True\n        print(\"seen: \", str(seen))\n    else:\n        dist=l[i]\n        print(\"dist: \", str(dist))\n        if water>=dist:\n            water-=dist\n            print(\"water: \", str(water))\n            time+=2*dist\n            print(\"time: \", str(time))\n        else:\n            dist-=water\n            print(\"dist: \", str(dist))\n            time+=2*water\n            print(\"time: \", str(time))\n            water=0\n            print(\"water: \", str(water))\n            if cgrass>=dist:\n                cgrass-=dist\n                print(\"cgrass: \", str(cgrass))\n                grass+=dist\n                print(\"grass: \", str(grass))\n                time+=3*dist\n                print(\"time: \", str(time))\n            else:\n                dist-=cgrass\n                print(\"dist: \", str(dist))\n                grass+=cgrass\n                print(\"grass: \", str(grass))\n                time+=3*cgrass\n                print(\"time: \", str(time))\n                cgrass=0\n                print(\"cgrass: \", str(cgrass))\n                if grass>=dist:\n                    grass-=dist\n                    print(\"grass: \", str(grass))\n                    time+=3*dist\n                    print(\"time: \", str(time))\n                else:\n                    dist-=grass\n                    print(\"dist: \", str(dist))\n                    time+=3*grass\n                    print(\"time: \", str(time))\n                    grass=0\n                    print(\"grass: \", str(grass))\n                    if seen:\n                        time+=4*dist\n                        print(\"time: \", str(time))\n                    else:\n                        time+=6*dist\n                        print(\"time: \", str(time))\nprint(\"time: \", str(time))\n</ans>", "format_properties": {}}
{"idx": 195, "result": 0, "generated": "<ans>\nMOD = 1000000007\n\n\ndef isSubset(a, b):\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a & b) == a\n\n\ndef isIntersect(a, b):\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a & b) != 0\n\n\n# Solve for each weakly connected component (WCC)\ndef cntOrder(s, t):\n\tp = len(s)\n\tm = len(t)\n\n\tinMask = [0 for i in range(m)]\n\n\tfor x in range(p):\n\t\tfor i in range(m):\n\t\t\tif t[i] % s[x] == 0:\n\t\t\t\tinMask[i] |= 1 << x\n\n\tcnt = [0 for mask in range(1<<p)]\n\tfor mask in range(1<<p):\n\t\tfor i in range(m):\n\t\t\tif isSubset(inMask[i], mask):\n\t\t\t\tcnt[mask] += 1\n\n\tdp = [[0 for mask in range(1<<p)] for k in range(m+1)]\n\tfor i in range(m):\n\t\tdp[1][inMask[i]] += 1\n\tfor k in range(m):\n\t\tfor mask in range(1<<p):\n\t\t\tfor i in range(m):\n\t\t\t\tif not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\n\t\t\t\t\tdp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD\n\t\t\tdp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\n\n\treturn dp[m][(1<<p)-1]\n\n\ndef dfs(u):\n\tnonlocal a, graph, degIn, visited, s, t\n\n\tvisited[u] = True\n\tif degIn[u] == 0:\n\t\ts.append(a[u])\n\telse:\n\t\tt.append(a[u])\n\n\tfor v in graph[u]:\n\t\tif not visited[v]:\n\t\t\tdfs(v)\n\n\ndef main():\n\tnonlocal a, graph, degIn, visited, s, t\n\n\t# Reading input\n\tn = int(input())\n\tprint(\"n: \", str(n))\n\ta = list(map(int, input().split()))\n\tprint(\"a: \", str(a))\n\n\t# Pre-calculate C(n, k)\n\tc = [[0 for j in range(n)] for i in range(n)]\n\tfor i in range(n):\n\t\tc[i][0] = 1\n\t\tfor j in range(1, i+1):\n\t\t\tc[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD\n\tprint(\"c: \", str(c))\n\n\t# Building divisibility graph\n\tdegIn = [0 for u in range(n)]\n\tgraph = [[] for u in range(n)]\n\tfor u in range(n):\n\t\tfor v in range(n):\n\t\t\tif u != v and a[v] % a[u] == 0:\n\t\t\t\tgraph[u].append(v)\n\t\t\t\tgraph[v].append(u)\n\t\t\t\tdegIn[v] += 1\n\tprint(\"degIn: \", str(degIn))\n\tprint(\"graph: \", str(graph))\n\n\t# Solve for each WCC of divisibility graph and combine result\n\tans = 1\n\tcurLen = 0\n\tvisited = [False for u in range(n)]\n\tfor u in range(n):\n\t\tif not visited[u]:\n\t\t\ts = []\n\t\t\tt = []\n\t\t\tdfs(u)\n\n\t\t\tif len(t) > 0:\n\t\t\t\tsz = len(t) - 1\n\t\t\t\tcnt = cntOrder(s, t)\n\n\t\t\t\t# Number of orders for current WCC\n\t\t\t\tans = (ans * cnt) % MOD\n\t\t\t\t# Number of ways to insert <sz> number to array of <curLen> elements\n\t\t\t\tans = (ans * c[curLen + sz][sz]) % MOD\n\t\t\t\tcurLen += sz\t\t\n\n\tprint(\"ans: \", str(ans))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 196, "result": 0, "generated": "<ans>\nN=int(input())\nprint(\"N: \", str(N))\nS=input()\nprint(\"S: \", str(S))\nS=[1 if S[i]=='o' else -1 for i in range(N)]\nprint(\"S: \", str(S))\n\n#0\u756a\u76ee\u306f\u7f8a\u306e\u30d1\u30bf\u30fc\u30f3\ntmp=[0]*N\nprint(\"tmp: \", str(tmp))\ntmp[0]=1\nprint(\"tmp: \", str(tmp))\nif S[0]==1: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u540c\u7a2e\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7f8a\n  tmp[1]=1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n    \n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u72fc\n  tmp[1]=-1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \nelse: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7570\u7a2e\n  #1\u756a\u76ee\u304c\u7f8a, N-1\u756a\u76ee\u304c\u72fc\n  tmp[1]=1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \n  #1\u756a\u76ee\u304c\u72fc, N-1\u756a\u76ee\u304c\u7f8a\n  tmp[1]=-1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \n#0\u756a\u76ee\u306f\u72fc\u306e\u30d1\u30bf\u30fc\u30f3\ntmp=[0]*N\nprint(\"tmp: \", str(tmp))\ntmp[0]=-1\nprint(\"tmp: \", str(tmp))\nif S[0]==-1: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u540c\u7a2e\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7f8a\n  tmp[1]=1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n    \n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u72fc\n  tmp[1]=-1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \nelse: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7570\u7a2e\n  #1\u756a\u76ee\u304c\u7f8a, N-1\u756a\u76ee\u304c\u72fc\n  tmp[1]=1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \n  #1\u756a\u76ee\u304c\u72fc, N-1\u756a\u76ee\u304c\u7f8a\n  tmp[1]=-1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n    print(\"tmp: \", str(tmp))\n    \n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n  \nprint(-1)\n</ans>", "format_properties": {}}
