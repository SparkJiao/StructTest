index,generated,result,format_properties
0,"<ans>
'''input
9 4 8
6 8 5 1 8 1 1 2 1
9 2
8 4
5 3
9 7
'''
from sys import stdin
import math
from copy import deepcopy
from collections import defaultdict


def process_offer(offers):
	aux = []
	for i in offers:
		temp = offers[i]
		temp.sort()
		aux.append([i, temp[-1]])

	aux = sorted(aux, key = lambda x: x[0])
	return aux


def make(first, second):
	return str(first) + ' ' + str(second)


def brute(arr, dp, offers, index, remain):
	#print(index, remain)
	# base case:
	if remain == 0:
		return 0

	if make(index, remain) in dp:
		return dp[make(index, remain)]

	min_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)
	#print(min_cost)
	for i in range(len(offers)):
		cost = 0
		if offers[i][0] <= remain:
			free = offers[i][1]
			for  j in range(index + free, index + offers[i][0]):
				cost += arr[j]
			cost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])
			min_cost = min(min_cost, cost)
		else:
			break
	dp[make(index, remain)] = min_cost
	print(""dp: "", str(dp))
	return min_cost



# main starts
n, m, k = list(map(int, stdin.readline().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
arr = list(map(int, stdin.readline().split()))
print(""arr: "", str(arr))
arr.sort()
offers = defaultdict(list)
for _ in range(m):
	x, y = list(map(int, stdin.readline().split()))
	print(""x: "", str(x), ""y: "", str(y))
	offers[x].append(y)

offers = process_offer(offers)
print(""offers: "", str(offers))
dp = dict()
print(""dp: "", str(dp))
print(brute(arr, dp, offers, 0, k))
#print(dp)
</ans>",0,{}
1,"<ans>
def PrimeDecomp(N,ConcFlag):
    if ConcFlag:
        if N<=1:
            return [1],1
        else:
            I = 2
            PrimeDec = []
            print(""I: "", str(I), ""PrimeDec: "", str(PrimeDec))
            DivCount = 1
            print(""DivCount: "", str(DivCount))
            while I*I<=N:
                Cnt = 0
                print(""Cnt: "", str(Cnt))
                while N%I==0:
                    N //= I
                    PrimeDec.append(I)
                DivCount *= (Cnt+1)
                I += 1
            if N>=2:
                PrimeDec.append(N)
                DivCount *= 2
            return PrimeDec,DivCount        
    else:
        if N<=1:
            return [1],[1],1
        else:
            I = 2
            PrimeDec = []
            print(""I: "", str(I), ""PrimeDec: "", str(PrimeDec))
            PrimeCnt = []
            print(""PrimeCnt: "", str(PrimeCnt))
            DivCount = 1
            print(""DivCount: "", str(DivCount))
            while I*I<=N:
                Cnt = 0
                print(""Cnt: "", str(Cnt))
                while N%I==0:
                    N //= I
                    Cnt += 1
                if Cnt>=1:
                    PrimeDec.append(I)
                    PrimeCnt.append(Cnt)
                    DivCount *= (Cnt+1)
                I += 1
            if N>=2:
                PrimeDec.append(N)
                PrimeCnt.append(1)
                DivCount *= 2
            return PrimeDec,PrimeCnt,DivCount

def DivisorFactorial(N,FactDec,FactCnt,MemoFlag,Mod,ModFlag):
    if MemoFlag:
        if N<=1:
            FDivCnt = 1
            print(""FDivCnt: "", str(FDivCnt))
            return FactDec,FactCnt,FDivCnt
        else:
            PrimeDec,PrimeCnt,_ = PrimeDecomp(N,False)
            for TP in range(0,len(PrimeDec)):
                if PrimeDec[TP] in set(FactDec):
                    FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                else:
                    FactDec.append(PrimeDec[TP])
                    FactCnt.append(PrimeCnt[TP])
            FDivCnt = 1
            print(""FDivCnt: "", str(FDivCnt))
            for TF in FactCnt:
                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,FDivCnt
    else:
        if N<=1:
            FDivCnt = 1
            print(""FDivCnt: "", str(FDivCnt))
            return FactDec,FactCnt,FDivCnt
        else:
            for TN in range(2,N+1): 
                PrimeDec,PrimeCnt,_ = PrimeDecomp(TN,False)
                for TP in range(0,len(PrimeDec)):
                    if PrimeDec[TP] in set(FactDec):
                        FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                    else:
                        FactDec.append(PrimeDec[TP])
                        FactCnt.append(PrimeCnt[TP])
            FDivCnt = 1
            print(""FDivCnt: "", str(FDivCnt))
            for TF in FactCnt:
                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,FDivCnt
FactDec,FactCnt,FDivCnt = DivisorFactorial(int(input()),[],[],False,10**9+7,True)
print(FDivCnt)
</ans>",0,{}
2,"<ans>
from math import sqrt,gcd


def gen_primes():
    """""" Generate an infinite sequence of prime numbers.
    """"""
    #
    D = {}
    print(""D: "", str(D))

    # The running integer that's checked for primeness
    q = 2
    print(""q: "", str(q))

    while True:
        if q not in D:
            # q is a new prime.
            # Yield it and mark its first multiple that isn't
            # already marked in previous iterations
            #
            yield q
            D[q * q] = [q]
            print(""D: "", str(D))
        else:
            # q is composite. D[q] is the list of primes that
            # divide it. Since we've reached q, we no longer
            # need it in the map, but we'll mark the next
            # multiples of its witnesses to prepare for larger
            # numbers
            #
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
                print(""D: "", str(D))
            del D[q]
            print(""D: "", str(D))

        q += 1
        print(""q: "", str(q))


def is_prime(n):
    if n<=1:
        return False
    if n == 2:
        return True
    if n % 2 ==0:
        return False
    return all(n%i for i in range(3,int(sqrt(n))+1))


def calculate_colors(n):
    primes = gen_primes()
    print(""primes: "", str(primes))
    sqr_n = int(sqrt(n)) + 1
    print(""sqr_n: "", str(sqr_n))
    if n == 1:
        return 1
    for p in primes:
        if n % p == 0:
            while n % p == 0:
                g= gcd(p,n)
                print(""g: "", str(g))
                n = int(n//g)
                print(""n: "", str(n))
            if n > 1:
                return 1
            else:
                return p
        if p > sqr_n:
            return n



n = int(input())
print(""n: "", str(n))
print(calculate_colors(n))
</ans>",1,{}
3,"<ans>
import numpy as np
mod = 998244353

def poly_mul(f, g):
    # 参考: https://judge.yosupo.jp/submission/2380
    Lf = len(f); Lg = len(g); L = Lf + Lg - 1
    print(""Lf: "", str(Lf), ""Lg: "", str(Lg), ""L: "", str(L))
    if Lf <= 16 or Lg <= 16:
        if Lf == 0 or Lg == 0:
            return np.zeros((0,), dtype=np.int64)
        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)
    fft = np.fft.rfft; ifft = np.fft.irfft
    fft_len = 1 << L.bit_length()
    print(""fft_len: "", str(fft_len))
    fl = f & (1 << 15) - 1; fh = f >> 15
    gl = g & (1 << 15) - 1; gh = g >> 15
    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod
    print(""x: "", str(x))
    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    print(""y: "", str(y))
    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    print(""z: "", str(z))
    return (x + ((y - x - z) << 15) + (z << 30)) % mod

def poly_inv(fps, n=None):
    assert fps[0] != 0
    if n is None:
        n = len(fps)
    print(""n: "", str(n))
    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)
    print(""res: "", str(res))
    res[0] = pow(int(fps[0]), mod-2, mod)
    print(""res[0]: "", str(res[0]))
    i = 1
    while i < n:
        i <<= 1
        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod
        print(""i: "", str(i), ""res[:i]: "", str(res[:i]))
    return res[:n]

def poly_div(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    print(""n1: "", str(n1), ""n2: "", str(n2))
    if n1 < n2:
        return np.zeros((0,), dtype=np.int64)
    n = n1 - n2 + 1
    print(""n: "", str(n))
    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]
    print(""res: "", str(res))
    return res

def poly_mod(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    print(""n1: "", str(n1), ""n2: "", str(n2))
    if n1 < n2:
        return fps1
    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]
    print(""res: "", str(res))
    return res % mod

def multipoint_evaluation(fps, xs):
    threshold = 8
    n_xs = len(xs)
    print(""threshold: "", str(threshold), ""n_xs: "", str(n_xs))
    bit = (n_xs-1).bit_length()
    print(""bit: "", str(bit))
    if bit <= threshold:
        res = np.zeros_like(xs)
        print(""res: "", str(res))
        xs_cumprod = np.ones_like(xs)
        print(""xs_cumprod: "", str(xs_cumprod))
        for coef in fps:
            res += xs_cumprod * coef
            xs_cumprod *= xs
            xs_cumprod %= mod
        return res
    k = 1<<bit
    print(""k: "", str(k))
    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)
    print(""fpss: "", str(fpss))
    fpss[0, :n_xs] = -xs % mod
    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod
    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod
    for i in range(1, bit):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+step] = f[:-1]
    f = poly_mod(fps, f)
    fpss[-1, :len(f)] = f
    fpss[-1, len(f):] = 0
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f = fpss[i+1, j:j+step]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss[i, j:j+half] = poly_mod(f, f1)
            fpss[i, j+half:j+step] = poly_mod(f, f2)
    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)
    print(""xs: "", str(xs))
    xs_cumprod = np.ones_like(xs)
    print(""xs_cumprod: "", str(xs_cumprod))
    res = np.zeros_like(xs)
    print(""res: "", str(res))
    for i in range(1<<threshold):
        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    return res.reshape(-1)[:n_xs] % mod

def poly_differential(fps):
    return fps[1:] * np.arange(1, len(fps)) % mod

def lagrange_interpolation(X, Y, mod):
    # old
    n = len(X)
    print(""n: "", str(n))
    g = [0]*(n+1)
    print(""g: "", str(g))
    g[0] = 1
    for i, x in enumerate(X):
        for j in range(i, -1, -1):
            g[j+1] += g[j] * (-x) % mod
    res = [0]*n
    print(""res: "", str(res))
    for x, y in zip(X, Y):
        f = g[:]
        denom = 0
        v = 1
        pow_x = [1]  # x の idx 乗
        for _ in range(n-1):
            v = v * x % mod
            pow_x.append(v)
        pow_x.reverse()  # n-1 乗 ~ 0 乗
        for i, po in enumerate(pow_x):
            f_i = f[i]
            f[i+1] += f_i * x % mod  # f = g / (x - x_i) を組立除法で求める
            denom = (denom + f_i * po) % mod
        denom_inv = pow(denom, mod-2, mod)
        for i, f_i in enumerate(f[:n]):
            res[i] += (f_i * y * denom_inv)# % mod  # mod が大きいと 64bit に収まらなくなるのでひとつずつ mod 取った方がいいか？
    return [v % mod for v in res]

def polynomial_interpolation(xs, ys):
    # 参考: https://rsk0315.hatenablog.com/entry/2020/04/05/203210
    assert len(xs) == len(ys)
    threshold = 8
    as_strided = np.lib.stride_tricks.as_strided
    n = len(xs)
    print(""n: "", str(n))
    if n==1:
        return ys.copy()
    bit = (n-1).bit_length()
    print(""bit: "", str(bit))
    if bit <= threshold:
        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)
        return np.array(res[::-1], dtype=np.int64)
    k = 1<<bit
    print(""k: "", str(k))
    fpss = np.zeros((bit+1, n+1), dtype=np.int64)
    print(""fpss: "", str(fpss))
    fpss[0, :n] = -xs % mod
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, n, step):
            if j+half >= n:
                fpss[i+1, j:n] = fpss[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+len(f)-1] = f[:-1]
    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)
    print(""fpss2: "", str(fpss2))
    fpss2[bit, :n] = poly_differential(f)
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, n, step):
            if j+half >= n:
                fpss2[i, j:n] = fpss2[i+1, j:n]
                continue
            f = fpss2[i+1, j:min(j+step, n)]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:min(j+step, n)+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i, j:j+half] = poly_mod(f, f1)
            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)
    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))
    print(""xs: "", str(xs))
    xs_cumprod = np.ones_like(xs)
    print(""xs_cumprod: "", str(xs_cumprod))
    f = np.zeros_like(xs)
    print(""f: "", str(f))
    for i in range(1<<threshold):
        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    f = f.ravel()
    for j in range(n):
        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod
        print(""fpss2[0, j]: "", str(fpss2[0, j]))
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, k, step):
            if j+half >= n:
                fpss2[i+1, j:n] = fpss2[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i+1, j:min(j+step, n)] = (
                poly_mul(fpss2[i, j:j+half], f2)
                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)
            ) % mod
    return fpss2[bit, :n]

mod = int(input())
print(""mod: "", str(mod))
A = np.array(input().split(), dtype=np.int64)
print(""A: "", str(A))
X = np.arange(mod, dtype=np.int64)
print(""X: "", str(X))
Ans = polynomial_interpolation(X, A)
print(""Ans: "", str(Ans))
print(("" "".join(map(str, Ans.tolist()))))
</ans>",0,{}
4,"<ans>
import math
from collections import defaultdict
import sys
#input = sys.stdin.readline


def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    k = list(map(int, input().split()))
    print(""k: "", str(k))
    sales = [(0, 0)] * m
    print(""sales: "", str(sales))
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        sales[i] = (b, a)
        print(""sales[{}]: "".format(i), str(sales[i]))

    def check(days):
        last_sale = {}
        print(""days: "", str(days))
        for sale in sales:
            if sale[1] <= days:
                if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:
                    last_sale[sale[0]] = sale[1]
                    print(""last_sale[{}]: "".format(sale[0]), str(last_sale[sale[0]]))

        date_last_sales = {}
        for t, d in list(last_sale.items()):
            if d not in date_last_sales:
                date_last_sales[d] = [t]
                print(""date_last_sales[{}]: "".format(d), str(date_last_sales[d]))
            else:
                date_last_sales[d].append(t)
                print(""date_last_sales[{}]: "".format(d), str(date_last_sales[d]))

        balance = 0
        required = [0] + k.copy()
        print(""required: "", str(required))

        end = 0
        for d in range(1, days+1):
            balance += 1
            if d in date_last_sales:
                for t in date_last_sales[d]:
                    if required[t] > 0:
                        if required[t] > balance:
                            end += required[t] - balance
                        balance -= min(required[t], balance)
                        required[t] = 0
            if d == days:  # last day
                for r in required:
                    if r > 0:
                        end += r

        return 2*end <= balance

    total = sum(k)
    print(""total: "", str(total))
    hi = 2*total
    print(""hi: "", str(hi))
    lo = 1
    print(""lo: "", str(lo))

    while lo + 1 < hi:
        mid = (lo + hi) // 2
        print(""mid: "", str(mid))
        if check(mid):
            hi = mid
        else:
            lo = mid

    if check(lo):
        print(lo)
    else:
        print(hi)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
5,"<ans>
import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
print(""N: "", str(N))
EDGE=[list(map(int,input().split())) for i in range(N-1)]
print(""EDGE: "", str(EDGE))

EDGELIST=[[] for i in range(N+1)]
print(""EDGELIST: "", str(EDGELIST))

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

#EDGES=[[] for i in range(N+1)]
REDG=[None for i in range(N+1)]
print(""REDG: "", str(REDG))
QUE=deque([1])
print(""QUE: "", str(QUE))
check=[0]*(N+1)
print(""check: "", str(check))
DEPTH=[None]*(N+1)
print(""DEPTH: "", str(DEPTH))
i=0
print(""i: "", str(i))
while QUE:
    NQUE=deque()
    print(""NQUE: "", str(NQUE))
    i+=1
    print(""i: "", str(i))
    
    while QUE:
        x=QUE.pop()
        print(""x: "", str(x))
        DEPTH[x]=i
        print(""DEPTH: "", str(DEPTH))
        check[x]=1
        print(""check: "", str(check))
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                REDG[to]=x
                print(""REDG: "", str(REDG))
                NQUE.append(to)
                print(""NQUE: "", str(NQUE))
    QUE=NQUE
    print(""QUE: "", str(QUE))


check=[0]*(N+1)
print(""check: "", str(check))
check[1]=1
print(""check: "", str(check))
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


LEAF=[]
print(""LEAF: "", str(LEAF))
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))
        print(""LEAF: "", str(LEAF))

QUE=LEAF
print(""QUE: "", str(QUE))
heapq.heapify(QUE)
ANS=0
print(""ANS: "", str(ANS))

#print(check,QUE)

while QUE:
    dep,x=heapq.heappop(QUE)
    print(""dep: "", str(dep), ""x: "", str(x))
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
        print(""check: "", str(check))
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
        print(""check: "", str(check))
    check[REDG[x]]=2   
    print(""check: "", str(check))
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    print(""QUE: "", str(QUE))
    ANS+=1
    print(""ANS: "", str(ANS))

    #print(x,QUE,check)

print(ANS)
</ans>",0,{}
6,"<ans>
class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        print(""_parent: "", str(self._parent))
        self._size = [1] * N
        print(""_size: "", str(self._size))

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
            print(""_parent: "", str(self._parent), ""_size: "", str(self._size))
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]
            print(""_parent: "", str(self._parent), ""_size: "", str(self._size))

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

    def calc_group_num(self):
        N = len(self._parent)
        ans = 0
        for i in range(N):
            if self.find_root(i) == i:
                ans += 1
        return ans

import sys

input=sys.stdin.readline

n,m=list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m))
t=list(map(int,input().split()))
print(""t: "", str(t))
t=[t[i]-1 for i in range(n)]
print(""t: "", str(t))
query=[]
for i in range(m-1):
    a,b=list(map(int,input().split()))
    query.append((a-1,b-1))
    print(""query: "", str(query))

tower=[[] for i in range(m)]
print(""tower: "", str(tower))
for i in range(n):
    id=t[i]
    if not tower[id]:
        tower[id].append((i+1,i+1))
    else:
        start,end=tower[id].pop()
        if end+1==i+1:
            tower[id].append((start,i+1))
        else:
            tower[id].append((start,end))
            tower[id].append((i+1,i+1))
    print(""tower: "", str(tower))

test=[]
for i in range(m):
    for start,end in tower[i]:
        if end!=n:
            test.append((t[start-1],t[end]))
print(""test: "", str(test))
start=[-1]*len(test)
print(""start: "", str(start))
end=[m-1]*len(test)
print(""end: "", str(end))
temp=[[] for i in range(m)]
print(""temp: "", str(temp))
for i in range(len(test)):
    T=(end[i]+start[i])//2
    temp[T].append(i)
    print(""temp: "", str(temp))


def parabisect():
    uf=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=query[i]
        uf.unite(a,b)
        while temp[i]:
            j=temp[i].pop()
            id1,id2=test[j]
            if uf.is_same_group(id1,id2):
                end[j]=i
                print(""end: "", str(end))
            else:
                start[j]=i
                print(""start: "", str(start))
            if end[j]-start[j]>1:
                T=(end[j]+start[j])//2
                temp[T].append(j)
                print(""temp: "", str(temp))

for i in range(20):
    parabisect()

res=[0]*m
print(""res: "", str(res))
for i in range(len(test)):
    res[end[i]+1]-=1
    print(""res: "", str(res))

for i in range(1,m):
    res[i]+=res[i-1]
    print(""res: "", str(res))

for i in range(m):
    print(len(test)+res[i])
</ans>",0,{}
7,"<ans>
# from collections import deque
import io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # 神奇快读，无法运行调试
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")


n, m = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m))
# d = {}
inc = {
    # chr(97+i):0 for i in range(26)

}
l = [None for i in range(n*m)]
print(""l: "", str(l))

for i in range(n):
    t = int(input())
    print(""t: "", str(t))
    # tmp = []
    for j in range(m):
        # tmp.append(input())
        ipt = input()
        print(""ipt: "", str(ipt))
        l[t*m+j] = ipt
        if len(inc)==26:continue
        for q in ipt:
            inc.setdefault(q, 0)
    # d[t] = tmp
# l = []
# for i in range(n):
#     for j in d[i]:
#         l.append(j)

d = {}
print(""d: "", str(d))


# f = l[0][0]

def ae(u, v):
    t = d.setdefault(u, set())
    if v not in t:
        t.add(v)
        inc[v] = inc.get(v, 0) + 1
        print(""inc: "", str(inc))


for p, i in enumerate(l[1:]):
    for j in range(min(len(l[p]), len(i))):
        if l[p][j] != i[j]:
            # if len(l[p])-1 != j:
                # ae(l[p][j],i[j])
            ae(i[j], l[p][j])
            break
        if len(i)-1==j and len(l[p])-1 > j:
            print(""IMPOSSIBLE"")
            return


ans = []
print(""ans: "", str(ans))
dq = []
# dq = deque()
ptr = 0
print(""ptr: "", str(ptr))


ninc = {}

for k, v in inc.items():
    if v == 0:
        dq.append(k)
    else:
        ninc[k] = v
print(""ninc: "", str(ninc))


# if ctr>1:
    # print(""IMPOSSIBLE"")
    # return

inc = ninc
print(""inc: "", str(inc))


while ptr != len(dq):
    fst = dq[ptr]
    ans.append(fst)
    print(""ans: "", str(ans))

    for i in d.get(fst, []):
        inc[i] -= 1
        if inc[i] == 0:
            dq.append(i)
            inc.pop(i)

    # if ctr>1:
        # print(""IMPOSSIBLE"")
        # return
    ptr += 1

if len(inc):
    print(""IMPOSSIBLE"")
    return

print(*reversed(ans), sep='')
</ans>",0,{}
8,"<ans>
import sys
import math
import itertools
import functools
import collections


def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
    print(""divs_number: "", str(divs_number))
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    print(""newnumber: "", str(newnumber))
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


t = ii()
print(""t: "", str(t))
for _ in range(t):
    r, g, b = sorted(mi())
    print(""r: "", str(r), ""g: "", str(g), ""b: "", str(b))
    if b > r + g + 1:
        print('No')
    else:
        print('Yes')
</ans>",0,{}
9,"<ans>
#!/usr/bin/env python
# 560B_art.py - Codeforces.com 560B Art program
#
# Copyright (C) 2015 Sergey

""""""
Gerald asks whether it is possible to place the paintings on the board,
or is the board he bought not large enough?
Input

The first line contains two space-separated numbers a1 and b1 the sides
of the board. Next two lines contain numbers a2 b2 a3 and b3 the sides
of the paintings. All numbers ai,?bi in the input are integers and fit into
the range from 1 to 1000.

Output

If the paintings can be placed on the wall, print ""YES"" (without the quotes),
and if they cannot, print ""NO"" (without the quotes).
""""""

# Standard modules
import unittest
import sys

# Additional modules


###############################################################################
# Art Class
###############################################################################


class Art:
    """""" Art representation """"""

    def __init__(self, args):
        """""" Default constructor """"""

        self.numa, self.numb = args
        print(""numa: "", str(self.numa), ""numb: "", str(self.numb))

        self.r = self.rect(self.numa[0], self.numb[0])
        print(""r: "", str(self.r))
        self.rmax = self.rect(self.numa[1], self.numb[1])
        print(""rmax: "", str(self.rmax))
        self.rmin = self.rect(self.numa[2], self.numb[2])
        print(""rmin: "", str(self.rmin))
        if self.rmax[0] < self.rmax[1]:
            self.rmax, self.rmin = self.rmin, self.rmax
            print(""rmax: "", str(self.rmax), ""rmin: "", str(self.rmin))

        self.remain = []
        print(""remain: "", str(self.remain))
        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))
            print(""remain: "", str(self.remain))
        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))
            print(""remain: "", str(self.remain))

        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))
            print(""remain: "", str(self.remain))
        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))
            print(""remain: "", str(self.remain))

    def rect(self, a, b):
        if a > b:
            return (a, b)
        else:
            return (b, a)

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        for rec in self.remain:
            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:
                return ""YES""
            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:
                return ""YES""
        return ""NO""


###############################################################################
# Helping classes
###############################################################################


###############################################################################
# Art Class testing wrapper code
###############################################################################


def get_inputs(test_inputs=None):

    it = iter(test_inputs.split(""\n"")) if test_inputs else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if it:
            return next(it)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    imax = 3
    print(""imax: "", str(imax))
    numnums = list(map(int, "" "".join(uinput() for i in range(imax)).split()))
    print(""numnums: "", str(numnums))

    # Splitting numnums into n arrays
    numa = []
    numb = []
    for i in range(0, 2*imax, 2):
        numa.append(numnums[i])
        numb.append(numnums[i+1])
    print(""numa: "", str(numa), ""numb: "", str(numb))

    # Decoding inputs into a list
    return [numa, numb]


def calculate(test_inputs=None):
    """""" Base class calculate method wrapper """"""
    return Art(get_inputs(test_inputs)).calculate()


###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_Art_class__basic_functions(self):
        """""" Art class basic functions testing """"""

        # Constructor test
        d = Art([[3, 1, 2], [2, 3, 1]])
        self.assertEqual(d.numa[0], 3)

        self.assertEqual(d.r, (3, 2))
        self.assertEqual(d.rmax, (3, 1))
        self.assertEqual(d.rmin, (2, 1))

        self.assertEqual(d.remain, [(3, 1)])

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        test = ""3 2\n1 3\n2 1""
        self.assertEqual(calculate(test), ""YES"")
        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])
        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])

        # Sample test 2
        test = ""5 5\n3 3\n3 3""
        self.assertEqual(calculate(test), ""NO"")

        # Sample test 3
        test = ""4 2\n2 3\n1 2""
        self.assertEqual(calculate(test), ""YES"")

        # My test 4
        test = ""5 5\n1 5\n1 5""
        self.assertEqual(calculate(test), ""YES"")

    def test_time_limit_test(self):
        """""" Quiz time limit test """"""

        import random

        # Time limit test
        test = ""1000 1000""
        test += ""\n900 900""
        test += ""\n50 50""

        import timeit

        start = timeit.default_timer()
        args = get_inputs(test)

        init = timeit.default_timer()
        d = Art(args)

        calc = timeit.default_timer()
        d.calculate()

        stop = timeit.default_timer()
        print((
            ""\nTime Test: "" +
            ""{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)"".
            format(stop-start, init-start, calc-init, stop-calc)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(calculate())

__starting_point()
</ans>",0,{}
10,"<ans>
import sys
from collections import defaultdict
 
class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * n
    
    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        result = 0
        while r > 0:
            result += self.tree[r-1]
            r &= (r - 1)
        return result
    
    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)
    
    def add(self, i, value=1):
        while i < self.n:
            self.tree[i] += value
            i |= (i + 1)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
swaps = []
print(""swaps: "", str(swaps))
for _ in range(n):
    i, j = list(map(int, input().split()))
    print(""i: "", str(i), ""j: "", str(j))
    swaps.append(i)
    swaps.append(j)

pos = defaultdict(list)
print(""pos: "", str(pos))
for i, val in enumerate(swaps):
    pos[val].append(i)

c = 0
print(""c: "", str(c))
prev = -1
print(""prev: "", str(prev))
compr = [0] * (2*n)
print(""compr: "", str(compr))
decompr = {}
print(""decompr: "", str(decompr))
for val in sorted(swaps):
    if prev == val: continue
    for j in pos[val]:
        compr[j] = c
    decompr[c] = val
    c += 1
    print(""c: "", str(c), ""prev: "", str(prev), ""val: "", str(val))
    prev = val

arr = list(range(c))
print(""arr: "", str(arr))
for t in range(n):
    i, j = compr[t<<1], compr[t<<1|1]
    arr[i], arr[j] = arr[j], arr[i]

bit = BIT(c)
total_inv = 0
print(""total_inv: "", str(total_inv))
for i, val in enumerate(arr):
    total_inv += bit.get_sum(val+1, c)
    if i != val:
        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)
    bit.add(val)
print(total_inv)
</ans>",0,{}
11,"<ans>
from math import sqrt

eps = 1e-9

def mysqrt(x):
    if x <= 0:
        return 0
    return sqrt(x)

def good(R):
    nonlocal xs
    nonlocal ys
    nonlocal n
    
    left = -10**20
    print(""left: "", str(left))
    right = 10**20
    print(""right: "", str(right))
    
    for i in range(n):
        # (x - xi)**2 + (y - yi)**2 = R**2
        # y = R
        xi = xs[i]
        yi = abs(ys[i])
        
        D = 2 * R * yi - yi**2
        print(""D: "", str(D))
        
        if D + eps < 0:
            return False
        
        sD = mysqrt(D)
        print(""sD: "", str(sD))
        
        new_left = xi - sD
        print(""new_left: "", str(new_left))
        new_right = xi + sD
        print(""new_right: "", str(new_right))
        
        left = max(left, new_left)
        print(""left: "", str(left))
        right = min(right, new_right)
        print(""right: "", str(right))
        
        if left + eps > right:
            return False
    
    return True
        

def solve(lower, high, md):
    R = 0
    for _ in range(150):
        R = md(lower, high)
        print(""R: "", str(R))
        
        if good(R):
            high = R
        else:
            lower = R
        
    return R

n = int(input())
print(""n: "", str(n))

xs = [0.0 for _ in range(n)]
print(""xs: "", str(xs))
ys = [0.0 for _ in range(n)]
print(""ys: "", str(ys))

for i in range(n):
    xs[i], ys[i] = list(map(float, input().split()))
    print(""xs[{}]: "".format(i), str(xs[i]), ""ys[{}]: "".format(i), str(ys[i]))
    if i > 0:
        if ys[i] * ys[0] < 0:
            print(-1)
            return

R = None
print(""R: "", str(R))
if good(1):
    R = solve(0, 1, lambda x, y: (x + y) / 2)
else:
    R = solve(1, 1e16, lambda x, y: sqrt(x * y))
    print(""R: "", str(R))

print('{:.16}'.format(R))
</ans>",0,{}
12,"<ans>
def bin_pow(num, degree , module):
    if degree == 0:
        return 1
    if degree == 1:
        return num % module

    if degree % 2 == 0:
        val = bin_pow(num, degree // 2, module)
        return (val * val) % module
    
    return (num * bin_pow(num , degree - 1, module)) % module



x, y = list(map(int,input().split()))
print(""x: "", str(x), ""y: "", str(y))

if y % x != 0:
    print(0)
    return

y //= x
print(""y: "", str(y))

divs = set()
print(""divs: "", str(divs))
to_gen = []
print(""to_gen: "", str(to_gen))

num = 2
print(""num: "", str(num))
val = y
print(""val: "", str(val))

while num * num <= val:
    degree = 0
    while y % num == 0:
        degree+=1
        y //= num
    if degree != 0:
        to_gen.append((num, degree))
        print(""to_gen: "", str(to_gen))

    if num == 2:
        num += 1
    else:
        num += 2

if y != 1:
    to_gen.append((y, 1))
    print(""to_gen: "", str(to_gen))

    
to_gen_len = len(to_gen)
print(""to_gen_len: "", str(to_gen_len))

def generate(ind):
    if ind == to_gen_len:
        yield 1
        return 
    gen_val = to_gen[ind][0]
    print(""gen_val: "", str(gen_val))
    
    for deg in range(1 + to_gen[ind][1]):
        for each in generate(ind  + 1):
            yield gen_val**deg * each

for each in generate(0):
    divs.add(each)

divs = list(divs)
print(""divs: "", str(divs))
divs.sort()
divs_answers = {}
print(""divs_answers: "", str(divs_answers))
mod = 10**9 + 7
print(""mod: "", str(mod))
ans = bin_pow(2, val - 1, mod)
print(""ans: "", str(ans))

for el in divs:
    if el == 1:
        divs_answers[el] = 1
        ans -= 1
    else:
        curr_val = bin_pow(2, el - 1 ,mod)
        print(""curr_val: "", str(curr_val))
        for other_el in divs:
            if other_el >= el:
                break
            if el % other_el !=0:
                continue
            
            curr_val -= divs_answers[other_el]

        divs_answers[el] = curr_val % mod
        print(""divs_answers: "", str(divs_answers))
        ans -= curr_val

print(divs_answers[val])
</ans>",0,{}
13,"<ans>
import bisect


class BTreeNode:
    def __init__(self):
        self.key = []
        self.child = []


class BTree:
    def __init__(self):
        self.root = BTreeNode()

    def search_higher(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_right(ptr.key, key)
            if i != len(ptr.key):
                ret = ptr.key[i]
            ptr = ptr.child[i]
        i = bisect.bisect_right(ptr.key, key)
        if i != len(ptr.key):
            ret = ptr.key[i]
        return ret

    def search_lower(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_left(ptr.key, key)
            if i != 0:
                ret = ptr.key[i - 1]
            ptr = ptr.child[i]
        i = bisect.bisect_left(ptr.key, key)
        if i != 0:
            ret = ptr.key[i - 1]
        return ret

    def insert(self, key):
        def insert_rec(ptr):
            b_size = 10
            print(""b_size: "", str(b_size))
            if not ptr.child:
                bisect.insort(ptr.key, key)
                if len(ptr.key) == b_size * 2 - 1:
                        ret = BTreeNode()
                        ret.key = ptr.key[:b_size]
                        print(""ret.key: "", str(ret.key))
                        ptr.key = ptr.key[b_size:]
                        return ret
            else:
                i = bisect.bisect(ptr.key, key)
                print(""i: "", str(i))
                temp = insert_rec(ptr.child[i])
                if temp is not None:
                    ptr.key.insert(i, temp.key.pop(-1))
                    ptr.child.insert(i, temp)
                    if len(ptr.child) == b_size * 2:
                        ret = BTreeNode()
                        ret.child = ptr.child[:b_size]
                        print(""ret.child: "", str(ret.child))
                        ptr.child = ptr.child[b_size:]
                        ret.key = ptr.key[:b_size]
                        print(""ret.key: "", str(ret.key))
                        ptr.key = ptr.key[b_size:]
                        return ret
            return None
        temp = insert_rec(self.root)
        if temp is not None:
            root = BTreeNode()
            root.key = [temp.key.pop(-1)]
            print(""root.key: "", str(root.key))
            root.child = [temp, self.root]
            self.root = root

    def dump(self):
        def dump_rec(ptr, dep):
            for _ in range(0, dep):
                print(""  "", end="""")
            print(ptr.key)
            for c in ptr.child:
                dump_rec(c, dep + 1)
        dump_rec(self.root, 0)
        print("""")


def main():
    n = int(input())
    print(""n: "", str(n))
    p = list(map(int, input().split()))
    print(""p: "", str(p))
    idx = [0] * n
    print(""idx: "", str(idx))
    for i in range(0, n):
        idx[i] = i
    idx.sort(key=lambda i: - p[i])
    print(""idx after sort: "", str(idx))
    t = BTree()
    print(""t: "", str(t))
    t.insert(-1)
    t.insert(n)
    ans = 0
    print(""ans: "", str(ans))
    for i in idx:
        nex = t.search_higher(i)
        print(""nex: "", str(nex))
        nexnex = t.search_higher(nex)
        print(""nexnex: "", str(nexnex))
        pre = t.search_lower(i)
        print(""pre: "", str(pre))
        prepre = t.search_lower(pre)
        print(""prepre: "", str(prepre))
        if prepre != None:
            ans += p[i] * (pre - prepre) * (nex - i)
        if nexnex != None:
            ans += p[i] * (i - pre) * (nexnex - nex)
        t.insert(i)
    print(ans)


main()

</ans>",0,{}
14,"<ans>
k = 72
print(""k: "", str(k))
K = 1<<k
print(""K: "", str(K))
nu = lambda L: int("""".join([bin(K+a)[-k:] for a in L[::-1]]), 2)
st = lambda n: bin(n)[2:] + ""0""
li = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]

def grow(d, v, h):
    h += [0] * d
    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]
    
    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):
        t = [1] * (2*d+2)
        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P
        ti = [1] * (2*d+2)
        ti[-1] = pow(t[-1], P-2, P)
        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P
        
        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]
        fg = li(st(nu(f) * nu(g)), d * 2 + 2)
            
        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
    return h

# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]
def create_table(v):
    s = 1
    X = [1, v+1]
    while s < v:
        X = grow(s, v, X)
        print(""X: "", str(X))
        s *= 2
    table = [1]
    for x in X:
        table.append(table[-1] * x % P)
    return table

def fact(i, table):
    a = table[i//v]
    print(""a: "", str(a))
    for j in range(i//v*v+1, i+1):
        a = a * j % P
        print(""a: "", str(a))
    return a

P = 10**9+7
print(""P: "", str(P))
v = 1 << 11
print(""v: "", str(v))
fa = [1] * (2*v+2)
fainv = [1] * (2*v+2)
for i in range(2*v+1):
    fa[i+1] = fa[i] * (i+1) % P
    print(""fa[{}]: "".format(i+1), str(fa[i+1]))
fainv[-1] = pow(fa[-1], P-2, P)
print(""fainv[-1]: "", str(fainv[-1]))
for i in range(2*v+1)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P
    print(""fainv[{}]: "".format(i), str(fainv[i]))

T = create_table(v)
print(""T: "", str(T))

f = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P
r1, c1, r2, c2 = list(map(int, input().split()))
print(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))
</ans>",0,{}
15,"<ans>
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        print(""self.parent: "", str(self.parent))
        self.size = [1] * n
        print(""self.size: "", str(self.size))
        self.num_sets = n
        print(""self.num_sets: "", str(self.num_sets))

    def find(self, a):
        to_update = []
        print(""to_update: "", str(to_update))

        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]

        for b in to_update:
            self.parent[b] = a

        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        print(""a: "", str(a))
        b = self.find(b)
        print(""b: "", str(b))

        if a == b:
            return

        if self.size[a] < self.size[b]:
            a, b = b, a

        self.num_sets -= 1
        print(""self.num_sets: "", str(self.num_sets))
        self.parent[b] = a
        self.size[a] += self.size[b]
        print(""self.parent: "", str(self.parent))
        print(""self.size: "", str(self.size))

    def set_size(self, a):
        return self.size[self.find(a)]


def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n, m = read_int_array()
    print(""n: "", str(n), ""m: "", str(m))
    uf = UnionFind(n)
    for _ in range(m):
        nums = read_int_array()
        print(""nums: "", str(nums))
        sz = nums[0]
        print(""sz: "", str(sz))
        leader = None
        print(""leader: "", str(leader))
        for i in range(sz):
            p = nums[1 + i] - 1
            print(""p: "", str(p))
            if leader is None:
                leader = p
                print(""leader: "", str(leader))
            else:
                uf.merge(p, leader)

    ans = [uf.set_size(i) for i in range(n)]
    print(""ans: "", str(ans))
    write(*ans)

main()
</ans>",0,{}
16,"<ans>
#!/usr/bin/env python3
# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015

import unittest
import sys

###############################################################################
# Sponge Class (Main Program)
###############################################################################


class Sponge:
    """""" Sponge representation """"""

    def __init__(self, test_inputs=None):
        """""" Default constructor """"""

        it = iter(test_inputs.split(""\n"")) if test_inputs else None
        print(""it: "", str(it))

        def uinput():
            return next(it) if it else sys.stdin.readline().rstrip()

        # Reading single elements
        [self.n, self.m] = list(map(int, uinput().split()))
        print(""self.n: "", str(self.n), ""self.m: "", str(self.m))

        # Reading a single line of multiple elements
        self.numf = list(map(int, uinput().split()))
        print(""self.numf: "", str(self.numf))

        # Reading a single line of multiple elements
        self.numb = list(map(int, uinput().split()))
        print(""self.numb: "", str(self.numb))

        self.fd = {}
        self.fdn = {}
        print(""self.fd: "", str(self.fd), ""self.fdn: "", str(self.fdn))
        for (i, n) in enumerate(self.numf):
            self.fd[n] = self.fd.setdefault(n, 0) + 1
            print(""self.fd[{}]: "".format(n), str(self.fd[n]))
            self.fdn[n] = i + 1
            print(""self.fdn[{}]: "".format(n), str(self.fdn[n]))

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        result = []
        print(""result: "", str(result))
        for n in self.numb:
            if n not in self.fd:
                return ""Impossible""
            result.append(self.fdn[n])
            print(""result after append: "", str(result))
        for n in self.numb:
            if self.fd[n] > 1:
                return ""Ambiguity""

        return ""Possible\n"" + "" "".join(map(str, result))

###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_single_test(self):
        """""" Sponge class testing """"""

        # Constructor test
        test = ""3 3\n3 2 1\n1 2 3""
        d = Sponge(test)
        self.assertEqual(d.n, 3)
        self.assertEqual(d.m, 3)
        self.assertEqual(d.numf, [3, 2, 1])
        self.assertEqual(d.numb, [1, 2, 3])

        # Sample test
        self.assertEqual(Sponge(test).calculate(), ""Possible\n3 2 1"")

        # Sample test
        test = ""3 3\n1 1 3\n1 2""
        self.assertEqual(Sponge(test).calculate(), ""Impossible"")

        # Sample test
        test = ""3 3\n1 1 1\n1 1 1""
        self.assertEqual(Sponge(test).calculate(), ""Ambiguity"")

        # My tests
        test = """"
        # self.assertEqual(Sponge(test).calculate(), ""0"")

        # Time limit test
        # self.time_limit_test(5000)

    def time_limit_test(self, nmax):
        """""" Timelimit testing """"""
        import random
        import timeit

        # Random inputs
        test = str(nmax) + "" "" + str(nmax) + ""\n""
        print(""test: "", str(test))
        numnums = [str(i) + "" "" + str(i+1) for i in range(nmax)]
        test += ""\n"".join(numnums) + ""\n""
        print(""test after adding numnums: "", str(test))
        nums = [random.randint(1, 10000) for i in range(nmax)]
        test += "" "".join(map(str, nums)) + ""\n""
        print(""test after adding nums: "", str(test))

        # Run the test
        start = timeit.default_timer()
        d = Sponge(test)
        calc = timeit.default_timer()
        d.calculate()
        stop = timeit.default_timer()
        print((""\nTimelimit Test: "" +
              ""{0:.3f}s (init {1:.3f}s calc {2:.3f}s)"".
              format(stop-start, calc-start, stop-calc)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(Sponge().calculate())

__starting_point()
</ans>",0,{}
17,"<ans>
n=input().split()
print(""n: "", str(n))
r=int(n[0])
print(""r: "", str(r))
k=int(n[1])
print(""k: "", str(k))
l=[]
print(""l: "", str(l))
for i in range(r):
    li=input()
    l.append(li)
print(""l: "", str(l))
rl=[]
print(""rl: "", str(rl))
for i in range(r):
    x=[]
    print(""x: "", str(x))
    for j in range(r):
        x.append(0)
    rl.append(x)
    print(""rl: "", str(rl))
for i in range(r):
    for j in range(len(l[i])):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[i][j+q:j+q+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[i][j+q]=rl[i][j+q]+1
                    print(""rl[{}][{}]: "".format(i, j+q), str(rl[i][j+q]))
            if flag==1:
                j=q+1
for i in range(r):
    for j in range(r):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[j+q][i:i+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[j+q][i]=rl[j+q][i]+1
                    print(""rl[{}][{}]: "".format(j+q, i), str(rl[j+q][i]))
            if flag==1:
                j=q+1
maxi=0
print(""maxi: "", str(maxi))
maxj=0
print(""maxj: "", str(maxj))
m=0
print(""m: "", str(m))
for i in range(r):
    for j in range(r):
        if rl[i][j]>m:
            m=rl[i][j]
            print(""m: "", str(m))
            maxi=i
            print(""maxi: "", str(maxi))
            maxj=j
            print(""maxj: "", str(maxj))
print(maxi+1,maxj+1)
</ans>",0,{}
18,"<ans>
"""""" ATSTNG's ejudge Python3 solution template """"""
import sys, queue

try:
    import dev_act_ffc429465ab634
    DEV = True
except:
    DEV = False

def log(*s):
    if DEV: print('L',list(s),sep='')

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        tmp = [[[5]*100000 for _ in range(1000)]]
        print(""tmp: "", str(tmp))
        while True: 
            tmp.append([[5]*100000 for _ in range(1000)])
            print(""tmp: "", str(tmp))

    def get_re(self):
        s = (0,)[8]
        print(""s: "", str(s))

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        return

class IntReader:
    def __init__(self):
        self.ost = queue.Queue()
        print(""ost: "", str(self.ost))

    def get(self):
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        return self.ost.get()

    def release(self):
        res = []
        while not self.ost.empty():
            res.append(self.ost.get())
        print(""res: "", str(res))
        return res

###############################################################################
ej = EJudge()
print(""ej: "", str(ej))
int_reader = IntReader()
print(""int_reader: "", str(int_reader))
fmap = lambda f,l: list(map(f,l))
parse_int = lambda: fmap(int, input().split())
sign = lambda x: (x>0)-(x<0)

# input
n,x = parse_int()
print(""n: "", str(n), ""x: "", str(x))
st = [0]*100500
print(""st: "", str(st))
xored = [0]*100500
print(""xored: "", str(xored))
for _ in range(n): 
    st[int_reader.get()] += 1
    print(""st: "", str(st))
for idx in range(100500):
    pair = idx^x
    if pair < 100500:
        xored[pair] = st[idx]
        print(""xored: "", str(xored))

ans = 0
for idx in range(100500):
    ans += st[idx]*xored[idx]
    print(""ans: "", str(ans))

if x == 0: ans -= n

print(ans//2)
</ans>",0,{}
19,"<ans>
import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

# Guide:
#   1. construct complex data types while reading (e.g. graph adj list)
#   2. avoid any non-necessary time/memory usage
#   3. avoid templates and write more from scratch
#   4. switch to ""flat"" implementations

def VI(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
def ELIST(n): return [[] for i in range(n)]
def MI(n=None,m=None): # input matrix of integers
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = VI()
    return arr
def MS(n=None,m=None): # input matrix of strings
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = input()
    return arr
def MIT(n=None,m=None): # input transposed matrix/array of integers
    if n is None: n,m = VI()
    a = MI(n,m)
    arr = LIST(m,n)
    for i,l in enumerate(a):
        for j,x in enumerate(l):
            arr[j][i] = x
    return arr


def run(n,a):
    for i in range(n+1):
        if a[0]==0:
            if sum([i==a[i] for i in range(n)])==n:
                print(""Yes"")
            else:
                print(""No"")
            return
        for j in range(n):
            if j%2==0:
                a[j] = (a[j]+1)%n
                print(""a[{}]: "".format(j), str(a[j]))
            else:
                a[j] = (a[j]-1)%n
                print(""a[{}]: "".format(j), str(a[j]))


def main(info=0):
    n = I()
    print(""n: "", str(n))
    a = VI()
    print(""a: "", str(a))

    run(n,a)



def __starting_point():
    main()

__starting_point()
</ans>",0,{}
20,"<ans>
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



def e_gcd(a, b ):
    if a==0 and b==0:
        return -1, 0, 0
    if b==0:
        return a, 1,0
    d, y,x = e_gcd(b, a%b )
    y-=  a //b *x
    return d , x,y

def m_reverse(a,n):
    d,x,y = e_gcd(a,n)
    dprint(x,y,a,n)
    assert x*a + y*n == d
    if d==1:
        if x%n<=0:
           return x%n+n
        else:
            return x%n
    else:
        return -1

inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit

    
base = 998244353
print(""base: "", str(base))
d = 1233
print(""d: "", str(d))
t = m_reverse( d, base)
print(""t: "", str(t))
z = t * d % base
print(""z: "", str(z))
N, M, K= getIntList()
print(""N: "", str(N), ""M: "", str(M), ""K: "", str(K))

J = N-1 - K   # same
print(""J: "", str(J))

Z = N - J
print(""Z: "", str(Z))
R = M
print(""R: "", str(R))
for i in range(Z-1):
    R *= M-1
    R%= base
    print(""R: "", str(R))
n0 = J
m0 = Z
print(""n0: "", str(n0), ""m0: "", str(m0))
#comb(n0 + m0 -1, m0-1)
for i in range(m0 -1):
    g = n0 + m0 -1  -i
    R*= g
    R%= base
    print(""R: "", str(R))

for i in range(2, m0):
    t = m_reverse(i,base)
    R*=t
    R%=base
    print(""R: "", str(R))

print(R)
</ans>",0,{}
21,"<ans>
import math
import bisect
import itertools
import sys
I=lambda : sys.stdin.readline()
mod=10**9 +7
'''fact=[1]*100001
ifact=[1]*100001
for i in range(1,100001):
    fact[i]=((fact[i-1])*i)%mod
    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod
def ncr(n,r):
    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod
def npr(n,r):
    return (((fact[n]*ifact[n-r])%mod))
    '''


def mindiff(a):
    b=a[:]
    b.sort()
    m=10000000000
    print(""b: "", str(b), ""m: "", str(m))
    for i in range(len(b)-1):
        if b[i+1]-b[i]<m:
            m=b[i+1]-b[i]
            print(""m: "", str(m))
    return m
    
def lcm(a,b):
    return a*b//math.gcd(a,b)

    
def merge(a,b):
    i=0;j=0
    c=0
    ans=[]
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c), ""ans: "", str(ans))
    while i<len(a) and j<len(b):
        if a[i]<b[j]:
            ans.append(a[i])
            i+=1
        else:
            ans.append(b[j])
            c+=len(a)-i
            j+=1
    ans+=a[i:]
    ans+=b[j:]
    return ans,c
def mergesort(a):
    if len(a)==1:
        return a,0
    mid=len(a)//2   
    left,left_inversion=mergesort(a[:mid])
    right,right_inversion=mergesort(a[mid:])
    m,c=merge(left,right)
    c+=(left_inversion+right_inversion)
    print(""m: "", str(m), ""c: "", str(c))
    return m,c
    
def is_prime(num):
    if num == 1: return False
    if num == 2: return True
    if num == 3: return True
    if num%2 == 0: return False
    if num%3 == 0: return False
    t = 5
    a = 2
    while t <= int(math.sqrt(num)):
        if num%t == 0: return False
        t += a
        a = 6 - a
    return True
    
  
def ceil(a,b):
    if a%b==0:
        return a//b
    else:
        return (a//b + 1)

def binsearch(arr,b,low,high):
    if low==high:
        return low
    if arr[math.ceil((low+high)/2)]<b:
        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )
    else:
        return binsearch(arr,b,math.ceil((low+high)/2),high)
def ncr1(n,r):
    s=1
    print(""s: "", str(s))
    for i in range(min(n-r,r)):
        s*=(n-i)
        s%=mod
        s*=pow(i+1,mod-2,mod)
        s%=mod
        print(""s: "", str(s))
    return s
    
def calc(n,m,r):
    s=0
    print(""s: "", str(s))
    for i in range(0,r+1,2):
        s+=ncr1(n,i)*ncr1(m,i)
        s%=mod
        print(""s: "", str(s))
    return s    
    
def modu(a,n):
    if a%n==0:
        return n
    return a%n

#/////////////////////////////////////////////////////////////////////////////////////////////////

for i in range(1):
    n,k=map(int,input().split())
    print(""n: "", str(n), ""k: "", str(k))
    a=list(map(int,input().split()))
    print(""a: "", str(a))
    s=input()
    c=1;b=[]
    for i in range(1,n):
        if s[i-1]==s[i]:
            c+=1
            f=True
        else:
            b.append(c)
            c=1
            f=False
    if True:
        b.append(c)
    print(""b: "", str(b)) 
    ans=0
    su=0
    print(""ans: "", str(ans), ""su: "", str(su))
    for i in b:
        c=a[su:min(su+i,10**9)]
        
        #print(c)
        
        
        c.sort(reverse=True)
        c=c[:min(i,k)]
        su+=i
        ans+=sum(c)
        
    print(ans)
</ans>",0,{}
22,"<ans>
def solve(printing):

    n = int(input())
    print(""n: "", str(n))
    nums = [int(st)-1 for st in input().split("" "")]
    print(""nums: "", str(nums))
    numdupe = [0] * n
    print(""numdupe: "", str(numdupe))
    dupeindex = []
    print(""dupeindex: "", str(dupeindex))
    dupeindexindv = {}
    print(""dupeindexindv: "", str(dupeindexindv))
    missing = []
    print(""missing: "", str(missing))

    if printing:
        print(""nums""); print(nums)

    for i in range(n):
        numdupe[nums[i]] += 1

    for i in range(n):
        if numdupe[i] == 0:
            missing.append(i)
            print(""missing: "", str(missing))
            
        if numdupe[nums[i]] >= 2:
            dupeindex.append(i)
            print(""dupeindex: "", str(dupeindex))
            if nums[i] in dupeindexindv:
                dupeindexindv[nums[i]][1].append(i)
            else:
                dupeindexindv[nums[i]] = [0, [i], False]
                print(""dupeindexindv: "", str(dupeindexindv))

    for num in dupeindexindv:
        dupeindexindv[num][0] = len(dupeindexindv[num][1])
        print(""dupeindexindv: "", str(dupeindexindv))

    if printing:
        print(""missing""); print(missing)
        print(""dupeindexindv""); print(dupeindexindv)

    misslen = len(missing)
    print(""misslen: "", str(misslen))
    misindex = 0
    print(""misindex: "", str(misindex))
    #answer = 0
    for index in dupeindex:

        if misslen <= misindex:
            break

        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:
            # one spot left but original not located yet.
            # locate original.
            dupeindexindv[nums[index]][0] -= 1
            dupeindexindv[nums[index]][2] = True
        
        elif dupeindexindv[nums[index]][0] > 0:
            
            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:
                # num is smaller or original is already located.
                # locate missing number.
                dupeindexindv[nums[index]][0] -= 1
                nums[index] = missing[misindex]
                print(""nums: "", str(nums))
                misindex += 1
                #answer += 1

            else: # locate original
                dupeindexindv[nums[index]][0] -= 1
                dupeindexindv[nums[index]][2] = True

    print(misslen)
    for num in nums:
        print(num+1, end = "" "")

solve(False)
</ans>",1,{}
23,"<ans>
from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
 #------------------Sublime--------------------------------------#
 sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
 def I():return (int(input()))
 def In():return(map(int,input().split()))
else:
 #------------------PYPY FAst I/o--------------------------------#
 def I():return (int(stdin.readline()))
 def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
 d={} 
 for x in a:
  if d.get(x,-1)!=-1:
   d[x]+=1
  else:
   d[x]=1
 return d
def find_gt(a, x):
 'Find leftmost value greater than x'
 i = bi.bisect_right(a, x)
 if i != len(a):
  return i
 else:            
  return -1

def find_ge(a, x):
 'Find leftmost item greater than or equal to x'
 i = bi.bisect_left(a, x)
 if i != len(a):
  return i
 else:
  return -1
def main():
 try:
  n,Q=In()
  print(""n: "", str(n), ""Q: "", str(Q))
  l=list(In())
  print(""l: "", str(l))
  l.sort()
  pre=[0]
  print(""pre: "", str(pre))
  su=0
  print(""su: "", str(su))
  for x in range(n):
   su+=l[x]
   print(""su: "", str(su))
   pre.append(su)
  #print(pre)
  for x in range(Q):
   q=I()
   print(""q: "", str(q))
   q*=2
   print(""q: "", str(q))
   pos=find_ge(l,q)
   #print(pos)
   if pos==-1:
    print(0)
   else:
    #print(pos)
    ans=pre[-1]-pre[pos]
    print(""ans: "", str(ans))
    print(ans)
 except:
  pass
  
M = 998244353
P = 1000000007
 print(""M: "", str(M), ""P: "", str(P))
def __starting_point():
 #for _ in range(I()):main()
 for _ in range(1):main()
__starting_point()
</ans>",0,{}
24,"<ans>
import sys

def gcd(l):
	if len(l)==0:
		return 0
	if len(l)==1:
		return l[0]
	if len(l)==2:                                   
		if l[1]==0:
			return l[0]  
		return gcd([l[1],l[0]%l[1]])
	return gcd([gcd(l[:-1]),l[-1]])
		
def brute_force(l1,l2,l,sol):                   
	if len(l)==0:
		g1=gcd(l1)
		g2=gcd(l2)
		print(""g1: "", str(g1), ""g2: "", str(g2))
		return g1==1 and g2==1,sol
	
	res,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])
	print(""res: "", str(res), ""s: "", str(s))
	if res:
		return True,s
	return brute_force(l1,l2+[l[0]],l[1:],sol+[2])

def factor(n):
	res=[]
	i=2
	while i*i<=n:
		if n%i==0:
			res.append(i)
		while n%i==0:
			n=int(n/i)
		i+=1

	if n!=1:
		res.append(n)

	return res

def dumpsol(sol):
	for v in sol:
		print(v,end=' ')

n=int(sys.stdin.readline())
l=sys.stdin.readline().strip().split("" "")[0:n]
l=[int(x) for x in l]
print(""n: "", str(n), ""l: "", str(l))
if n<12:
	ret,sol=brute_force([],[],l,[])
	print(""ret: "", str(ret), ""sol: "", str(sol))
	if ret:
		print(""YES"")
		dumpsol(sol)
	else:
		print(""NO"")
	return

factors={}
for i in range(10):
	for key in factor(l[i]):
		factors[key]=0
	print(""factors: "", str(factors))

flists={}
for f in factors:
	flists[f]=[]
	pos=0
	found=False
	for v in l:
		if v%f!=0:
			found=True
			factors[f]+=1
			flists[f].append(pos)
			if (factors[f]>9):
				break
		pos+=1
	print(""flists: "", str(flists), ""factors: "", str(factors))
	if not found:
		print(""NO"")
		return

oftf=[]
isoftf={}
for f in factors:
	if factors[f]==0:
		print(""NO"")
		return

	if factors[f]<10:
		oftf.append(f)
		isoftf[f]=1
	print(""oftf: "", str(oftf), ""isoftf: "", str(isoftf))

sol=[1 for i in range(len(l))]
print(""sol: "", str(sol))
x=l[0]
sol[0]=2
print(""x: "", str(x), ""sol[0]: "", str(sol[0]))
oxf=factor(x)
print(""oxf: "", str(oxf))
xf=[]
nxf=0
isxoftf={}
for f in oxf:
	if f in isoftf:
		nxf+=1
		isxoftf[f]=1
		xf.append(f)
	else:
		sol[flists[f][0]]=2
		print(""sol[flists[f][0]]: "", str(sol[flists[f][0]]))

nonxf=[]
for f in oftf:
	if not f in isxoftf:
		nonxf.append(f)
print(""nonxf: "", str(nonxf))

masks={}
pos=0

for f in xf+nonxf:
	for v in flists[f]:
		if not v in masks:	
			masks[v]=0
		masks[v]|=1<<pos
		print(""masks[v]: "", str(masks[v]))
	pos+=1

vals=[{} for i in range(len(masks)+1)]
vals[0][0]=0
print(""vals: "", str(vals))
pos=0
mlist=[]
for mask in masks:
	mlist.append(mask)
	cmask=masks[mask]
	cmask1=cmask<<10
	for v in vals[pos]:
		vals[pos+1][v|cmask]=v
		# first number is always in group2
		if (mask!=0):
			vals[pos+1][v|cmask1]=v
	pos+=1	

test_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
print(""test_val: "", str(test_val))
for v in vals[pos]:
	if (v&test_val)==test_val:
		print(""YES"")

		while (pos!=0):
			nv=vals[pos][v]
			if (nv^v<1024 and nv^v!=0):
				sol[mlist[pos-1]]=2
			v=nv
			pos-=1

		dumpsol(sol)
		return

print(""NO"")
</ans>",0,{}
25,"<ans>
a, b, f, k = [int(i) for i in input().split()]
print(""a: "", str(a), ""b: "", str(b), ""f: "", str(f), ""k: "", str(k))

if b < f:
    print(-1)
    return

journeys = 0
print(""journeys: "", str(journeys))
previous = 0
print(""previous: "", str(previous))
refuels1 = 0
print(""refuels1: "", str(refuels1))
tank = b-f
print(""tank: "", str(tank))

while(journeys != k): ## necessary? while(True) ?
    if previous == 0:
        if tank >= a-f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= a-f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*(a-f):
            tank -= 2*(a-f)
        elif b >= 2*(a-f):
            refuels1 += 1
            tank = b - 2*(a-f)
            print(""refuels1: "", str(refuels1))
        else:
            print(-1)
            return
        
        journeys += 1
        print(""journeys: "", str(journeys))
        previous = a
        print(""previous: "", str(previous))
        
    if previous == a:
        if tank >= f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*f:
            tank -= 2*f
        elif b >= 2*f:
            refuels1 += 1
            tank = b-2*f
            print(""refuels1: "", str(refuels1))
        else:
            print(-1)
            return
        
        journeys += 1
        print(""journeys: "", str(journeys))
        previous = 0
        print(""previous: "", str(previous))

if journeys == k:
    print(refuels1)
else:
    print(-1)
</ans>",0,{}
26,"<ans>
import heapq
n,m,k = list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
connectionList = []
for _ in range(n):
    connectionList.append([])
edgeList = []
for _ in range(m):
    x,y,w = list(map(int,input().split()))
    edgeList.append((x,y,w))
edgeList.sort(key = lambda x: x[2])
if k < m:
    maxDist = edgeList[min(m,k) - 1][2]
    print(""maxDist: "", str(maxDist))
else:
    maxDist = sum([x[2] for x in edgeList])
    print(""maxDist: "", str(maxDist))
colorList = {}
colorVertex = []
for i in range(n):
    colorList[i] = [i]
    colorVertex.append(i)

for i in range(min(m,k)):
    x,y,w = edgeList[i]
    connectionList[x-1].append((y-1,w))
    connectionList[y-1].append((x-1,w))
    if colorVertex[x-1] != colorVertex[y-1]:
        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):
            prevColor = colorVertex[y-1]
            for elem in colorList[colorVertex[y-1]]:
                colorVertex[elem] = colorVertex[x-1]
                colorList[colorVertex[x-1]].append(elem)
            del colorList[prevColor]
        else:
            prevColor = colorVertex[x-1]
            for elem in colorList[colorVertex[x-1]]:
                colorVertex[elem] = colorVertex[y-1]
                colorList[colorVertex[y-1]].append(elem)
            del colorList[prevColor]

pathList = []
for key in colorList:
    vertexList = colorList[key]
    for mainVertex in vertexList:
        vertexPQueue = []
        isCovered = {}
        distanceDic = {}
        for elem in vertexList:
            isCovered[elem] = False
            distanceDic[elem] = maxDist
        isCovered[mainVertex] = True
        for elem in connectionList[mainVertex]:
            heapq.heappush(vertexPQueue,(elem[1],elem[0]))
            distanceDic[elem[0]] = elem[1]
        while vertexPQueue:
            distance, curVertex = heapq.heappop(vertexPQueue)
            if isCovered[curVertex]:
                continue
            elif distance >= maxDist:
                break
            for elem in connectionList[curVertex]:
                if distance + elem[1] < distanceDic[elem[0]]:
                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))
                    distanceDic[elem[0]] = distance + elem[1]
        for key in distanceDic:
            if distanceDic[key] <= maxDist and key > mainVertex:
                pathList.append(distanceDic[key])
        if len(pathList) > k:
            pathList.sort()
            pathList = pathList[0:k]
            if pathList[-1] < maxDist:
                maxDist = pathList[-1]
                print(""maxDist: "", str(maxDist))
pathList.sort()
print(pathList[k-1])
</ans>",0,{}
27,"<ans>
class Ddict:
    def __init__(self):
        self.dicts={}
    def add(self,key):
        d=self.dicts
        for i in key:
            if i not in d:
                d[i]={}
            d=d[i]
        d[' ']=''
    def find(self,key):
        if key=='':
            return '',''
        d=self.dicts
        q=[]
        h=[key[0]]
        for i in key:
            if i not in d:
                if ' ' in d and len(d)==1:
                    return ''.join(q),''.join(h)
                return '',''
            q.append(i)
            if len(d)!=1:
                h=q[:]
            d=d[i]
        if ' ' in d and len(d)==1:
            return ''.join(q),''.join(h)
        return '',''
words = Ddict()
print(""words: "", str(words))
ans=0
print(""ans: "", str(ans))
while True:
    try:
        x=input()
        if not x:
            break
    except:
        break
    ans+=len(x)+1
    print(""ans: "", str(ans))
    ws=[[]]
    print(""ws: "", str(ws))
    for i in x:
        if i in '.,?!\'- ':
            if ws[-1]:
                ws.append([])
        else:
            ws[-1].append(i)
    ws=list([''.join(e) for e in ws])
    print(""ws: "", str(ws))
    for w in ws:
        next_word,helped_word = words.find(w)
        print(""next_word: "", str(next_word), ""helped_word: "", str(helped_word))
        if next_word and next_word!=helped_word:
            ans-=len(next_word)-len(helped_word)-1
            print(""ans: "", str(ans))
        words.add(w)
        print(""words: "", str(words))
print(ans)
</ans>",0,{}
28,"<ans>
from statistics import median
import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
print(""mod: "", str(mod))
# mod = 9982443453
# mod = 998244353
INF = float('inf')
print(""INF: "", str(INF))
from sys import stdin
readline = stdin.readline
print(""readline: "", str(readline))
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
    return int(readline())
n = I()
print(""n: "", str(n))
ans = 0
print(""ans: "", str(ans))
def dfs(v):
    if len(v) != 0:
        if int(v) > n:
            return
    if v.count('3') and v.count('5') and v.count('7'):
        nonlocal ans
        ans += 1
    for s in ""357"":
        v += s
        dfs(v)
        v = v[:-1]
dfs("""")
print(ans)
</ans>",0,{}
29,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
from itertools import accumulate

#T = int(input())
s = input()
#N,M,K,Q = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

def computeGCD(x, y):

   while(y):
       x, y = y, x % y

   return x

record = {}
print(""record: "", str(record))

for x in range(10):
    for y in range(10):
        for d in range(10):
            m = 9999
            print(""m: "", str(m))
            if (x==0 or y==0) and d==0:
                record[(x,y,d)] = 0
                print(""record[({}, {}, {}): "".format(x, y, d), str(record[(x,y,d)]))
            elif x==0 and y==0 and d!=0:
                record[(x,y,d)] = -1
                print(""record[({}, {}, {}): "".format(x, y, d), str(record[(x,y,d)]))
            else:
                for k in range(10):
                    d_tmp = d + 10*k
                    print(""d_tmp: "", str(d_tmp))
                    if x==0:
                        if d_tmp%y==0:
                            record[(x,y,d)] = d_tmp//y - 1
                            print(""record[({}, {}, {}): "".format(x, y, d), str(record[(x,y,d)]))
                            break

                    elif y==0:
                        if d_tmp%x==0:
                            record[(x,y,d)] = d_tmp//x - 1
                            print(""record[({}, {}, {}): "".format(x, y, d), str(record[(x,y,d)]))
                            break

                    else:
                        for a in range((d_tmp//x)+1):
                            for b in range((d_tmp//y)+1):
                                if x*a+y*b==d_tmp and d_tmp!=0:
                                    m = min(m,a+b-1)
                                    print(""m: "", str(m))

                if (x,y,d) not in record:
                    if m==9999:
                        m = -1
                    record[(x,y,d)] = m
                    print(""record[({}, {}, {}): "".format(x, y, d), str(record[(x,y,d)]))
            #print(x,y,d,record[(x,y,d)])

data = [[0]*10 for _ in range(10)]
print(""data: "", str(data))

len_s = len(s)
s = list(s)
print(""s: "", str(s))
freq = [0]*10
print(""freq: "", str(freq))
for i in range(len_s-1):
    A = s[i]
    B = s[i+1]

    d = ord(B)-ord(A)
    if d<0:
        d += 10

    freq[d] += 1
    print(""freq: "", str(freq))

for x in range(10):
    for y in range(10):
        for d in range(10):
            if freq[d]==0:
                data[x][y] += 0
            elif record[(x,y,d)]==-1:
                data[x][y] = -10000000
            else:
                data[x][y] += freq[d]*record[(x,y,d)]
                print(""data[{}, {}]: "".format(x, y), str(data[x][y]))

for x in range(10):
    for y in range(10):
        if data[x][y]<0:
            print(-1,end=' ')
        else:
            print(data[x][y],end=' ')
    print('',end='\n')
</ans>",0,{}
30,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import math

#T = int(input())
#N = int(input())
#print(N)
N,r = [int(x) for x in stdin.readline().split()]
print(""N: "", str(N), ""r: "", str(r))
#arr = [int(x) for x in stdin.readline().split()]

visited = [0]*N
print(""visited: "", str(visited))

a = [0]*N
print(""a: "", str(a))
b = [0]*N
print(""b: "", str(b))

pos = 0
print(""pos: "", str(pos))

for i in range(N):
    arr = [int(x) for x in stdin.readline().split()]
    a[i] = arr[0]
    print(""a[{}]: "".format(i), str(a[i]))
    b[i] = arr[1]
    print(""b[{}]: "".format(i), str(b[i]))
    
    if b[i]>=0:
        pos += 1
        print(""pos: "", str(pos))

for i in range(pos):
    idx = -1
    start = 0
    gain = -50000
    print(""idx: "", str(idx), ""start: "", str(start), ""gain: "", str(gain))
    for j in range(N):
        # find available and largest gain
        # if gain tie, find largest start r
        if visited[j]==1 or b[j]<0:
            continue
            
        if b[j]>gain and r>=a[j]:
            gain = b[j]
            idx = j
            start = a[j]
            print(""gain: "", str(gain), ""idx: "", str(idx), ""start: "", str(start))
        elif b[j]==gain and r>=a[j]:
            if a[j]>start:
                idx = j
                start = a[j]
                print(""gain tie, new idx: "", str(idx), ""new start: "", str(start))
                
    if idx==-1:
        print('NO')
        quit()
    else:
        visited[idx] = 1
        print(""visited[{}]: "".format(idx), str(visited[idx]))
        r += b[idx]
        print(""r: "", str(r))
        #print(idx,r)
        
        
tmp = []
for i in range(N):
    if visited[i]==1 or b[i]>=0:
        continue
    tmp.append((a[i],b[i],i))
    
tmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)

for i in range(len(tmp)):
    require = tmp[i][0]
    bias = tmp[i][1]
    print(""require: "", str(require), ""bias: "", str(bias))
    
    if r>=require:
        r += bias
        print(""r: "", str(r))
    else:
        print('NO')
        quit()
        

if r<0:
    print('NO')
    quit()
        
print('YES')
</ans>",0,{}
31,"<ans>
from math import*
from random import*

n = int(input()) * 2
print(""n: "", str(n))
A = list(map(int, input().split()))
print(""A: "", str(A))
amount = [0] * 101
print(""amount: "", str(amount))

B = []
print(""B: "", str(B))
for i in range(n):
    if amount[A[i]] < 2:
        amount[A[i]] += 1
        print(""amount[A[i]]: "", str(amount[A[i]]))
        B += [(A[i], i)]
        print(""B: "", str(B))
B.sort()
x, y = [], []
print(""x: "", str(x))
print(""y: "", str(y))
for i in range(len(B)):
    if(i % 2 == 0):
        x.append(B[i][1])
        print(""x: "", str(x))
    else:
        y.append(B[i][1])
        print(""y: "", str(y))
lolka = 0
print(""lolka: "", str(lolka))
aaa = 0
print(""aaa: "", str(aaa))
# print(x)
# print(y)
print(len(x) * len(y))
for i in range(n):
    if i in x:
        lolka += 1
        print(""lolka: "", str(lolka))
        aaa += 1
        print(""aaa: "", str(aaa))
        print(1, end = ' ')
    elif i in y:
        print(2, end = ' ')
    else:
        if len(x) - lolka + aaa < n // 2:
            print(1, end = ' ')
            aaa += 1
            print(""aaa: "", str(aaa))
        else:
            print(2, end = ' ')
print()

# B, C = [], []
# for i in range(n):


# S = list(set(A))
# where = [0] * 101
# am1, am2 = 0, 0
# for i in range(len(S)):
#     if(i % 2 == 0):
#         where[S[i]] = 1
#         am1 += 1
#     else:
#         where[S[i]] = 2
#         am2 += 1
# used = [0] * 201
# for i in range(n):
#     if not used[A[i]]:
#         print(where[A[i]])
#         used[A[i]] = True
#     else:
#         print(3 - where[A[i]])
</ans>",1,{}
32,"<ans>
def check(mid):
    ans = []
    print(""ans: "", str(ans))
    res = 0
    print(""res: "", str(res))
    for c, count in d:
        tmp = count // mid
        print(""tmp: "", str(tmp))
        if (count % mid != 0):
            tmp += 1
            print(""tmp: "", str(tmp))
        ans.append((c, tmp))
        res += tmp
        print(""ans: "", str(ans), ""res: "", str(res))
    return res <= n, ans
        

a = input()
n = int(input())
d = dict()
print(""d: "", str(d))
t = 0
print(""t: "", str(t))
for i in a:
    if i not in d:
        d[i] = 1
        print(""d: "", str(d))
        t += 1
        print(""t: "", str(t))
    else: 
        d[i] += 1
        print(""d: "", str(d))
ans = []
print(""ans: "", str(ans))
res = """"
print(""res: "", str(res))
for i in d:
    ans.append(i)
    print(""ans: "", str(ans))
    res = i
    print(""res: "", str(res))
if n >= len(a):
    print(1)
    print(a, end = '')
    n -= len(a)
    for u in range(n):
        print(res, end ='')
else:
    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))
    print(""d: "", str(d))
    l = 1
    print(""l: "", str(l))
    r = len(a)
    print(""r: "", str(r))
    res = []
    print(""res: "", str(res))
    count_res = 0
    print(""count_res: "", str(count_res))
    while (l <= r):
        mid = (l + r) // 2
        print(""mid: "", str(mid))
        flag, tmp = check(mid)
        if (flag):
            r = mid - 1
            count_res = mid
            res = tmp
            print(""count_res: "", str(count_res), ""res: "", str(res))
        else:
            l = mid + 1
        #print(l, r, tmp)
    if (len(res) == 0):
        print(-1)
    else:
        ttt = 0
        print(""ttt: "", str(ttt))
        print(count_res)
        for c, sl in res:
            for j in range(sl):
                print(c, end = '')
                ttt += 1
                print(""ttt: "", str(ttt))
        n -= ttt
        print(""n: "", str(n))
        for i in range(n):
            print(a[0], end ='')
</ans>",0,{}
33,"<ans>
""""""
Codeforces Contest Good Bye 2014 Contest Problem B

Author  : chaotic_iak
Language: Python 3.4.2
""""""

################################################### SOLUTION

def main():
    n, = read()
    print(""n: "", str(n))
    p = read()
    print(""p: "", str(p))
    dsu = DSU()
    print(""dsu: "", str(dsu))
    for i in range(n):
        a = read(0)
        print(""a: "", str(a))
        dsu.make()
        for j in range(i):
            if a[j] == ""1"":
                dsu.union(j, i)
    used = [0] * n
    print(""used: "", str(used))
    res = [0] * n
    print(""res: "", str(res))
    for i in range(n):
        if not used[i]:
            pr = dsu.find(i)
            print(""pr: "", str(pr))
            indices = []
            elements = []
            for j in range(n):
                if dsu.find(j) == pr:
                    used[j] = 1
                    indices.append(j)
                    elements.append(p[j])
            elements.sort()
            for i,e in zip(indices, elements):
                res[i] = e
    write(res)

#################################################### HELPERS

class DSU(object):
    """"""
    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.

    Methods:
    make(): add a new element and returns its index
    find(x): return representative of x
    union(x, y): merge the sets containing x and y

    Not to be used publicly:
    _parent: a list of ints for the parent of each vertex, used internally; call find instead
    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case
    __init__(): called when initialization, initialize DSU to be empty
    __str__(): return a readable string description of the DSU; meant to be printed while debugging
    """"""

    def __init__(self):
        self._parent = []
        print(""_parent: "", str(self._parent))
        self._rank = []
        print(""_rank: "", str(self._rank))

    def make(self):
        i = len(self._parent)
        print(""i: "", str(i))
        self._parent.append(i)
        print(""_parent: "", str(self._parent))
        self._rank.append(0)
        print(""_rank: "", str(self._rank))
        return i

    def find(self, x):
        if self._parent[x] != x:
            self._parent[x] = self.find(self._parent[x])
        return self._parent[x]

    def union(self, x, y):
        xr = self.find(x)
        print(""xr: "", str(xr))
        yr = self.find(y)
        print(""yr: "", str(yr))
        if xr == yr: return
        if self._rank[xr] < self._rank[yr]:
            self._parent[xr] = yr
        elif self._rank[yr] < self._rank[xr]:
            self._parent[yr] = xr
        else:
            self._parent[yr] = xr
            self._rank[xr] += 1
        print(""_parent: "", str(self._parent))
        print(""_rank: "", str(self._rank))

    def __str__(self):
        s = ""DSU\n""
        for i in range(len(self._parent)):
            s += str(i) + "" in set "" + str(self.find(i)) + "" with rank "" + str(self._rank[self.find(i)]) + ""\n""
        return s

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return list(map(int, inputs.split()))

def write(s=""\n""):
    if s is None: s = """"
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

write(main())
</ans>",0,{}
34,"<ans>
from math import log2, floor

def is_power2(num):
    return num != 0 and ((num & (num - 1)) == 0)


def next_two_pow(val):
    pw=0
    while 2**pw <= val:
        pw=+1
    print(""pw: "", str(pw))
    return pw        

n = int(input())
print(""n: "", str(n))
arr=[int(x) for x in input().split()]
print(""arr: "", str(arr))


win_idx =-1
print(""win_idx: "", str(win_idx))
selected=[] 
print(""selected: "", str(selected))

for i in range(1,n+1):
    val = arr[i-1]
    print(""val: "", str(val))
    if win_idx ==-1:
       if  val == -1: 
           win_idx =i
           print(""win_idx: "", str(win_idx))
    else:
         if is_power2(i):
             selected.append(val)
             selected.sort()
             print(""selected: "", str(selected))
         else:
             if len(selected) > 0 and val < selected[-1]:
                 selected.pop()
                 print(""selected after pop: "", str(selected))
                 selected.append(val)
                 selected.sort()
                 print(""selected after append: "", str(selected))

print(sum(selected))
</ans>",0,{}
35,"<ans>
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__


def go():
    n = int(input())
    print(""n: "", str(n))
    # n, h, l, r = map(int, input().split())
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    e = {i: set() for i in range(n)}
    print(""e: "", str(e))
    for _ in range(n - 1):
        u, v = list(map(int, input().split()))
        print(""u: "", str(u), ""v: "", str(v))
        u, v = u - 1, v - 1
        print(""u: "", str(u), ""v: "", str(v))
        e[u].add(v)
        e[v].add(u)
    ranks = [len(e[i]) for i in range(n)]
    print(""ranks: "", str(ranks))
    leafs = [i for i in range(n) if ranks[i] == 1]
    print(""leafs: "", str(leafs))
    index = 0
    vs = {i: {} for i in range(n)}
    print(""vs: "", str(vs))
    done = set()
    while index < len(leafs):
        cur = leafs[index]
        print(""cur: "", str(cur))
        mysum = sum(vs[cur].values())
        print(""mysum: "", str(mysum))

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        for i in e[cur] - done:
            vs[i][cur] = max(mysum, 0)
            print(""vs[{}][{}]: "".format(i, cur), str(vs[i][cur]))
            ranks[i] -= 1
            if ranks[i] == 1:
                leafs.append(i)
        done.add(cur)
        index += 1

    sums = [0] * n
    print(""sums: "", str(sums))
    que = [ranks.index(0)]
    print(""que: "", str(que))
    done = set()
    index = 0
    while index < len(que):
        cur = que[index]
        print(""cur: "", str(cur))

        mysum = sum(vs[cur].values())
        print(""mysum: "", str(mysum))

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        sums[cur] = mysum
        print(""sums[{}]: "".format(cur), str(sums[cur]))

        for i in e[cur] - done:
            vs[i][cur] = max(mysum - vs[cur][i], 0)
            print(""vs[{}][{}]: "".format(i, cur), str(vs[i][cur]))
            que.append(i)

        done.add(cur)
        index += 1

    return ' '.join(map(str,sums))


# t = int(input())
for _ in range(1):
    print(go())
</ans>",0,{}
36,"<ans>
from statistics import median
import collections
from math import gcd
from itertools import combinations,permutations,accumulate, product
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
print(""mod: "", str(mod))
INF = float('inf')
print(""INF: "", str(INF))
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
    return int(readline())
n = I()
print(""n: "", str(n))
A = readInts()
print(""A: "", str(A))
B = readInts()
print(""B: "", str(B))
ans = 0
print(""ans: "", str(ans))
for i in range(n):
    v = B[i]
    print(""v: "", str(v))
    nya = min(v, A[i])
    print(""nya: "", str(nya))
    A[i] -= nya
    print(""A[i]: "", str(A[i]))
    v -= nya
    print(""v: "", str(v))
    ans += nya
    print(""ans: "", str(ans))
    nya = min(A[i+1], v)
    print(""nya: "", str(nya))
    ans += nya
    print(""ans: "", str(ans))
    A[i+1] -= nya
    print(""A[i+1]: "", str(A[i+1]))
print(ans)
</ans>",0,{}
37,"<ans>
def solve(s,t):
    hash_s = [False] * 256
    print(""hash_s: "", str(hash_s))
    hash_t = [False] * 256
    print(""hash_t: "", str(hash_t))
    arr = []
    print(""arr: "", str(arr))
    n = len(s)
    print(""n: "", str(n))
    for c in s:
        hash_s[ord(c)] = True
    for c in t:
        hash_t[ord(c)] = True
    for i in range(256):
        if not hash_s[i] and hash_t[i]:
            print(-1)
            return
    rev = s[::-1]
    print(""rev: "", str(rev))
    i,j = 0,0
    print(""i: "", str(i), ""j: "", str(j))
    while i < len(t):
        flag = True
        temp = t[i]
        print(""temp: "", str(temp))
        j = i + 1
        while j < len(t):
            temp += t[j]
            print(""temp: "", str(temp))
            if temp not in s and temp not in rev:
                flag = False
                break
            j += 1
        if flag:
            x = s.find(temp)
            print(""x: "", str(x))
            if x != -1:
                arr.append((x + 1,x + len(temp)))
                # print('1',x + 1,x + len(temp))
            else:
                y = rev.find(temp)
                print(""y: "", str(y))
                arr.append((n - y,n - y - len(temp) + 1))
                # print('2',n - y,n - y - len(temp) + 1)
        else:
            x = s.find(temp[:-1])
            print(""x: "", str(x))
            if x != -1:
                arr.append((x + 1,x + len(temp) - 1))
                # print('3',x + 1,x + len(temp) - 1)
            else:
                x = rev.find(temp[:-1])
                print(""x: "", str(x))
                arr.append((n - x,n - x - len(temp) + 2))
                # print('4',n - x,n - x - len(temp) + 2)
        i = j
    print(len(arr))
    for x,y in arr:
        print(x,y)

s = input()
t = input()

solve(s,t)
</ans>",0,{}
38,"<ans>
from itertools import chain
import sys

def main():
    N = int(input())
    print(""N: "", str(N))
    # TLEs were caused mostly by slow input (1s+)
    # S = list(input() for _ in range(N))
    S = sys.stdin.read().split('\n')
    print(""S: "", str(S))
    print((solve(S)))

def get_count(args):
    s, result = args # messy input to work with map.
    cum_sum = 0
    for c in s:
        if c == ')':
            cum_sum -= 1
        else:
            cum_sum += 1
        result[0] = max(result[0], -cum_sum)
    result[1] = result[0] + cum_sum
    print(""result: "", str(result))
    return result

# Made-up name, don't remember what to call this. Radix-ish
def silly_sort(array, value_min, value_max, get_value):
    if len(array) == 0:
        return
    cache = [None for _ in range(value_max - value_min + 1)]
    print(""cache: "", str(cache))
    for elem in array:
        # Assume elem[0] is the value
        value = get_value(elem) - value_min
        if cache[value] is None:
            cache[value] = []
        cache[value].append(elem)
    for values in cache:
        if values is None:
            continue
        for value in values:
            yield value

def solve(S):
    counts = [[0,0] for _ in range(len(S))]
    print(""counts: "", str(counts))
    counts = list(map(get_count, list(zip(S,counts))))
    print(""counts after get_count: "", str(counts))
    first_group = []
    second_group = []
    min_first_group = float('inf')
    max_first_group = 0
    min_second_group = float('inf')
    max_second_group = 0

    for c in counts:
        if c[0] - c[1] <= 0:
            first_group.append(c)
            max_first_group = max(max_first_group, c[0])
            min_first_group = min(min_first_group, c[0])
        else:
            second_group.append(c)
            max_second_group = max(max_second_group, c[1])
            min_second_group = min(min_first_group, c[1])
    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])
    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))

    order = chain(first_group, second_group)

    cum_sum = 0
    for c in order:
        cum_sum -= c[0]
        if cum_sum < 0:
            return 'No'
        cum_sum += c[1]
    if cum_sum == 0:
        return 'Yes'
    return 'No'

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
39,"<ans>
import math
from functools import reduce
class SegmentTree():
    def __init__(self, L, function = lambda x,y: x+y):
        self.function = function
        N = self.size = len(L)
        print(""N: "", str(N))
        M = 1 << N.bit_length()
        print(""M: "", str(M))
        self.margin = 2*M - N
        print(""self.margin: "", str(self.margin))
        self.L = [None for i in range(self.margin)] + L
        print(""self.L: "", str(self.L))
        for i in range(M-1, 0, -1):
            x, y = self.L[i<<1], self.L[i<<1|1]
            self.L[i] = None if x is None or y is None else function(x, y)
    def modify(self, pos, value):
        p = pos + self.margin
        print(""p: "", str(p))
        self.L[p] = value 
        print(""self.L[p]: "", str(self.L[p]))
        while p > 1:
            x, y = self.L[p], self.L[p^1]
            if p&1: x, y = y, x
            self.L[p>>1] = None if x is None or y is None else self.function(x, y)
            print(""self.L[p>>1]: "", str(self.L[p>>1]))
            p>>=1
    def query(self, left, right):
        l, r = left + self.margin, right + self.margin
        print(""l: "", str(l), ""r: "", str(r))
        stack = []
        void = True
        while l < r:
            if l&1:
                if void:
                    result = self.L[l]
                    void = False
                else:
                    result = self.function(result, self.L[l])
                print(""result: "", str(result))
                l+=1
            if r&1:
                r-=1
                stack.append(self.L[r])
                print(""stack: "", str(stack))
            l>>=1
            r>>=1
        init = stack.pop() if void else result
        print(""init: "", str(init))
        return reduce(self.function, reversed(stack), init)

n = int(input())
pies, index, first_equal = [0]*n, [0]*n, [0]*n
print(""pies: "", str(pies), ""index: "", str(index), ""first_equal: "", str(first_equal))
for i in range(n):
    r, h = [int(x) for x in input().split()]
    pies[i] = r*r*h
    print(""pies[{}]: "".format(i), str(pies[i]))
s_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))
print(""s_pies: "", str(s_pies))
for i in range(n): index[s_pies[i][0]] = i
print(""index: "", str(index))
for i in range(1, n):
    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]
print(""first_equal: "", str(first_equal))
towers = SegmentTree([0]*(n+1), max)
print(""towers: "", str(towers))
for j, pie in enumerate(pies):
    i, k = index[j], first_equal[j]
    print(""i: "", str(i), ""k: "", str(k))
    q = towers.query(0, k+1)
    print(""q: "", str(q))
    towers.modify(i+1, q + pie)
print(math.pi * towers.query(0, n+1))
</ans>",0,{}
40,"<ans>
```python
# returns answer to the subproblem with interval range [start, end],
# but with a total of ""extra"" additional stuff on the end
# that must be deleted last.
memo = {}
def f(dat, rewards, start, end, extra):
    curr = (start, end, extra)
    if curr in memo:
        return memo[curr]
    
    if start > end:
        return 0
    if start == end:
        memo[curr] = rewards[dat[start] + extra]
        print(""memo[curr]: "", str(memo[curr]))
        return memo[curr]
    
    # test all possible ""cut points"".
    # ""cut"" is the earliest index to die in the same deletion as ""end"".
    out = 0
    for cut in range(end, start-1, -2):
        if cut == end:
            # in this case, we're deleting the last interval right away.
            out_curr = rewards[dat[cut] + extra]
            print(""out_curr: "", str(out_curr))
            out_curr += f(dat, rewards, start, cut-1, 0)
        else:
            # split into 2 pieces:
            # 1) slots [start, cut] plus [end + extra]
            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).
            out_curr = f(dat, rewards, start, cut, extra + dat[end])
            print(""out_curr (after first f call): "", str(out_curr))
            out_curr += f(dat, rewards, cut+1, end-1, 0)
        
        out = max(out, out_curr)
    
    memo[curr] = out
    print(""memo[curr] (final): "", str(memo[curr]))
    return memo[curr]

def solve(dat_str, rewards_orig):
    # break into intervals.
    dat = []
    pos = 0
    while pos < len(dat_str):
        end = pos
        while end < len(dat_str) and dat_str[pos] == dat_str[end]:
            end += 1

        dat.append(end - pos)
        print(""dat (after append): "", str(dat))
        pos = end
    
    # compute the highest-value way to remove a run of size k.
    # (google translated from C++ thinking)
    rewards = [0, rewards_orig[0]]
    print(""rewards (initial): "", str(rewards))
    for k in range(2, len(rewards_orig) + 1):
        rewards.append(
            max(
                rewards[k-j] + rewards_orig[j-1]
                for j in range(1, k+1)
            )
        )
        print(""rewards (after append in loop): "", str(rewards))
    
    return f(dat, rewards, 0, len(dat)-1, 0)

# get the integer
int_dummy = input()
# get the string
dat_str = input().strip()
# get the array
rewards_input = input().strip().split()
rewards_ints = [int(x) for x in rewards_input]
print(""rewards_ints: "", str(rewards_ints))

# print(dat_str)
# print(rewards_ints)

print((
    solve(
        dat_str,
        rewards_ints,
    )
))


# dat_test = ""10101""
# rewards_test = [3, 10, 15, 15, 15]
# print(solve(dat_test, rewards_test))
```
</ans>",0,{}
41,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

class RAQ_RMQ():
    def __init__(self, n, inf=2**31-1):
        self.n0 = 1<<(n-1).bit_length()
        print(""self.n0: "", str(self.n0))
        self.INF = inf
        print(""self.INF: "", str(self.INF))
        self.data = [0]*(2*self.n0)
        print(""self.data: "", str(self.data))
        self.lazy = [0]*(2*self.n0)
        print(""self.lazy: "", str(self.lazy))

    def getIndex(self, l, r):
        l += self.n0; r += self.n0
        lm = (l // (l & -l)) >> 1
        rm = (r // (r & -r)) >> 1
        while l < r:
            if r <= rm:
                yield r
            if l <= lm:
                yield l
            l >>= 1; r >>= 1
        while l:
            yield l
            l >>= 1

    def propagates(self, *ids):
        for i in reversed(ids):
            v = self.lazy[i-1]
            if not v:
                continue
            self.lazy[2*i-1] += v; self.lazy[2*i] += v
            self.data[2*i-1] += v; self.data[2*i] += v
            self.lazy[i-1] = 0

    def update(self, l, r, x):
        *ids, = self.getIndex(l, r)

        l += self.n0; r += self.n0
        while l < r:
            if r & 1:
                r -= 1
                self.lazy[r-1] += x; self.data[r-1] += x
                print(""self.lazy[r-1]: "", str(self.lazy[r-1]), ""self.data[r-1]: "", str(self.data[r-1]))
            if l & 1:
                self.lazy[l-1] += x; self.data[l-1] += x
                print(""self.lazy[l-1]: "", str(self.lazy[l-1]), ""self.data[l-1]: "", str(self.data[l-1]))
                l += 1
            l >>= 1; r >>= 1
        for i in ids:
            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]
            print(""self.data[i-1]: "", str(self.data[i-1]))

    def query(self, l, r):
        self.propagates(*self.getIndex(l, r))
        l += self.n0; r += self.n0

        s = self.INF
        print(""s: "", str(s))
        while l < r:
            if r & 1:
                r -= 1
                s = min(s, self.data[r-1])
                print(""s after min: "", str(s))
            if l & 1:
                s = min(s, self.data[l-1])
                print(""s after min: "", str(s))
                l += 1
            l >>= 1; r >>= 1
        return s

n,m,k = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
l = [0]*(n+1)
print(""l: "", str(l))
now = k
print(""now: "", str(now))
point = [0]*n
print(""point: "", str(point))
for i in range(n):
    a,b,c = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
    point[i] = c
    print(""point[i]: "", str(point[i]))
    now = now-a
    print(""now after subtraction: "", str(now))
    l[i] = now
    print(""l[i]: "", str(l[i]))
    now += b+a
l[n] = now
print(""l[n]: "", str(l[n]))

RMQ = RAQ_RMQ(n+1)
for i in range(n+1):
    RMQ.update(i,i+1,l[i])

portal = list(range(n))
print(""portal: "", str(portal))
for i in range(m):
    u,v = map(int, input().split())
    print(""u: "", str(u), ""v: "", str(v))
    u,v = u-1, v-1
    if portal[v]<u:
        portal[v] = u
        print(""portal[v]: "", str(portal[v]))

if RMQ.query(0, n+1) < 0:
    print(-1)
    return

heap = [(-point[i], -portal[i]) for i in range(n)]
print(""heap: "", str(heap))
from heapq import heapify, heappop
heapify(heap)

ans = 0
print(""ans: "", str(ans))
while heap:
    p,i = heappop(heap)
    print(""p: "", str(p), ""i: "", str(i))
    p,i = -p,-i
    if RMQ.query(i+1, n+1)>0:
        ans += p
        print(""ans after addition: "", str(ans))
        RMQ.update(i+1, n+1, -1)

print(ans)
</ans>",0,{}
42,"<ans>
import sys
from collections import deque

t=1
for _ in range(int(input())):
    n=int(input())
    print(""n: "", str(n))
    val=set([0,2*10**5+1])
    print(""val: "", str(val))
    seg=[(0,2*10**5+1)]
    print(""seg: "", str(seg))
    for i in range(n):
        l,r=map(int,input().split())
        print(""l: "", str(l), ""r: "", str(r))
        val.add(l)
        val.add(r)
        seg.append((l,r))
    val=list(val)
    print(""val: "", str(val))
    val.sort()
    comp={i:e+1 for e,i in enumerate(val)}
    print(""comp: "", str(comp))
    for i in range(n+1):
        l,r=seg[i]
        seg[i]=(comp[l],comp[r])
        print(""seg[{}]: "".format(i), str(seg[i]))

    deg=[0]*(n+1)
    print(""deg: "", str(deg))
    out=[[] for i in range(n+1)]
    print(""out: "", str(out))
    for i in range(n+1):
        for j in range(i+1,n+1):
            l,r=seg[i]
            L,R=seg[j]
            if L<=l and r<=R:
                out[j].append(i)
                deg[i]+=1
            elif l<=L and R<=r:
                out[i].append(j)
                deg[j]+=1

    ans=[0]
    print(""ans: "", str(ans))
    deq=deque(ans)
    print(""deq: "", str(deq))

    while deq:
        v=deq.popleft()
        for nv in out[v]:
            deg[nv]-=1
            if deg[nv]==0:
                deq.append(nv)
                ans.append(nv)
                print(""ans: "", str(ans))

    dp=[0]*(n+1)
    print(""dp: "", str(dp))

    def solve(v):
        query=[[] for i in range(2*n+3)]
        for nv in out[v]:
            l,r=seg[nv]
            query[r].append((l,dp[nv]))
        subdp=[0]*(2*n+3)
        for i in range(1,2*n+3):
            res=subdp[i-1]
            for l,val in query[i]:
                test=subdp[l-1]+val
                res=max(test,res)
            subdp[i]=res
            print(""subdp[{}]: "".format(i), str(subdp[i]))

        dp[v]=subdp[-1]+1
        print(""dp[{}]: "".format(v), str(dp[v]))

    for v in ans[::-1]:
        solve(v)

    print(dp[0]-1)
</ans>",0,{}
43,"<ans>
n=int(input())
print(""n: "", str(n))
arr=list(map(int,input().split()))
print(""arr: "", str(arr))
dict1={}
print(""dict1: "", str(dict1))
for i in range(2*n):
	try:
		dict1[arr[i]].append(i+1)
		dict1[arr[i]].sort()
	except:
		KeyError
		dict1[arr[i]]=[i+1]
		print(""dict1: "", str(dict1))
ans=0
print(""ans: "", str(ans))
curr1=1
print(""curr1: "", str(curr1))
curr2=1
print(""curr2: "", str(curr2))
for i in range(1,n+1):
	if(i==1):
		ans+=(dict1[i][0]-curr1)
		ans+=(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	elif(dict1[i][0]>curr1 and dict1[i][0]>curr2):
		ans+=(dict1[i][0]-curr1)
		ans+=(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	elif(dict1[i][1]<curr1<curr2):
		ans+=abs(dict1[i][0]-curr1)
		ans+=abs(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	elif(dict1[i][0]<curr1 and curr1<dict1[i][1]<curr2):
		ans+=abs(dict1[i][0]-curr1)
		ans+=abs(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	elif(dict1[i][0]<curr1 and dict1[i][1]<curr2):
		ans+=abs(dict1[i][0]-curr1)
		ans+=abs(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	elif(curr1<dict1[i][0]<dict1[i][1]<curr2):
		ans+=abs(dict1[i][0]-curr1)
		ans+=abs(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
	else:
		ans+=abs(dict1[i][0]-curr1)
		ans+=abs(dict1[i][1]-curr2)
		curr1=dict1[i][0]
		curr2=dict1[i][1]
		print(""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
print(ans)
</ans>",0,{}
44,"<ans>
def gcd(a,b):
    while b:
        a, b = b, a%b
    return a

n = int(input())
P = [[int(x) for x in input().split()] for _ in range(n)]
print(""n: "", str(n), ""P: "", str(P))

L = []
print(""L: "", str(L))
def addLine(x,y,dx,dy):
    if dx < 0:
        dx *= -1
        dy *= -1
    elif dx == 0:
        if dy < 0:
            dy *= -1
    g = gcd(dx,dy)
    print(""g: "", str(g))
    dx //= g
    dy //= g
    print(""dx: "", str(dx), ""dy: "", str(dy))

    x += dx * (10**9)
    y += dy * (10**9)
    if dx:
        k = x//dx
    else:
        k = y//dy
    print(""k: "", str(k))
    x -= k*dx
    y -= k*dy
    print(""x: "", str(x), ""y: "", str(y))
    L.append((x,y,dx,dy))
    print(""L: "", str(L))


for i in range(n):
    for j in range(i+1,n):
        xi,yi = P[i]
        xj,yj = P[j]
        dx,dy = xi-xj,yi-yj
        print(""xi: "", str(xi), ""yi: "", str(yi), ""xj: "", str(xj), ""yj: "", str(yj), ""dx: "", str(dx), ""dy: "", str(dy))
        addLine(xi,yi,dx,dy)

from collections import defaultdict as dd, deque

L = list(set(L))
print(""L: "", str(L))
res = 0
print(""res: "", str(res))

C = dd(int)
for x,y,dx,dy in L:
    C[dx,dy] += 1
    print(""C[dx,dy]: "", str(C[dx,dy]))

ss = sum(C.values())
print(""ss: "", str(ss))

for x in C.values():
    res += (ss-x)*x
    print(""res: "", str(res), ""x: "", str(x))

#for i in range(len(L)):
#    for j in range(i+1, len(L)):
#        x1,y1,dx1,dy1 = L[i]
#        x2,y2,dx2,dy2 = L[j]
#        if dx1 != dx2 or dy1 != dy2:
#            #print(L[i])
#            #print(L[j])
#            #print('---')
#            res += 1

print(res//2)
</ans>",0,{}
45,"<ans>
import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m))
A=[list(map(int,input().split())) for i in range(n)]
print(""A: "", str(A))

for i in range(m):
    #一行目をi-1まで0にする

    ANSR=[0]*n
    print(""ANSR: "", str(ANSR))
    ANSC=[0]*m
    print(""ANSC: "", str(ANSC))

    for j in range(i):
        if A[0][j]==1:
            ANSC[j]=1
            print(""ANSC: "", str(ANSC))

    for j in range(i,m):
        if A[0][j]==0:
            ANSC[j]=1
            print(""ANSC: "", str(ANSC))

    for r in range(1,n):
        B=set()
        for c in range(m):
            if ANSC[c]==0:
                B.add(A[r][c])
            else:
                B.add(1-A[r][c])

        if len(B)>=2:
            break
        if max(B)==0:
            ANSR[r]=1
            print(""ANSR: "", str(ANSR))

    else:
        print(""YES"")
        print("""".join(map(str,ANSR)))
        print("""".join(map(str,ANSC)))
        return

ANSR=[0]*n
print(""ANSR: "", str(ANSR))
ANSC=[0]*m
print(""ANSC: "", str(ANSC))

for j in range(m):
    if A[0][j]==1:
        ANSC[j]=1
        print(""ANSC: "", str(ANSC))

flag=0
for r in range(1,n):
    if flag==0:
        B=[]
        for c in range(m):
            if ANSC[c]==0:
                B.append(A[r][c])
            else:
                B.append(1-A[r][c])

        if max(B)==0:
            continue
        elif min(B)==1:
            ANSR[r]=1
            print(""ANSR: "", str(ANSR))
            continue
        else:
            OI=B.index(1)
            if min(B[OI:])==1:
                flag=1
                continue

            OO=B.index(0)
            if max(B[OO:])==0:
                flag=1
                ANSR[r]=1
                print(""ANSR: "", str(ANSR))
                continue

            else:
                print(""NO"")
                return

    else:

        B=set()
        for c in range(m):
            if ANSC[c]==0:
                B.add(A[r][c])
            else:
                B.add(1-A[r][c])

        if len(B)>=2:
            break
        if max(B)==0:
            ANSR[r]=1
            print(""ANSR: "", str(ANSR))

    else:
        print(""YES"")
        print("""".join(map(str,ANSR)))
        print("""".join(map(str,ANSC)))
        return

print(""NO"")
</ans>",0,{}
46,"<ans>
```python
""""""Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I""""""
# from fractions import Fraction


# def convert_to_fractions(poly):
#     """"""convert polygon vertex to fractional type""""""
#     poly_frac = []
#     for x, y, z in poly:
#         vertex = (Fraction(x),
#                   Fraction(y),
#                   Fraction(z))
#         poly_frac.append(vertex)
#     return poly_frac


def convert_to_float(poly):
    """"""convert polygon vertex to float type""""""
    poly_float = []
    for x, y, z in poly:
        vertex = (float(x),
                  float(y),
                  float(z))
        poly_float.append(vertex)
        print(""vertex: "", str(vertex))
    return poly_float


def cross_product(a, b):
    """"""3-vector product""""""
    return (a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0])


def dot_product(a, b):
    """"""scalar product of 3-vectors""""""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def vect_diff(a, b):
    """"""vector difference""""""
    return a[0] - b[0], a[1] - b[1], a[2] - b[2]


def poly_normal(poly):
    """"""return normal vector for first three vertex""""""
    assert len(poly) >= 3
    x, y, z = poly[:3]
    u = vect_diff(y, x)
    v = vect_diff(z, y)
    print(""u: "", str(u), ""v: "", str(v))
    return cross_product(u, v)


def intersect_list(poly, plain_norm, plain_point, proj_dir):
    """"""list of intersection points

    find points where the edges enter or leave upper half-space over the plain
    :return list of points projection on proj_dir
    """"""
    # vertex projection
    u = [dot_product(vert, proj_dir) for vert in poly]
    print(""u: "", str(u))

    # plain anchor
    vr = dot_product(plain_point, plain_norm)
    print(""vr: "", str(vr))

    # polygon vertex
    v = [dot_product(vert, plain_norm) for vert in poly]
    print(""v: "", str(v))

    u_list = []
    for i in range(len(poly)):
        if (v[i-1] > vr) != (v[i] > vr):
            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])
            u_list.append(ur)
            print(""ur: "", str(ur))

    return u_list


def points_to_str(a_points, b_points):
    """"""string representing the order of points 'a' and 'b'""""""
    a_pairs = [('a', val) for val in a_points]
    b_pairs = [('b', val) for val in b_points]
    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])
    letters = [ch for ch, _ in pairs]
    return ''.join(letters)


def recognize_str(s):
    """"""return True if string s belong to the grammar

    The context-free grammar is given
    S -> SS
    S -> a S a
    S -> b S b
    S -> e

    The recognising automaton is implemented
    """"""
    toggle = {'a':'b', 'b':'a'}
    cross_num = 0
    top = None
    for ch in s:
        if not cross_num:
            cross_num = 1
            top = ch
            continue

        if ch == top:
            cross_num -= 1
        else:
            cross_num += 1

        if cross_num:
            top = toggle[top]
        else:
            top = None
    return not cross_num


def is_well_connected(a, b):
    """"""Two planar polygons are bind together in 3D

    Arguments:
        a_poly,
        b_poly -- lists of vertex triples
    """"""
    a = convert_to_float(a)
    b = convert_to_float(b)

    a_norm = poly_normal(a)
    print(""a_norm: "", str(a_norm))
    b_norm = poly_normal(b)
    print(""b_norm: "", str(b_norm))

    common_dir = cross_product(a_norm, b_norm)
    print(""common_dir: "", str(common_dir))
    if not any(common_dir):
        return False

    a_list = intersect_list(a, b_norm, b[0], common_dir)
    print(""a_list: "", str(a_list))
    b_list = intersect_list(b, a_norm, a[0], common_dir)
    print(""b_list: "", str(b_list))

    char_str = points_to_str(a_list, b_list)
    print(""char_str: "", str(char_str))
    return not recognize_str(char_str)


def run_from_console():
    a_len, = [int(num) for num in input().split()]
    print(""a_len: "", str(a_len))

    a = []
    for _ in range(a_len):
        vertex = tuple(int(num) for num in input().split())
        a.append(vertex)
        print(""vertex: "", str(vertex))

    b_len, = [int(num) for num in input().split()]
    print(""b_len: "", str(b_len))

    b = []
    for _ in range(b_len):
        vertex = tuple(int(num) for num in input().split())
        b.append(vertex)
        print(""vertex: "", str(vertex))

    if is_well_connected(a, b):
        print('YES')
    else:
        print('NO')


def __starting_point():
    run_from_console()
__starting_point()
```
</ans>",0,{}
47,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


ORDA = 97
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=2):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
    return divs_number
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


for _ in range(ii()):
    n = ii()
    print(""n: "", str(n))
    a = li()
    print(""a: "", str(a))
    if n == 1 and a[0] & 1:
        print(-1)
    else:
        for i in range(n):
            if a[i] % 2 == 0:
                print(1)
                print(i + 1)
                break
        else:
            print(2)
            print(1, 2)

</ans>",0,{}
48,"<ans>
n, k = list(map(int, input().split()))
print(""n: "", str(n), ""k: "", str(k))
p  = {}
np = {}
pair    = []
used    = {}
rev_d   = {}

def push(d, s, v):
    if s not in d:
        d[s] = []
    d[s].append(v)

def is_pal(s):
    n = len(s)
    flg=True
    for i in range(n//2):
        if s[i] != s[n-1-i]:
            flg = False
            break
    return flg        

def rev(s):
    return s[::-1]

for _ in range(n):
    s, val = input().split()
    val    = int(val)
    print(""s: "", str(s), ""val: "", str(val))
    
    if is_pal(s):
        push(p, s, val)
    else:
        push(np, s, val)
        
        if s not in rev_d:
            rev_d[s] = rev(s)
            print(""rev_d[{}]: "".format(s), str(rev_d[s]))

for k, v in list(p.items()):
    p[k] = sorted(v, reverse=True)
    print(""p[{}]: "".format(k), str(p[k]))
        
for k, v in list(np.items()):
    np[k] = sorted(v, reverse=True)
    print(""np[{}]: "".format(k), str(np[k]))
    
for s in np:
    if s not in used and rev_d[s] in np:
        pair.append([s, rev_d[s]])
        used[s] = True
        used[rev_d[s]] = True
        
max_remain = 0
minus = 0
max_S = 0
print(""max_remain: "", str(max_remain), ""minus: "", str(minus), ""max_S: "", str(max_S))

for v_arr in list(p.values()):
    n = len(v_arr)
    for i in range(0, n, 2):
        if i+1==n:
            if v_arr[i] > 0:
                max_remain = max(max_remain, v_arr[i]) 
                print(""max_remain: "", str(max_remain))
            
        else:
            if v_arr[i] + v_arr[i+1] >= 0:
                max_S += v_arr[i] + v_arr[i+1]
                print(""max_S: "", str(max_S))
                
                if v_arr[i+1] < 0:
                    minus = min(minus, v_arr[i+1])
                    print(""minus: "", str(minus))
            else:
                if v_arr[i] > 0:
                    max_remain = max(max_remain, v_arr[i]) 
                    print(""max_remain: "", str(max_remain))

for [u, v] in pair:
    n = min(len(np[u]), len(np[v]))
    print(""u: "", str(u), ""v: "", str(v), ""n: "", str(n))
        
    for x, y in  zip(np[u][:n], np[v][:n]):
        if x+y > 0:
            max_S += x+y
            print(""max_S: "", str(max_S))
            
print(max(max_S+max_remain, max_S-minus))            
</ans>",0,{}
49,"<ans>
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    q = a//k
    r = (a-q*k)%(q+1)
    if r==0:
        return a//k
    v = (a-q*k)//(q+1) + 1
    print(""q: "", str(q), ""r: "", str(r), ""v: "", str(v))
    #print(a,k,q,v)
    return grundy(a-(q+1)*v,k)


""""""
# coding: utf-8
# Your code here!
import sys
readline = sys.stdin.readline
read = sys.stdin.read
sys.setrecursionlimit(10**8)

n, = list(map(int,readline().split()))
print(""n: "", str(n))
g = 0
print(""g: "", str(g))
for _ in range(n):
    a,k = list(map(int,readline().split()))
    print(""a: "", str(a), ""k: "", str(k))
    g ^= grundy(a,k)
if g:
    print(""Takahashi"")
else:
    print(""Aoki"")
</ans>",0,{}
50,"<ans>
a = input()
ans=[]
print(""ans: "", str(ans))
t=''
print(""t: "", str(t))
qoute =0
print(""qoute: "", str(qoute))
space =0
print(""space: "", str(space))
start =1 if a[0]=='""' else 0
print(""start: "", str(start))
for i in range(len(a)):
    v= a[i]
    print(""v: "", str(v))
    if start:
        if t=='':
            if v=='""':
                qoute+=1
                print(""qoute: "", str(qoute))
                t = '<'
                print(""t: "", str(t))
            elif v==' ':
                pass
            else:
                space+=1
                print(""space: "", str(space))
                t='<'+v
                print(""t: "", str(t))
        elif qoute>0:
            if v =='""':
                t+='>'
                print(""t: "", str(t))
                qoute=0
                ans.append(t)
                print(""ans: "", str(ans))
                t=''
                print(""t: "", str(t))
                start=0
            else:
                t+=v
                print(""t: "", str(t))
        else:
            if v ==' ':
                if t!='<':
                    t+='>'
                    print(""t: "", str(t))
                    ans.append(t)
                    print(""ans: "", str(ans))
                    t=''
                    print(""t: "", str(t))
                    start=0
            else:
                t+=v
                print(""t: "", str(t))
    else:
        if v==' ':
            start=1
        elif v=='""':
            start=1
            t='<'
            print(""t: "", str(t))
            qoute=1
            print(""qoute: "", str(qoute))
        else:
            t='<'+v
            print(""t: "", str(t))
            start=1
if t!='':
    t+='>'
    print(""t: "", str(t))
    ans.append(t)
    print(""ans: "", str(ans))
for v in ans:
    print(v)
</ans>",0,{}
51,"<ans>
def main1():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    print(""n: "", str(n))
    M = int(buflist[1])
    print(""M: "", str(M))
    buf = input()
    buflist = buf.split()
    t = list(map(int, buflist))
    print(""t: "", str(t))
    student = []
    print(""student: "", str(student))
    minimum = []
    print(""minimum: "", str(minimum))
    for i in range(n):
        count = 0
        print(""count: "", str(count))
        pointer = 0
        print(""pointer: "", str(pointer))
        while pointer < i:
            if count + student[pointer] <= M - t[i]:
                count += student[pointer]
                print(""count: "", str(count))
                pointer += 1
                print(""pointer: "", str(pointer))
            else:
                break
        minimum.append(i - pointer)
        print(""minimum: "", str(minimum))
        student.append(t[i])
        print(""student: "", str(student))
        student.sort()
    print(' '.join(list(map(str, minimum))))

def main2():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    print(""n: "", str(n))
    M = int(buflist[1])
    print(""M: "", str(M))
    buf = input()
    buflist = buf.split()
    t = list(map(int, buflist))
    print(""t: "", str(t))
    bucket = []
    for i in range(101):
        bucket.append(0)
    print(""bucket: "", str(bucket))
    minimum = []
    print(""minimum: "", str(minimum))
    for i in range(n):
        target = M - t[i]
        print(""target: "", str(target))
        count = 0
        print(""count: "", str(count))
        subtotal = 0
        print(""subtotal: "", str(subtotal))
        for j in range(1, 101):
            if subtotal + bucket[j] * j > target:
                count += (target - subtotal) // j
                print(""count: "", str(count))
                break
            else:
                count += bucket[j]
                print(""count: "", str(count))
                subtotal += bucket[j] * j
                print(""subtotal: "", str(subtotal))
        minimum.append(i - count)
        print(""minimum: "", str(minimum))
        bucket[t[i]] += 1
        print(""bucket: "", str(bucket))
    print(' '.join(list(map(str, minimum))))

def __starting_point():
    #main1() # for C1
    main2() # for C2

__starting_point()
</ans>",0,{}
52,"<ans>
import itertools
from collections import deque,defaultdict,Counter
from itertools import accumulate
import bisect
from heapq import heappop,heappush,heapify
import math
from copy import deepcopy
import queue
#import numpy as np
# sympy as syp(素因数分解とか)
Mod = 1000000007
fact = [1, 1]
factinv = [1, 1]
inv = [0, 1] 
for i in range(2, 10**5 + 1):
    fact.append((fact[-1] * i) % Mod)
    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)
    factinv.append((factinv[-1] * inv[-1]) % Mod)
    
def cmb(n, r, p):
    if (r < 0) or (n < r):
        return 0
    r = min(r, n - r)
    return fact[n] * factinv[r] * factinv[n - r] % p
    
def sieve_of_eratosthenes(n):
    if not isinstance(n,int):
        raise TypeError(""n is not int"")
    if n<2:
        raise ValueError(""n is not effective"")
    prime = [1]*(n+1)
    for i in range(2,int(math.sqrt(n))+1):
        if prime[i] == 1:
            for j in range(2*i,n+1):
                if j%i == 0:
                    prime[j] = 0
    res = []
    for i in range(2,n+1):
        if prime[i] == 1:
            res.append(i)
    return res

 
class UnionFind:
    def __init__(self,n):
        self.parent = [i for i in range(n+1)]
        print(""self.parent: "", str(self.parent))
        self.rank = [0 for i in range(n+1)]
        print(""self.rank: "", str(self.rank))
    
    def findroot(self,x):
        if x == self.parent[x]:
            return x
        else:
            y = self.parent[x]
            y = self.findroot(self.parent[x])
            return y
    
    def union(self,x,y):
        px = self.findroot(x)
        py = self.findroot(y)
        if px < py:
            self.parent[y] = px
            print(""self.parent[y]: "", str(self.parent[y]))
        else:
            self.parent[px] = py
            print(""self.parent[px]: "", str(self.parent[px]))
 
    def same_group_or_no(self,x,y):
        return self.findroot(x) == self.findroot(y)
def pow_k(x, n):

    if n == 0:
        return 1

    K = 1
    print(""K: "", str(K))
    while n > 1:
        if n % 2 != 0:
            K *= x
            print(""K: "", str(K))
        x *= x
        n //= 2

    return K * x
def main():  #startline-------------------------------------------
    n = int(input())
    print(""n: "", str(n))
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    d = defaultdict(int)
    print(""d: "", str(d))
    ans = 0
    print(""ans: "", str(ans))
    for i in range(n):
        l = i - a[i]
        print(""l: "", str(l))
        ans += d[l]
        d[a[i] + i] += 1
        print(""d[a[i] + i]: "", str(d[a[i] + i]))
        
    print(ans)
def __starting_point():
    main() #endline===============================================
__starting_point()
</ans>",0,{}
53,"<ans>
#template
import sys
sys.setrecursionlimit(10**9)

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

read_int = lambda: int(readline())
read_ints = lambda: map(int,readline().split())
read_ints_list = lambda: list(map(int,readline().split()))
read_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))
read_strs_list = lambda: list(map(str,readline().rstrip().split()))
read_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))

def read_allints_grid(w):
    grid = map(int,read().split())
    grid = list(map(list,zip(*(grid for _ in range(w)))))
    return grid

def read_allstrs_grid(w):
    grid = map(str,read().split())
    grid = list(map(list,zip(*(grid for _ in range(w)))))
    return grid

#import
# from copy import deepcopy
# from decimal import Decimal
# from math import ceil,floor
# from collections import deque,Counter
# from heapq import heapify,heappop,heappush
# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement
# from bisect import bisect_left,bisect_right

#solution
def sol():
    return None
def GCD(a:int,b:int)->int:
    '''
    ユークリッドの互除法による最大公約数/O(log min(a,b))
    '''
    if b==0:
        return a
    else:
        return GCD(b,a%b)

def GCD_multi(vec:list)->int:
    '''
    数列の要素の最大公約数を求める/O(N log(a'))
    '''
    l = vec[0]
    print(""l: "", str(l))
    for i in range(len(vec)-1):
        l = GCD(l,vec[i+1])
        print(""l: "", str(l))
    return l

def main():
    #input data
    n = read_int()
    print(""n: "", str(n))
    A = read_ints_list()
    print(""A: "", str(A))

    #solve
    print(GCD_multi(A))

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
54,"<ans>
```python
__author__ = ""Ryabchun Vladimir""


class Stack:
    """"""
    This is a stack class. There is 5 Procedures we can do with stack:
    1. Push - we add one element at the end of the stack
    2. Pop - we remove last element from the stack and return it
    3. Last - We return last element but don't remove it
    4. len() - returns the length of stack(we don't use len() because it's too
    slow).
    5. Clear - remove all elements from stack
    """"""
    def __init__(self, element=None):
        """"""
        self.length - length of the stack. When we append an element we increase it(length) by 1
        __stack - this is our stack. Because we can't get any elements from the stack except the last one
        we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,
        but we mustn't do it).
        :param element: Can be any type
        """"""
        self.length = 0
        print(""self.length: "", str(self.length))
        if element is None:
            self.__stack = []
            print(""self.__stack: "", str(self.__stack))
        else:
            self.__stack = []
            print(""self.__stack: "", str(self.__stack))
            for el in element:
                self.__stack.append(el)
                self.length += 1
                print(""self.length: "", str(self.length))
                print(""self.__stack: "", str(self.__stack))

    def push(self, element):
        """"""
        This function adds an element at the end of the stack.
        When we append an element we increase self.length by 1.
        :param element: Can be any type
        :return: NoneType
        """"""
        self.__stack.append(element)
        print(""self.__stack: "", str(self.__stack))
        self.length += 1
        print(""self.length: "", str(self.length))

    def pop(self):
        """"""
        This function removes an element from the end of the stack and
        returns it's value.
        When we append an element we decrease self.length by 1.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            self.length -= 1
            print(""self.length: "", str(self.length))
            return self.__stack.pop()

    def last(self):
        """"""
        This function just returns an element from the end of the stack
        but it doesn't remove it.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            return self.__stack[-1]

    def __len__(self):
        """"""
        This function returns the length of the stack.
        :return: self.length(int)
        """"""
        return self.length

    def clear(self):
        """"""
        Clears the stack.
        :return: NoneType
        """"""
        self.__stack = []
        print(""self.__stack: "", str(self.__stack))

n = int(input())
print(""n: "", str(n))
snekovik = Stack()
print(""snekovik: "", str(snekovik))
wrong_snaks = set()
print(""wrong_snaks: "", str(wrong_snaks))
the_biggest_snek = n
print(""the_biggest_snek: "", str(the_biggest_snek))
sneks = list(map(int, input().split()))
print(""sneks: "", str(sneks))
for i in sneks:
    printing = []
    print(""printing: "", str(printing))
    if i == the_biggest_snek:
        snekovik.push(i)
        printing.append(i)
        print(""printing: "", str(printing))
        the_biggest_snek -= 1
        print(""the_biggest_snek: "", str(the_biggest_snek))
        while the_biggest_snek in wrong_snaks:
            snekovik.push(the_biggest_snek)
            wrong_snaks.remove(the_biggest_snek)
            printing.append(the_biggest_snek)
            print(""printing: "", str(printing))
            the_biggest_snek -= 1
            print(""the_biggest_snek: "", str(the_biggest_snek))
    else:
        wrong_snaks.add(i)
        print(""wrong_snaks: "", str(wrong_snaks))
    print(*printing)
```
</ans>",0,{}
55,"<ans>
H,W=map(int,input().split())
print(""H: "", str(H), ""W: "", str(W))
List = [list(input()) for i in range(H)]
print(""List: "", str(List))
res = ""Yes""
print(""res: "", str(res))
flag = True
print(""flag: "", str(flag))

def checkAround(ListX,i,j):
  if i == 0 and j ==0:
    if List[i+1][j] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j !=0 and j != W-1:
    if List[i+1][j] == ""#"" or List[i][j-1] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j == W-1:
    if List[i+1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == 0:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == W-1:
    if List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j !=0 and j != W-1:
    if List[i-1][j] == ""#"" or List[i][j+1] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == 0:
    if List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == W-1:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  else:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j-1] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False

for k in range(H):
  print(""k: "", str(k))
  for l in range(W):
    print(""l: "", str(l))
    if List[k][l] == ""."":
      pass
    else:
      flag = checkAround(List,k,l)
      print(""flag: "", str(flag))
      if not flag:
        res = ""No""
        print(""res: "", str(res))
        break
  if not flag:
    break
print(res)
</ans>",1,{}
56,"<ans>
import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity

    def bfs(self, s, t):
        open_q = [s]

        visited = set()
        parent = dict()
        while open_q:
            close_q = []
            for node in open_q:
                for v, capacity in list(self.edges[node].items()):
                    if v not in visited and capacity > 0:
                        close_q.append(v)
                        parent[v] = node
                        visited.add(v)
                        if v == t:
                            result = []
                            n2 = v
                            n1 = node
                            while n1 != s:
                                result.append((n1, n2))
                                n2 = n1
                                n1 = parent[n1]
                            result.append((n1, n2))
                            return result

            open_q = close_q

        return None

    def solve(self, s, t):
        flow = 0
        route = self.bfs(s, t)
        while route is not None:
            new_flow = float('inf')
            for _, (n1, n2) in enumerate(route):
                new_flow = min(new_flow, self.edges[n1][n2])
            for _, (n1, n2) in enumerate(route):
                self.edges[n1][n2] -= new_flow
                self.edges[n2][n1] += new_flow
            flow += new_flow

            route = self.bfs(s, t)

        return flow

    def __str__(self):
        result = ""{ ""
        for k, v in list(self.edges.items()):
            result += str(k) + "":"" + str(dict(v)) + "", ""
        result += ""}""
        return result


def main():
    (n, m) = tuple([int(x) for x in input().split()])
    print(""n: "", str(n), ""m: "", str(m))
    r = []
    print(""r: "", str(r))
    xs = set()
    print(""xs: "", str(xs))
    ys = set()
    print(""ys: "", str(ys))
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))
        r.append((x1, y1, x2, y2))
        print(""r: "", str(r))
        xs.add(x1)
        xs.add(x2 + 1)
        print(""xs: "", str(xs))
        ys.add(y1)
        ys.add(y2 + 1)
        print(""ys: "", str(ys))

    xx = sorted(xs)
    print(""xx: "", str(xx))
    yy = sorted(ys)
    print(""yy: "", str(yy))
    xsize = len(xs)
    print(""xsize: "", str(xsize))
    ysize = len(ys)
    print(""ysize: "", str(ysize))
    grid = []
    for i in range(ysize):
        grid.append([False] * xsize)
        print(""grid: "", str(grid))

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    grid[i][j] = True
                    print(""grid[{}][{}]: "".format(i, j), str(grid[i][j]))

    f = MaxFlow()
    print(""f: "", str(f))
    for i in range(len(yy)):
        for j in range(len(xx)):
            if grid[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])

    # print(xx)
    # print(yy)
    # print(f)
    print(f.solve(0, len(xx) + len(yy) + 1))


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
57,"<ans>
""""""
#If FastIO not needed, used this and don't forget to strip
#import sys, math
#input = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string


def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def getMat(n):
    return [getInts() for _ in range(n)]

MOD = 10**9+7


""""""
Each edge goes from parent U to child V
Edge appears on S_V * (N - S_V) paths

For each path of length L, (L + (-L)%K)/K


L%K 0, 1, 2, 3, 4
(K - L%K)%K K K-1 K-2 ...
0 K-1 K-2 ...

""""""
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

def solve():
    N, K = getInts()
    print(""N: "", str(N), ""K: "", str(K))
    graph = dd(set)
    print(""graph: "", str(graph))
    for i in range(N-1):
        A, B = getInts()
        print(""A: "", str(A), ""B: "", str(B))
        graph[A].add(B)
        graph[B].add(A)
    dp_count = [[0 for j in range(5)] for i in range(N+1)]
    print(""dp_count: "", str(dp_count))
    dp_total = [0 for j in range(N+1)]
    print(""dp_total: "", str(dp_total))
    nonlocal ans
    ans = 0
    print(""ans: "", str(ans))
    @bootstrap
    def dfs(node,parent,depth):
        nonlocal ans
        dp_count[node][depth % K] = 1
        print(""dp_count[{}][{}]: "".format(node, depth % K), str(dp_count[node][depth % K]))
        dp_total[node] = 1
        print(""dp_total[{}]: "".format(node), str(dp_total[node]))
        for neigh in graph[node]:
            if neigh != parent:
                yield dfs(neigh,node,depth+1)
                for i in range(K):
                    for j in range(K):
                        diff = (i+j-2*depth)%K
                        req = (-diff)%K
                        ans += req * dp_count[node][i] * dp_count[neigh][j]
                for i in range(K):
                    dp_count[node][i] += dp_count[neigh][i]
                dp_total[node] += dp_total[neigh]
        ans += dp_total[node] * (N - dp_total[node])
        yield
    dfs(1,-1,0)
    return ans//K
    
    
print(solve())
</ans>",0,{}
58,"<ans>
import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy


class UnionFind:

    def __init__(self, n: int):
        self._n = n
        print(""_n: "", str(self._n))
        self._parents = [i for i in range(n)]
        print(""_parents: "", str(self._parents))
        self._size = [1 for _ in range(n)]
        print(""_size: "", str(self._size))

    def unite(self, x: int, y: int) -> None:
        px = self.find(x)
        py = self.find(y)

        # 一致していないときはリンクをつける
        if px != py:
            self._link(px, py)

    def _link(self, x: int, y: int):
        if self._size[x] < self._size[y]:
            self._parents[x] = y
            self._size[y] += self._size[x]
            print(""_parents: "", str(self._parents))
            print(""_size: "", str(self._size))
        else:
            self._parents[y] = x
            self._size[x] += self._size[y]
            print(""_parents: "", str(self._parents))
            print(""_size: "", str(self._size))

    def same(self, x: int, y: int) -> bool:
        px = self.find(x)
        py = self.find(y)
        return px == py

    def find(self, x: int) -> int:
        if self._parents[x] == x:
            return x

        self._parents[x] = self.find(self._parents[x])
        return self._parents[x]

    def size(self, x: int):
        return self._size[self.find(self._parents[x])]

N, K, L = map(int, input().split())
print(""N: "", str(N), ""K: "", str(K), ""L: "", str(L))

road = UnionFind(N + 1)
rail = UnionFind(N + 1)
share = UnionFind(N + 1)

roads = [list(map(int, input().split())) for _ in range(K)]
print(""roads: "", str(roads))
rails = [list(map(int, input().split())) for _ in range(L)]
print(""rails: "", str(rails))

for i in range(K):
    p, q = roads[i]
    print(""p: "", str(p), ""q: "", str(q))
    road.unite(p, q)

for i in range(L):
    r, s = rails[i]
    print(""r: "", str(r), ""s: "", str(s))
    rail.unite(r, s)

m = {}
print(""m: "", str(m))

for i in range(1, N + 1):
    cnt = m.get((road.find(i), rail.find(i)), 0)
    m[(road.find(i), rail.find(i))] = cnt + 1
    print(""m: "", str(m))

ans = [0] * N
print(""ans: "", str(ans))
for i in range(N):
    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]
    print(""ans[{}]: "".format(i), str(ans[i]))

print(*ans)
</ans>",0,{}
59,"<ans>
import sys

MOD = (int)(1e9+7)

def add(a, b):
	a += b
	if a >= MOD: a -= MOD
	return a
	
def mul(a, b):
	return (a * b) % MOD

class fenwickTree:
	def __init__(self, max_val):
		self.max_val = max_val + 5
		self.tree = [0] * self.max_val
	
	def update(self, idx, value):
		idx += 1
		while idx < self.max_val:
			self.tree[idx] = add(self.tree[idx], value)
			idx += (idx & (-idx))
	
	def read(self, idx):
		idx += 1
		res = 0
		while idx > 0:
			res = add(res, self.tree[idx])
			idx -= (idx & (-idx))
		return res

inp = [int(x) for x in sys.stdin.read().split()]
print(""inp: "", str(inp))

n = inp[0]
print(""n: "", str(n))
a = []
for i in range(1, n + 1):
	a.append(inp[i])
print(""a: "", str(a))

sorted_array = sorted(a)
print(""sorted_array: "", str(sorted_array))
dict = {}
for i in range(n):
	dict[sorted_array[i]] = i
print(""dict: "", str(dict))

factor = [0] * n
print(""factor: "", str(factor))
for i in range(0, n):
	factor[i] = mul(i + 1, n - i)
	print(""factor[{}]: "".format(i), str(factor[i]))

left_tree = fenwickTree(n)
print(""left_tree: "", str(left_tree))
for i in range(0, n):
	element_idx = dict[a[i]]
	factor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))
	print(""factor[{}]: "".format(i), str(factor[i]))
	left_tree.update(element_idx, i + 1)

right_tree = fenwickTree(n)
print(""right_tree: "", str(right_tree))
for i in range(n - 1, -1, -1):
	element_idx = dict[a[i]]
	factor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))
	print(""factor[{}]: "".format(i), str(factor[i]))
	right_tree.update(element_idx, n - i)

ans = 0
print(""ans: "", str(ans))
for i in range(n):
	ans = add(ans, mul(a[i], factor[i]))
	print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
60,"<ans>
import sys 
input = lambda: sys.stdin.readline().strip()

def f(A, r, c, l):
  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]

  #print(r, c, x,y,z,l, q,w,e)
  if x != y and y != z and e >= l and  w == q == l:
    return (l, z, y, x)
  else:
    return 0
  
  

r, c = list(map(int, input().split()))
print(""r: "", str(r), ""c: "", str(c))
s = """"
for i in range(r):
  s += input()

arr = []
print(""arr: "", str(arr))
narr = [[0]*r for i in range(c)]
print(""narr: "", str(narr))
for i in range(c):
  arr.append(s[i:r*c:c])

r, c = c, r 
print(""r: "", str(r), ""c: "", str(c))

length_str = [ [0] * c for i in range(r)]
print(""length_str: "", str(length_str))
for i in range(r):
  for j in range(c):
    if j == 0:
      length_str[i][j] = (1, arr[i][j])
      print(""length_str[{}][{}]: "".format(i, j), str(length_str[i][j]))
    elif arr[i][j-1] == arr[i][j]:
      length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])
      print(""length_str[{}][{}]: "".format(i, j), str(length_str[i][j]))
    else:
      length_str[i][j] = (1, arr[i][j])
      print(""length_str[{}][{}]: "".format(i, j), str(length_str[i][j]))

for i in range(r):
  for j in range(c):
    l, _ = length_str[i][j] 
    if j - l*3 + 1 < 0:
      continue 
    else:
      narr[i][j] = f(length_str, i, j, l)
      print(""narr[{}][{}]: "".format(i, j), str(narr[i][j]))
      




#for i in narr:
#  print(i)

dp =[ [0] * c for i in range(r) ]
print(""dp: "", str(dp))

for j in range(c):
  cnt = 1
  print(""j: "", str(j), ""cnt: "", str(cnt))
  for i in range(r):
    if narr[i][j] == 0:
      cnt = 1
      continue 
    else:
      if i == 0:
        dp[i][j] = 1
        print(""dp[{}][{}]: "".format(i, j), str(dp[i][j]))

      elif narr[i][j] == narr[i-1][j]:
        cnt += 1
        dp[i][j] = cnt
        dp[i-1][j] = 0
        print(""dp[{}][{}]: "".format(i, j), str(dp[i][j]))

      else:
        cnt = 1
        dp[i][j] = 1 
        print(""dp[{}][{}]: "".format(i, j), str(dp[i][j]))

ans = 0
print(""ans: "", str(ans))
for i in dp:
  for j in i:
    ans += ((j)*(j+1))//2

print(ans)

</ans>",0,{}
61,"<ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)


class TreapNode:
    _value = None
    _priority = None
    _count = None
    _left = None
    _right = None

    def __init__(self, value):
        self._value = value
        self._priority = random()
        print(""_priority: "", str(self._priority))
        self._count = 1
        print(""_count: "", str(self._count))


def treap_rotate_right(n):
    l = n._left
    print(""l: "", str(l))
    n._left = l._right
    l._right = n
    return l


def treap_rotate_left(n):
    r = n._right
    print(""r: "", str(r))
    n._right = r._left
    r._left = n
    return r


def treap_insert(n, v):
    if n is None:
        return TreapNode(v)
    if n._value == v:
        n._count += 1
        print(""n._count: "", str(n._count))
        return n
    if n._value > v:
        n._left = treap_insert(n._left, v)
        print(""n._left: "", str(n._left))
        if n._priority > n._left._priority:
            n = treap_rotate_right(n)
    else:
        n._right = treap_insert(n._right, v)
        print(""n._right: "", str(n._right))
        if n._priority > n._right._priority:
            n = treap_rotate_left(n)
    return n


def treap_delete(n, v):
    if n is None:
        raise Exception('no nodes')
    if n._value > v:
        n._left = treap_delete(n._left, v)
        print(""n._left: "", str(n._left))
        return n
    if n._value < v:
        n._right = treap_delete(n._right, v)
        print(""n._right: "", str(n._right))
        return n

    # n._value == v
    if n._count > 1:
        n._count -= 1
        print(""n._count: "", str(n._count))
        return n

    if n._left is None and n._right is None:
        return None

    if n._left is None:
        n = treap_rotate_left(n)
    elif n._right is None:
        n = treap_rotate_right(n)
    else:
        # n._left is not None and n._right is not None
        if n._left._priority < n._right._priority:
            n = treap_rotate_right(n)
        else:
            n = treap_rotate_left(n)
    return treap_delete(n, v)


def treap_size(n):
    if n is None:
        return 0
    return n._count + treap_size(n._left) + treap_size(n._right)


def treap_str(n):
    if n is None:
        return """"
    result = []
    if n._left is not None:
        result.append(treap_str(n._left))
    result.append(""%d:%d"" % (n._value, n._count))
    if n._right is not None:
        result.append(treap_str(n._right))
    return ' '.join(result)


def treap_search(n, v):
    # v 未満で最大のノードを検索する. v 未満のノードがなければ None を返す
    if n is None:
        return None
    if n._value >= v:
        if n._left is None:
            return None
        return treap_search(n._left, v)
    # n._value < v
    if n._right is None:
        return n
    r = treap_search(n._right, v)
    if r is None:
        return n
    return r


class Treap:
    _root = None
    _size = 0

    def insert(self, v):
        self._root = treap_insert(self._root, v)
        print(""_root: "", str(self._root))
        self._size += 1
        print(""_size: "", str(self._size))

    def delete(self, v):
        self._root = treap_delete(self._root, v)
        print(""_root: "", str(self._root))
        self._size -= 1
        print(""_size: "", str(self._size))

    def __len__(self):
        return self._size

    def __str__(self):
        return treap_str(self._root)

    def search(self, v):
        return treap_search(self._root, v)


N = int(input())
print(""N: "", str(N))
A = [int(input()) for _ in range(N)]
print(""A: "", str(A))

t = Treap()
for a in A:
    n = t.search(a)
    print(""n: "", str(n))
    if n is not None:
        t.delete(n._value)
    t.insert(a)
print((len(t)))
</ans>",0,{}
62,"<ans>
def _3():
    from collections import defaultdict

    def can_pair(s1, s2):
        l = []
        print(""l: "", str(l))
        for c1, c2 in zip(s1, s2):
            c = sorted([c1, c2])
            print(""c: "", str(c))
            if c in l:
                l.remove(c)
            else:
                l.append(c)
                print(""l: "", str(l))

        if len(s1) % 2 == 0:
            return len(l) == 0
        else:
            return len(l) == 1 and l[0][0] == l[0][1]

    def pair_graph(s1, s2):
        N = len(s1)
        print(""N: "", str(N))
        G = np.zeros([N, N])
        print(""G: "", str(G))
        for i in range(N):
            for j in range(i+1, N):
                if s1[i] == s2[j] and s1[j] == s2[i]:
                    G[i, j] = 1
                    G[j, i] = 1
        return G

    import numpy as np
    H, W = list(map(int, input().split(' ')))
    print(""H: "", str(H), ""W: "", str(W))
    S = []
    print(""S: "", str(S))
    d = defaultdict(list)
    print(""d: "", str(d))

    for h in range(H):
        s = input()
        S.append(s)
        print(""S: "", str(S))
        d[''.join(sorted(S))].append(h)
        print(""d: "", str(d))

    already_paired = np.zeros(H)
    print(""already_paired: "", str(already_paired))

    Gs = []
    print(""Gs: "", str(Gs))

    for i in range(H):
        if already_paired[i]:
            continue

        for j in range(i+1, H):
            if already_paired[j]:
                continue

            if can_pair(S[i], S[j]):
                already_paired[i] = 1
                already_paired[j] = 1
                G = pair_graph(S[i], S[j])
                Gs.append(G)
                print(""G: "", str(G))
                print(""Gs: "", str(Gs))
                break

    if already_paired.sum() < H - 1:
        print('NO')
        return

    elif already_paired.sum() == H - 1:
        for i in range(H):
            if already_paired[i] == 0:
                G = pair_graph(S[i], S[i])
                Gs.append(G)
                print(""G: "", str(G))
                print(""Gs: "", str(Gs))
                break

    G = np.array(Gs).sum(axis=0) // len(Gs)
    print(""G: "", str(G))

    def is_perfect_matching(G):
        N = len(G)
        print(""N: "", str(N))
        if N == 1:
            return True

        for i in range(N):
            for j in range(i+1, N):
                if G[i, j] == 1:
                    l = list(range(N))
                    l.remove(i)
                    l.remove(j)
                    print(""l: "", str(l))
                    if len(l) == 0:
                        return True
                    if is_perfect_matching(G[l][:, l]):
                        return True
        return False

    if is_perfect_matching(G):
        print('YES')
    else:
        print('NO')

def __starting_point():
    _3()
__starting_point()
</ans>",0,{}
63,"<ans>
import sys
readline = sys.stdin.readline

def accumulate2d(X):
    N = len(X)
    print(""N: "", str(N))
    M = len(X[0])
    print(""M: "", str(M))
    
    for i in range(0, N):
        for j in range(1, M):
            X[i][j] += X[i][j-1]
    
    for j in range(0, M):
        for i in range(1, N):
            X[i][j] += X[i-1][j]
    
    return X

N, M, Q = map(int, readline().split())
print(""N: "", str(N), ""M: "", str(M), ""Q: "", str(Q))
table = [None]*100
table[ord('R')] = 0
table[ord('G')] = 1
table[ord('B')] = 2
table[ord('Y')] = 3

INF = 10**3
D = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]
print(""D: "", str(D))
G = [[0]*M for _ in range(N)]
print(""G: "", str(G))

BS = 25
print(""BS: "", str(BS))
candi = []
print(""candi: "", str(candi))
geta = M
print(""geta: "", str(geta))
for i in range(N-1):
    for j in range(M-1):
        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:
            G[i][j] = 1
            nh, nw = i, j
            print(""nh: "", str(nh), ""nw: "", str(nw))
            while True:
                k = G[nh][nw]
                fh, fw = nh-k, nw-k
                k2 = 2*(k+1)
                kh = k+1
                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:
                    break
                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\
                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):
                    break
                G[nh][nw] += 1
            if G[nh][nw] > BS:
                candi.append((nh, nw))

 
Gnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]
print(""Gnum: "", str(Gnum))
for h in range(N):
    for w in range(M):
        if G[h][w] > 0:
            for k in range(1, min(BS, G[h][w])+1):
                Gnum[k][h][w] = 1
                print(""Gnum[{}][{}][{}]: "".format(k, h, w), str(Gnum[k][h][w]))

Gnum = [None] + [accumulate2d(g) for g in Gnum[1:]]
print(""Gnum: "", str(Gnum))


Ans = [None]*Q
print(""Ans: "", str(Ans))
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())
    print(""h1: "", str(h1), ""w1: "", str(w1), ""h2: "", str(h2), ""w2: "", str(w2))
    res = 0
    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+k-1, w1+k-1
        he, we = h2-k, w2-k
        print(""hs: "", str(hs), ""ws: "", str(ws), ""he: "", str(he), ""we: "", str(we))
        if hs <= he and ws <= we:
            cnt = Gnum[k][he][we]
            if hs:
                cnt -= Gnum[k][hs-1][we]
            if ws:
                cnt -= Gnum[k][he][ws-1]
            if hs and ws:
                cnt += Gnum[k][hs-1][ws-1]
            if cnt:
                res = k
                break
    
    for nh, nw in candi:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))
    Ans[qu] = 4*res**2
    print(""Ans[{}]: "".format(qu), str(Ans[qu]))
print('\n'.join(map(str, Ans)))
</ans>",0,{}
64,"<ans>
# problem http://codeforces.com/contest/1100/problem/E
import copy
import sys


def find_loop(g, w, k, n):
    visited = [False] * n
    visited_int = [False] * n
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False


def top_sort(g, w, k, n):
    visited = [False] * n
    order = [-1] * n
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        path = [i]
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in list(w.items()):
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse


def __starting_point():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    w = {}
    g = [[] for _ in range(n)]
    print(""g: "", str(g))
    w_tmp = {}
    print(""w_tmp: "", str(w_tmp))
    c_m = 0
    kk = [0]
    print(""kk: "", str(kk))
    lines = sys.stdin.readlines()
    for i, line in enumerate(lines): #range(1, m + 1):
        u, v, c = list(map(int, line.split()))
        print(""u: "", str(u), ""v: "", str(v), ""c: "", str(c))
        g[u - 1].append(v - 1)
        print(""g: "", str(g))
        if (u - 1, v - 1) in list(w.keys()):
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
            print(""w: "", str(w))
        else:
            w[(u - 1, v - 1)] = c
            print(""w: "", str(w))
        if (u - 1, v - 1) in list(w_tmp.keys()):
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
            print(""w_tmp: "", str(w_tmp))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
            print(""w_tmp: "", str(w_tmp))
        kk.append(c)
        print(""kk: "", str(kk))
        # c_m = max(c, c_m)

    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))

    kk.sort()
    print(""kk after sort: "", str(kk))
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        return
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
        print(""kkk: "", str(kkk))
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]
        print(""kkk: "", str(kkk))

    to_reverse = top_sort(g, w, kkk, n)
    print(""to_reverse: "", str(to_reverse))
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))






__starting_point()
</ans>",0,{}
65,"<ans>
a = list(map(int,input().split()))
print(""a: "", str(a))
b = [0,0,0,0,0];
print(""b: "", str(b))
c = [0,0,0,0,0];
print(""c: "", str(c))
ipt = [];
print(""ipt: "", str(ipt))
ans = [];
print(""ans: "", str(ans))
d = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}
print(""d: "", str(d))

n = int(input())
print(""n: "", str(n))

for i in range(1,n+1) :
    j = input()
    ipt.append(j)
    print(""j: "", str(j))
    print(""ipt: "", str(ipt))
    ans.append(j)
    print(""ans: "", str(ans))
    if j.find(',') == -1 :
        a[d[j]] -= 1
        print(""a: "", str(a))
    else :
        b[d[j[0:j.find(',')]]] += 1
        print(""b: "", str(b))

ans = False;
print(""ans: "", str(ans))

for i in range(0,6) :
    if (a[i] < 0) and ans == False:
        ans = True
        print(""ans: "", str(ans))
    elif i < 5:
        if i==0 :
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                print(""c: "", str(c))
                b[i] -= a[i];
                print(""b: "", str(b))
                a[i] = 0;
                print(""a: "", str(a))
            else :
                c[i] = 0;
                print(""c: "", str(c))
                a[i] -= b[i];
                print(""a: "", str(a))
                b[i] = 0;
                print(""b: "", str(b))
                
        else :
            if b[i-1] > 0 :
                if b[i-1] > a[i] :
                    ans = True
                    print(""ans: "", str(ans))
                else :
                    a[i] -= b[i-1];
                    print(""a: "", str(a))
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                print(""c: "", str(c))
                b[i] -= a[i];
                print(""b: "", str(b))
                a[i] = 0;
                print(""a: "", str(a))
            else :
                c[i] = 0;
                print(""c: "", str(c))
                a[i] -= b[i];
                print(""a: "", str(a))
                b[i] = 0;
                print(""b: "", str(b))
    elif i==5 :
        if a[i] < b[i-1]:
            ans = True
            print(""ans: "", str(ans))
                
if ans == True :
    print(""NO"");

else :
    print(""YES"")
    for i in ipt :
        if i.find(',') == -1 :
            print(i)
        else :
            tmp = i[0:i.find(',')];
            print(""tmp: "", str(tmp))
            if (c[d[tmp]] > 0) :
                print(i[i.find(',')+1:])
                c[d[tmp]] -= 1
                print(""c: "", str(c))
            else :
                print(tmp)
</ans>",0,{}
66,"<ans>
n, m = list(map(int, input().split()))
print(""n: "", str(n), ""m: "", str(m))
A = list(map(int, input().split()))
print(""A: "", str(A))
if n > 300:
    lst = []
    print(""lst: "", str(lst))
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        lst.append([a, b])
    print(""lst: "", str(lst))
    answer = 0
    print(""answer: "", str(answer))
    answer_1 = []
    print(""answer_1: "", str(answer_1))
    m300 = [[-1, -10**6]]
    print(""m300: "", str(m300))
    for i in range(max(0, m-1)):
        m300.append([-1, -10**6])
    print(""m300: "", str(m300))
    for u in range(n):
        if A[u] > min(m300)[1]:
            m300[m300.index(min(m300))] = [u, A[u]]
            print(""m300: "", str(m300))
    for i, mi in m300:
        B = A.copy()
        print(""B: "", str(B))
        kek = []
        print(""kek: "", str(kek))
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            print(""a: "", str(a), ""b: "", str(b))
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
                print(""B: "", str(B))
        elem = max(B)
        print(""elem: "", str(elem))
        if answer < elem - mi:
            answer = elem - mi
            print(""answer: "", str(answer))
            answer_1 = kek.copy()
            print(""answer_1: "", str(answer_1))
    print(answer)
    print(len(answer_1))
    print(' '.join(map(str, answer_1)))
else:
    lst = []
    print(""lst: "", str(lst))
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        lst.append([a, b])
    print(""lst: "", str(lst))
    answer = 0
    print(""answer: "", str(answer))
    answer_1 = []
    print(""answer_1: "", str(answer_1))
    for i in range(n):
        B = A.copy()
        print(""B: "", str(B))
        kek = []
        print(""kek: "", str(kek))
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            print(""a: "", str(a), ""b: "", str(b))
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
                print(""B: "", str(B))
        elem = max(B)
        print(""elem: "", str(elem))
        if answer < elem - B[i]:
            answer = elem - B[i]
            print(""answer: "", str(answer))
            answer_1 = kek.copy()
            print(""answer_1: "", str(answer_1))
    print(answer)
    print(len(answer_1))
    print(' '.join(map(str, answer_1)))
</ans>",1,{}
67,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    print(""ans: "", str(ans))
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True
#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b
#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag
#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)
#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)
#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""
#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1
#####quadratic#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        print(""ans1: "", str(ans1), ""ans2: "", str(ans2))
        return [int(ans1),int(ans2)]
    return -1
#####taking an array/list as input#####
def inp():
    ls=list(map(int,input().split()))
    return ls
#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))
#####Main function starts from here#####
n=int(input())
print(""n: "", str(n))
d={}
while(n%2==0):
    if 2 in d:
        d[2]+=1
    else:
        d[2]=1
    n/=2
for i in range(3,int(n**0.5)+1,2):
    while(n%i==0):
        if i in d:
            d[i]+=1
        else:
            d[i]=1
        n/=i
n=int(n)
if n>1:
    d[n]=1
n=1
#print(d,n)
ans=0
for i in d:
    c=-2*d[i]
    a=b=1
    print(""c: "", str(c), ""a: "", str(a), ""b: "", str(b))
    ls=qdrt(a,b,c)
    if ls[0]>=0:
        ans+=ls[0]
    elif ls[1]>=0:
        ans+=ls[1]
print(""ans: "", str(ans))
</ans>",0,{}
68,"<ans>
from statistics import median
import collections
from math import gcd
from itertools import combinations, permutations, accumulate, product, combinations_with_replacement
from collections import deque, defaultdict, Counter
import decimal
import re
import math
import bisect
import heapq
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
INF = float('inf')
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
from sys import stdin
readline = stdin.readline
def readInts():
    return list(map(int, readline().split()))
def readTuples():
    return tuple(map(int, readline().split()))
def I():
    return int(readline())
N, S = input().split()
print(""N: "", str(N), ""S: "", str(S))
N = int(N)
print(""N: "", str(N))
ans = 0
print(""ans: "", str(ans))
for i in range(N):
    a = 0; t = 0; c = 0; g = 0;
    print(""a: "", str(a), ""t: "", str(t), ""c: "", str(c), ""g: "", str(g))
    for j in range(i, N):
        if S[j] == 'A':
            a += 1
            print(""a: "", str(a))
        elif S[j] == 'T':
            t += 1
            print(""t: "", str(t))
        elif S[j] == 'C':
            c += 1
            print(""c: "", str(c))
        else:
            g += 1
            print(""g: "", str(g))
        if a == t and c == g:
            ans += 1
            print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
69,"<ans>
from collections import deque
import math
    
def dfs(edges, s):
    stack = deque([s])
    print(""stack: "", str(stack))
    used  = {s}
    print(""used: "", str(used))
    while stack:
        x = stack.pop()
        print(""x: "", str(x))
        for y in edges[x]:
            if y not in used:
                used.add(y)
                print(""used: "", str(used))
                stack.append(y)
    return used


def bfs(edges, s):
    queue = deque([s])
    print(""queue: "", str(queue))
    used  = {s}
    print(""used: "", str(used))
    while queue:
        x = queue.popleft()
        print(""x: "", str(x))
        for y in edges[x]:
            if y in used:
                continue
            used.add(y)
            print(""used: "", str(used))
            queue.append(y)
    return used
    

def bellman(dist):  #負辺があるケースでの、スタートからゴールへの最短路を求めるアルゴ。
    cost = [float(""inf"")] * n
    print(""cost: "", str(cost))
    cost[0] = 0
    print(""cost: "", str(cost))
    for _ in range(n): #頂点の個数の分だけ回る
        updated = False
        print(""updated: "", str(updated))
        for u,v,c in dist: #辺の個数の分だけ回る
            if cost[u] + c < cost[v]:
                cost[v] = cost[u] + c
                print(""cost[v]: "", str(cost[v]))
                updated = True                
        print(""updated: "", str(updated))
    #収束しない場合は負閉路があるため無限に小さくできる。
    if updated==True:
        return -1
    else:
        return max(0, cost[n-1]*-1)    
        

n,m,p = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""p: "", str(p))
dist  = []
print(""dist: "", str(dist))
edge1 = [[] for _ in range(n)]
print(""edge1: "", str(edge1))
edge2 = [[] for _ in range(n)]  # rev_edge
print(""edge2: "", str(edge2))
for _ in range(m):
    u,v,c = map(int, input().split())
    u -= 1
    v -= 1
    dist.append((u,v,(c-p)*-1))
    print(""dist: "", str(dist))
    edge1[u].append(v)
    print(""edge1: "", str(edge1))
    edge2[v].append(u)
    print(""edge2: "", str(edge2))    
    
use = dfs(edge1, 0) & dfs(edge2, n-1)
print(""use: "", str(use))
dist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]
print(""dist2: "", str(dist2))
print(bellman(dist2))
</ans>",1,{}
70,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        print(""self.nodes: "", str(self.nodes))
        self.adj_list={}
        print(""self.adj_list: "", str(self.adj_list))
        self.is_directed=is_directed
        print(""self.is_directed: "", str(self.is_directed))
 
        for node in self.nodes:
            self.adj_list[node]=[]
            print(""self.adj_list[{}]: "".format(node), str(self.adj_list[node]))
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        print(""self.adj_list[{}]: "".format(u), str(self.adj_list[u]))
        if self.is_directed==False:
            self.adj_list[v].append(u)
            print(""self.adj_list[{}]: "".format(v), str(self.adj_list[v]))
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        print(""visited[{}]: "".format(v), str(visited[v]))
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        print(""visited: "", str(visited))
        parents=[v]
        print(""parents: "", str(parents))
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    print(""ans: "", str(ans))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    print(""temp: "", str(temp))
    a=b
    print(""a: "", str(a))
    b=temp
    print(""b: "", str(b))
    return a,b

#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    print(""flag: "", str(flag))
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    print(""d: "", str(d))
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    print(""chk: "", str(chk))
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        print(""ans1: "", str(ans1))
        ans2=(-b-chk**0.5)/(2*a)
        print(""ans2: "", str(ans2))
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    print(""ans: "", str(ans))
    for i in range(n-r+1,n+1):
        ans*=i
        print(""ans: "", str(ans))
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    print(""ans: "", str(ans))
    for i in range(r):
        ans*=(n-i)
        print(""ans: "", str(ans))
    div=1
    for i in range(2,r+1):
        div*=i
        print(""div: "", str(div))
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    return ls

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    n,m=mult_inp()
    print(""n: "", str(n), ""m: "", str(m))
    print((combination(n,2)+combination(m,2)))
def __starting_point():
    main()
    

__starting_point()
</ans>",0,{}
71,"<ans>
import math
import bisect
import sys

def flrt(exp,x):
    l=max(0,math.floor(x**(1/exp))-3)
    print(""l: "", str(l))
    r= math.floor(x**(1/exp))+3
    print(""r: "", str(r))
    while l<r:
        mid=(l+r)//2
        print(""mid: "", str(mid))
        if mid**exp<=x:
            l=mid+1
            print(""l: "", str(l))
        else: 
            r=mid
            print(""r: "", str(r))
    return l-1
   
    
def c1(r):
    ans=set()
    print(""ans: "", str(ans))
    pr = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
    print(""pr: "", str(pr))
    for i in pr:
        x=2
        print(""x: "", str(x))
        while x**i <= r:
            val=x**i
            print(""val: "", str(val))
            b2=flrt(2,val)
            b3=flrt(3,val)
            if b2**2 != val and b3**3 != val:
                ans.add(val)
                print(""ans: "", str(ans))
            x+=1
            print(""x: "", str(x))
    return ans
    
def solve(r, pc):
    if r==0:
        return 0
    
    a=[2,3]
    print(""a: "", str(a))
    ans=0
    for i in range(1,2**len(a)):
        tot=0
        mult=1
        for j,x in enumerate(a):
            if i&(1<<j):
                mult*=x
                print(""mult: "", str(mult))
                tot+=1
                print(""tot: "", str(tot))
        d=  flrt(mult,r)      
        ans+= d if tot%2 else -d
        print(""ans: "", str(ans))
        
    return ans + bisect.bisect_right(pc,r)    
       
    lp=0 
    rp=len(pc)
    while lp<rp:
        mid = (lp+rp)//2
        print(""mid: "", str(mid))
        if pc[mid] <= r:
            lp = mid+1
            print(""lp: "", str(lp))
        else:
            rp = mid
            print(""rp: "", str(rp))
        
    
    return ans + lp
q = int(input())

pc= c1(1e18+1)
print(""pc: "", str(pc))

pca=list(pc)
print(""pca: "", str(pca))
pca.sort()
print(""pca: "", str(pca))
        
 
for i in range(q):
    l,r = [int(x) for x in sys.stdin.readline().split()]
    print(""l: "", str(l), ""r: "", str(r))
    ans=solve(r,pca)-solve(l-1,pca)
    sys.stdout.write(str(ans)+'\n')
</ans>",0,{}
72,"<ans>
'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return list(map(int,input().split()))
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')





def solve():
    
    n,m,w=mi()
    print(""n: "", str(n), ""m: "", str(m), ""w: "", str(w))
    a=li()
    print(""a: "", str(a))
    
    def fessible(mid):
        
        b=[0]*n
        print(""b: "", str(b))
        moves=0
        if(a[0]<mid):
            b[0]+=(mid-a[0])
            if(w<n):
                b[w]-=(mid-a[0])
            moves+=(mid-a[0])
            if(moves>m):
                return 0
        for i in range(1,n):
            b[i]+=b[i-1]
            x=a[i]+b[i]
            if(x<mid):
                b[i]+=(mid-x)
                if(i+w<n):
                    b[i+w]-=(mid-x)
                moves+=(mid-x)
            if(moves>m):
                return 0
        return 1
            
        
    
    l=1
    r=1e10
    print(""l: "", str(l), ""r: "", str(r))
    while(l<=r):
        mid=l+(r-l)//2
        print(""mid: "", str(mid))
        if(fessible(mid)):
            l=mid+1
            ans=mid
            print(""l: "", str(l), ""ans: "", str(ans))
        else:
            r=mid-1
            print(""r: "", str(r))
    print(int(ans))
        
    
    
    
        
        
def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
73,"<ans>
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

S=lambda x:sum(map(int,str(x)))

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	z=S(x)%a
	print(""z: "", str(z))
	if z:
		z=a-z
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(z,9-int(digit))
			z-=diff
			tail.append(str(int(digit)+diff))
			if z==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert S(x)%a==0
	x=int(x)
	print(""x: "", str(x))
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	print(""a: "", str(a))
	while a%5==0: a//=5
	return a==1

def solve(a):
	for first in range(1,60): # 120
		q=str((first*10**3000+a-1) // a) # 5000
		print(""q: "", str(q))
		for s1 in range(1,200):
			i=1
			s2=int(q[0])
			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				print(""small: "", str(small))
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,a)
					if S(small*a)*a==S(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

if 0:
	#for a in (a for a in range(2,1000)):
	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
	#for a in [32]:

		def work():
			nonlocal x
			x=solve(a)

		t=timeit(work,number=1)
		if t>0.5 or x==None:
			if x!=None:
				print(a,t,'>>',powform(a*x))
			else:
				print(a,t,'>> ?????')

	#print(solve(int(input())))


special='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104
582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003
636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5475810970001476 >> 2 * 10 ** 2140 + 439
64 0.5633312410000144 >> ?????
200 0.5639609099998779 >> ?????
100 0.565854023000611 >> ?????
125 0.5663040710005589 >> ?????
160 0.5668467480008985 >> ?????
800 0.5676178080002501 >> ?????
128 0.5676772269998764 >> ?????
80 0.5682811480000964 >> ?????
256 0.5685735130000467 >> ?????
250 0.5691464900000938 >> ?????
512 0.569266141999833 >> ?????
32 0.5692826909998985 >> ?????
50 0.5692834940000466 >> ?????
25 0.5696684799995637 >> ?????
400 0.5703751219998594 >> ?????
20 0.5706145570002263 >> ?????
500 0.5742691679997733 >> ?????
640 0.5749700739997934 >> ?????
40 0.5768258159996549 >> ?????
625 0.5775357299999087 >> ?????
16 0.5789494729997386 >> ?????
833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008
320 0.6031684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.045185064999714 >> 22 * 10 ** 1822 + 1130
990 6.413724044000446 >> 39 * 10 ** 2970 + 302010
666 6.967028857000514 >> 33 * 10 ** 2997 + 32934
941 6.982767053000316 >> 21 * 10 ** 1885 + 312
924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152
858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142
939 8.241953895999359 >> 33 * 10 ** 1879 + 20001
813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314
921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008
831 1.683305384999585 >> 1 * 10 ** 3702 + 1646
846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234
888 6.891388972000641 >> 3 * 10 ** 3998 + 27672
909 11.340291348999926 >> 7 * 10 ** 4673 + 17201
957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403
933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234
891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079
783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814
999 102.2252583720001 >> 89 * 10 ** 4760 + 20071
777 37.847382832999756 >> 24 * 10 ** 4661 + 474123
855 0.934857464999368 >> 1 * 10 ** 3420 + 21545
942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058
807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123
'''

a=int(input())
print(""a: "", str(a))
for line in special.splitlines():
	if line:
		expr,out=line.split('>>')
		expr=expr.split()[0]
		if int(expr)==a:
			print(-1 if out.strip()=='?????' else eval(out)//a)
			break
else:
	print(solve(a))
</ans>",0,{}
74,"<ans>
from collections import deque
from sys import stdin

#parser
def parser():
    return map(int, stdin.readline().split())

def DFS_Discriminiting():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    print(""stack: "", str(stack))
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                if attacked_city[u]:
                    count_attacked_cities_subtree[u]+=1
                stack.append(u)
                intrudoction_order.append(u)    
    for v in intrudoction_order[::-1]:
        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]
        if count_attacked_cities_subtree[v]==0:
            important_cities[v]=False

def DFS_Heigths():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    print(""stack: "", str(stack))
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                stack.append(u)
                intrudoction_order.append(u)
    for v in intrudoction_order[::-1]:
        if heights1[pi[v]] < heights1[v]+1:
            heights2[pi[v]]=heights1[pi[v]]
            heights1[pi[v]]=heights1[v]+1
        elif heights2[pi[v]]<heights1[v]+1:
            heights2[pi[v]]=heights1[v]+1

def Distance_Root(s):
    for v in adjacents_list[s]:
        if heights1[v]+1>distances1[s]:
            distances2[s]=distances1[s]
            distances1[s]=heights1[v]+1

def DFS_Distances():
    #visitados
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    visited[numbers_of_attacked_cities[0]]=True
    stack=[]
    stack.append(numbers_of_attacked_cities[0])
    Distance_Root(numbers_of_attacked_cities[0])
    while len(stack)>0:
        v=stack.pop()
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                determinate=False
                stack.append(u)
                if heights1[u]+1==distances1[v]:
                    if heights1[u]+1>distances2[v]:
                        determinate=True
                        distances1[u]=max(heights1[u],distances2[v]+1)
                        if distances1[u]==heights1[u]:
                            distances2[u]=max(distances2[v]+1,heights2[u])
                        else:
                            distances2[u]=heights1[u]
                if not determinate:
                    distances1[u]=distances1[v]+1
                    distances2[u]=heights1[u]

def BFS(s):
    distance=[-1 for x in range(n)]
    print(""distance: "", str(distance))
    distance[s]=0
    q=deque()
    q.append(s)
    while len(q)>0:
        v=q.popleft()
        for u in adjacents_list[v]:
            if distance[u] == -1:
                distance[u]=distance[v]+1
                q.append(u)
    return distance


n,m=parser()
print(""n: "", str(n), ""m: "", str(m))
#Creando los arrays necesarios para la ejecucion de DFS
#padres
pi=[0 for x in range(n)]
print(""pi: "", str(pi))
#ciudades atacadas en el subarbol
count_attacked_cities_subtree=[0 for x in range(n)]
print(""count_attacked_cities_subtree: "", str(count_attacked_cities_subtree))
#ciudad atacada o no atacada
attacked_city=[False for x in range(n)]
print(""attacked_city: "", str(attacked_city))
#ciudades_que_son atacadas o sirven para llegar a las mismas
important_cities=[True for x in range(n)]
print(""important_cities: "", str(important_cities))

adjacents_list=[[] for x in range(n)]
print(""adjacents_list: "", str(adjacents_list))
for i in range(n-1):
    v1,v2=parser()
    adjacents_list[v1-1].append(v2-1)
    adjacents_list[v2-1].append(v1-1)

#numero de ciudades atacadas
numbers_of_attacked_cities=[x-1 for x in parser()]
print(""numbers_of_attacked_cities: "", str(numbers_of_attacked_cities))

if m==1:
    print(numbers_of_attacked_cities[0]+1)
    print(0)
    return

#marcando las ciudades atacadas
for i in numbers_of_attacked_cities:
    attacked_city[i]=True

DFS_Discriminiting()

adjacents_list=[[] for x in range(n)]
print(""adjacents_list: "", str(adjacents_list))

count_edges=0
for v in range(n):
    if v==numbers_of_attacked_cities[0]:
        continue
    elif important_cities[v] and important_cities[pi[v]]:
        adjacents_list[v].append(pi[v])
        adjacents_list[pi[v]].append(v)
        count_edges+=1
print(""count_edges: "", str(count_edges))

#padres
pi=[0 for x in range(n)]
print(""pi: "", str(pi))

#alturas
heights1=[0 for x in range(n)]
print(""heights1: "", str(heights1))
heights2=[0 for x in range(n)]
print(""heights2: "", str(heights2))

DFS_Heigths()

#distances
distances1=[0 for x in range(n)]
print(""distances1: "", str(distances1))
distances2=[0 for x in range(n)]
print(""distances2: "", str(distances2))

DFS_Distances()

lower=distances1[numbers_of_attacked_cities[0]]
print(""lower: "", str(lower))
for i in range(n):
    if important_cities[i] and lower>distances1[i]:
        lower=distances1[i]

centers=[]
for i in range(n):
    if distances1[i]==lower:
        centers.append(i)
print(""centers: "", str(centers))


posibles_begin_cities=[]

for i in centers:
    distances_center=BFS(i)
    print(""distances_center: "", str(distances_center))
    max_distance=0
    for j in range(n):
        if distances_center[j]>max_distance:
            max_distance=distances_center[j]
    for j in range(n):
        if distances_center[j]==max_distance:
            posibles_begin_cities.append(j)
print(""posibles_begin_cities: "", str(posibles_begin_cities))


print(min(posibles_begin_cities)+1)

print(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))
</ans>",0,{}
75,"<ans>
from copy import deepcopy
n, k, m, a = [int(i) for i in input().split()]
print(""n: "", str(n), ""k: "", str(k), ""m: "", str(m), ""a: "", str(a))
cn = [0] * (n + 1)
print(""cn: "", str(cn))
last = [-1] * (n + 1)
print(""last: "", str(last))
v = [int(i) for i in input().split()]
print(""v: "", str(v))

for i in range(len(v)):
    last[v[i]] = i
    print(""last: "", str(last))
    cn[v[i]] += 1
    print(""cn: "", str(cn))

cn1 = deepcopy(cn)
print(""cn1: "", str(cn1))
last1 = deepcopy(last)
print(""last1: "", str(last1))

for i in range(1, n + 1):
    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last))
    res = [i1 for i1 in range(1, n + 1)]
    print(""res: "", str(res))
    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    
    for j in range(len(res)):
        if res[j] != i:
            continue
        j1 = j + 1
        lft = m - a
        print(""lft: "", str(lft))
        while j1 < n and lft:
            pls = min(lft, cn[i] - cn[res[j1]] + 1)
            print(""pls: "", str(pls))
            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)
            print(""cn: "", str(cn))
            last[res[j1]] = m
            print(""last: "", str(last))
            lft -= pls
            j1 += 1

    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    sans = 0
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break

    if sans == 1:
        print(1, end= ' ')
        continue
    
    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last))

    if m - a:
        cn[i] += m - a
        print(""cn: "", str(cn))
        last[i] = m - 1
        print(""last: "", str(last))

    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break
    
    if sans:
        print(2, end=' ')
    else:
        print(3, end=' ')
</ans>",0,{}
76,"<ans>
def indeksTurun(a):
	for x in range(len(a)-1):
		if a[x] > a[x+1]:
			return x+1
			pass
		pass
	return -1
	pass

def menaik(a,i1):
	for x in range(i1,len(a)-1):
		if a[x] > a[x+1]:
			return False
			pass
		pass
	return True
	pass

a=input()
a=list(map(int,input().split("" "")))
print(""a: "", str(a))

if len(a) == 1:
	print (""yes"")
	print (""1 1"")
else:
	reversed_indeks1=-1
	print(""reversed_indeks1: "", str(reversed_indeks1))
	for x in range(len(a)-1):
		if a[x] > a[x+1]:
			reversed_indeks1=x
			print(""reversed_indeks1: "", str(reversed_indeks1))
			break
			pass
		pass
	if reversed_indeks1 == -1:
		print (""yes"")
		print (""1 1"")
	else:
		reversed_indeks2=len(a)-1
		print(""reversed_indeks2: "", str(reversed_indeks2))
		for x in range(reversed_indeks1,len(a)-1):
			if a[x] < a[x+1]:
				reversed_indeks2=x
				print(""reversed_indeks2: "", str(reversed_indeks2))
				break
		asc=True
		print(""asc: "", str(asc))
		if reversed_indeks2 != len(a)-1:
			asc=menaik(a,reversed_indeks2+1)
			print(""asc: "", str(asc))
		if asc:
			kiri=True
			kanan=True
			print(""kiri: "", str(kiri))
			print(""kanan: "", str(kanan))
			if reversed_indeks1 != 0:
				if a[reversed_indeks2] < a[reversed_indeks1-1]:
					kiri=False
					print(""kiri: "", str(kiri))
					pass
			if reversed_indeks2 != len(a)-1:
				if a[reversed_indeks1] > a[reversed_indeks2+1]:
					kanan=False
					print(""kanan: "", str(kanan))
					pass
				pass
				pass
			if kiri and kanan:
				print (""yes"")
				print (""%d %d""%(reversed_indeks1+1,reversed_indeks2+1))
				pass
			else:
				print (""no"")
		else:
			print (""no"")
			pass
	pass
</ans>",0,{}
77,"<ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
    if i == 2 * n + 1:
        nonlocal ans
        ans = ""Yes""
        return
    if ans == ""No"":
        if y[i] == 0:
            for k in range(1, n):
                if ok(k, i):
                    dfs(i + 2 * k)
        else:
            if ok(y[i], i):
                dfs(i + 2 * y[i])
    return

def ok(k, i):
    if k + i >= 2 * n + 1:
        return 0
    f = 1
    print(""f: "", str(f))
    for l in range(k):
        if k + i + l >= 2 * n + 1:
            f = 0
            print(""f: "", str(f))
            break
        if x[i + l] == 2 or x[k + i + l] == 1:
            f = 0
            print(""f: "", str(f))
            break
        if not (y[i + l] == 0 or y[i + l] == k):
            f = 0
            print(""f: "", str(f))
            break
        if not z[i + l] == z[k + i + l] and min(z[i + l], z[k + i + l]) >= 1:
            f = 0
            print(""f: "", str(f))
            break
    return f

n = int(input())
print(""n: "", str(n))
ans = ""Yes""
print(""ans: "", str(ans))
x = [0] * (2 * n + 2)
print(""x: "", str(x))
y = [0] * (2 * n + 2)
print(""y: "", str(y))
z = [0] * (2 * n + 2)
print(""z: "", str(z))
for i in range(1, n + 1):
    a, b = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b))
    if a >= b and not (a == -1 or b == -1):
        ans = ""No""
        print(""ans: "", str(ans))
    if not (x[a] == 0 and x[b] == 0):
        ans = ""No""
        print(""ans: "", str(ans))
    if not a == -1:
        x[a] = 1
        print(""x: "", str(x))
        z[a] = i
        print(""z: "", str(z))
    if not b == -1:
        x[b] = 2
        print(""x: "", str(x))
        z[b] = i
        print(""z: "", str(z))
    if not (a == -1 or b == -1):
        y[a] = b - a
        print(""y: "", str(y))
if ans == ""No"":
    print(ans)
    return
ans = ""No""
print(""ans: "", str(ans))
dfs(1)
print(ans)
</ans>",1,{}
78,"<ans>
n, m = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m))

t = [0] * (n + 1)
print(""t: "", str(t))
p = [0] * (n + 1)
print(""p: "", str(p))
q = [[] for i in range(n + 1)] 
print(""q: "", str(q))

def f(x):
    for i in q[x]:
        u, v = i[0], i[1]
        if t[u] and t[v]: continue
        if t[u] and not t[v]:
            t[v] = 7 - t[x] - t[u]
            print(""t[v]: "", str(t[v]))
            for j in q[v]:
                p[j[0]] |= t[v]
                print(""p[j[0]]: "", str(p[j[0]]))
                p[j[1]] |= t[v]
                print(""p[j[1]]: "", str(p[j[1]]))
            #f(u)
            f(v)
        elif not t[u] and t[v]:
            t[u] = 7 - t[x] - t[v]
            print(""t[u]: "", str(t[u]))
            for j in q[u]:
                p[j[0]] |= t[u]
                print(""p[j[0]]: "", str(p[j[0]]))
                p[j[1]] |= t[u]
                print(""p[j[1]]: "", str(p[j[1]]))
            f(u)
            #f(v)
        else:
            for k in [1, 2, 4]:                
                t[u], t[v] = k, 7 - t[x] - k
                print(""t[u]: "", str(t[u]), ""t[v]: "", str(t[v]))
                if not (p[u] & t[u] or p[v] & t[v]): break                    
            
            for j in q[v]:
                p[j[0]] |= t[v]
                print(""p[j[0]]: "", str(p[j[0]]))
                p[j[1]] |= t[v]
                print(""p[j[1]]: "", str(p[j[1]]))                
            for j in q[u]:
                p[j[0]] |= t[u]
                print(""p[j[0]]: "", str(p[j[0]]))
                p[j[1]] |= t[u]
                print(""p[j[1]]: "", str(p[j[1]]))
            f(u)
            f(v)

if m == 49999:
    for j in range(m):
        a, b, c = map(int, input().split())
        print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
        x = t[a] | t[b] | t[c]
        print(""x: "", str(x))
        for i in (a, b, c):
            if not t[i]:
                if not x & 1: t[i] = 1; x += 1; print(""t[i]: "", str(t[i]), ""x: "", str(x))
                elif not x & 2: t[i] = 2; x += 2; print(""t[i]: "", str(t[i]), ""x: "", str(x))
                else: t[i] = 4; print(""t[i]: "", str(t[i]))
else:           
    for i in range(m):
        a, b, c = map(int, input().split())
        print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

        q[a].append((b, c))
        print(""q[a]: "", str(q[a]))
        q[b].append((a, c))
        print(""q[b]: "", str(q[b]))
        q[c].append((a, b))
        print(""q[c]: "", str(q[c]))
        
    for x in range(1, n + 1):
        if not t[x]:
            t[x] = 1
            print(""t[x]: "", str(t[x]))
            for j in q[x]:
                p[j[0]] |= 1
                print(""p[j[0]]: "", str(p[j[0]]))
                p[j[1]] |= 1
                print(""p[j[1]]: "", str(p[j[1]]))
            f(x)
        
p = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(""p: "", str(p))
print(''.join(p[x] for x in t[1:]))
</ans>",0,{}
79,"<ans>
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 missingdays <missingdays@missingdays>
#
# Distributed under terms of the MIT license.

""""""

""""""

def good(nums):
    for num in nums:
        if nums[num] > 1:
            return True
    return False

n = int(input())
print(""n: "", str(n))

a = [int(i) for i in input().split()]
print(""a: "", str(a))

s = []
print(""s: "", str(s))

l, r = 0, 0
print(""l: "", str(l), ""r: "", str(r))

nums = {}
print(""nums: "", str(nums))

for i in range(n):
    num = a[i]
    print(""num: "", str(num))

    if num in nums:
        break
    else:
        nums[num] = True
        print(""nums: "", str(nums))

else:
    print(-1)
    return

nums = {}
print(""nums: "", str(nums))

while r < n:
    while r < n:
        num = a[r]
        print(""num: "", str(num))

        if num in nums:
            r += 1
            break
        else:
            nums[num] = True
            print(""nums: "", str(nums))

        r += 1

    r -= 1

    s.append([l, r])
    print(""s: "", str(s))
    r += 1
    l = r
    print(""l: "", str(l))

    nums = {}
    print(""nums: "", str(nums))

length = len(s)
print(""length: "", str(length))

last = s[length-1]
print(""last: "", str(last))

for i in range(last[0], last[1]+1):
    num = a[i]
    print(""num: "", str(num))
    if num in nums:
        print(length)
        break
    else:
        nums[num] = True
        print(""nums: "", str(nums))

else:
    s.pop()
    print(""s: "", str(s))

    s[length-2][1] = n-1
    print(""s[length-2][1]: "", str(s[length-2][1]))

    print(length-1)

for st in s:
    for c in st:
        print(c+1, end="" "")
    print()
</ans>",1,{}
80,"<ans>
import sys
input = sys.stdin.readline


G0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
G1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
G2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]


for x in range(1,6):
    for y in range(1,6):
        for z in range(1,6):
            
            for i in range(1,5500):
                s=G0[x][y][z][max(0,i-x)]
                print(""s: "", str(s))
                t=G1[x][y][z][max(0,i-y)]
                print(""t: "", str(t))
                u=G2[x][y][z][max(0,i-z)]
                print(""u: "", str(u))

                for j in range(5):
                    if j==s or j==t or j==u:
                        continue
                    else:
                        G0[x][y][z][i]=j
                        print(""G0[{}][{}][{}][{}]: "".format(x, y, z, i), str(G0[x][y][z][i]))
                        break

                for j in range(5):
                    if j==s or j==u:
                        continue
                    else:
                        G1[x][y][z][i]=j
                        print(""G1[{}][{}][{}][{}]: "".format(x, y, z, i), str(G1[x][y][z][i]))
                        break

                for j in range(5):
                    if j==s or j==t:
                        continue
                    else:
                        G2[x][y][z][i]=j
                        print(""G2[{}][{}][{}][{}]: "".format(x, y, z, i), str(G2[x][y][z][i]))
                        break

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

t=int(input())
print(""t: "", str(t))
for tests in range(t):
    n,x,y,z=list(map(int,input().split()))
    print(""n: "", str(n), ""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
    B=list(map(int,input().split()))
    print(""B: "", str(B))
    A=[]
    for a in B:
        if a<=5400:
            A.append(a)
        else:
            A.append(a%2520+2520)

    print(""A: "", str(A))
    XOR=0

    for a in A:
        XOR^=G0[x][y][z][a]

    print(""XOR: "", str(XOR))
    ANS=0
    for a in A:
        k=XOR^G0[x][y][z][a]
        print(""k: "", str(k))

        if G0[x][y][z][max(0,a-x)]==k:
            ANS+=1

        if G1[x][y][z][max(0,a-y)]==k:
            ANS+=1

        if G2[x][y][z][max(0,a-z)]==k:
            ANS+=1

    print(""ANS: "", str(ANS))
    print(ANS)

</ans>",0,{}
81,"<ans>
def dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)
    
x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
print(""x0: "", str(x0), ""y0: "", str(y0), ""a1: "", str(a1), ""a2: "", str(a2), ""b1: "", str(b1), ""b2: "", str(b2))
xs, ys, t = list(map(int, input().split()))
print(""xs: "", str(xs), ""ys: "", str(ys), ""t: "", str(t))
arr = []
print(""arr: "", str(arr))
arr.append((x0, y0))
now1 = x0
print(""now1: "", str(now1))
now2 = y0
print(""now2: "", str(now2))
while (1):
    now1 = a1 * now1 + b1
    print(""now1: "", str(now1))
    now2 = a2 * now2 + b2
    print(""now2: "", str(now2))
    if (now1 < xs or now2 < ys):
        arr.append((now1, now2))
        continue
    arr.append((now1, now2))
    if (dist(now1, now2, xs, ys) > t):
        break
ans = 0
print(""ans: "", str(ans))
N = len(arr)
print(""N: "", str(N))
for i in range(N):
    need = dist(arr[i][0], arr[i][1], xs, ys)
    print(""need: "", str(need))
    if (need > t):
        continue
    left = t - need
    print(""left: "", str(left))
    now = 1
    print(""now: "", str(now))
    flag = 1
    now1 = arr[i][0]
    print(""now1: "", str(now1))
    now2 = arr[i][1]
    print(""now2: "", str(now2))
    for j in range(i - 1, -1, -1):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        print(""d: "", str(d))
        if (d > left):
            flag = 0
            break
        left -= d
        print(""left: "", str(left))
        now1 = arr[j][0]
        print(""now1: "", str(now1))
        now2 = arr[j][1]
        print(""now2: "", str(now2))
        now += 1
        print(""now: "", str(now))
    if (not flag):
        ans = max(ans, now)
        print(""ans: "", str(ans))
        continue
    for j in range(i + 1, N):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        print(""d: "", str(d))
        if (d > left):
            break
        left -= d
        print(""left: "", str(left))
        now1 = arr[j][0]
        print(""now1: "", str(now1))
        now2 = arr[j][1]
        print(""now2: "", str(now2))
        now += 1
        print(""now: "", str(now))
    ans = max(ans, now)
    print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
82,"<ans>
# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random

""""""
created by shhuan at 2017/10/6 22:19

""""""

t0 = time.time()
a, b, c = list(map(int, input().split()))
print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

def ct(a, b):
    if a > b:
        a, b = b, a
        print(""a: "", str(a), ""b: "", str(b))
    L=998244353
    s=1
    sx=1
    print(""s: "", str(s), ""sx: "", str(sx))
    for k in range(1,a+1):
        s = s*(a+1-k)*(b+1-k)//k
        print(""s: "", str(s))
        sx += s % L
    return sx

L=998244353
print(""L: "", str(L))

print(ct(a,b)*ct(a,c)*ct(b,c)%L)

# print(time.time()-t0)

# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]
# for i in range(1, MAXN):
#     p[i][0] = 1
#     for j in range(1, i+1):
#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD
# print(time.time() - t0)
# pre = [0] * MAXN
# pre[0] = 1
# for i in range(1, MAXN):
#     pre[i] = (i*pre[i-1]) % MOD
#
#
# def solve(x, y):
#     ans = 0
#     for k in range(min(x, y)+1):
#         d = pre[k]
#         d = (d*p[x][k]) % MOD
#         d = (d*p[y][k]) % MOD
#         ans = (ans+d) % MOD
#
#     return ans
#
# ans = 1
# ans = (ans * solve(a, b)) % MOD
# ans = (ans * solve(b, c)) % MOD
# ans = (ans * solve(a, c)) % MOD
# print(ans)
#
# print(time.time() - t0)

</ans>",0,{}
83,"<ans>
import sys
from functools import reduce

zz=1
print(""zz: "", str(zz))

sys.setrecursionlimit(10**5)
if zz:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
di=[[-1,0],[1,0],[0,1],[0,-1]]

def fori(n):
	return [fi() for i in range(n)]	
def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x
def ii():
	return input().rstrip()	
def li():
	return [int(xx) for xx in input().split()]
def fli():
	return [float(x) for x in input().split()]	
def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0		
def gi():	
	return [xx for xx in input().split()]
def gtc(tc,ans):
	print((""Case #""+str(tc)+"":"",ans))	
def cil(n,m):
	return n//m+int(n%m>0)	
def fi():
	return int(input())
def pro(a): 
	return reduce(lambda a,b:a*b,a)		
def swap(a,i,j): 
	a[i],a[j]=a[j],a[i]	
def si():
	return list(input().rstrip())	
def mi():
	return 	list(map(int,input().split()))			
def gh():
	sys.stdout.flush()
def isvalid(i,j,n,m):
	return 0<=i<n and 0<=j<m 
def bo(i):
	return ord(i)-ord('a')	
def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)

t=1
print(""t: "", str(t))
uu=t
print(""uu: "", str(uu))

def can(val):
	p=val
	print(""p: "", str(p))
	c=0
	for i in range(n):
		c+=abs(a[i]-p)
		p+=1
	return c	

while t>0:
	t-=1
	print(""t: "", str(t))
	n=fi()
	print(""n: "", str(n))
	a=li()
	print(""a: "", str(a))
	l=-2*max(a)
	print(""l: "", str(l))
	r=2*max(a)
	print(""r: "", str(r))
	mini=10**18
	print(""mini: "", str(mini))
	while l<=r:
		lmid=l+(r-l)//3
		print(""lmid: "", str(lmid))
		rmid=r-(r-l)//3
		print(""rmid: "", str(rmid))
		p1=can(lmid)
		print(""p1: "", str(p1))
		p2=can(rmid)
		print(""p2: "", str(p2))
		mini=min([mini,p1,p2])
		print(""mini: "", str(mini))
		if p1>=p2:
			l=lmid+1
			print(""l: "", str(l))
		else:
			r=rmid-1
			print(""r: "", str(r))
	print(mini)			
</ans>",0,{}
84,"<ans>
def local_right_to_global(test, local_right):
    return(len(test) + local_right)
    
def local_left_to_global(test, local_left):
    return(local_left)

def check_left(test, template, good_symbols):
    left_idx = -1
    print(""left_idx: "", str(left_idx))
    for symbol in template:
        left_idx += 1
        print(""left_idx: "", str(left_idx))
        if symbol == '*':
            return(local_left_to_global(test, left_idx))
        try:
            if test[left_idx] != template[left_idx]:
                if template[left_idx] != '?':
                    return('NO')
                elif test[left_idx] not in good_symbols:
                    return('NO')
        except:
            return('NO')

def check_right(test, template, good_symbols):
    right_idx = 0
    print(""right_idx: "", str(right_idx))
    for symbol in reversed(template):
        right_idx -= 1
        print(""right_idx: "", str(right_idx))
        if symbol == '*':
            return(local_right_to_global(test, right_idx))
        try:
            if test[right_idx] != template[right_idx]:
                if template[right_idx] != '?':
                    return('NO')
                elif test[right_idx] not in good_symbols:
                    return('NO')            
        except:
            return('NO')
    
good_symbols = set(list(input()))
print(""good_symbols: "", str(good_symbols))
template = input()
print(""template: "", str(template))
tests_nr = int(input())
print(""tests_nr: "", str(tests_nr))
tests = []
for _ in range(tests_nr):
    tests.append(input())
    print(""tests: "", str(tests))
    
abaca = '*' not in template
print(""abaca: "", str(abaca))
for test in tests:
    if abaca:
        pos = -1
        print(""pos: "", str(pos))
        flag = True
        if len(test) != len(template):
            print('NO')
            continue
        for symbol in template:
            pos += 1
            print(""pos: "", str(pos))
            try:
                if test[pos] != template[pos]:
                    if template[pos] != '?':
                        print('NO')
                        flag = False
                        break
                    elif test[pos] not in good_symbols:
                        print('NO')
                        flag = False
                        break
            except:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')
        continue
    left_idx = check_left(test, template, good_symbols)
    print(""left_idx: "", str(left_idx))
    right_idx = check_right(test, template, good_symbols)
    print(""right_idx: "", str(right_idx))
    # print(left_idx, right_idx)
    if left_idx == 'NO':
        print('NO')
    elif right_idx == 'NO':
        print('NO')
    else:
        if right_idx < left_idx - 1:
            print('NO')
            continue
        flag = True
        for pos in range(left_idx, right_idx + 1):
            if test[pos] in good_symbols:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')
</ans>",0,{}
85,"<ans>
n = int(input())
print(""n: "", str(n))
x0, y0 = map(int, input().split())
print(""x0: "", str(x0), ""y0: "", str(y0))
Nord = 10 ** 9 + 1
print(""Nord: "", str(Nord))
fNord = '-'
print(""fNord: "", str(fNord))
East = 10 ** 9 + 1
print(""East: "", str(East))
fEast = '-'
print(""fEast: "", str(fEast))
South = -10 ** 9 - 1
print(""South: "", str(South))
fSouth = '-'
print(""fSouth: "", str(fSouth))
West = -10 ** 9 - 1
print(""West: "", str(West))
fWest = '-'
print(""fWest: "", str(fWest))

NE = 10 ** 9 + 1
print(""NE: "", str(NE))
fNE = '-'
print(""fNE: "", str(fNE))
NW = 10 ** 9 + 1
print(""NW: "", str(NW))
fNW = '-'
print(""fNW: "", str(fNW))
SE = -10 ** 9 - 1
print(""SE: "", str(SE))
fSE = '-'
print(""fSE: "", str(fSE))
SW = -10 ** 9 - 1
print(""SW: "", str(SW))
fSW = '-'
print(""fSW: "", str(fSW))

for i in range(n):
    f, x, y = input().split()
    print(""f: "", str(f), ""x: "", str(x), ""y: "", str(y))
    x = int(x)
    print(""x: "", str(x))
    y = int(y)
    print(""y: "", str(y))
    if x == x0:
        if y0 < y < Nord:
            fNord = f
            print(""fNord: "", str(fNord))
            Nord = y
            print(""Nord: "", str(Nord))
        elif y0 > y > South:
            fSouth = f
            print(""fSouth: "", str(fSouth))
            South = y
            print(""South: "", str(South))
    if y == y0:
        if x0 < x < East:
            fEast = f
            print(""fEast: "", str(fEast))
            East = x
            print(""East: "", str(East))
        elif x0 > x > West:
            fWest = f
            print(""fWest: "", str(fWest))
            West = x
            print(""West: "", str(West))
            
    if x + y == x0 + y0:
        if y0 < y < NW:
            fNW = f
            print(""fNW: "", str(fNW))
            NW = y
            print(""NW: "", str(NW))
        elif y0 > y > SE:
            fSE = f
            print(""fSE: "", str(fSE))
            SE = y
            print(""SE: "", str(SE))
    if x - y == x0 - y0:
        if y0 < y < NE:
            fNE = f
            print(""fNE: "", str(fNE))
            NE = y
            print(""NE: "", str(NE))
        elif y0 > y > SW:
            fSW = f
            print(""fSW: "", str(fSW))
            SW = y
            print(""SW: "", str(SW))
ans  = False
if fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':
    ans = True
if fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':
    ans = True
if fSW == 'B' or fSE == 'B' or fNW == 'B' or fNE == 'B':
    ans = True
if fNord == 'R' or fSouth == 'R' or fWest == 'R' or fEast == 'R':
    ans = True

#print(fSW, fSE, fNW, fNE) 
#print(fNord, fSouth, fWest, fEast)
print('YES' if ans else 'NO')
</ans>",0,{}
86,"<ans>
#n, m = map(int, input().split())
n = int(input())
print(""n: "", str(n))

s = input()
print(""s: "", str(s))

ans = int(n * (n - 1) / 2)
print(""ans: "", str(ans))
c = 0
print(""c: "", str(c))

for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
            print(""ans: "", str(ans))
        c = 0
c = 0
print(""c: "", str(c))

for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
            print(""ans: "", str(ans))
        c = 0
c = 0
print(""c: "", str(c))

s = s[::-1]
print(""s: "", str(s))

c = 0
for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
            print(""ans: "", str(ans))
        c = 0
c = 0
print(""c: "", str(c))

for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
            print(""ans: "", str(ans))
        c = 0
c = 0
print(""c: "", str(c))

if s[0] == 'A':
    c += 1
for i in range(n):
    if s[i] == 'A':
        c += 1
    elif c >= 1:
        ans -= 1
        print(""ans: "", str(ans))
        c = 0

c = 0
if s[0] == 'B':
    c += 1
for i in range(n):
    if s[i] == 'B':
        c += 1
    elif c >= 1:
        ans -= 1
        print(""ans: "", str(ans))
        c = 0

print(ans)
</ans>",0,{}
87,"<ans>
#!/usr/bin/env python3


class CantException(Exception):
    pass


def odd_v(value):
    return 1 if value % 2 == 1 else -1


change_idx = 1
print(""change_idx: "", str(change_idx))

acceptable = {-1: set(), 1: set()}
print(""acceptable: "", str(acceptable))


def change(card_values, oddv, m):
    nonlocal change_idx

    if acceptable[oddv]:
        res = acceptable[oddv].pop()
        card_values.add(res)
        return res

    change_idx_start = change_idx
    print(""change_idx_start: "", str(change_idx_start))

    while change_idx in card_values or odd_v(change_idx) != oddv:
        if change_idx not in card_values:
            acceptable[odd_v(change_idx)].add(change_idx)
        change_idx += 1
        if change_idx > m:
            change_idx = 1
        if change_idx == change_idx_start:
            raise CantException()

    res = change_idx
    card_values.add(res)
    print(""res: "", str(res))

    change_idx += 1
    if change_idx > m:
        change_idx = 1
    return res


def solve():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    cards = list(map(int, input().split()))
    print(""cards: "", str(cards))

    odd_balance = 0
    card_values = set()
    indices_to_be_changed = set()
    print(""odd_balance: "", str(odd_balance))
    print(""card_values: "", str(card_values))
    print(""indices_to_be_changed: "", str(indices_to_be_changed))

    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
        if c in card_values:
            indices_to_be_changed.add(i)
        card_values.add(c)

    # print(""indices to be changed: "", indices_to_be_changed)
    change_count = len(indices_to_be_changed)
    print(""change_count: "", str(change_count))

    for i in indices_to_be_changed:
        if odd_v(cards[i]) * odd_balance <= 0:
            #print(""Changing "", cards[i])
            cards[i] = change(card_values, odd_v(cards[i]), m)
            #print(""Changed to "", cards[i])
        else:
            #print(""For teh balance changing "", cards[i])
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, - odd_v(cards[i]), m)
            #print(""Changed to "", cards[i])

    #print(""current odd balance:"", odd_balance)
    for i in range(len(cards)):
        if odd_balance == 0:
            break
        if odd_v(cards[i]) * odd_balance > 0:
            # print(""gonna change"")
            change_count += 1
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, -odd_v(cards[i]), m)

    odd_balance = 0
    print(""odd_balance: "", str(odd_balance))
    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
    if odd_balance != 0:
        print(odd_balance)
        print(""WTFFFFF"")

    return change_count, cards


def __starting_point():
    try:
        change_cnt, cards = solve()
        print(""change_cnt: "", str(change_cnt))
        print(""cards: "", str(cards))
    except CantException:
        print(""-1"")

__starting_point()
</ans>",0,{}
88,"<ans>
def dp(ind, max_covered):
    max_covered = min(m, max_covered)
    print(""max_covered: "", str(max_covered))

    if ind not in cache:
        cache[ind] = {}
        print(""cache[ind]: "", str(cache[ind]))

    d = cache[ind]
    if max_covered in d:
        return d[max_covered]

    ans = blah(ind, max_covered)
    print(""ans: "", str(ans))

    d[max_covered] = ans
    print(""d[max_covered]: "", str(d[max_covered]))
    return ans


# path = {}

class Node:
    def __init__(self, key, val, next=None):
        self.key = key
        self.val = val
        self.next = next

def blah(ind, max_covered):
    x, s = antenna[ind]
    print(""x: "", str(x), ""s: "", str(s))
    # key = (ind, max_covered)

    if max_covered >= m:
        # path[key] = Node(key, 0)
        return 0

    if ind == len(antenna) - 1:
        if max_covered < x - s - 1:
            left_needed = x - s - (max_covered + 1)
            right_needed = max(m - (x + s), 0)
            ans = max(left_needed, right_needed)
            # path[key] = Node(key, ans)
            print(""ans: "", str(ans))
            return ans
        else:
            right_boundary = max(max_covered, x + s)
            ans = max(0, m - right_boundary)
            # path[key] = Node(key, ans)
            print(""ans: "", str(ans))
            return ans

    if max_covered < x - s - 1:
        num_needed = x - s - (max_covered + 1)
        new_boundary = min(x + s + num_needed, m)
        use_i = num_needed + dp(ind + 1, new_boundary)
        dont_use_i = dp(ind + 1, max_covered)

        # if use_i < dont_use_i:
        #     path[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])
        # else:
        #     path[key] = Node(key, 0, path[(ind + 1, max_covered)])

        return min(use_i, dont_use_i)
    else:
        new_boundary = min(max(max_covered, x + s), m)
        ans = dp(ind + 1, new_boundary)
        # path[key] = Node(key, 0, path[(ind + 1, new_boundary)])
        return ans

import sys

cache = {}
print(""cache: "", str(cache))

n, m = [int(x) for x in sys.stdin.readline().split("" "")]
print(""n: "", str(n), ""m: "", str(m))

antenna = []
print(""antenna: "", str(antenna))

for i in range(n):
    x, s = [int(x) for x in sys.stdin.readline().split("" "")]
    print(""x: "", str(x), ""s: "", str(s))

    antenna.append((x, s))
    print(""antenna: "", str(antenna))

antenna.sort(key=lambda a: a[0])
print(""antenna: "", str(antenna))

print(dp(0, 0))
</ans>",0,{}
89,"<ans>
import math;
#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(gx, gy, alpha, x, y):
    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);
    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);
    return x1, y1
#Вычисление угла, на который надо повернуть точку с координатами x, y,
#чтобы она оказалась прямо над gx, gy
def getAngle(gx, gy, x, y):
    x=x-gx;
    y=y-gy;
    cos=x/math.sqrt(x**2+y**2);
    alpha=math.acos(cos);
    if y<0:
        alpha=-alpha;
    return math.pi/2-alpha;
n, q = list(map(int, input().split(' ')));
print(""n: "", str(n), ""q: "", str(q))
x=[0]*n;
print(""x: "", str(x))
y=[0]*n;
print(""y: "", str(y))
for i in range(n):
    x[i], y[i]=list(map(int, input().split(' ')));
r=[0]*q;
print(""r: "", str(r))
f=[0]*q;
print(""f: "", str(f))
t=[0]*q;
print(""t: "", str(t))
v=[0]*q;
print(""v: "", str(v))
for i in range(q):
    l=list(map(int, input().split(' ')));
    r[i]=l[0];
    print(""r[{}]: "".format(i), str(r[i]))
    if r[i]==1:
        f[i]=l[1]-1;
        print(""f[{}]: "".format(i), str(f[i]))
        t[i]=l[2]-1;
        print(""t[{}]: "".format(i), str(t[i]))
    else:
        v[i]=l[1]-1;
        print(""v[{}]: "".format(i), str(v[i]))
gx=0;
print(""gx: "", str(gx))
gy=0;
print(""gy: "", str(gy))
s=0;
print(""s: "", str(s))
for i in range(n):
    ip=i+1;
    if ip==n:
        ip=0;
    ds=x[i]*y[ip]-x[ip]*y[i];
    s+=ds;
    gx+=(x[i]+x[ip])*ds;
    gy+=(y[i]+y[ip])*ds;
s/=2;
print(""s: "", str(s))
gx/=6*s;
print(""gx: "", str(gx))
gy/=6*s;
print(""gy: "", str(gy))
angles=[0]*n;
print(""angles: "", str(angles))
for i in range(n):
    angles[i]=getAngle(gx, gy, x[i], y[i]);
    print(""angles[{}]: "".format(i), str(angles[i]))
for i in range(n):
    x[i]-=gx;
    print(""x[{}]: "".format(i), str(x[i]))
    y[i]-=gy;
    print(""y[{}]: "".format(i), str(y[i]))
alpha=0;
print(""alpha: "", str(alpha))
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
fix={0, 1}
for i in range(q):
    if r[i]==2:
        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);
        print(""%.6f %.6f""%(currX, currY))
    else:
        if len(fix)==2:
            fix.remove(f[i]);
        #print('remove',f[i])
        #j - единственный элемент в множестве
        for j in fix:
            #print(j);
            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);
            #print('fix:', currX, currY)
            #dalpha=getAngle(gx, gy, currX, currY);
            #alpha+=dalpha;
            alpha=angles[j];
            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол
            #dalpha относительно currX, currY
            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);
            print(""gx: "", str(gx), ""gy: "", str(gy), ""alpha: "", str(alpha))
        fix.add(t[i]);
</ans>",0,{}
90,"<ans>
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)
print(""N: "", str(N))
re = 1
print(""re: "", str(re))
mc = 1
print(""mc: "", str(mc))
zc = []
print(""zc: "", str(zc))
for i in range(2, 10000):
    if N%i != 0 : continue
    re *= i
    print(""re: "", str(re))
    c = 0
    print(""c: "", str(c))
    while N%i==0:
        N//=i
        print(""N: "", str(N))
        c+=1
        print(""c: "", str(c))
    
    zc.append(c)
    print(""zc: "", str(zc))
if N>1:
    re*=N
    print(""re: "", str(re))
    zc.append(1)
    print(""zc: "", str(zc))
if zc:
    mc = max(zc)
    print(""mc: "", str(mc))
t =1 
print(""t: "", str(t))
for i in range(100):
    if mc<=t:
        break
    t*=2
    print(""t: "", str(t))
dprint(t)
dprint(zc)
g = i
print(""g: "", str(g))
for x in zc:
    if x<t:
        g+=1
        print(""g: "", str(g))
        break

print(re,g)
</ans>",0,{}
91,"<ans>
#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=1000000007
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()


n,m,o=value()
print(""n: "", str(n), ""m: "", str(m), ""o: "", str(o))
for i in range(n):
    input()

result = m*(m-1)//2
print(""result: "", str(result))
print(result)
for i in range(1,m+1):
    for j in range(i+1,m+1):
        if(o==0):
            print(i,j)
        else:
            print(m-i+1,m-j+1)
</ans>",0,{}
92,"<ans>
def solve1(a, n):  
    left=[]
    print(""left: "", str(left))
    st=[]
    print(""st: "", str(st))
    i=0
    print(""i: "", str(i))
    while i<(n):
        if not st:
            left.append(-1)
            st.append(i)
            print(""left: "", str(left))
            print(""st: "", str(st))
            
        elif st and a[i]<a[st[-1]]:
            left.append(st[-1])
            st.append(i)
            print(""left: "", str(left))
            print(""st: "", str(st))
        else:
            while st and a[i]>a[st[-1]]:
                st.pop()
                
            if not st:
                st.append(i)
                left.append(-1)
                print(""left: "", str(left))
                print(""st: "", str(st))
                
            else:
                left.append(st[-1])
                st.append(i)
                print(""left: "", str(left))
                print(""st: "", str(st))
                
        i+=1
    # print(left)
    right=[]
    print(""right: "", str(right))
    st=[]
    print(""st: "", str(st))
    i=n-1
    print(""i: "", str(i))
    while i>(-1):
        if not st:
            right.append(n)
            st.append(i)
            print(""right: "", str(right))
            print(""st: "", str(st))
            
        elif st and a[i]<a[st[-1]]:
            right.append(st[-1])
            st.append(i)
            print(""right: "", str(right))
            print(""st: "", str(st))
        else:
            while st and a[i]>=a[st[-1]]:
                st.pop()
                
            if not st:
                st.append(i)
                right.append(n)
                print(""right: "", str(right))
                print(""st: "", str(st))
                
            else:
                right.append(st[-1])
                st.append(i)
                print(""right: "", str(right))
                print(""st: "", str(st))
                
        i-=1
    right=right[::-1]
    print(""right: "", str(right))
    c=0
    print(""c: "", str(c))
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        print(""x: "", str(x))
        # print(x)
        if x==0:
            c+=a[i]
        else:
            c+=x
    # print(c)
    # print(a)
    # print(left)
    # print(right)
            
    return c

    

            
def solve2(a, n): 
    left=[]
    print(""left: "", str(left))
    st=[]
    print(""st: "", str(st))
    i=0
    print(""i: "", str(i))
    while i<(n):
        if not st:
            left.append(-1)
            st.append(i)
            print(""left: "", str(left))
            print(""st: "", str(st))
            
        elif st and a[i]>a[st[-1]]:
            left.append(st[-1])
            st.append(i)
            print(""left: "", str(left))
            print(""st: "", str(st))
        else:
            while st and a[i]<a[st[-1]]:
                st.pop()
                
            if not st:
                st.append(i)
                left.append(-1)
                print(""left: "", str(left))
                print(""st: "", str(st))
                
            else:
                left.append(st[-1])
                st.append(i)
                print(""left: "", str(left))
                print(""st: "", str(st))
                
        i+=1
    # print(left)
    right=[]
    print(""right: "", str(right))
    st=[]
    print(""st: "", str(st))
    i=n-1
    print(""i: "", str(i))
    while i>(-1):
        if not st:
            right.append(n)
            st.append(i)
            print(""right: "", str(right))
            print(""st: "", str(st))
            
        elif st and a[i]>a[st[-1]]:
            right.append(st[-1])
            st.append(i)
            print(""right: "", str(right))
            print(""st: "", str(st))
        else:
            while st and a[i]<=a[st[-1]]:
                st.pop()
                
            if not st:
                st.append(i)
                right.append(n)
                print(""right: "", str(right))
                print(""st: "", str(st))
                
            else:
                right.append(st[-1])
                st.append(i)
                print(""right: "", str(right))
                print(""st: "", str(st))
                
        i-=1
    right=right[::-1]
    print(""right: "", str(right))
    c=0
    print(""c: "", str(c))
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        print(""x: "", str(x))
        # print(x)
        if x==0:
            c+=a[i]
        else:
            c+=x
    # print(c)
    # print(a)
    # print(left)
    # print(right)
            
    return c



n=int(input())
arr=[int(x) for x in input().split()]
# solve2(arr,n)
# print(solve1(arr,n))
# print(solve2(arr,n))
# print()
# (solve2(arr,n))

print(solve1(arr,n)-solve2(arr,n))
</ans>",0,{}
93,"<ans>
import math
N=int(input())
print(""N: "", str(N))

def get_circle_2p(p1,p2):
  x1,y1=p1
  print(""x1: "", str(x1), ""y1: "", str(y1))
  x2,y2=p2
  print(""x2: "", str(x2), ""y2: "", str(y2))
  
  x=(x1+x2)/2
  print(""x: "", str(x))
  y=(y1+y2)/2  
  print(""y: "", str(y))
  r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
  print(""r: "", str(r))
  return x,y,r

def get_circle_3p(p1,p2,p3):
  x1,y1=p1
  print(""x1: "", str(x1), ""y1: "", str(y1))
  x2,y2=p2
  print(""x2: "", str(x2), ""y2: "", str(y2))
  x3,y3=p3
  print(""x3: "", str(x3), ""y3: "", str(y3))
  d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))  
  print(""d: "", str(d))
  
  if d==0:
    rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
    print(""rad1: "", str(rad1))
    rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2
    print(""rad2: "", str(rad2))
    rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2
    print(""rad3: "", str(rad3))
    
    if rad1>=rad2 and rad1>=rad3:
      x=(x1+x2)/2
      print(""x: "", str(x))
      y=(y1+y2)/2
      print(""y: "", str(y))
      return x,y,rad1
    elif rad2>=rad1 and rad2>=rad3:
      x=(x1+x3)/2
      print(""x: "", str(x))
      y=(y1+y3)/2
      print(""y: "", str(y))
      return x,y,rad2
    elif rad3>=rad1 and rad3>=rad2:
      x=(x2+x3)/2
      print(""x: "", str(x))
      y=(y2+y3)/2
      print(""y: "", str(y))
      return x,y,rad3      
  else:
    x=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/d
    print(""x: "", str(x))
    y=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-d
    print(""y: "", str(y))
    r=math.sqrt((x-x1)**2+(y-y1)**2)
    print(""r: "", str(r))
    return x,y,r
  
xylist=[]
for i in range(N):
  xi,yi=map(int,input().split())
  print(""xi: "", str(xi), ""yi: "", str(yi))
  xylist.append((xi,yi))
  
#print(xylist)

if N==2:
  x,y,r=get_circle_2p(xylist[0],xylist[1])
  print(""r: "", str(r))
else:
  min_radius=float(""inf"")
  print(""min_radius: "", str(min_radius))
  for i in range(N):
    for j in range(i+1,N):
      #print(xylist[i],xylist[j])
      x,y,r=get_circle_2p(xylist[i],xylist[j])
      print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
      #print(x,y,r)
      if r>min_radius:
        continue
      
      for l in range(N):
        if l==i or l==j:
          continue
          
        xl,yl=xylist[l]
        diff_xl=xl-x
        diff_yl=yl-y
        if math.sqrt(diff_xl**2+diff_yl**2)>r:
          break
      else:
        min_radius=r
        print(""min_radius: "", str(min_radius))
  
  for i in range(N):
    for j in range(i+1,N):
      for k in range(j+1,N):
        #print(xylist[i],xylist[j],xylist[k])
        x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])
        print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
        #print(x,y,r)
        if r>min_radius:
          continue
        
        for l in range(N):
          if l==i or l==j or l==k:
            continue
            
          xl,yl=xylist[l]
          diff_xl=xl-x
          diff_yl=yl-y
          if math.sqrt(diff_xl**2+diff_yl**2)>r:
            break
        else:
          min_radius=r
          print(""min_radius: "", str(min_radius))
  
  print(min_radius)
</ans>",0,{}
94,"<ans>
import math
from decimal import Decimal
import heapq
from collections import deque
def na():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,b
 
 
def nab():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,c
 
 
def dv():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	return n,m
 
 
def dva():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	a = [int(x) for x in input().split()]
	print(""a: "", str(a))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,m,b
 
 
def eratosthenes(n): 
	sieve = list(range(n + 1))
	print(""sieve: "", str(sieve))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
def lol(lst,k):
	k=k%len(lst)
	print(""k: "", str(k))
	ret=[0]*len(lst)
	for i in range(len(lst)):
		if i+k<len(lst) and i+k>=0:
			ret[i]=lst[i+k]
		if i+k>=len(lst):
			ret[i]=lst[i+k-len(lst)]
		if i+k<0:
			ret[i]=lst[i+k+len(lst)]
	return(ret)
def nm():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	m = int(input())
	print(""m: "", str(m))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,m,c
 
 
def dvs():
	n = int(input())
	print(""n: "", str(n))
	m = int(input())
	print(""m: "", str(m))
	return n, m 
 
def fact(a, b):
	c = []
	print(""c: "", str(c))
	ans = 0
	f = int(math.sqrt(a))
	print(""f: "", str(f))
	for i in range(1, f + 1):
		if a % i == 0:
			c.append(i)
	l = len(c)
	print(""l: "", str(l))
	for i in range(l):
		c.append(a // c[i])
	for i in range(len(c)):
		if c[i] <= b:
			ans += 1
	if a / f == f and b >= f:
		return ans - 1
	return ans
 
 
t = int(input())
print(""t: "", str(t))
for i in range(t):
	x, y = list(map(int, input().split()))
	print(""x: "", str(x), ""y: "", str(y))
	if x >= y:
		print('YES')
		continue
	if x == 2 and y == 3:
		print('YES')
		continue
	elif x <= 3 and y > 3:
		print('NO')
		continue
	if x == 1:
		print('NO')
	else:
		print('YES')
</ans>",0,{}
95,"<ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(x) for x in input().split(' ')]
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))

if k&1:
  print('IMPOSSIBLE')
  return

s = [None]*n
print(""s: "", str(s))
for i in range(n):
  s[i] = [None]*m
  print(""s[{}]: "".format(i), str(s[i]))
  t = input()
  for j in range(m):
    s[i][j] = t[j]
    if t[j] == 'X': x, y = j, i
    print(""s[{}][{}]: "".format(i, j), str(s[i][j]), ""x: "", str(x), ""y: "", str(y))

def bfs(x, y):
  res = [[10000000]*m for i in range(n)]
  print(""res: "", str(res))
  if s[y][x] == '*': return res
  q = Queue()
  q.put((x, y))
  step = 0
  print(""step: "", str(step))

  def add(x, y):
    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return
    q.put((x, y))
    res[y][x] = step+1
    print(""add - x: "", str(x), ""y: "", str(y), ""res[{}][{}]: "".format(y, x), str(res[y][x]))

  res[y][x] = step
  print(""res[{}][{}]: "".format(y, x), str(res[y][x]))

  while not q.empty():
    x, y = q.get()
    step = res[y][x]
    print(""x: "", str(x), ""y: "", str(y), ""step: "", str(step))
    #print('-')
    if y < n-1: add(x, y+1) #D
    if x > 0: add(x-1, y)   #L
    if x < m-1: add(x+1, y) #R
    if y >",0,{}
96,"<ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

inf = float('inf')
Edge = namedtuple('Edge', 'start, end, cost')


def make_edge(start, end, cost=1):
    return Edge(start, end, cost)


class Graph:
    def __init__(self, edges, bi=True):
        wrong_edges = [i for i in edges if len(i) not in [2, 3]]
        if wrong_edges:
            raise ValueError('Wrong edges data: {}'.format(wrong_edges))
        self.edges = [make_edge(*edge) for edge in edges]
        print(""self.edges: "", str(self.edges))
        self.vertices = set(
            sum(
                ([edge.start, edge.end] for edge in self.edges), []
            ))
        print(""self.vertices: "", str(self.vertices))
        self.neighbors = {vertex: set() for vertex in self.vertices}
        print(""self.neighbors: "", str(self.neighbors))
        for edge in self.edges:
            self.neighbors[edge.start].add(edge.end)

    def get_node_pairs(self, n1, n2, both_ends=True):
        if both_ends:
            node_pairs = [[n1, n2], [n2, n1]]
        else:
            node_pairs = [[n1, n2]]
        print(""node_pairs: "", str(node_pairs))
        return node_pairs

    def remove_edge(self, n1, n2, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        edges = self.edges[:]
        for edge in edges:
            if[edge.start, edge.end] in node_pairs:
                self.edges.remove(edge)

    def add_edge(self, n1, n2, cost=1, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        for edge in self.edges:
            if [edge.start, edge.end] in node_pairs:
                return ValueError('Edge {} {} already exists'.format(n1, n2))

        self.edges.append(Edge(start=n1, end=n2, cost=cost))
        print(""self.edges after append: "", str(self.edges))
        if both_ends:
            self.edges.append(Edge(start=n2, end=n1, cost=cost))
            print(""self.edges after both_ends append: "", str(self.edges))

    def dijkstra(self, source, dest):
        assert source in self.vertices, 'Such source node doesn\'t exist'
        distances = {vertex: inf for vertex in self.vertices}
        distances[source] = 0
        print(""distances: "", str(distances))

        q, seen = [(0, source)], set()
        while q:
            (curr_cost, current_vertex) = heappop(q)
            if current_vertex in seen:
                continue
            seen.add(current_vertex)
            for neighbor in self.neighbors[current_vertex]:
                cost = 1
                if neighbor in seen:
                    continue
                alternative_route = distances[current_vertex] + cost
                if alternative_route < distances[neighbor]:
                    distances[neighbor] = alternative_route
                    print(""distances updated: "", str(distances))
                    heappush(q, (alternative_route, neighbor))

        return distances


n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]

verts = []
for i in range(m):
    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
print(""verts: "", str(verts))
rev_verts = []
for i in verts:
    rev_verts.append((i[1], i[0]))
print(""rev_verts: "", str(rev_verts))
for i in rev_verts:
    verts.append(i)
print(""verts after appending rev_verts: "", str(verts))
graph = Graph(verts)
s_dist = graph.dijkstra(s, t)
print(""s_dist: "", str(s_dist))
t_dist = graph.dijkstra(t, s)
print(""t_dist: "", str(t_dist))
SHORTEST_DIST = s_dist[t]
print(""SHORTEST_DIST: "", str(SHORTEST_DIST))
count = 0
print(""count initialized: "", str(count))

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        if j not in graph.neighbors[i] and \
                i not in graph.neighbors[j] and \
                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \
                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:
            count = count + 1
            print(""count updated: "", str(count))

print(count)
</ans>",0,{}
97,"<ans>
#
#
#
# 笑え、君が好きなように。
#                         笑いは世界を救う。
#                                           あなたが笑ってくれるなら。
#
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3回
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
# set型だと、 | と & が使えるよ
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
# 整数か判定する
# nanka.is_integer()
# ref https://atcoder.jp/contests/abc133/tasks/abc133_b
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
# mod = 9982443453
# mod = 998244353
INF = float('inf')
dx = [0,1,0,-1]
dy = [1,0,-1,0]
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
    return int(readline())
def f(n):
    return int(math.ceil(n-0.5))
N,K = readInts()
print(""N: "", str(N), ""K: "", str(K))
def calc(n):
    if n <= 0 or n > 2*N:
        return 0
    else:
        return min(n-1, 2*N-n+1)
ans = 0
print(""ans: "", str(ans))
for AB in range(2*N+1):
    #print(AB,calc(AB),AB-K, calc(K-AB))
    ans += calc(AB) * calc(AB-K)
    print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
98,"<ans>
import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline    ####
def int1(x): return int(x) - 1
def II(): return int(input())
def MI(): return list(map(int, input().split()))
def MI1(): return list(map(int1, input().split()))
def LI(): return list(map(int, input().split()))
def LI1(): return list(map(int1, input().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def MS(): return input().split()
def LS(): return list(input())
def LLS(rows_number): return [LS() for _ in range(rows_number)]
def printlist(lst, k=' '): print((k.join(list(map(str, lst)))))
INF = float('inf')
# from math import ceil, floor, log2
# from collections import deque
from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum  # accumulate

def solve():
    N, K = MI()
    print(""N: "", str(N), ""K: "", str(K))
    A = LI()
    print(""A: "", str(A))

    M = sum(A)
    print(""M: "", str(M))
    divs = []
    for i in range(1, int(pow(M, 0.5))+1):
        if M % i: continue
        divs.append(i)
        if i != M//i: divs.append(M//i)
    divs.sort(reverse=True)
    print(""divs: "", str(divs))

    for d in divs:
        B = list([x%d for x in A])
        B.sort()
        print(""B: "", str(B))
        C = list([d-x for x in B])
        print(""C: "", str(C))
        # print(d, B, C)
        # print(list(accumulate(B)), list(accumulate(C)))
        Ba = list(accumulate(B))
        print(""Ba: "", str(Ba))
        Ca = list(accumulate(C))
        print(""Ca: "", str(Ca))
        for i in range(0, N-1):
            b = Ba[i]
            c = Ca[-1] - Ca[i]
            print(""b: "", str(b), ""c: "", str(c))
            # print(b, c)
            if b == c and b <= K:
                print(d)
                return
    print((1))


def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
99,"<ans>
import sys

def matching(node, visited, adj, assigned):
	if node == -1:
		return True
	if visited[node]:
		return False
	visited[node] = True
	for neighbor in adj[node]:
		if matching(assigned[neighbor], visited, adj, assigned):
			assigned[neighbor] = node
			return True
	return False

INF = 1000 * 1000

inp = [int(x) for x in sys.stdin.read().split()]
print(""inp: "", str(inp))

n, m = inp[0], inp[1]
print(""n: "", str(n), ""m: "", str(m))
inp_idx = 2

G = [[INF] * n for _ in range(n)]
print(""G: "", str(G))

for _ in range(m):
	a, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1
	print(""a: "", str(a), ""b: "", str(b))
	inp_idx += 2
	G[a][b] = G[b][a] = 1

for v in range(n):
	G[v][v] = 0
	
for k in range(n): 
	for i in range(n): 
		for j in range(n): 
			G[i][j] = min(G[i][j], G[i][k] + G[k][j])
	
s, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]
print(""s: "", str(s), ""b: "", str(b), ""k: "", str(k), ""h: "", str(h))
inp_idx += 4

spaceships = []
for _ in range(s):
	x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]
	print(""x: "", str(x), ""a: "", str(a), ""f: "", str(f))
	inp_idx += 3
	spaceships.append((x, a, f))
	
bases = []
for _ in range(b):
	x, d = inp[inp_idx] - 1, inp[inp_idx + 1]
	print(""x: "", str(x), ""d: "", str(d))
	inp_idx += 2
	bases.append((x, d))
	
adj = [[] for _ in range(s)]
print(""adj: "", str(adj))
assigned = [[] for _ in range(b)]
print(""assigned: "", str(assigned))
for i in range(s):
	space = spaceships[i]
	for j in range(b):
		base = bases[j]
		u, v = space[0], base[0]
		fuel = space[2]
		if G[u][v] <= fuel and space[1] >= base[1]:
			adj[i].append(j)

visited = [False] * s
print(""visited: "", str(visited))
assigned = [-1] * b
print(""assigned: "", str(assigned))

matched = 0
for i in range(s):
	visited = [False] * s
	print(""visited: "", str(visited))
	if matching(i, visited, adj, assigned):
		matched += 1


print(min(matched * k, h * s))
</ans>",0,{}
100,"<ans>
```python
# n = int(input())
# a = [int(i) for i in input().split(' ')]
# t = [int(i) for i in input().split(' ')]
#
# import collections
# from heapq import heapify, heappop, heappush
#
#
# l = collections.defaultdict(list)
# at = [[a[i], t[i]] for i in range(n)]
# at.sort(key = lambda x: x[0])
# for aa, tt in at:
#     l[aa].append(tt)
#
# for k in l.keys():
#     heapify(l[k])
#
#
# # print(at)
# # print(l)
# res = 0
#
# # tmp = []
#
# q = sorted(l.keys())[::-1]
# while q:
#     i = q.pop()
#     # print(""i"", i, l[i])
#     # l[i].extend(tmp)
#     if len(l[i]) == 1:
#         continue
#     else:
#         tmp = sorted(l[i])
#         sums = sum(tmp)
#         # res += sums - maxx # leave the one with max time and increase all other by 1, cost their time
#         idx = i
#         while tmp and ((q and idx + 1 != q[-1]) or not q):
#             # print(i, idx, q, tmp)
#             p = tmp.pop()
#             res += sums - p
#             sums -= p
#             idx += 1
#         if tmp:
#             p = tmp.pop()
#             res += sums - p
#             sums -= p
#             l[idx+1].extend(tmp)
#             if not q:
#                 q.append(idx+1)
# print(res)
#
#
#
#
#
#
#


import sys

inp = sys.stdin.readline
input = lambda: inp().strip()


# flush= sys.stdout.flush
# import threading
# sys.setrecursionlimit(10**6)
# threading.stack_size(2**26)

def iin(): return int(input())


def lin(): return list(map(int, input().split()))


def main():
    import heapq as hq
    n = iin()
    print(""n: "", str(n))
    a = lin()
    print(""a: "", str(a))
    t = lin()
    print(""t: "", str(t))
    dc = {}
    print(""dc: "", str(dc))
    for i in range(n):
        try:
            dc[a[i]].append(t[i])
        except:
            dc[a[i]] = [t[i], ]
    # print(dc)
    sa = list(dc.keys())
    print(""sa: "", str(sa))
    sa.sort()
    n = len(sa)
    print(""n: "", str(n))
    ch = 0
    print(""ch: "", str(ch))
    pt = sa[ch]
    print(""pt: "", str(pt))
    temp = []
    print(""temp: "", str(temp))
    sm = 0
    print(""sm: "", str(sm))
    ans = 0
    print(""ans: "", str(ans))
    hq.heapify(temp)
    done = 0
    while ch < n:
        # print(temp, sa[ch])
        pt = sa[ch]
        print(""pt: "", str(pt))
        if len(dc[pt]) > 1 or done:
            a1 = sorted(dc[pt])
            print(""a1: "", str(a1))
            for item in a1:
                hq.heappush(temp, -item)
                sm += item
            x = hq.heappop(temp) * (-1)
            print(""x: "", str(x))
            dc[pt] = [x]
            sm -= x
            while len(temp):
                # print('A', ch, pt, temp )
                ans += sm
                pt += 1
                if pt in dc:
                    ch += 1
                    done = 1
                    break
                else:
                    x = hq.heappop(temp) * (-1)
                    sm -= x
            else:
                done = 0
        else:
            ch += 1
            done = 0
    # print(dc)
    print(ans)

main()
```
</ans>",0,{}
101,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return [int(i) for i in input().split()]
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    print(""divs_number: "", str(divs_number))
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        print(""t: "", str(t))
        while n % i == 0:
            t += 1
            n //= i
            print(""n: "", str(n), ""t: "", str(t))
        divs_number *= t
        print(""divs_number: "", str(divs_number))
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    print(""newnumber: "", str(newnumber))
    while number > 0:
        newnumber += number % base
        number //= base
        print(""number: "", str(number), ""newnumber: "", str(newnumber))
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


for _ in range(ii()):
    a, b = mi()
    print(""a: "", str(a), ""b: "", str(b))
    print(b - a % b) if a % b else print(0)
</ans>",0,{}
102,"<ans>
def add(a,b):
    a = a%(1000000000+7)
    print(""a: "", str(a))
    b=b%(1000000000+7)
    print(""b: "", str(b))
    return (a+b)%(1000000000+7)

n  =int(input())
print(""n: "", str(n))
i=1
statements = []
print(""statements: "", str(statements))
dp = [[0 for i in range(n)] for i in range(n)]
print(""dp: "", str(dp))
prefix = [[0 for i in range(n)] for i in range(n)]
print(""prefix: "", str(prefix))
while(i<=n):
    s = input()
    statements.append(s)
    print(""s: "", str(s))
    print(""statements: "", str(statements))
    i+=1

dp[0][0]=1
print(""dp[0][0]: "", str(dp[0][0]))
prefix[0][0]=1
print(""prefix[0][0]: "", str(prefix[0][0]))
j=1
while(j<n):
    dp[0][j]=0
    print(""dp[0][j]: "", str(dp[0][j]))
    prefix[0][j] = dp[0][j] + prefix[0][j-1]
    print(""prefix[0][j]: "", str(prefix[0][j]))
    j+=1

i=1
while(i<n):
    if(statements[i-1]=='f'):
        j=1
        while(j<n):
            dp[i][0]=0
            print(""dp[i][0]: "", str(dp[i][0]))
            prefix[i][0]=0
            print(""prefix[i][0]: "", str(prefix[i][0]))
            dp[i][j] = dp[i-1][j-1]
            print(""dp[i][j]: "", str(dp[i][j]))
            prefix[i][j] = add(prefix[i][j-1],dp[i][j])
            print(""prefix[i][j]: "", str(prefix[i][j]))

            j+=1
    else:
        j=0
        while(j<n):
            if(j==0):
                dp[i][j] = prefix[i-1][n-1]
                print(""dp[i][j]: "", str(dp[i][j]))
            else:
                dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
                print(""dp[i][j]: "", str(dp[i][j]))
            prefix[i][j] = add(prefix[i][j-1],dp[i][j])
            print(""prefix[i][j]: "", str(prefix[i][j]))
            j+=1
    i+=1

ans = 0
print(""ans: "", str(ans))
j=0
while(j<n):
    ans=add(ans,dp[n-1][j])
    print(""ans: "", str(ans))
    j+=1

print(ans%(1000000000+7))
</ans>",0,{}
103,"<ans>
def compute():
    n, m = [int(s) for s in input().split()]
    print(""n: "", str(n), ""m: "", str(m))
    p = {}
    print(""p: "", str(p))
    for i in range(m):
        u, v = [int(s) for s in input().split()]
        print(""u: "", str(u), ""v: "", str(v))
        if u > v:
            if p.get(u) == 2:
                return 0
            if p.get(v) == 1:
                return 0
            p[u] = 1
            print(""p[{}]: "".format(u), str(p[u]))
            p[v] = 2
            print(""p[{}]: "".format(v), str(p[v]))
        else:
            if p.get(v) == 2:
                return 0
            if p.get(u) == 1:
                return 0
            p[v] = 1
            print(""p[{}]: "".format(v), str(p[v]))
            p[u] = 2
            print(""p[{}]: "".format(u), str(p[u]))
    div1, div2 = [], []
    print(""div1: "", str(div1), ""div2: "", str(div2))
    for k, v in list(p.items()):
        if v == 1:
            div1.append(k)
        else:
            div2.append(k)
    print(""div1 after append: "", str(div1), ""div2 after append: "", str(div2))
    p_left = [i for i in range(1, n + 1) if i not in p]
    print(""p_left: "", str(p_left))
    if not div1:
        if p_left:
            div1.append(p_left[-1])
            print(""div1 after append from p_left: "", str(div1))
            p_left.remove(p_left[-1])
            print(""p_left after remove: "", str(p_left))
        else:
            return 0
    if not div2:
        if p_left:
            div2.append(p_left[0])
            print(""div2 after append from p_left: "", str(div2))
            p_left.remove(p_left[0])
            print(""p_left after remove: "", str(p_left))
        else:
            return 0
    div1_easiest = min(div1)
    print(""div1_easiest: "", str(div1_easiest))
    div2_hardest = max(div2)
    print(""div2_hardest: "", str(div2_hardest))
    if div2_hardest > div1_easiest:
        return 0

    res = 1
    print(""res: "", str(res))
    for i in range(len(p_left)):
        if p_left[i] > div1_easiest:
            pass
        elif p_left[i] < div2_hardest:
            pass
        else:
            res += 1
            print(""res after increment: "", str(res))

    return res
res = compute()
print(res)
</ans>",0,{}
104,"<ans>
import itertools


class SolutionImpossible(Exception):
    pass


blocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]
print(""blocks_cnt: "", str(blocks_cnt), ""finish: "", str(finish), ""min_sprint: "", str(min_sprint), ""max_jump: "", str(max_jump))


def read_blocks_coords():
    it = (int(x) for x in input().split())
    return (x for x in it if x < finish)


# TODO: код можно сократить за счет избавления от лишней записи в `_grouper._current_key`
def _grouper(value):
    if _grouper._prev_value is not None:
        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        if value - _grouper._prev_value - 1 <= min_sprint:
            # расстояние между препятствиями слишком мало
            # чтобы между ними приземляться, и затем разогнаться для нового прыжка, считаем их за одно
            _current_key = _grouper._current_key
        else:
            _current_key = id(value)
    else:
        # первое вхождение, ставим данные по умолчанию
        _current_key = id(_grouper)

    _grouper._prev_value = value
    _grouper._current_key = _current_key

    return _current_key


_grouper._prev_value = None
_grouper._current_key = None


def check_chunk(run_from, block=None):
    if block is None:
        return

    next_run_from = block[-1] + 1  # следующая за преградой позиция (точка приземления)
    if next_run_from - block[0] >= max_jump:
        # если преграда слишком длинная, то мы не можем ее пересечь
        raise SolutionImpossible

    if abs(run_from - block[0]) <= min_sprint:
        # нет возможности для разбега
        raise SolutionImpossible


def solve_chunk(run_from, block=None):
    if block is not None:
        run_len = block[0] - run_from - 1  # добегаем ДО преграды
        jump_len = block[-1] - block[0] + 2  # прыгаем ЗА нее
        print((
            ""RUN {run_len}\n""
            ""JUMP {jump_len}"".format(
                run_len=run_len,
                jump_len=jump_len,
            )
        ))

    else:
        run_len = finish - run_from
        if run_len > 0:
            print(""RUN {run_len}"".format(run_len=run_len))


def main():
    # некоторые препятствия могут находиться так близко, что между ними нет возможности разогнаться
    # считаем такие препятствия за одно
    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))
    print(""blocks: "", str(blocks))

    chunks = []
    print(""chunks: "", str(chunks))

    run_from = 0
    print(""run_from: "", str(run_from))
    while True:
        block = next(blocks, None)
        print(""block: "", str(block))

        chunk = (run_from, block)
        print(""chunk: "", str(chunk))
        check_chunk(*chunk)

        chunks.append(chunk)
        print(""chunks: "", str(chunks))

        if block is None:
            break

        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        run_from = block[-1] + 1
        print(""run_from: "", str(run_from))

    #print(chunks)

    for chunk in chunks:
        solve_chunk(*chunk)


def __starting_point():
    try:
        main()
    except SolutionImpossible:
        print(""IMPOSSIBLE"")

__starting_point()
</ans>",0,{}
105,"<ans>
#import sys
#sys.stdin = open('in.txt')
#sys.setrecursionlimit(10000)
def isPrefix(sa, sb):
    if len(sa) <= len(sb):
        return False
    return sa[0:len(sb)] == sb

def getOrder(sa, sb):
    for i in range(0, min(len(sa), len(sb))):
        if sa[i] != sb[i]: 
            return sa[i], sb[i]

test = False
print(""test: "", str(test))
if test:
    fp = open(""in.txt"", 'r')
    n = int(fp.readline().strip())
    names = [fp.readline().strip() for i in range(0, n)]
    fp.close()
else:
    n = int(input().strip())
    print(""n: "", str(n))
    names = [input().strip() for i in range(0, n)]
    print(""names: "", str(names))
 
g = [[False] * 26 for i in range(0, 26)]
print(""g: "", str(g))

res = True
print(""res: "", str(res))
for i in range(1, n):
    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):
        continue
    elif isPrefix(names[i - 1], names[i]):
        res = False
        print(""res: "", str(res))
        break
    else:
        ca, cb = getOrder(names[i - 1], names[i])
        print(""ca: "", str(ca), ""cb: "", str(cb))
        #print(ca, '<', cb)
        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:
            res = False
            print(""res: "", str(res))
            break
        else:
            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True
            print(""g: "", str(g))

def printG():
    print(""   abcdefghijklmnopqrstuvwxyz"")
    for i in range(0, 26):
        print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in g[i]]), sep = 

"""")

if not res:
    print(""Impossible"")
else:
    
    def getZeroIndegreeNode():
        for i in range(0, 26):
            if not used[i] and indegree[i] == 0:
                return i
        return -1
    #topo sort
    theOrder = []
    print(""theOrder: "", str(theOrder))
    indegree = [0] * 26
    print(""indegree: "", str(indegree))
    used = [False] * 26
    print(""used: "", str(used))
    
    #calc indegree
    for i in range(0, 26):
        ithIndegree = 0
        for j in range(0, 26):
           if g[j][i]: ithIndegree += 1
        indegree[i] = ithIndegree
        print(""indegree: "", str(indegree))
    for i in range(0, 26):
        zeroIndegreeNode = getZeroIndegreeNode()
        print(""zeroIndegreeNode: "", str(zeroIndegreeNode))
        if zeroIndegreeNode == -1:
            res = False
            print(""res: "", str(res))
            break
        else:
            used[zeroIndegreeNode] = True
            print(""used: "", str(used))
            theOrder.append(chr(ord('a') + zeroIndegreeNode))
            print(""theOrder: "", str(theOrder))
            for j in range(0, 26):
                if g[zeroIndegreeNode][j]:
                    indegree[j] -= 1
                    print(""indegree: "", str(indegree))
    if not res:
        print(""Impossible"")
    else:
        print("""".join(theOrder))
</ans>",0,{}
106,"<ans>
#!/usr/bin/env python3
class UnionFind:
    # 作りたい要素数nで初期化
    # 使用するインスタンス変数の初期化
    def __init__(self, n):
        self.n = n
        print(""n: "", str(self.n))
        # root[x]<0ならそのノードが根かつその値が木の要素数
        # rootノードでその木の要素数を記録する
        self.root = [-1] * (n + 1)
        print(""root: "", str(self.root))
        # 木をくっつける時にアンバランスにならないように調整する
        self.rnk = [0] * (n + 1)
        print(""rnk: "", str(self.rnk))

    # ノードxのrootノードを見つける
    def Find_Root(self, x):
        if self.root[x] < 0:
            return x
        else:
            # ここで代入しておくことで、後の繰り返しを避ける
            self.root[x] = self.Find_Root(self.root[x])
            print(""root[{}]: "".format(x), str(self.root[x]))
            return self.root[x]

    # 木の併合、入力は併合したい各ノード
    def Unite(self, x, y):
        # 入力ノードのrootノードを見つける
        x = self.Find_Root(x)
        print(""x: "", str(x))
        y = self.Find_Root(y)
        print(""y: "", str(y))
        # すでに同じ木に属していた場合
        if x == y:
            return
        # 違う木に属していた場合rnkを見てくっつける方を決める
        elif self.rnk[x] > self.rnk[y]:
            self.root[x] += self.root[y]
            print(""root[{}]: "".format(x), str(self.root[x]))
            self.root[y] = x
            print(""root[{}]: "".format(y), str(self.root[y]))

        else:
            self.root[y] += self.root[x]
            print(""root[{}]: "".format(y), str(self.root[y]))
            self.root[x] = y
            print(""root[{}]: "".format(x), str(self.root[x]))
            # rnkが同じ（深さに差がない場合）は1増やす
            if self.rnk[x] == self.rnk[y]:
                self.rnk[y] += 1
                print(""rnk[{}]: "".format(y), str(self.rnk[y]))

    # xとyが同じグループに属するか判断
    def isSameGroup(self, x, y):
        return self.Find_Root(x) == self.Find_Root(y)

    # ノードxが属する木のサイズを返す
    def Count(self, x):
        return -self.root[self.Find_Root(x)]


def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n))
    print(""m: "", str(m))
    uf = UnionFind(n)

    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a))
        print(""b: "", str(b))
        uf.Unite(a, b)

    for i in range(n):
        i += 1
        uf.isSameGroup(i, i)

    ans = 0
    print(""ans: "", str(ans))
    for i in range(n):
        ans = max(ans, -uf.root[i + 1])
        print(""ans: "", str(ans))

    # print(uf.root)
    print(ans)


main()
</ans>",0,{}
107,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
MAX = sys.maxsize
print(""MAX: "", str(MAX))
MAXN = 10**5+10
print(""MAXN: "", str(MAXN))
MOD = 10**9+7
print(""MOD: "", str(MOD))

def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    print(""msf: "", str(msf))
    meh = 0
    print(""meh: "", str(meh))
    st = en = be = 0
    print(""st: "", str(st), ""en: "", str(en), ""be: "", str(be))
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    print(""num: "", str(num), ""den: "", str(den))
    for i in range(r):
        num = (num*(n-i))%MOD
        print(""num: "", str(num))
        den = (den*(i+1))%MOD
        print(""den: "", str(den))

    return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    a,b,c = arrIN()
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
    print((a+b+c)//2)
</ans>",0,{}
108,"<ans>
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))

flag = True
if n == 1:
    if s == '0':
        print(pow(10, 10))
    elif s == '1':
        print(pow(10, 10) * 2)
elif n == 2:
    if s in ['11', '10']:
        print(pow(10, 10))
    elif s == '01':
        print(pow(10, 10) - 1)
    else:
        print(0)
else:
    flag = True
    print(""flag: "", str(flag))
    f = n // 3
    print(""f: "", str(f))
    r = n % 3
    print(""r: "", str(r))
    for i in range(0, n, 3):
        if i == 0:
            ans = s[0:3]
            print(""ans: "", str(ans))
            if ans not in ['110', '101', '011']:
                flag = False
                print(""flag: "", str(flag))
                break
        elif i < 3 * f:
            tmp = s[i:i + 3]
            print(""tmp: "", str(tmp))
            if tmp != ans:
                flag = False
                print(""flag: "", str(flag))
                break
        else:
            tmp = s[i:n]
            print(""tmp: "", str(tmp))
            if tmp != ans[0:n - i]:
                flag = False
                print(""flag: "", str(flag))
                break
    if not flag:
        print(0)
    else:
        if ans == '110':
            if r == 0:
                print(pow(10, 10) - f + 1)
            else:
                print(pow(10, 10) - f)
        elif ans == '101':
            print(pow(10, 10) - f)
        elif ans == '011':
            if r < 2:
                print(pow(10, 10) - f)
            else:
                print(pow(10, 10) - f - 1)
</ans>",1,{}
109,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

def gcd(a,b):
	while b != 0:
		a,b = b,a%b
	return a

def stupid(x):
	r = 1
	for i in range(1, x):
		r = max(r, gcd(i&x, i^x))
	return r

d = dict()
d[511] = 73
d[2047] = 89
d[32767] = 4681
d[2097151] = 299593
d[8388607] = 178481
d[33554431] = 1082401
def smart(x):
	if x in d:
		return d[x]
	if (x & (x+1)) == 0:
		i = 0
		print(""i: "", str(i))
		while ((1<<i)-1) != x:
			i += 1
			print(""i: "", str(i))
		if i % 2 == 0:
			z = 0
			print(""z: "", str(z))
			for i in range(0,i,2):
				z += (1<<i)
				print(""z: "", str(z))
			return z
		else:
			return 1
	else:
		i = 1
		print(""i: "", str(i))
		z = 0
		print(""z: "", str(z))
		while i < x:
			if (i & x) == 0:
				z += i
				print(""z: "", str(z))
			i *= 2
			print(""i: "", str(i))
		return x+z

q = mint()
print(""q: "", str(q))
for i in range(q):
	x = mint()
	print(""x: "", str(x))
	print(smart(x))
	#if (x & (x+1)) == 0:
	#	a = stupid(x)
	#	b = smart(x)
	#	if a != b:
	#		print(x,a,b)

</ans>",0,{}
110,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
MAX = sys.maxsize
print(""MAX: "", str(MAX))
MAXN = 1000010
print(""MAXN: "", str(MAXN))
MOD = 10**9+7
print(""MOD: "", str(MOD))
spf = [i for i in range(MAXN)]
print(""spf: "", str(spf))
spf[0]=spf[1] = -1
print(""spf[0]: "", str(spf[0]), ""spf[1]: "", str(spf[1]))

def sieve():
    for i in range(2,MAXN,2):
        spf[i] = 2
    for i in range(3,int(MAXN**0.5)+1):
        if spf[i]==i:
            for j in range(i*i,MAXN,i):
                if spf[j]==j:
                    spf[j]=i

def fib(n,m):
    if n == 0:
        return [0, 1]
    else:
        a, b = fib(n // 2)
        c = ((a%m) * ((b%m) * 2 - (a%m)))%m
        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m
        print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c), ""d: "", str(d))
        if n % 2 == 0:
            return [c, d]
        else:
            return [d, c + d]
 
def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))
 
def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))
 
def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD
        print(""num: "", str(num), ""den: "", str(den))
 
    return (num*(pow(den,MOD-2,MOD)))%MOD
 
def flush():
    return sys.stdout.flush()
 
'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n = int(input())
    print(""n: "", str(n))
    if n%2:
        print(n//2)
    else:
        print(n//2-1)

</ans>",0,{}
111,"<ans>
from math import log
from decimal import Decimal

def a1(x, y, z):
    return (y ** z) * Decimal(log(x))

def s1(x, y, z):
    return ""x^y^z""

def a2(x, y, z):
    return (z ** y) * Decimal(log(x))

def s2(x, y, z):
    return ""x^z^y""

def a3(x, y, z):
    return (y * z) * Decimal(log(x))

def s3(x, y, z):
    return ""(x^y)^z""

def a4(x, y, z):
    return (y * z) * Decimal(log(x))

def s4(x, y, z):
    return ""(x^z)^y""

def a5(x, y, z):
    return (x ** z) * Decimal(log(y))

def s5(x, y, z):
    return ""y^x^z""

def a6(x, y, z):
    return (z ** x) * Decimal(log(y))

def s6(x, y, z):
    return ""y^z^x""

def a7(x, y, z):
    return (x * z) * Decimal(log(y))

def s7(x, y, z):
    return ""(y^x)^z""

def a8(x, y, z):
    return (z * x) * Decimal(log(y))

def s8(x, y, z):
    return ""(y^z)^x""

def a9(x, y, z):
    return (x ** y) * Decimal(log(z))

def s9(x, y, z):
    return ""z^x^y""

def a10(x, y, z):
    return (y ** x) * Decimal(log(z))

def s10(x, y, z):
    return ""z^y^x""

def a11(x, y, z):
    return (x * y) * Decimal(log(z))

def s11(x, y, z):
    return ""(z^x)^y""

def a12(x, y, z):
    return (y * x) * Decimal(log(z))

def s12(x, y, z):
    return ""(z^y)^x""

x, y, z = list(map(Decimal, input().split()))
print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
ans = s1(x, y, z)
print(""ans: "", str(ans))
a = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]
s = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]
max = a1(x, y, z)
print(""max: "", str(max))
for i in range (12):
    if max < a[i](x, y, z):
        ans = s[i](x, y, z)
        print(""ans: "", str(ans))
        max = a[i](x, y, z)
        print(""max: "", str(max))
print(ans)
</ans>",0,{}
112,"<ans>
s = input()

cur_len = 1
print(""cur_len: "", str(cur_len))
a = []
print(""a: "", str(a))
char = []
print(""char: "", str(char))
for i in range(1, len(s)):
    if s[i] == s[i-1]: cur_len += 1
    else:
      a.append(cur_len)
      char.append(s[i-1])
      cur_len = 1
      
a.append(cur_len)
print(""a: "", str(a))
char.append(s[len(s)-1])
print(""char: "", str(char))

ans = 0
print(""ans: "", str(ans))
while len(a) > 1:
    n = len(a)
    print(""n: "", str(n))
    inner_min = 100000000
    print(""inner_min: "", str(inner_min))
    for i in range(1,n-1):
        if a[i] < inner_min: inner_min = a[i]
        
    k = min(a[0], a[n-1],(inner_min + 1)//2)
    print(""k: "", str(k))
    b = []
    print(""b: "", str(b))
    new_char = []
    print(""new_char: "", str(new_char))
    for i in range(n):
        if i == 0 or i == n-1:
            if a[i] > k:
                b.append(a[i]-k)
                new_char.append(char[i])
        else:
            if a[i] > 2*k:
                b.append(a[i] - 2*k)
                new_char.append(char[i])
##    print(b)
    ans += k
    print(""ans: "", str(ans))
    if len(b) > 1:
        c = [0]*n
        print(""c: "", str(c))
        newnew_char = [new_char[0]]
        print(""newnew_char: "", str(newnew_char))
        count = 0
        print(""count: "", str(count))
    
        for i in range(0,len(b)-1):
            c[count] += b[i]
            if new_char[i] == new_char[i+1]: continue
            else:
                count += 1
                newnew_char.append(new_char[i+1])
        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]
        else:
            #count += 1
            newnew_char.append(new_char[i+1])
            c[count] = b[len(b)-1]
        a = c[:count+1]
        print(""a: "", str(a))
        char = newnew_char[:]
        print(""char: "", str(char))
    else:
        a = b[:]
        print(""a: "", str(a))

print(ans)
</ans>",0,{}
113,"<ans>
a,r,l,m = list(map(int,input().split()))
print(""a: "", str(a), ""r: "", str(r), ""l: "", str(l), ""m: "", str(m))
_l = list(map(int,input().split()))
print(""_l: "", str(_l))
s = set(_l)
print(""s: "", str(s))
tot = 0
print(""tot: "", str(tot))
while(abs(a)<=l):
    if(a not in s):
        tot+=1
        print(""tot: "", str(tot))
    a*=r
    print(""a: "", str(a))
print(tot)
</ans>",0,{}
114,"<ans>
import datetime
import sys
import copy
import functools
import collections
import itertools

class Solution:
    def __init__(self):
        self.N = 0
        self.boards = None

    def test(self):
        pass

    def readInput(self):
        self.N = int(input())
        print(""N: "", str(self.N))
        self.boards = []
        print(""boards: "", str(self.boards))
        for i in range(self.N):
            self.boards.append(list(input()))
            print(""boards: "", str(self.boards))

    def readMockInput(self):
        pass

    def solve(self):
        N = self.N
        print(""N: "", str(N))
        impossibleMoves = set()
        print(""impossibleMoves: "", str(impossibleMoves))
        chesses = list()
        print(""chesses: "", str(chesses))
        notAttacked = list()
        print(""notAttacked: "", str(notAttacked))
        # record all impossible moves
        for r in range(N):
            for c in range(N):
                if self.boards[r][c] == 'o':
                    chesses.append((r, c))
                    print(""chesses: "", str(chesses))
                elif self.boards[r][c] == '.':
                    notAttacked.append((r, c))
                    print(""notAttacked: "", str(notAttacked))
        # print(chesses)
        # print(notAttacked)
        for r, c in chesses:
            for i, j in notAttacked:
                impossibleMoves.add((i-r, j-c))
                print(""impossibleMoves: "", str(impossibleMoves))
        # print(impossibleMoves)

        # check whether there are any conflicts
        # reboard = [['.' for c in range(N)] for r in range(N)]
        # for r, c in chesses:
        #     reboard[r][c] = 'o'

        startTime = datetime.datetime.now()

        for i in range(N):
            for j in range(N):
                if self.boards[i][j] == 'o':
                    continue
                for r, c in chesses:
                    if (i-r, j-c) not in impossibleMoves:
                        if self.boards[i][j] == '.':
                            print('NO')
                            return
                        self.boards[i][j] = 'v'
                        print(""boards: "", str(self.boards))


        # for r, c in chesses:
        #     for i in range(-N+1, N):
        #         for j in range(-N+1, N):
        #             # much faster than 2 for
        #             if (i, j) not in impossibleMoves:
        #                 nr = r + i
        #                 nc = c + j
        #                 if 0 <= nr < N and 0 <= nc < N and self.boards[nr][nc] != 'o':
        #                     # reboard[nr][nc] = 'x'
        #
        #                     if self.boards[nr][nc] == '.':
        #                         print('NO')
        #                         return
        #                     self.boards[nr][nc] = 'v'
        #                     print(""boards: "", str(self.boards))
        if sum([row.count('x') for row in self.boards]) > 0:
            print('NO')
            return
        # for r in range(N):
        #     for c in range(N):
        #         if self.boards[r][c] != reboard[r][c]:
        #             print('NO')
        #             return
        sys.stderr.write('Check Cost: {}\n'.format(datetime.datetime.now()-startTime))



        rn = 2*N-1
        print(""rn: "", str(rn))
        res = [['.' for c in range(rn)] for r in range(rn)]
        print(""res: "", str(res))
        res[N-1][N-1] = 'o'
        for i in range(-N+1, N):
            for j in range(-N+1, N):
                if not (i == 0 and j == 0) and (i, j) not in impossibleMoves:
                    res[i+N-1][j+N-1] = 'x'
                    print(""res: "", str(res))
        print('YES')
        for row in res:
            print(''.join(row))



solution = Solution()
solution.readInput()
startTime = datetime.datetime.now()
solution.solve()
sys.stderr.write('Time Cost:{}\n'.format(datetime.datetime.now() - startTime))
</ans>",0,{}
115,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import copy
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


def pop_count(x):
    x = x - ((x >> 1) & 0x5555555555555555)
    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    x = x + (x >> 32)
    return x & 0x0000007f


def solve():
    S = Scanner.string()
    print(""S: "", str(S))
    N = len(S)
    print(""N: "", str(N))
    K = Scanner.int()
    print(""K: "", str(K))
    dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]
    print(""dp: "", str(dp))
    dp[0][0][0] = 1
    for i in range(N):
        for j in range(4):
            for k in range(2):
                nd = int(S[i])
                print(""nd: "", str(nd))
                for d in range(10):
                    ni, nj, nk = i + 1, j, k
                    print(""ni: "", str(ni), ""nj: "", str(nj), ""nk: "", str(nk))
                    if d != 0:
                        nj += 1
                    if nj > K:
                        continue
                    if k == 0:
                        if d > nd:
                            continue
                        if d < nd:
                            nk += 1
                    dp[ni][nj][nk] += dp[i][j][k]
    print((dp[N][K][0] + dp[N][K][1]))


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
116,"<ans>
import heapq


INF = float('inf')
N, M = map(int, input().split())
print(""N: "", str(N), ""M: "", str(M))
to = [[] for _ in range(N)]
print(""to: "", str(to))

#sides[i][j] : i-->jへ向かう辺を通るかどうかを保持
# 1 : 通る、0 : 通らない
sides = [[0] * N for _ in range(N)]
print(""sides: "", str(sides))


for _ in range(M):
    a, b, c = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
    a, b = a - 1, b - 1
    to[a].append((c, b))
    to[b].append((c, a))
    sides[a][b] = 1 #a, b間に辺がある
    sides[b][a] = 1


# dijkstraで最短経路木をつくる
def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq) 
    cost = [[INF, []] for i in range(N)]
    print(""cost: "", str(cost))
    cost[s][0] = 0
    while hq:
        c, v = heapq.heappop(hq)
        print(""c: "", str(c), ""v: "", str(v))
        if c > cost[v][0]:
            continue
        for d, u in to[v]:
            tmp = d + cost[v][0]
            print(""d: "", str(d), ""u: "", str(u), ""tmp: "", str(tmp))
            if tmp < cost[u][0]:
                cost[u][0] = tmp
                cost[u][1] = [v] # 更新する場合は直前の頂点を保持
                heapq.heappush(hq, (tmp, u))
                print(""Updated cost[u]: "", str(cost[u]))
            elif tmp == cost[u][0]:
                cost[u][1].append(v) # 距離が等しい場合はリストで直前の頂点を保持  
                heapq.heappush(hq, (tmp, u))
    return cost


# 作成した最短経路木を探索して、通る辺を調べる
def dfs(v, tree, p=-1):
    if p >= 0:
        sides[v][p] = 0
        sides[p][v] = 0
    for nv in tree[v][1]:
        dfs(nv, tree, v)


def main():
    for s in range(N):
        tree = dijkstra(s)
        print(""tree: "", str(tree))
        for g in range(N):
            dfs(g, tree)

    print(sum(sum(column) for column in sides) // 2)


def __starting_point():
    main()
__starting_point()
</ans>",0,{}
117,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

n, k = mints()
print(""n: "", str(n), ""k: "", str(k))
q = list(mints())
print(""q: "", str(q))
for i in range(n):
	q[i] -= 1
print(""q: "", str(q))
s = list(mints())
print(""s: "", str(s))
a = [i for i in range(1,n+1)]
print(""a: "", str(a))
d = [0]*n
print(""d: "", str(d))
b = [False]*(k+1)
print(""b: "", str(b))
c = [False]*(k+1)
print(""c: "", str(c))
e = [10000]*2
print(""e: "", str(e))
f = [10000]*2
print(""f: "", str(f))
for i in range(k+1):
	#print(a)
	b[i] = (a == s)
	if b[i]:
		e[i%2] = min(e[i%2], i)
	for j in range(n):
		d[j] = a[q[j]]
	a,d = d,a
	print(""a: "", str(a), ""d: "", str(d))
#print('====')
a = [i for i in range(1,n+1)]
print(""a: "", str(a))
for i in range(k+1):
	#print(a)
	c[i] = (a == s)
	if c[i]:
		f[i%2] = min(f[i%2], i)
	for j in range(n):
		d[q[j]] = a[j]
	a,d = d,a
	print(""a: "", str(a), ""d: "", str(d))
#print('====')
#print(e)
#print(f)
if e[0] == 0:
	print('NO')
elif e[1] == 1:
	if f[1] == 1 and k > 1:
		print('NO')
	elif k%2 == 1 or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
elif f[1] == 1:
	if k%2 == 1 or e[k%2] <= k:
		print('YES')
	else:
		print('NO')
else:
	if e[k%2] <= k or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
</ans>",1,{}
118,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    print(""divisors: "", str(divisors))
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    print(""divs_number: "", str(divs_number))
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
        print(""divs_number: "", str(divs_number))
    return divs_number

def flin(d, x, default=-1):
    left = right = -1
    print(""left: "", str(left), ""right: "", str(right))
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    if left == -1:
        return default, default
    else:
        return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' ', end='\n'): print(sep.join(map(str, a)), end=end)
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, m = mi()
    print(""n: "", str(n), ""m: "", str(m))
    if n == 1:
        print(0)
    elif n == 2:
        print(m)
    else:
        print(2*m)
</ans>",0,{}
119,"<ans>
from random import randint

def factMod(n, mod):
    res = 1
    for i in range(2, n+1):
        res = (res * i) % mod
    return res

def powMod(n, p, mod):
    res = 1

    while p > 0:
        if p % 2 == 1:
            res = (res * n) % mod
        
        p //= 2
        n = (n * n) % mod

    return res

def invMod(n, mod):
    return powMod(n, mod - 2, mod)

#t = 6
#print(invMod(t, 97))
#print( (invMod(t, 97) * t) % 97 )
#return

def CnkMod(n, k, mod):
    return (
        factMod(n, mod) *
        invMod(factMod(k, mod) * factMod(n-k, mod), mod)
    ) % mod

def computeCnksMod(N, mod):
    res = [[0] * (N+1) for i in range(N+1)]
    res[0][0] = 1
    for n in range(1, N+1):
        res[n][0] = res[n-1][0]
        for k in range(1, n+1):
            res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod

    return res

magic = 998244353
print(""magic: "", str(magic))

n = int(input()) + 1
print(""n: "", str(n))

aa = [1] + [int(s)+1 for s in input().split(' ')]
print(""aa: "", str(aa))

cnks = computeCnksMod(n, magic)
print(""cnks: "", str(cnks))

d = [0] * (n + 1)
print(""d: "", str(d))

d[n] = 1
print(""d[n]: "", str(d[n]))

for i in reversed(list(range(n))):
    if i != 0 and aa[i] < 2:
        continue
    
    cur = 0
    print(""cur: "", str(cur))

    tosel = aa[i] - 1
    print(""tosel: "", str(tosel))

    for j in range(i + tosel + 1, n + 1):
        avail = j - i - 1
        print(""avail: "", str(avail))
        #cur = (cur + CnkMod(avail, tosel, magic) *",0,{}
120,"<ans>
from math import sin
def mp():  return list(map(int,input().split()))
def lt():  return list(map(int,input().split()))
def pt(x):  print(x)
def ip():  return input()
def it():  return int(input())
def sl(x):  return [t for t in x]
def spl(x): return x.split()
def aj(liste, item): liste.append(item)
def bin(x):  return ""{0:b}"".format(x)
def listring(l): return ' '.join([str(x) for x in l])
def ptlist(l): print(' '.join([str(x) for x in l]))

n = it()
print(""n: "", str(n))
step = lt()
print(""step: "", str(step))
dict = {}
def explosion(start,s,d):
    (i,j) = start
    t = s+1
    print(""t: "", str(t))
    if d == 0:
        for k in range(j+1,j+t):
            dict[(i,k)] = True
        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)
    if d == 1:
        for k in range(1,t):
            dict[(i+k,j+k)] = True
        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)
    if d == 2:
        for k in range(1,t):
            dict[(i+k,j)] = True
        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)
    if d == 3:
        for k in range(1,t):
            dict[(i+k,j-k)] = True
        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)
    if d == 4:
        for k in range(1,t):
            dict[(i,j-k)] = True
        return ((i,j-t+1),(d+7)%8),((i,j-t",0,{}
121,"<ans>
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
import itertools
from functools import *
from itertools import permutations,combinations,groupby
import sys
import bisect
import string
import math
import time
import random
def Golf():
    *a,=map(int,open(0))
def S_():
    return input()
def IS():
    return input().split()
def LS():
    return [i for i in input().split()]
def I():
    return int(input())
def MI():
    return map(int,input().split())
def LI():
    return [int(i) for i in input().split()]
def LI_():
    return [int(i)-1 for i in input().split()]
def NI(n):
    return [int(input()) for i in range(n)]
def NI_(n):
    return [int(input())-1 for i in range(n)]
def StoI():
    return [ord(i)-97 for i in input()]
def ItoS(nn):
    return chr(nn+97)
def LtoS(ls):
    return ''.join([chr(i+97) for i in ls])
def GI(V,E,Directed=False,index=0):
    org_inp=[]
    g=[[] for i in range(n)]
    for i in range(E):
        inp=LI()
        org_inp.append(inp)
        if index==0:
            inp[0]-=1
            inp[1]-=1
        if len(inp)==2:
            a,b=inp
            print(""a: "", str(a), ""b: "", str(b))
            g[a].append(b)
            if not Directed:
                g[b].append(a)
        elif len(inp)==3:
            a,b,c=inp
            print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
            aa=(inp[0],inp[2])
            bb=(inp[1],inp[2])
            g[a].append(bb)
            if not Directed:
                g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):
#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage
    mp=[1]*(w+2)
    found={}
    for i in range(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[1]+[mp_def[j] for j in s]+[1]
    mp+=[1]*(w+2)
    return h+2,w+2,mp,found
def bit_combination(k,n=2):
    rt=[]
    for tb in range(n**k):
        s=[tb//(n**bt)%n for bt in range(k)]
        rt+=[s]
    return rt
def show(*inp,end='\n'):
    if show_flg:
        print(*inp,end=end)
YN=['YES','NO']
Yn=['Yes','No']

mo=10**9+7
inf=float('inf')
l_alp=string.ascii_lowercase
u_alp=string.ascii_uppercase
#ts=time.time()
#sys.setrecursionlimit(10**7)
input=lambda: sys.stdin.readline().rstrip()
 
def ran_input():
    import random
    n=random.randint(4,16)
    rmin,rmax=1,10
    a=[random.randint(rmin,rmax) for _ in range(n)]
    return n,a

def ran_input():
    import random
    n=random.randint(4,16)
    rmin,rmax=1,10
    a=[random.randint(rmin,rmax) for _ in range(n)]
    return n,a

show_flg=False
show_flg=True

ans=0
print(""ans: "", str(ans))

n=I()
print(""n: "", str(n))
m=LI()
print(""m: "", str(m))
tot=0
for i in range(n):
    l,r=[],[]
    
    tmp=m[i]
    print(""tmp: "", str(tmp))
    p=m[i]
    print(""p: "", str(p))
    
    # right
    for j in range(i+1,n):
        if m[j]<p:
            p=m[j]
        tmp+=p
        r+=[p]
    
    p=m[i]
    print(""p: "", str(p))
    # left
    for j in range(i-1,-1,-1):
        if m[j]<p:
            p=m[j]
        tmp+=p
        l+=[p]
    
    if tmp>tot:
        tot=tmp
        print(""tot: "", str(tot))
        ans=l[::-1]+[m[i]]+r
        print(""ans: "", str(ans))
        
print(*ans)
</ans>",0,{}
122,"<ans>
#f = lambda: input()
#file = open(""btest"", ""r"")
#f = lambda:file.readline()

# n, m = map(int, f().split())

# g = []

# for i in range(n):
#     g.append(f())

# disco = [[False for _ in range(m)] for _ in range(n)]

# #print(disco)
# #print(parent)
          
# def found_cycle(w):
#     nonlocal disco
#     s = []
#     s.append(w)
#     while s:
#         v = s.pop()
#         if disco[v[0]][v[1]] == False:
#             if v[0] > 0 and g[v[0]-1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]-1, v[1]])
                
#             if v[0] < n-1 and g[v[0]+1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]+1, v[1]])
                
#             if v[1] > 0 and g[v[0]][v[1]-1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]-1])
                
#             if v[1] < m-1 and g[v[0]][v[1]+1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]+1])
                
#         else:
#             disco[v[0]][v[1]] = True
#     return False

# found = False
# for i in range(n):
#     if found:
#         break
#     for j in range(m):
#         if disco[i][j] == False:
#             found = found_cycle([i,j])
#             break

# if found:
#     print (""Yes"")
# else:
#     print (""No"")

#Editorial
import sys
sys.setrecursionlimit(10000)

#file = open(""btest"", ""r"")
#f = lambda:file.readline()
f = lambda:input()

n,m = list(map(int, f().split()))
print(""n: "", str(n), ""m: "", str(m))

matrix = []
print(""matrix: "", str(matrix))

disco = [[0 for _ in range(m)] for _ in range(n)]
print(""disco: "", str(disco))

for i in range(n):
    matrix.append(f())
    print(""matrix: "", str(matrix))

def valid_node(i, j):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, k, cc = 0):
    if disco[i][j] == k:
        return True
    
    disco[i][j] = k
    print(""disco: "", str(disco))

    res = False
    dd = [[0,1], [1,0], [-1,0], [0,-1]]
    for d in dd:
        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:
                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)

    return res

ok = False
print(""ok: "", str(ok))
k = 1
print(""k: "", str(k))
for i in range(n):
    for j in range(m):
        if disco[i][j] == 0:
            ok = ok or dfs(i, j, [i, j], k)
            print(""ok: "", str(ok))
            k += 1
            print(""k: "", str(k))

if ok:
    print(""Yes"")
else:
    print(""No"")
</ans>",0,{}
123,"<ans>
D = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100}

k = int(input())
print(""k: "", str(k))
start = k - k%100
print(""start: "", str(start))
i = D[start]
print(""i: "", str(i))
j = start
print(""j: "", str(j))

while j < k:
    i += 1
    print(""i: "", str(i))
    if sum(int(d) for d in str(i))==10:
        j += 1
        print(""j: "", str(j))
print(i)
</ans>",1,{}
124,"<ans>
MOD = 998244353


def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    print(""mask: "", str(mask))
    nx = int(x)
    print(""nx: "", str(nx))
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)] 
    print(""sx: "", str(sx))
    n = len(sx) 
    print(""n: "", str(n))
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) : 
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    print(""cmask: "", str(cmask))
    csum = 0
    print(""csum: "", str(csum))
    for i in range(n) :
        cdig = sx[i]
        print(""cdig: "", str(cdig))
        for use in range(cdig) : 
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            print(""nmask: "", str(nmask))
            for mask in range(1 << 10) : 
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        print(""cmask: "", str(cmask))
        csum = (10 * csum + cdig) % MOD
        print(""csum: "", str(csum))
    return ans

prepare()
l, r, k = list(map(int, input().split()))
print(""l: "", str(l), ""r: "", str(r), ""k: "", str(k))
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(""ans: "", str(ans))
    

</ans>",0,{}
125,"<ans>
def main():
    N, M = (int(i) for i in input().split())
    print(""N: "", str(N), ""M: "", str(M))

    par = [i for i in range(N)]
    print(""par: "", str(par))
    size = [1 for i in range(N)]
    print(""size: "", str(size))

    def find(x):
        if par[x] == x:
            return x
        else:
            par[x] = find(par[x])
            size[x] = size[par[x]]
            return par[x]

    def same(x, y):
        return find(x) == find(y)

    def union(x, y):
        x = find(x)
        y = find(y)
        if x == y:
            return
        if size[x] < size[y]:
            x, y = y, x
        size[x] += size[y]
        par[y] = x

    def get_size(x):
        return size[find(x)]

    G = [[] for _ in range(N)]
    print(""G: "", str(G))
    for _ in range(M):
        a, b = (int(i) for i in input().split())
        print(""a: "", str(a), ""b: "", str(b))
        G[a-1].append(b-1)
        G[b-1].append(a-1)
        union(a-1, b-1)

    S = [False]*4
    print(""S: "", str(S))
    for i in range(N):
        S[min(3, get_size(i))] = True
        if S[3]:
            break
    t = 0
    if S[3]:
        t = 1
    elif S[2]:
        t = 2
    else:
        t = 3
    print(""t: "", str(t))

    color = [-1]*N
    print(""color: "", str(color))

    def dfs(s):
        stack = [s]
        color[s] = 0
        b = 1
        w = 0
        while stack:
            v = stack.pop()
            for u in G[v]:
                if color[u] != -1:
                    if color[u] == color[v]:
                        return False, b*w
                    continue
                color[u] = color[v] ^ 1
                if color[u] == 0:
                    b += 1
                else:
                    w += 1
                stack.append(u)
        return True, b*(b-1)//2 + w*(w-1)//2

    is_bipartite, _ = dfs(0)
    if is_bipartite:
        w = 0
        if t == 3:
            w = N*(N-1)*(N-2)//3//2
        elif t == 2:
            used = [False]*N
            print(""used: "", str(used))
            for i in range(N):
                if not used[find(i)] and get_size(i) == 2:
                    w += (N-2)
                    used[find(i)] = True
        elif t == 1:
            used = [False]*N
            print(""used: "", str(used))
            color = [-1]*N
            print(""color: "", str(color))
            for i in range(N):
                if not used[find(i)] and get_size(i) >= 3:
                    _, ways = dfs(i)
                    w += ways
                    used[find(i)] = True
        print(t, w)
    else:
        print(0, 1)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
126,"<ans>
__author__ = 'Michael Ilyin'

import math

# debug = True
debug = False


def dist(x1, y1, x2, y2):
    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))


def get_y(x1, y1, x2, y2, x):
    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1

if debug:
    with open(""input.txt"", ""r"") as inp:
        firstLine = inp.readline()
        secondLine = inp.readline()
        thirdLine = inp.readline()
        fourthLine = inp.readline()
else:
    firstLine = input()
    secondLine = input()
    thirdLine = input()
    fourthLine = input()

first = firstLine.split()
print(""first: "", str(first))
n = float(first[0])
print(""n: "", str(n))
m = float(first[1])
print(""m: "", str(m))
a = float(first[2])
print(""a: "", str(a))
b = float(first[3])
print(""b: "", str(b))

A = [float(x) for x in secondLine.split()]
print(""A: "", str(A))
B = [float(x) for x in thirdLine.split()]
print(""B: "", str(B))
L = [float(x) for x in fourthLine.split()]
print(""L: "", str(L))

if debug:
    print(A)
    print(B)
    print(L)

optimalLen = float(""inf"")
print(""optimalLen: "", str(optimalLen))
optimalBIdx = -1
print(""optimalBIdx: "", str(optimalBIdx))
for i, bi in enumerate(B):
    d = dist(0, 0, b, bi) + L[i]
    print(""d: "", str(d))
    if d <= optimalLen:
        optimalLen = d
        print(""optimalLen: "", str(optimalLen))
        optimalBIdx = i
        print(""optimalBIdx: "", str(optimalBIdx))

if debug:
    print(optimalBIdx + 1, optimalLen)

intersectY = get_y(0, 0, b, B[optimalBIdx], a)
print(""intersectY: "", str(intersectY))

if debug:
    print(intersectY)

pointDist = float(""inf"")
print(""pointDist: "", str(pointDist))
optimalAIdx = -1
print(""optimalAIdx: "", str(optimalAIdx))
for i, ai in enumerate(A):
    d = dist(a, ai, a, intersectY)
    print(""d: "", str(d))
    if d < pointDist:
        pointDist = d
        print(""pointDist: "", str(pointDist))
        optimalAIdx = i
        print(""optimalAIdx: "", str(optimalAIdx))

if debug:
    print(optimalAIdx + 1, pointDist)

optimalLen = float(""inf"")
print(""optimalLen: "", str(optimalLen))
optimalBIdx = -1
print(""optimalBIdx: "", str(optimalBIdx))
for i, bi in enumerate(B):
    d = dist(a, A[optimalAIdx], b, bi) + L[i]
    print(""d: "", str(d))
    if d <= optimalLen:
        optimalLen = d
        print(""optimalLen: "", str(optimalLen))
        optimalBIdx = i
        print(""optimalBIdx: "", str(optimalBIdx))

print(optimalAIdx + 1, optimalBIdx + 1)
</ans>",0,{}
127,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

# M = mod = 998244353
def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))
def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\n')]


n = val()
print(""n: "", str(n))
l = li()
print(""l: "", str(l))
l1 = l[:]
print(""l1: "", str(l1))
l2 = l[:]
print(""l2: "", str(l2))

i = 0
l1 = sorted(list(set(l1)))
print(""l1: "", str(l1))
doit = tot1 = 0
print(""doit: "", str(doit), ""tot1: "", str(tot1))
cn = Counter(l1)
print(""cn: "", str(cn))
l = l1[:]
print(""l: "", str(l))
while i < len(l1):
    if cn[l[i] - 1] > 0:
        cn[l[i]] -= 1
        cn[l[i] - 1] += 1
        l[i] -= 1
        i += 1
    else:
        cn[l[i]] -= 1
        cn[l[i] + 1] += 1
        l[i] += 1
        if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2
        else:i += 1
# print(cn)
tot1 = sum(1 for i in cn if cn[i])
print(""tot1: "", str(tot1))







# print(l1)



i = 0

cnt = Counter(l2)
print(""cnt: "", str(cnt))
l2 = sorted(l2)
print(""l2: "", str(l2))

l = l2[:]
print(""l: "", str(l))



for i in range(n):
    if cnt[l[i] - 1] == 0:
        cnt[l[i] - 1] += 1
        cnt[l[i]] -= 1
        l[i] -= 1
    elif cnt[l[i]] > 1:
        cnt[l[i] + 1] += 1
        cnt[l[i]] -= 1
        l[i] += 1


tot2 = sum(1 for i in cnt if cnt[i])
print(""tot2: "", str(tot2))




print(tot1,tot2)
</ans>",0,{}
128,"<ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush
    
input = sys.stdin.readline
def RD(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]
    
    
def main():
    N = I()
    print(""N: "", str(N))
    if N == 0:
        print(0)
        return
    if N < 0:
        N = -N
        print(""N: "", str(N))
        D = defaultdict(int)
        print(""D: "", str(D))
        index = 0
        print(""index: "", str(index))
        while N >= 1:
            #bitフラグがたっていたら
            if N & 1 == 1:
                #2の倍数の場合D[index]とD[index+1]に1を足す
                if index % 2 == 0:
                    D[index] += 1
                    print(""D[index]: "", str(D[index]))
                    D[index+1] += 1
                    print(""D[index+1]: "", str(D[index+1]))
                else:
                    D[index] += 1
                    print(""D[index]: "", str(D[index]))
            else:
                D[index] = D[index]
            N = N>>1
            index += 1
            print(""N: "", str(N))
            print(""index: "", str(index))
    else:
        D = defaultdict(int)
        print(""D: "", str(D))
        if N & 1 == 1:
            D[0] = 1
            print(""D[0]: "", str(D[0]))
        else:
            D[0] = 0
            print(""D[0]: "", str(D[0]))
        index = 1
        print(""index: "", str(index))
        N = N >> 1
        print(""N: "", str(N))

        while N >= 1:
            #bitフラグがたっていたら
            if N & 1 == 1:
                #2の倍数の場合D[index]とD[index+1]に1を足す
                if index % 2 == 1:
                    D[index] += 1
                    print(""D[index]: "", str(D[index]))
                    D[index+1] += 1
                    print(""D[index+1]: "", str(D[index+1]))
                else:
                    D[index] += 1
                    print(""D[index]: "", str(D[index]))
            else:
                D[index] = D[index]
            N = N>>1
            index += 1
            print(""N: "", str(N))
            print(""index: "", str(index))
            
    index = 0
    print(""index: "", str(index))
    while True:
        if not index in D.keys():
            break
        if D[index] <= 1:
            pass
        else:
            temp = D[index]
            print(""temp: "", str(temp))
            D[index] = temp % 2
            print(""D[index]: "", str(D[index]))
            D[index+1] += (temp // 2)
            print(""D[index+1]: "", str(D[index+1]))
            D[index+2] += (temp // 2)
            print(""D[index+2]: "", str(D[index+2]))
            if D[index+1] >= D[index+2] * 2:
                temp = D[index+2]
                print(""temp: "", str(temp))
                D[index+2] -= temp
                print(""D[index+2]: "", str(D[index+2]))
                D[index+1] -= temp * 2
                print(""D[index+1]: "", str(D[index+1]))
        index += 1
        print(""index: "", str(index))
    res = True
    print(""res: "", str(res))

    for i in reversed(D.values()):
        if res and i == 1:
            res = False
        if not res:
            print(i, end="""")
    print()

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
129,"<ans>
n, k = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k))
XY = [list(map(int, input().split())) for _ in range(n)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[0])
XY = [xy + [x] for x, xy in enumerate(XY)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[1])
XY = [xy + [y] for y, xy in enumerate(XY)]
print(""XY: "", str(XY))

gr = [[0] * n for _ in range(n)]
print(""gr: "", str(gr))
for _, _, i, j in XY:
  gr[i][j] = 1
  
rui = [[0] * (n + 1) for _ in range(n + 1)]
print(""rui: "", str(rui))
for i in range(n):
  for j in range(n):
    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]
    print(""rui[{}][{}]: "".format(i + 1, j + 1), str(rui[i + 1][j + 1]))

# XYの2点,3点,4点を総当たり
ans = 10 ** 21
print(""ans: "", str(ans))
for i in range(n - 1):
  for j in range(i + 1, n):
    x = [XY[m][0] for m in [i, j]]
    print(""x: "", str(x))
    y = [XY[m][1] for m in [i, j]]
    print(""y: "", str(y))
    ii = [XY[m][2] for m in [i, j]]
    print(""ii: "", str(ii))
    jj = [XY[m][3] for m in [i, j]]
    print(""jj: "", str(jj))
    innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                + rui[min(ii)][min(jj)] \
                - rui[min(ii)][max(jj) + 1] \
                - rui[max(ii) + 1][min(jj)]
    print(""innerPoints: "", str(innerPoints))
    if innerPoints >= k:
      area = (max(x) - min(x)) * (max(y) - min(y)) 
      print(""area: "", str(area))
      if area < ans:
        ans = area
        print(""ans: "", str(ans))

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        x = [XY[m][0] for m in [i, j, l]]
        print(""x: "", str(x))
        y = [XY[m][1] for m in [i, j, l]]
        print(""y: "", str(y))
        ii = [XY[m][2] for m in [i, j, l]]
        print(""ii: "", str(ii))
        jj = [XY[m][3] for m in [i, j, l]]
        print(""jj: "", str(jj))
        innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                    + rui[min(ii)][min(jj)] \
                    - rui[min(ii)][max(jj) + 1] \
                    - rui[max(ii) + 1][min(jj)]
        print(""innerPoints: "", str(innerPoints))
        if innerPoints >= k:
          area = (max(x) - min(x)) * (max(y) - min(y)) 
          print(""area: "", str(area))
          if area < ans:
            ans = area
            print(""ans: "", str(ans))

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          x = [XY[m][0] for m in [i, j, o, l]]
          print(""x: "", str(x))
          y = [XY[m][1] for m in [i, j, o, l]]
          print(""y: "", str(y))
          ii = [XY[m][2] for m in [i, j, o, l]]
          print(""ii: "", str(ii))
          jj = [XY[m][3] for m in [i, j, o, l]]
          print(""jj: "", str(jj))
          innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                      + rui[min(ii)][min(jj)] \
                      - rui[min(ii)][max(jj) + 1] \
                      - rui[max(ii) + 1][min(jj)]
          print(""innerPoints: "", str(innerPoints))
          if innerPoints >= k:
            area = (max(x) - min(x)) * (max(y) - min(y)) 
            print(""area: "", str(area))
            if area < ans:
              ans = area
              print(""ans: "", str(ans))

print(ans)
</ans>",1,{}
130,"<ans>
import math
from fractions import gcd

def primes(limit):
    Ans=[]
    C=[True]*(limit+1)
    L=list(range(2,limit+1))
    for item in L:
        if(C[item]):
            i=2
            while(item*i<=limit):
                C[item*i]=False
                i+=1
    for item in L:
        if(C[item]):
            Ans+=[item]
    return Ans


a,b=list(map(int,input().split()))
print(""a: "", str(a), ""b: "", str(b))
aa=a
print(""aa: "", str(aa))
bb=b
print(""bb: "", str(bb))
A=[]
print(""A: "", str(A))
B=[]
print(""B: "", str(B))

p=primes(int(math.sqrt(10**9)))
print(""p: "", str(p))

for i in range(len(p)):
    if(p[i]>a):
        break
    while(a%p[i]==0):
        A.append(p[i])
        print(""A: "", str(A))
        a//=p[i]
if(a!=1):
    A.append(a)
    print(""A: "", str(A))


for i in range(len(p)):
    if(p[i]>b):
        break
    while(b%p[i]==0):
        B.append(p[i])
        print(""B: "", str(B))
        b//=p[i]
if(b!=1):
    B.append(b)
    print(""B: "", str(B))

if(aa==1 and bb==1):
    print(0)

elif(aa==1):
    Done=True
    for item in B:
        if(item>5):
            Done=False
            break
    if(Done):
        print(len(B))
    else:
        print(-1)
elif(bb==1):
    Done=True
    for item in A:
        if(item>5):
            Done=False
            break
    if(Done):
        print(len(A))
    else:
        print(-1)

else:

    B.sort()
    print(""B: "", str(B))
    A.sort()
    print(""A: "", str(A))
    Done=True
    ind=0
    ans=0
    while(A!=B):
        if(ind>=len(A) and ind>=len(B)):
            Done=False
            break
        elif(ind>=len(A)):
            if(B[-1]>5):
                Done=False
                break
            else:
                ans+=len(B)-ind
                break
        elif(ind>=len(B)):
            if(A[-1]>5):
                Done=False
                break
            else:
                ans+=len(A)-ind
                break
        if(A[ind]==B[ind]):
            ind+=1
            continue
        
        if(A[ind]<B[ind]):
            if(A[ind]>5):
                Done=False
                break
            else:
                ans+=1
                A.pop(ind)
                print(""A: "", str(A))
        else:
            if(B[ind]>5):
                Done=False
                break
            else:
                ans+=1
                B.pop(ind)
                print(""B: "", str(B))
    if(Done):
        print(ans)
    else:
        print(-1)

</ans>",0,{}
131,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


MOD = int(1e09) + 7
INF = int(1e15)


def solve():
    N = Scanner.int()
    print(""N: "", str(N))
    A = [0 for _ in range(N)]
    print(""A: "", str(A))
    B = [0 for _ in range(N)]
    print(""B: "", str(B))
    for i in range(N):
        A[i], B[i] = Scanner.map_int()
        print(""A[{}]: "".format(i), str(A[i]), ""B[{}]: "".format(i), str(B[i]))
    A.sort()
    print(""A sorted: "", str(A))
    B.sort()
    print(""B sorted: "", str(B))
    if N % 2 == 0:
        mA = A[N // 2] + A[N // 2 - 1]
        print(""mA: "", str(mA))
        mB = B[N // 2] + B[N // 2 - 1]
        print(""mB: "", str(mB))
        print((mB - mA + 1))
    else:
        mA = A[N // 2]
        print(""mA: "", str(mA))
        mB = B[N // 2]
        print(""mB: "", str(mB))
        print((mB - mA + 1))


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
132,"<ans>
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))

c=[0]*1001
print(""c: "", str(c))

for i in range (len(a)):
	c[a[i]]+=1

sym=0
print(""sym: "", str(sym))
sin=0
print(""sin: "", str(sin))

for i in range (1001):
	sym+=(c[i]//4)
	print(""sym: "", str(sym))
	if(c[i]%2==1):
		sin+=1
		print(""sin: "", str(sin))

if(n%2==0 and sym==((n*n)//4)):
	mat= [([0]*(n//2)) for i in range (n//2)]
	print(""mat: "", str(mat))
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			print(""ar: "", str(ar))
			c[i]-=4
	
	k=0
	print(""k: "", str(k))
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			print(""mat[{}][{}]: "".format(i, j), str(mat[i][j]))
			k+=1

	newm=[([0]*n) for i in range (n)]
	print(""newm: "", str(newm))
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			print(""newm[{}][{}]: "".format(i, j), str(newm[i][j]))
			newm[n-i-1][j]=mat[i][j]
			print(""newm[{}][{}]: "".format(n-i-1, j), str(newm[n-i-1][j]))
			newm[n-i-1][n-j-1]=mat[i][j]
			print(""newm[{}][{}]: "".format(n-i-1, n-j-1), str(newm[n-i-1][n-j-1]))
			newm[i][n-j-1]=mat[i][j]
			print(""newm[{}][{}]: "".format(i, n-j-1), str(newm[i][n-j-1]))

	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

	
elif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):
	mat= [([0]*(n//2)) for i in range (n//2)]
	print(""mat: "", str(mat))
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			print(""ar: "", str(ar))
			c[i]-=4
	
	k=0
	print(""k: "", str(k))
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			print(""mat[{}][{}]: "".format(i, j), str(mat[i][j]))
			ar.pop(k)

	newm=[([0]*n) for i in range (n)]
	print(""newm: "", str(newm))
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			print(""newm[{}][{}]: "".format(i, j), str(newm[i][j]))
			newm[n-i-1][j]=mat[i][j]
			print(""newm[{}][{}]: "".format(n-i-1, j), str(newm[n-i-1][j]))
			newm[n-i-1][n-j-1]=mat[i][j]
			print(""newm[{}][{}]: "".format(n-i-1, n-j-1), str(newm[n-i-1][n-j-1]))
			newm[i][n-j-1]=mat[i][j]
			print(""newm[{}][{}]: "".format(i, n-j-1), str(newm[i][n-j-1]))

	na=len(ar)
print(""na: "", str(na))
	ar2=[]
	for i in range (na):
		ar2.append(ar[i])
		print(""ar2: "", str(ar2))
		ar2.append(ar[i])

	for i in range (1001):
		while(c[i]>=2):
			ar2.append(i)
			print(""ar2: "", str(ar2))
			c[i]-=2

	#print(ar)
	for i in range (n//2):
		newm[n//2 ][i]=ar2[0]
		print(""newm[{}][{}]: "".format(n//2, i), str(newm[n//2 ][i]))
		newm[n//2 ][n-i-1]=ar2[0]
		print(""newm[{}][{}]: "".format(n//2, n-i-1), str(newm[n//2 ][n-i-1]))
		ar2.pop(0)
		newm[i][n//2 ]=ar2[0]
		print(""newm[{}][{}]: "".format(i, n//2), str(newm[i][n//2 ]))
		newm[n-i-1][n//2 ]=ar2[0]
		print(""newm[{}][{}]: "".format(n-i-1, n//2), str(newm[n-i-1][n//2 ]))
		ar2.pop(0)

	for i in range (1001):
		if(c[i]==1):
			newm[n//2][n//2]=i
			print(""newm[{}][{}]: "".format(n//2, n//2), str(newm[n//2][n//2]))

	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

else:
	print(""NO"")
</ans>",0,{}
133,"<ans>
import sys
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))
height=n
print(""height: "", str(height))
ans=[]
print(""ans: "", str(ans))
last3=-1
print(""last3: "", str(last3))
fail=0
print(""fail: "", str(fail))
used=-1
print(""used: "", str(used))
for i in range(n):
    if a[i]==3:
        if height==n:
            ans.append((n-height+1,i+1))
            height-=1
            print(""height: "", str(height))
        else:
            ans.append((n+1-(height+1),i+1))
            ans.append((n+1-height,i+1))
            height-=1
            print(""height: "", str(height))
        last3=i
        print(""last3: "", str(last3))
if last3==n-1:
    print(-1)
    return
if last3>-1:
    flag=0
    for i in range(last3,n):
        if a[i]==2:
            flag=1
            ans.append((n+1-(height+1),i+1))
            height-=1
            print(""height: "", str(height))
            break
    if flag==0:
        flag2=0
        for i in range(last3,n):
            if a[i]==1:
                ans.append((n+1-(height+1),i+1))
                height-=1
                print(""height: "", str(height))
                flag2=1
                used=i
                print(""used: "", str(used))
                break
        if flag2==0:
            print(-1)
            return
ones=[]
print(""ones: "", str(ones))
if used==-1:
    height-=1
    print(""height: "", str(height))
for i in range(n-1,-1,-1):
    if a[i]==1 and i!=used:
        ones.append(i)
        print(""ones: "", str(ones))
    if a[i]==2:
        if len(ones)==0:
            print(-1)
            return
        k=ones.pop()
        ans.append((n+1-(height+1),i+1))
        ans.append((n+1-(height+1),k+1))
        height-=1
        print(""height: "", str(height))
if used>-1:
    ones.append(used)
    print(""ones: "", str(ones))
for i in ones:
    ans.append((n+1-(height+1),i+1))
    height-=1
    print(""height: "", str(height))
print(len(ans))
for x,y in ans:
    print(x,y)
</ans>",0,{}
134,"<ans>
__author__ = 'zhan'

import time
[a1, b1] = [int(i) for i in input().split()]
print(""a1: "", str(a1), ""b1: "", str(b1))
[a2, b2] = [int(i) for i in input().split()]
print(""a2: "", str(a2), ""b2: "", str(b2))

t0 = time.time()
q1 = [[a1, b1, 0]]
print(""q1: "", str(q1))
q2 = [[a2, b2, 0]]
print(""q2: "", str(q2))
tested1 = []
print(""tested1: "", str(tested1))
tested2 = []
print(""tested2: "", str(tested2))
tested_total1 = []
print(""tested_total1: "", str(tested_total1))
tested_total2 = []
print(""tested_total2: "", str(tested_total2))


def equal(t, q):
    lo = 0
    print(""lo: "", str(lo))
    hi = len(q)
    print(""hi: "", str(hi))
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        print(""m: "", str(m))
        p = q[m]
        print(""p: "", str(p))
        temp = p[0] * p[1]
        print(""temp: "", str(temp))
        if t == temp:
            return [p[0], p[1], p[2]]
        if t < temp:
            lo = m + 1
            print(""lo: "", str(lo))
        elif t > temp:
            hi = m
            print(""hi: "", str(hi))


def found(key, a):
    lo = 0
    print(""lo: "", str(lo))
    hi = len(a)
    print(""hi: "", str(hi))
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        print(""m: "", str(m))
        p = a[m]
        print(""p: "", str(p))
        if key[0] == p[0] and key[1] == p[1]:
            return True
        if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:
            lo = m + 1
            print(""lo: "", str(lo))
        if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:
            hi = m
            print(""hi: "", str(hi))


while True:
    if len(q1) > 0 and len(q2) > 0:
        total1 = q1[0][0] * q1[0][1]
        print(""total1: "", str(total1))
        total2 = q2[0][0] * q2[0][1]
        print(""total2: "", str(total2))
        if total1 > total2:
            ans = equal(total1, q2)
            if ans:
                print(str(ans[2] + q1[0][2]) + ""\n"" + str(q1[0][0]) + "" "" + str(q1[0][1]) + ""\n"" + str(ans[0]) + "" "" + str(ans[1]))
            else:
                if not(q1[0][0] & 1):
                    tt = [q1[0][0] // 2, q1[0][1], q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested1) == 0 or (not found([tt[0], tt[1]], tested1)):
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        print(""tested1: "", str(tested1))
                        q1.append(tt)
                        print(""q1: "", str(q1))
                        tested_total1.append(tt[0]*tt[1])
                        print(""tested_total1: "", str(tested_total1))
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q1[0][0] % 3 == 0:
                    tt = [q1[0][0] // 3 * 2, q1[0][1], q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested1) == 0 or (not found([tt[0], tt[1]], tested1)):
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        print(""tested1: "", str(tested1))
                        q1.append(tt)
                        print(""q1: "", str(q1))
                        tested_total1.append(tt[0]*tt[1])
                        print(""tested_total1: "", str(tested_total1))
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(q1[0][1] & 1):
                    tt = [q1[0][0], q1[0][1] // 2, q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested1) == 0 or (not found([tt[0], tt[1]], tested1)):
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        print(""tested1: "", str(tested1))
                        q1.append(tt)
                        print(""q1: "", str(q1))
                        tested_total1.append(tt[0]*tt[1])
                        print(""tested_total1: "", str(tested_total1))
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q1[0][1] % 3 == 0:
                    tt = [q1[0][0], q1[0][1] // 3 * 2, q1[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested1) == 0 or (not found([tt[0], tt[1]], tested1)):
                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
                        tested1.append([tt[0], tt[1]])
                        print(""tested1: "", str(tested1))
                        q1.append(tt)
                        print(""q1: "", str(q1))
                        tested_total1.append(tt[0]*tt[1])
                        print(""tested_total1: "", str(tested_total1))
                        an = equal(tt[0]*tt[1], q2)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                q1.pop(0)
                q1.sort(key=lambda x: x[0]*x[1], reverse=True)
                #tested1.sort(key=lambda x: (x[0], x[1]), reverse=True)

        elif total1 < total2:
            ans = equal(total2, q1)
            if ans:
                print(str(ans[2] + q2[0][2]) + ""\n"" + str(ans[0]) + "" "" + str(ans[1]) + ""\n"" + str(q2[0][0]) + "" "" + str(q2[0][1]))
                break
            else:
                if not(q2[0][0] & 1):
                    tt = [q2[0][0] // 2, q2[0][1], q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested2) == 0 or (not found([tt[0], tt[1]], tested2)):
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        print(""tested2: "", str(tested2))
                        q2.append(tt)
                        print(""q2: "", str(q2))
                        tested_total2.append(tt[0]*tt[1])
                        print(""tested_total2: "", str(tested_total2))
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q2[0][0] % 3 == 0:
                    tt = [q2[0][0] // 3 * 2, q2[0][1], q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested2) == 0 or (not found([tt[0], tt[1]], tested2)):
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        print(""tested2: "", str(tested2))
                        q2.append(tt)
                        print(""q2: "", str(q2))
                        tested_total2.append(tt[0]*tt[1])
                        print(""tested_total2: "", str(tested_total2))
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(q2[0][1] & 1):
                    tt = [q2[0][0], q2[0][1] // 2, q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested2) == 0 or (not found([tt[0], tt[1]], tested2)):
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        print(""tested2: "", str(tested2))
                        q2.append(tt)
                        print(""q2: "", str(q2))
                        tested_total2.append(tt[0]*tt[1])
                        print(""tested_total2: "", str(tested_total2))
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if q2[0][1] % 3 == 0:
                    tt = [q2[0][0], q2[0][1] // 3 * 2, q2[0][2] + 1]
                    print(""tt: "", str(tt))
                    #if len(tested2) == 0 or (not found([tt[0], tt[1]], tested2)):
                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):
                        tested2.append([tt[0], tt[1]])
                        print(""tested2: "", str(tested2))
                        q2.append(tt)
                        print(""q2: "", str(q2))
                        tested_total2.append(tt[0]*tt[1])
                        print(""tested_total2: "", str(tested_total2))
                        an = equal(tt[0]*tt[1], q1)
                        if ans:
                            print(str(an[2] + tt[2]) + ""\n"" + str(tt[0]) + "" "" + str(tt[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                q2.pop(0)
                q2.sort(key=lambda x: x[0]*x[1], reverse=True)
                #tested2.sort(key=lambda x: (x[0], x[1]), reverse=True)

        else:
            print(str(q1[0][2] + q2[0][2]) + ""\n"" + str(q1[0][0]) + "" "" + str(q1[0][1]) + ""\n"" + str(q2[0][0]) + "" "" + str(q2[0][1]))
            break
    else:
        print(-1)
        break

t1 = time.time()
#print(t1-t0)
</ans>",0,{}
135,"<ans>
from fractions import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
print(""mod: "", str(mod))
from sys import stdin
readline = stdin.readline
def readInts():
  return list(map(int,readline().split()))
def readTuples():
    return tuple(map(int,readline().split()))
def I():
  return int(readline())
n = I()
print(""n: "", str(n))
s = input()
print(""s: "", str(s))
ans = """"
print(""ans: "", str(ans))
prv = None
print(""prv: "", str(prv))
for i in range(n):
    if i == 0:
        prv = s[i]
        print(""prv: "", str(prv))
        ans += s[i]
        print(""ans: "", str(ans))
        continue
    if s[i] == prv:
        continue
    else:
        prv = s[i]
        print(""prv: "", str(prv))
        ans += s[i]
        print(""ans: "", str(ans))
print((len(ans)))
</ans>",0,{}
136,"<ans>
import sys

n = int(sys.stdin.readline().split()[0])
print(""n: "", str(n))

class Polynomial:
    def __init__(self, coef):
        first_nonzero = False
        index = len(coef) - 1
        while not first_nonzero:
            if not coef[index] == 0:
                first_nonzero = True
            else:
                if index == 0:
                    first_nonzero = True
                else:
                    index -= 1
        self.degree = index
        print(""self.degree: "", str(self.degree))
        self.coef = [coef[j] for j in range(index + 1)]
        print(""self.coef: "", str(self.coef))
        
    def multiply_by_x(self):
        new_coef = [0]
        print(""new_coef: "", str(new_coef))
        for j in range(self.degree + 1):
            new_coef.append(self.coef[j])
        print(""new_coef after appending: "", str(new_coef))
        return Polynomial(new_coef)
    
    def minus(self):
        new_coef = [-self.coef[j] for j in range(self.degree + 1)]
        print(""new_coef (minus): "", str(new_coef))
        return Polynomial(new_coef)
    
    def add(self, other):
        other_coef = other.coef
        print(""other_coef: "", str(other_coef))
        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]
        print(""new_coef (add): "", str(new_coef))
        m = min(self.degree, other.degree)
        M = max(self.degree, other.degree)
        if self.degree > other.degree:
            bigger_poly = self
        else:
            bigger_poly = other
        for j in range(m + 1):
            new_coef[j] = self.coef[j] + other.coef[j]
        for j in range(m + 1, M+1):
            new_coef[j] = bigger_poly.coef[j]
        print(""new_coef after addition: "", str(new_coef))
        return Polynomial(new_coef) 
    
    def is_legal(self):
        result = True
        bools = [None for j in range(self.degree + 1)]
        bools[self.degree] = self.coef[self.degree] == 1
        for j in range(self.degree):
            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1
        for j in range(self.degree + 1):
            result = result and bools[j]
        return result
    
    def print(self):
        output = """"
        for j in range(self.degree + 1):
            output += str(self.coef[j]) + "" ""
        print(output)
            
        

f = []

f.append(Polynomial([1]))
f.append(Polynomial([0, 1]))

for j in range(2, 151):
    xf = f[j-1].multiply_by_x()
    print(""xf: "", str(xf))
    t_1 = xf.add(f[j - 2])
    print(""t_1: "", str(t_1))
    t_2 = xf.add(f[j - 2].minus())
    print(""t_2: "", str(t_2))
    if t_1.is_legal():
        f.append(t_1)
        print(""f: "", str(f))
    elif t_2.is_legal():
        f.append(t_2)
        print(""f: "", str(f))

print(f[n].degree)
f[n].print()
print(f[n-1].degree)
f[n-1].print()

#for j in range(len(f)):
    #f[j].print()

</ans>",0,{}
137,"<ans>
class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""
    def __init__(self, n_max, mod=10**9+7):
        self.mod = mod
        print(""self.mod: "", str(self.mod))
        self.modinv = self.make_modinv_list(n_max)
        print(""self.modinv: "", str(self.modinv))
        self.fac, self.facinv = self.make_factorial_list(n_max)
        print(""self.fac: "", str(self.fac), ""self.facinv: "", str(self.facinv))

    def __call__(self, n, r):
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        print(""fac: "", str(fac))
        facinv = [1]
        print(""facinv: "", str(facinv))
        for i in range(1, n+1):
            fac.append(fac[i-1] * i % self.mod)
            print(""fac: "", str(fac))
            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)
            print(""facinv: "", str(facinv))
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n+1)
        print(""modinv: "", str(modinv))
        modinv[1] = 1
        print(""modinv[1]: "", str(modinv[1]))
        for i in range(2, n+1):
            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod
            print(""modinv[{}]: "".format(i), str(modinv[i]))
        return modinv

mod = 998244353
print(""mod: "", str(mod))
K, N = map(int, input().split())
print(""K: "", str(K), ""N: "", str(N))
comb = Combination(10000, mod=mod)
print(""comb: "", str(comb))
def C(n, r):
    if n<r or r<0:
        return 0
    else:
        return comb(n, r)

def H(n, r):
    return C(n+r-1, r)

L = []
print(""L: "", str(L))
for i in range(2, 2*K+1, 2):
    ans = 0
    print(""ans: "", str(ans))
    M = i//2
    print(""M: "", str(M))
    b = 1
    print(""b: "", str(b))
    for j, a in enumerate(range(M, K)):
        if M-j<0:
            break
        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b
        #print((j, a), C(M, j) , H(N, K-a), b, pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b)
        ans %= mod
        b = -b
        print(""ans: "", str(ans), ""b: "", str(b))
    print(ans)
    if i == K+1:
        break
    elif i == K:
        print(ans)
        print(ans)
        break
    L.append(ans)
    print(""L: "", str(L))
    L.append(ans)

print(*L[::-1], sep=""\n"")
</ans>",0,{}
138,"<ans>
import sys
import math
import random
n, k, x = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k), ""x: "", str(x))
a = list(map(int, input().split()))
print(""a: "", str(a))
ans = 0
print(""ans: "", str(ans))
if n == 1:
    print(0)
    return
for i in range(0, n - 1):   
    if a[i] == a[i + 1] == x:
        l = i    
        print(""l: "", str(l))
        while l >= 0 and a[i] == a[l]:
            l -= 1
            print(""l: "", str(l))
        r = i + 1
        print(""r: "", str(r))
        while r < n and a[r] == x:
            r += 1
            print(""r: "", str(r))
        while (1):
            if l == -1 or r == n:
                break
            if a[l] != a[r]:
                break
            if l == 0 and r == n - 1:
                break
            if l == 0:
                if a[0] == a[r + 1]:
                    while r < n and a[r] == a[0]:
                        r += 1
                        print(""r: "", str(r))
                    l -= 1
                    print(""l: "", str(l))
                    continue
                else:
                    break
            if r == n - 1:
                if a[n - 1] == a[l - 1]:
                    while l >= 0 and a[l] == a[n - 1]:
                        l -= 1
                        print(""l: "", str(l))
                    r += 1
                    print(""r: "", str(r))
                    continue
                else:
                    break
            if a[l] == a[r + 1] or a[l - 1] == a[r]:
                t = a[l]
                print(""t: "", str(t))
                while l >= 0 and a[l] == t:
                    l -= 1
                    print(""l: "", str(l))
                while r < n and a[r] == t:
                    r += 1
                    print(""r: "", str(r))
            else:
                break
        ans = max(ans, r - l - 1)     
        print(""ans: "", str(ans))
print(ans)
</ans>",1,{}
139,"<ans>
ka, kb = 0, 0
print(""ka: "", str(ka), ""kb: "", str(kb))

def g(a, b):
    nonlocal ka, kb
    if a == b:
        return
    if abs(a - b) == 2:
        if a == 1:
            ka += 1
            print(""ka: "", str(ka))
        else:
            kb += 1
            print(""kb: "", str(kb))
    else:
        if a > b:
            ka += 1
            print(""ka: "", str(ka))
        else:
            kb += 1
            print(""kb: "", str(kb))

def main():
    nonlocal ka, kb
    k, a, b = list(map(int, input().split()))
    print(""k: "", str(k), ""a: "", str(a), ""b: "", str(b))
    aa = [[] for i in [1, 1, 1]]
    bb = [[] for i in [1, 1, 1]]
    aa[0] = list(map(int, input().split()))
    aa[1] = list(map(int, input().split()))
    aa[2] = list(map(int, input().split()))
    bb[0] = list(map(int, input().split()))
    bb[1] = list(map(int, input().split()))
    bb[2] = list(map(int, input().split()))
    print(""aa: "", str(aa), ""bb: "", str(bb))
    x = a
    print(""x: "", str(x))
    y = b
    print(""y: "", str(y))
    o = 1
    print(""o: "", str(o))
    c = [[x, y]]
    print(""c: "", str(c))
    d = [[0, 0]]
    print(""d: "", str(d))
    g(x, y)
    if k == 1:
        return
    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
    print(""x: "", str(x), ""y: "", str(y))
    while [x, y] not in c:
        o += 1
        print(""o: "", str(o))
        c += [[x, y]]
        print(""c: "", str(c))
        d += [[ka, kb]]
        print(""d: "", str(d))
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y))
        if o == k:
            return
    ind = c.index([x, y])
    print(""ind: "", str(ind))
    dka = ka - d[ind][0]
    print(""dka: "", str(dka))
    dkb = kb - d[ind][1]
    print(""dkb: "", str(dkb))
    delta = o - ind
    print(""delta: "", str(delta))
    kk = (k - ind) // delta - 1
    print(""kk: "", str(kk))
    ka += kk * dka
    print(""ka: "", str(ka))
    kb += kk * dkb
    print(""kb: "", str(kb))
    o += kk * delta
    print(""o: "", str(o))
    while o != k:
        o += 1
        print(""o: "", str(o))
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y))

main()
print(ka, kb)
</ans>",0,{}
140,"<ans>
import sys
sys.setrecursionlimit(4100000)
import math
import fractions



'''
1行のint
N, K = map(int, input().split())

1行のstring
S, T = input().split()

1行の整数配列
P = list(map(int,input().split()))

複数行2数値
x = []
y = []
for i in range(5):
    x1,y1=[int(i) for i in input().split()]
    x.append(x1)
    y.append(y1)

'''


S = input()
print(""S: "", str(S))

check = len(S)-1
print(""check: "", str(check))

while(check >= 0):

    if S[check] == ""r"":
        if S[check-2] == ""m"":
            remove = S[check-6: check+1]
            print(""remove: "", str(remove))
            if remove == ""dreamer"":
                check -= 7
                print(""check: "", str(check))
            else:
                print(""NO"")
                return


        elif S[check-2] == ""s"":
            remove = S[check-5: check+1]
            print(""remove: "", str(remove))
            
            if remove == ""eraser"":
                check -= 6
                print(""check: "", str(check))
            else:
                print(""NO"")
                return

        else:
            print(""NO"")
            return

    elif S[check] == ""e"":
        remove = S[check-4: check+1]
        print(""remove: "", str(remove))
            
        if remove == ""erase"":
            check -= 5
            print(""check: "", str(check))
        else:
            print(""NO"")
            return

    elif S[check] == ""m"":
        remove = S[check-4: check+1]
        print(""remove: "", str(remove))
            
        if remove == ""dream"":
            check -= 5
            print(""check: "", str(check))
        else:
            print(""NO"")
            return

    else:
        print(""NO"")
        return


print(""YES"")
</ans>",1,{}
141,"<ans>
class UnionFind():
    def __init__(self, n):
        self.n = n + 1
        print(""self.n: "", str(self.n))
        self.parents = [-1] * self.n
        print(""self.parents: "", str(self.parents))

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            print(""self.parents[x]: "", str(self.parents[x]))
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        print(""x: "", str(x))
        y = self.find(y)
        print(""y: "", str(y))

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        print(""self.parents[x]: "", str(self.parents[x]))
        self.parents[y] = x
        print(""self.parents[y]: "", str(self.parents[y]))

        # TODO 根を返す
        return x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        print(""root: "", str(root))
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
    N, M = list(map(int, input().split()))
    print(""N: "", str(N), ""M: "", str(M))
    A = list(map(int, input().split()))
    print(""A: "", str(A))
    B = list(map(int, input().split()))
    print(""B: "", str(B))
    A.append(0)
    print(""A after append: "", str(A))
    B.append(0)
    print(""B after append: "", str(B))
    uf = UnionFind(N+1)
    print(""uf: "", str(uf))
    for _ in range(M):
        c, d = list(map(int,input().split()))
        print(""c: "", str(c), ""d: "", str(d))
        uf.union(c, d)
    A_sums = defaultdict(int)
    print(""A_sums: "", str(A_sums))
    B_sums = defaultdict(int)
    print(""B_sums: "", str(B_sums))
    for i in range(1, N+1):
        x = uf.find(i)
        print(""x: "", str(x))
        A_sums[x] += A[i-1]
        print(""A_sums[x]: "", str(A_sums[x]))
        B_sums[x] += B[i-1]
        print(""B_sums[x]: "", str(B_sums[x]))
    for a, b in zip(list(A_sums.values()), list(B_sums.values())):
        if a != b:
            print('No')
            return
    print('Yes')


main()

</ans>",1,{}
142,"<ans>
from sys import stdin, stdout



k = int(stdin.readline())
print(""k: "", str(k))

n, m = list(map(int, stdin.readline().split()))
print(""n: "", str(n), ""m: "", str(m))

left, right, down, up = [], [], [], []
print(""left: "", str(left), ""right: "", str(right), ""down: "", str(down), ""up: "", str(up))

coordinates = []
print(""coordinates: "", str(coordinates))



for i in range(k):

    x1, y1, x2, y2 = list(map(int, stdin.readline().split()))
    print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))

    

    if x1 == x2:

        if y1 < y2:

            coordinates.append((x1, y1, x2, y2, i))
            print(""coordinates: "", str(coordinates))

        else:

            coordinates.append((x2, y2, x1, y1, i))
            print(""coordinates: "", str(coordinates))

    else:

        if x1 < x2:

            coordinates.append((x1, y1, x2, y2, i))
            print(""coordinates: "", str(coordinates))

        else:

            coordinates.append((x2, y2, x1, y1, i))
            print(""coordinates: "", str(coordinates))

    

    left.append(coordinates[-1])
    print(""left: "", str(left))

    right.append(coordinates[-1])
    print(""right: "", str(right))

    up.append(coordinates[-1])
    print(""up: "", str(up))

    down.append(coordinates[-1])
    print(""down: "", str(down))



left.sort(key = lambda x: (x[0], x[2]))
print(""left: "", str(left))

down.sort(key = lambda x: (x[1], x[3]))
print(""down: "", str(down))



challengers = [[], [], [], []]
print(""challengers: "", str(challengers))

cntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))
print(""cntl: "", str(cntl), ""cntr: "", str(cntr), ""cntd: "", str(cntd), ""cntu: "", str(cntu))

label = 1
print(""label: "", str(label))



if cntl or not cntl:

    for i in range(cntl, -1, -1):

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

            challengers[0].append(left[i][-1])  
            print(""challengers[0]: "", str(challengers[0]))

        else:

            break

        

    for i in range(cntl + 1, k):

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:

            label = 0
            print(""label: "", str(label))

        

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

            challengers[0].append(left[i][-1])  
            print(""challengers[0]: "", str(challengers[0]))

        else:

            break



if cntr or not cntr:

    for i in range(k - 1 - cntr, k):

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

            challengers[1].append(left[i][-1])
            print(""challengers[1]: "", str(challengers[1]))

        else:

            break

    

    for i in range(k - 2 - cntr, -1, -1):

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:

            label = 0
            print(""label: "", str(label))

        

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

            challengers[1].append(left[i][-1])
            print(""challengers[1]: "", str(challengers[1]))

        else:

            break



#!!!!!!!!!!!



if cntd or not cntd:

    for i in range(cntd, -1, -1):

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

            challengers[2].append(down[i][-1])
            print(""challengers[2]: "", str(challengers[2]))

        else:

            break

        

    for i in range(cntd + 1, k):

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:

            label = 0
            print(""label: "", str(label))

            

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

            challengers[2].append(down[i][-1])  
            print(""challengers[2]: "", str(challengers[2]))

        else:

            break

        

if cntu or not cntu:

    for i in range(k - 1 - cntu, k):

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

            challengers[3].append(down[i][-1])
            print(""challengers[3]: "", str(challengers[3]))

        else:

            break

    

    for i in range(k - 2 - cntu, -1, -1):

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:

            label = 0
            print(""label: "", str(label))

        

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

            challengers[3].append(down[i][-1])
            print(""challengers[3]: "", str(challengers[3]))

        else:

            break



ans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])
print(""ans: "", str(ans))



if not len(ans) or not label:

    stdout.write('-1')

else:

    stdout.write(str(list(ans)[0] + 1))
</ans>",1,{}
143,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        print(""self.nodes: "", str(self.nodes))
        self.adj_list={}
        print(""self.adj_list: "", str(self.adj_list))
        self.is_directed=is_directed
        print(""self.is_directed: "", str(self.is_directed))
 
        for node in self.nodes:
            self.adj_list[node]=[]
            print(""self.adj_list[{}]: "".format(node), str(self.adj_list[node]))
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        print(""self.adj_list[{}]: "".format(u), str(self.adj_list[u]))
        if self.is_directed==False:
            self.adj_list[v].append(u)
            print(""self.adj_list[{}]: "".format(v), str(self.adj_list[v]))
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        print(""visited[{}]: "".format(v), str(visited[v]))
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        print(""visited: "", str(visited))
        parents=[v]
        print(""parents: "", str(parents))
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    print(""ans: "", str(ans))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    print(""temp: "", str(temp))
    a=b
    print(""a: "", str(a))
    b=temp
    print(""b: "", str(b))
    return a,b

#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    print(""flag: "", str(flag))
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    print(""d: "", str(d))
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    print(""chk: "", str(chk))
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        print(""ans1: "", str(ans1))
        ans2=(-b-chk**0.5)/(2*a)
        print(""ans2: "", str(ans2))
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    print(""ans: "", str(ans))
    for i in range(n-r+1,n+1):
        ans*=i
        print(""ans: "", str(ans))
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    print(""ans: "", str(ans))
    for i in range(r):
        ans*=(n-i)
        print(""ans: "", str(ans))
    div=1
    for i in range(2,r+1):
        div*=i
        print(""div: "", str(div))
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    print(""ls: "", str(ls))
    return ls

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    s=input()
    n=len(s)
    print(""n: "", str(n))
    if s==s[::-1] and s[:n//2]==s[n//2+1:]:
        print('Yes')
    else:
        print('No')
def __starting_point():
    main()
    
__starting_point()
</ans>",0,{}
144,"<ans>
from array import array
inf = (1 << 30)

def main():
    (n,k) = [int(x) for x in input().split(' ')]
    print(""n: "", str(n), ""k: "", str(k))
    Matrix = []
    print(""Matrix: "", str(Matrix))
    for i in range(n):
        Matrix.append(array('b',[ord(x) for x in input()]))
    print(""Matrix: "", str(Matrix))
    dp = [array('l', [inf for j in range(n)]) for i in range(n)]
    print(""dp: "", str(dp))
    direct = [[ord('d') for j in range(n)] for i in range(n)]
    print(""direct: "", str(direct))
    opt = """"
    print(""opt: "", str(opt))
    for s in range (2 * n - 1):
        opchar = chr(ord('z') + 1)
        print(""opchar: "", str(opchar))
        positions = []
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(i > 0 and j > 0):
                    if(dp[i-1][j] < dp[i][j-1]):
                        dp[i][j] = dp[i-1][j]
                        direct[i][j] = 'l'
                    else:
                       dp[i][j] = dp[i][j-1]
                       direct[i][j] = 'd'
                elif i > 0:
                    dp[i][j] = dp[i-1][j]
                    direct[i][j] = 'l'
                elif j > 0:
                    dp[i][j] = dp[i][j-1]
                    direct[i][j] = 'd'
                else:
                    dp[i][j] = 0
                    direct[i][j] = 'e'
                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):
                    dp[i][j]+=1
                    Matrix[i][j] = ord('a')
                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):
                     opchar = chr(Matrix[i][j])
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(Matrix[i][j] is not ord(opchar)):
                    dp[i][j] = inf
    ans = """"
    print(""ans: "", str(ans))
    a,b = (n-1,n-1)
    print(""a: "", str(a), ""b: "", str(b))
    while(direct[a][b] is not 'e'):
        ans += chr(Matrix[a][b])
        print(""ans: "", str(ans))
        if(direct[a][b] is 'l'):
            a-=1
        else:
            b-=1
    ans += chr(Matrix[0][0])
    print(""ans: "", str(ans))
    print(ans[::-1])

main()
</ans>",0,{}
145,"<ans>
import sys

cases = False

# Pre-defined function
# Begin
def fast_pow(a:int, b:int):
    res = 1
    while b > 0:
        if b & 1:
            res *= a
        a *= a
        b >>= 1
    return res

def c2(n):
    return n * (n-1) // 2

def get():
    return list(map(int, input().split()))

def bits(n: int):
    return list(bin(n)).count('1')

def main(test_case = False):
    n = int(input()) if test_case else 1
    print(""n: "", str(n))
    for _ in range(n):
        test()

def flush():
    sys.stdout.flush()

def parr(arr):
    print(*arr, sep=' ')

def gcd(a, b):
    while b:
        if b % a == 0:
            break
        tmp = a
        a = b % a
        b = tmp
    return a

def ext_gcd(a: int, b: int):
    if (b == 0):
        return [a, [1, 0]]
 
    res = ext_gcd(b, a % b)
    g = res[0]
    x1 = res[1][0]
    y1 = res[1][1]
    x = y1
    y = x1 - y1 * (a // b)
 
    return [g, [x, y]]

# End

b = []
p = []
n = m = a = 0
 
def check(cnt):
    if cnt == 0:
        return True
    x = b[-cnt:]
    y = p[:cnt]
    s = a
    i = 0
    while i < cnt and s >= 0:
        s -= max(0, y[i]-x[i])
        i += 1
    return s >= 0
 
def test():
    nonlocal n, m, a, b, p
    n, m, a = get()
    print(""n: "", str(n), ""m: "", str(m), ""a: "", str(a))
    b = sorted(get())
    print(""b: "", str(b))
    p = sorted(get())
    print(""p: "", str(p))
 
    left = 0
    right = min(n, m)
 
    ans = -1
 
    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            ans = max(ans, mid)
            left = mid + 1
        else:
            right = mid - 1
 
    if ans == -1:
        print(0, 0)
        return
 
    # print(ans)
 
    t = 0
    x = b[-ans:]
    y = p[:ans]
    print(""x: "", str(x), ""y: "", str(y))
    i = 0
    while i < ans:
        t += min(x[i], y[i])
        a -= max(0, y[i]-x[i])
        print(""a: "", str(a))
        i += 1
    print(ans, max(0, t-a)) 

main(cases)
</ans>",0,{}
146,"<ans>
n=int(input())
print(""n: "", str(n))
la=[]
print(""la: "", str(la))
le=[]
print(""le: "", str(le))
li=[]
print(""li: "", str(li))
lo=[]
print(""lo: "", str(lo))
lu=[]
print(""lu: "", str(lu))
ans=[]
print(""ans: "", str(ans))
d1={}
print(""d1: "", str(d1))
for i in range(n):
    s=input()
    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')
    print(""x: "", str(x))
    if x>0:
        
        for c in s[::-1]:
            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':
                break
        print(""c: "", str(c))
        if (x,c) in d1:
            d1[(x,c)].append(s)
        else :
            d1[(x,c)]=[s]
            print(""d1: "", str(d1))
d2={}
print(""d2: "", str(d2))
pairs1=[]
print(""pairs1: "", str(pairs1))
pairs2=[]
print(""pairs2: "", str(pairs2))
for k in d1:
    if len(d1[k])%2==1:
        if k[0] in d2:
            d2[k[0]].append(d1[k][0])
        else :
            d2[k[0]]=[d1[k][0]]
            print(""d2: "", str(d2))
        for i in range(1,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
            print(""pairs1: "", str(pairs1))
    else :
        for i in range(0,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
            print(""pairs1: "", str(pairs1))
for k in d2:
    if len(d2[k])>1:
        if len(d2[k])%2==1:
            d2[k].pop()
        for i in range(0,len(d2[k]),2):
            pairs2.append((d2[k][i],d2[k][i+1]))
            print(""pairs2: "", str(pairs2))
if len(pairs1)<len(pairs2):
    print(len(pairs1))
    for i in range(len(pairs1)):
        print(pairs2[i][0],pairs1[i][0])
        print(pairs2[i][1],pairs1[i][1])
else :
    print(len(pairs2)+(len(pairs1)-len(pairs2))//2)
    for i in range(len(pairs2)):
        print(pairs2[i][0],pairs1[i][0])
        print(pairs2[i][1],pairs1[i][1])
    for j in range(len(pairs2),len(pairs1),2):
        if j==len(pairs1)-1:
            break
        else :
            print(pairs1[j][0],pairs1[j+1][0])
            print(pairs1[j][1],pairs1[j+1][1])
</ans>",0,{}
147,"<ans>
import sys
from functools import lru_cache

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007


def main():
    N, K, *A = list(map(int, read().split()))
    print(""N: "", str(N), ""K: "", str(K), ""A: "", str(A))

    K = list(map(int, f'{K:>040b}'))
    print(""K: "", str(K))
    A2 = [list(map(int, f'{a:>040b}')) for a in A]
    print(""A2: "", str(A2))
    B = [0] * 40
    print(""B: "", str(B))
    for a in A2:
        for i, bit in enumerate(a):
            B[i] += bit
    for i in range(40):
        if B[i] == N - B[i]:
            B[i] = 2
        elif B[i] < N - B[i]:
            B[i] = 1
        else:
            B[i] = 0
    print(""B: "", str(B))

    @lru_cache(maxsize=None)
    def rec(i, x, smaller):
        if i == 40:
            ans = 0
            for a in A:
                ans += x ^ a
            return ans
        elif smaller:
            if B[i] == 2:
                return rec(i + 1, (x << 1), True)
            else:
                return rec(i + 1, (x << 1) + B[i], True)
        else:
            if B[i] == 2:
                if K[i] == 0:
                    return rec(i + 1, (x << 1), False)
                else:
                    return rec(i + 1, (x << 1), True)
            elif K[i] == B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            elif K[i] < B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            else:
                return rec(i + 1, (x << 1) + B[i], True)

    print((rec(0, 0, False)))
    return


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
148,"<ans>
#
# abc069 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
1 10 100""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""4
1 2 3 4""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""3
1 4 1""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_4(self):
        input = """"""2
1 1""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_5(self):
        input = """"""6
2 7 1 8 2 8""""""
        output = """"""Yes""""""
        self.assertIO(input, output)


def resolve():
    N = int(input())
    print(""N: "", str(N))
    A = list(map(int, input().split()))
    print(""A: "", str(A))

    Q = 0
    print(""Q: "", str(Q))
    E = 0
    print(""E: "", str(E))
    O = 0
    print(""O: "", str(O))
    for a in A:
        if a % 4 == 0:
            Q += 1
            print(""Q: "", str(Q))
        elif a % 2 == 0:
            E += 1
            print(""E: "", str(E))
        else:
            O += 1
            print(""O: "", str(O))

    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:
        print(""Yes"")
    else:
        print(""No"")


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",0,{}
149,"<ans>
import sys
input = sys.stdin.readline
enum = enumerate
inf = 1001001001

import collections
import random

def linput(ty=int, cvt=list):
	return cvt(list(map(ty,input().split())))

def vinput(rep=1, ty=int, cvt=list):
	return cvt(ty(input().rstrip()) for _ in ""*""*rep)

def gcd(a: int, b: int):
	while b: a, b = b, a%b
	return a

def lcm(a: int, b: int):
	return a * b // gcd(a, b)

def dist(x1,y1,x2,y2):
	return abs(x1-x2)+abs(y1-y2)

#vD = [chr(ord(""a"")+i) for i in range(26)]

def ran():
	vRan = [random.randint(1, 10),
	        random.randint(0, 10),
	        random.randint(1, 100)]
	print(""vRan: "", str(vRan))
	return vRan

def bye(res):
	sT = ""No Yes"".split()
	print((sT[res]))
	#return

def sol_n(a,b,c):
	res = 0
	cnt = 0
	while cnt<c:
		res += 1
		cnt += a
		if res%7==0:
			cnt += b
	print(""res: "", str(res), ""cnt: "", str(cnt))
	return res


def sol(a,b,c):
	#a,b,c = linput()
	### 3 6 9 12 15
	### 1 2 3 4  5
	
	res = 0
	L = -(-a//c)
	R = (b//c)
	print(""L: "", str(L), ""R: "", str(R))
	res = R-L+1
	print(""res: "", str(res))
	return res

def deb():
	#vI = linput()
	vI = ran()
	#print(vI)
	I = sol_n(*vI)
	J = sol(*vI)
	if 1:#I!=J:
		print((vI, I, J))

def main():
	vI = linput()
	print(""vI: "", str(vI))
	print((sol(*vI)))

def __starting_point():
	#for _ in ""*""*1000:
	#	deb()
	main()

__starting_point()
</ans>",0,{}
150,"<ans>
from math import sqrt, pow, log, log2, log10, exp
from copy import deepcopy
from fractions import gcd


def read_ints():
    return list(map(int, input().split()))


def read_int():
    return read_ints()[0]


def read_floats():
    return list(map(float, input().split()))


def read_float():
    return read_floats()[0]


def format_list(l):
    return ' '.join(list(map(str, l)))


def one_dim_array(n, value=0):
    return [deepcopy(value) for x in range(n)]


def two_dim_array(n, m, value=0):
    return [[deepcopy(value) for x in range(m)] for x in range(n)]


def is_prime(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, sqrt(n) + 1):
        if n % i == 0:
            return False
    return True


def max_len_sublist(l, f):
    start, max_length, length = 0, 0, 0
    for i in range(1, len(l)):
        if f(l[i], l[i - 1]):
            length += 1
        else:
            if max_length < length:
                start = i - length
                max_length = length
            length = 0
    return start, max_length


def tf_to_yn(b):
    return 'YES' if b else 'NO'


def longest_non_descent_subsequence(s, restore_sequence=False):
    d = one_dim_array(len(s), 0)
    print(""d: "", str(d))
    for i in range(len(s)):
        possible = [d[j] + 1 if s[j] <= s[i] else 1 for j in range(i)]
        print(""possible: "", str(possible))
        d[i] = 1 if len(possible) == 0 else max(possible)
        print(""d[i]: "", str(d[i]))

    if not restore_sequence:
        return d[-1] if len(d) != 0 else 0


l = read_int()
print(""l: "", str(l))
p = read_int()
print(""p: "", str(p))
q = read_int()
print(""q: "", str(q))
t = l / (p + q)
print(""t: "", str(t))
print(t*p)

</ans>",0,{}
151,"<ans>
z=[int(p) for p in input().split()]
print(""z: "", str(z))
m=z[2]
print(""m: "", str(m))
lst=[]
print(""lst: "", str(lst))
lst.append(z[0])
print(""lst: "", str(lst))
lst.append(z[1])
print(""lst: "", str(lst))
tempi=min(lst)
print(""tempi: "", str(tempi))
tempa=max(lst)
print(""tempa: "", str(tempa))

count=0
print(""count: "", str(count))
fibo=[] 
print(""fibo: "", str(fibo))

n=1000000000000000000
print(""n: "", str(n))
def fib(n):
        
        a, b = 0, 1
        print(""a: "", str(a))
        print(""b: "", str(b))
        while b < n:
                fibo.append(b)
                print(""fibo: "", str(fibo))
                a, b = b, a+b
                print(""a: "", str(a))
                print(""b: "", str(b))
    

def add(m):
        n=10**18
        print(""n: "", str(n))
        tempi=min(lst)
        print(""tempi: "", str(tempi))
        tempa=max(lst)
        print(""tempa: "", str(tempa))
        count=0
        print(""count: "", str(count))
        if(tempi>0 and tempa>0 and m>tempa):
                fib(n)
                for p in range(1,len(fibo)+1):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count
        elif(tempi==0 or tempa==0):
                count=1
                print(""count: "", str(count))
                fib(n)
                tempi=tempa+(tempi)
                print(""tempi: "", str(tempi))
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count

        elif(tempi<0 and tempa>0):
                val=(-(tempi)//tempa)+1
                print(""val: "", str(val))
                count=val
                print(""count: "", str(count))
                tempi=tempi+(val*tempa)
                print(""tempi: "", str(tempi))
                fib(n)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count

if(tempi>0 and tempa>0 and m>tempa):
        cou=add(m)
        print(""cou: "", str(cou))

elif(tempi>0 and tempa>0 and m<=tempa):
        print(0)

elif(tempi==0 ):
        if(tempi==0 and tempa==0 and m>0):
                print(-1)
        elif(tempi==0 and tempa==0 and m<=0):
                print(0)
        elif(tempa==0 and tempi<0 and m>0):
                print(-1)
                
        else:
                cou=add(m)
                print(""cou: "", str(cou))
elif(tempi<0 and tempa>0):
        if(m<=tempa):
                print(0)
        else:
                cou=add(m)
                print(""cou: "", str(cou))
elif(tempi<0 and tempa==0):
        if(m>0):
                print(-1)
        else:
                print(0)
elif(tempi<0 and tempa<0):
        if(m>=0):
                print(-1)
        elif(m<0 and m<=tempa):
                print(0)
        elif(m<0 and m>tempa):
                print(-1)
</ans>",1,{}
152,"<ans>
# NOT MY CODE
# https://codeforces.com/contest/919/submission/80857731
 
from types import GeneratorType
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        to = f(*args, **kwargs)
        if stack:
            return to
        else:
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        return to
                    to = stack[-1].send(to)
    return wrappedfunc
 
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
'''
def iscyclic(g):
    for i in range(1,n+1):
        if(
'''
n,m=list(map(int,input().split()))
s=input()
d=dd(list)
print(""d: "", str(d))
lol=0
print(""lol: "", str(lol))
for i in range(m):
    u,v=list(map(int,input().split()))
    if(u==v):
        lol=1
        print(-1)
        return
    d[u].append(v)
'''
if(iscyclic(d)):
    lol=1
    print(-1)
    return
'''
vis=[0]*(n+1)
print(""vis: "", str(vis))
rvis=[0]*(n+1)
print(""rvis: "", str(rvis))
cou=[0]
print(""cou: "", str(cou))
dp=[dd(int) for i in range(n+1)]
print(""dp: "", str(dp))
mx=[0]
print(""mx: "", str(mx))
h=[0]
print(""h: "", str(h))
#print(d)
@bootstrap
def dfs(u):
    if(h[0]==1):
        yield
    vis[u]=1
    rvis[u]=1
    for i in d[u]:
        if(h[0]==1):
            yield
        if(vis[i]==0):
            yield dfs(i)
            if(h[0]==1):
                yield            
        elif(rvis[i]==True):
            h[0]=1
            yield
    rvis[u]=0
    if(h[0]==1):
        yield
    for i in d[u]:
        for j in dp[i]:
            dp[u][j]=max(dp[u][j],dp[i][j])
            mx[0]=max(mx[0],dp[u][j])
    dp[u][s[u-1]]+=1
    #print(u,dp[u])
    mx[0]=max(mx[0],dp[u][s[u-1]])
    yield
#print(dp)
for i in range(1,n+1):
    if(vis[i]==0):
        cou=[0]
        print(""cou: "", str(cou))
        dfs(i)
if(h[0]):
    print(-1)
else:
    print(mx[0])
</ans>",0,{}
153,"<ans>
#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float(""inf"")


def solve(N: int, X: int, D: int):
    if D == 0:
        if X == 0:
            print((1))
        else:
            print((N+1))
        return

    if D < 0:
        X = X + (N-1)*D
        print(""X: "", str(X))
        D = abs(D)
        print(""D: "", str(D))

    segs = defaultdict(list)
    print(""segs: "", str(segs))
    for k in range(N+1):
        L = k*(k-1)//2
        print(""L: "", str(L))
        R = k*N - k*(k+1)//2
        print(""R: "", str(R))
        Ck = k*X + D*L
        print(""Ck: "", str(Ck))
        Rk = R-L
        print(""Rk: "", str(Rk))
        seg = (Ck//D, Ck//D+Rk+1)
        print(""seg: "", str(seg))
        s = Ck % D
        print(""s: "", str(s))
        segs[s].append(seg)

    tot = 0
    print(""tot: "", str(tot))
    for k in segs:
        event = defaultdict(int)
        print(""event: "", str(event))
        for l, r in segs[k]:
            event[l] += 1
            event[r] -= 1
            print(""event: "", str(event))

        curr = 0
        print(""curr: "", str(curr))
        pre = -1
        print(""pre: "", str(pre))
        for k in sorted(event.keys()):
            if curr > 0:
                tot += k - pre
            curr += event[k]
            pre = k
    print(""tot: "", str(tot))

    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    print(""N: "", str(N))
    X = int(next(tokens))  # type: int
    print(""X: "", str(X))
    D = int(next(tokens))  # type: int
    print(""D: "", str(D))
    solve(N, X, D)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
154,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
p = list(map(int, input().split()))
print(""p: "", str(p))
odd = (n+1)//2
print(""odd: "", str(odd))
even = n-odd
print(""even: "", str(even))
for i in p:
    if i:
        if i%2 == 0:
            even -= 1
        else:
            odd -= 1

if even == 0:
    p = [i if i else 1 for i in p]
    print(""p: "", str(p))
if odd*even == 0:
    ans = 0
    print(""ans: "", str(ans))
    prev = p[0]
    print(""prev: "", str(prev))
    for pi in p:
        ans += (pi+prev)%2
        prev = pi
        print(""prev: "", str(prev))
    print(ans)
    return

DP = [[float(""inf"")]*(even+1) for i in range(2)]
print(""DP: "", str(DP))
for i in range(n):
    nxt = [[float(""inf"")]*(even+1) for i in range(2)]
    print(""nxt: "", str(nxt))
    if i == 0:
        if p[i]:
            if p[i]%2 == 0:
                nxt[0][0] = 0
                print(""nxt[0][0]: "", str(nxt[0][0]))
            else:
                nxt[1][0] = 0
                print(""nxt[1][0]: "", str(nxt[1][0]))
        else:
            nxt[0][1] = 0
            print(""nxt[0][1]: "", str(nxt[0][1]))
            nxt[1][0] = 0
            print(""nxt[1][0]: "", str(nxt[1][0]))
    else:
        if p[i]:
            if p[i]%2 == 0:
                for j in range(even+1):
                    nxt[0][j] = min(DP[0][j], DP[1][j]+1)
                    print(""nxt[0][{}]: "".format(j), str(nxt[0][j]))
            else:
                for j in range(even+1):
                    nxt[1][j] = min(DP[0][j]+1, DP[1][j])
                    print(""nxt[1][{}]: "".format(j), str(nxt[1][j]))
        else:
            for j in range(1, even+1):
                nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)
                print(""nxt[0][{}]: "".format(j), str(nxt[0][j]))
            for j in range(even+1):
                nxt[1][j] = min(DP[0][j]+1, DP[1][j])
                print(""nxt[1][{}]: "".format(j), str(nxt[1][j]))
    DP = nxt
    print(""DP: "", str(DP))
print(min(DP[0][-1], DP[1][-1]))
</ans>",0,{}
155,"<ans>
# E
N = int(input())
print(""N: "", str(N))
P_list = list(map(int, input().split()))
print(""P_list: "", str(P_list))
X_list = list(map(int, input().split()))
print(""X_list: "", str(X_list))

# graph
child_list = [[] for _ in range(N+1)]
print(""child_list: "", str(child_list))
for i in range(2, N+1):
    child_list[P_list[i-2]].append(i)

# from root
# minimize local total weight

color1 = [0]+X_list
print(""color1: "", str(color1))
color2 = [0]*(N+1)
print(""color2: "", str(color2))

# solve knapsack
def solve_knapsack(L, M):
    min_acc = sum([min(color1[j], color2[j]) for j in L])
    if min_acc > M:
        return -1
    else:
        add_can = M - min_acc
        print(""add_can: "", str(add_can))
        add_set = set([0])
        for j in L:
            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])
            print(""add_j: "", str(add_j))
            add_set_ = set(add_set)
            for s in add_set:
                if s + add_j <= add_can:
                    add_set_.add(s + add_j)
            add_set = add_set_
        
        total = sum([color1[j]+color2[j] for j in L])
        print(""total: "", str(total))
        return total - max(add_set) - min_acc

res = ""POSSIBLE""

for i in range(N, 0, -1):
    if len(child_list[i]) == 0:
        pass
    elif len(child_list[i]) == 1:
        j = child_list[i][0]
        if min(color1[j], color2[j]) > X_list[i-1]:
            res = ""IMPOSSIBLE""
            break
        elif max(color1[j], color2[j]) > X_list[i-1]:
            color2[i] = max(color1[j], color2[j])
            print(""color2[{}]: "".format(i), str(color2[i]))
        else:
            color2[i] = min(color1[j], color2[j])
            print(""color2[{}]: "".format(i), str(color2[i]))
    else:
        c2 = solve_knapsack(child_list[i], X_list[i-1])
        print(""c2: "", str(c2))
        if c2 < 0:
            res = ""IMPOSSIBLE""
            break
        else:
            color2[i] = c2
            print(""color2[{}]: "".format(i), str(color2[i]))
    
print(res)
</ans>",0,{}
156,"<ans>
def prime_factor(n):
    i = 2
    print(""i: "", str(i))
    factors = []
    print(""factors: "", str(factors))
    while i * i <= n:
        if n % i:
            i += 1
            print(""i: "", str(i))
        else:
            while n % i == 0:
                n //= i
            factors.append(i)
            print(""factors: "", str(factors))
    if n > 1:
        factors.append(n)
        print(""factors: "", str(factors))
    return factors


def divisors(n):
    divisors = []
    print(""divisors: "", str(divisors))
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            print(""divisors: "", str(divisors))
            if i != n // i:
                divisors.append(n//i)
                print(""divisors: "", str(divisors))
    divisors.sort()
    print(""divisors: "", str(divisors))
    return divisors


def mebius(n):
    res = {}
    print(""res: "", str(res))
    primes = prime_factor(n)
    print(""primes: "", str(primes))
    m = len(primes)
    print(""m: "", str(m))
    for i in range(1 << m):
        mu = 1
        d = 1
        print(""mu: "", str(mu), ""d: "", str(d))
        for j in range(m):
            if i >> j & 1:
                mu *= -1
                d *= primes[j]
                print(""mu: "", str(mu), ""d: "", str(d))
        res[d] = mu
        print(""res: "", str(res))
    return res


mod = 10**9+7
print(""mod: "", str(mod))
N, K = list(map(int, input().split()))
print(""N: "", str(N), ""K: "", str(K))
div = divisors(N)
print(""div: "", str(div))

ans = 0
print(""ans: "", str(ans))

for x in div:
    div2 = divisors(x)
    print(""div2: "", str(div2))
    mu = mebius(x)
    print(""mu: "", str(mu))
    cnt = 0
    print(""cnt: "", str(cnt))
    for y in list(mu.keys()):
        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]
        print(""cnt: "", str(cnt))
    if x % 2 == 0:
        cnt *= pow(2, mod-2, mod)
        print(""cnt: "", str(cnt))
    ans += x*cnt
    print(""ans: "", str(ans))
    ans %= mod

print(ans)
</ans>",0,{}
157,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

n = int(minp())
print(""n: "", str(n))
m = [None]*n
print(""m: "", str(m))
k = [None]*3
print(""k: "", str(k))
dp = [None]*3
print(""dp: "", str(dp))
dp[0] = [None]*(n*n)
print(""dp[0]: "", str(dp[0]))
dp[1] = [None]*(n*n)
print(""dp[1]: "", str(dp[1]))
dp[2] = [None]*(n*n)
print(""dp[2]: "", str(dp[2]))
path = [None]*(n*n)
print(""path: "", str(path))
for i in range(n):
	m[i] = list(map(int, minp().split()))
	print(""m[{}]: "".format(i), str(m[i]))
	for j in range(n):
		path[m[i][j]-1] = (i,j)
		print(""path[{}]: "".format(m[i][j]-1), str(path[m[i][j]-1]))
for z in range(3):
	k_ = [None]*n
	print(""k_{}: "".format(z), str(k_))
	for i in range(n):
		kk = [None]*n
		print(""kk[{}]: "".format(i), str(kk))
		for j in range(n):
			kkk_ = [None]*3
			print(""kkk_{}[{}]: "".format(z, j), str(kkk_))
			for zz in range(3):
				kkk = [None]*n
				print(""kkk[{}][{}]: "".format(zz, j), str(kkk))
				for w in range(n):
					kkk[w] = [(1000000,0)]*n
				kkk_[zz] = kkk
			kk[j] = kkk_
		k_[i] = kk
	k[z] = k_
	print(""k[{}]: "".format(z), str(k[z]))

q = [0]*(10*n*n)
print(""q: "", str(q))
qr = 0
print(""qr: "", str(qr))
km = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
print(""km: "", str(km))
sm = [(1,1),(1,-1),(-1,1),(-1,-1)]
print(""sm: "", str(sm))
lm = [(0,1),(0,-1),(-1,0),(1,0)]
print(""lm: "", str(lm))
mm = [km,sm,lm]
print(""mm: "", str(mm))
for z in range(3):
	for i in range(n):
		for j in range(n):
			#print('========')
			ql = 0
			qr = 1
			q[0] = (z, i, j, (0,0))
			print(""q[0]: "", str(q[0]))
			kc = k[z][i][j]
			print(""kc[{}][{}]: "".format(z, i), str(kc))
			kc[z][i][j] = (0, 0)
			print(""kc[{}][{}][{}]: "".format(z, i, j), str(kc[z][i][j]))
			while ql < qr:
				t, x, y, dd = q[ql]
				#print(t,x,y,dd)
				d = kc[t][x][y]
				ql += 1
				if d != dd:
					continue
				dd = (d[0]+1, d[1]+1)
				for tt in range(3):
					if t != tt and kc[tt][x][y] > dd:
						kc[tt][x][y] = dd
						q[qr] = (tt,x,y,dd)
						print(""q[{}]: "".format(qr), str(q[qr]))
						qr += 1
				dd = (d[0]+1,d[1])
				if t == 0:
					for w in mm[t]:
						xx,yy = w[0]+x,w[1]+y
						if xx >= 0 and xx < n and yy >= 0 and yy < n:
							if kc[t][xx][yy] > dd:
								kc[t][xx][yy] = dd
								q[qr] = (t,xx,yy,dd)
								print(""q[{}]: "".format(qr), str(q[qr]))
								qr += 1
				else:
					for w in mm[t]:
						for hm in range(n*2):
							xx,yy = w[0]*hm+x,w[1]*hm+y
							if xx >= 0 and xx < n and yy >= 0 and yy < n:
								if kc[t][xx][yy] > dd:
									kc[t][xx][yy] = dd
									q[qr] = (t,xx,yy,dd)
									print(""q[{}]: "".format(qr), str(q[qr]))
									qr += 1
							else:
								break
dp[0][0] = (0,0)
print(""dp[0][0]: "", str(dp[0][0]))
dp[1][0] = (0,0)
print(""dp[1][0]: "", str(dp[1][0]))
dp[2][0] = (0,0)
print(""dp[2][0]: "", str(dp[2][0]))
for i in range(0,n*n-1):
	x,y = path[i]
	print(""x,y: "", str((x,y)))
	xx,yy = path[i+1]
	print(""xx,yy: "", str((xx,yy)))
	for z in range(3):
		for j in range(3):
			dist = k[j][x][y][z][xx][yy]
			print(""dist: "", str(dist))
			if dp[j][i] != None:
				nd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])
				print(""nd: "", str(nd))
				if dp[z][i+1] == None:
					dp[z][i+1] = nd
					print(""dp[{}][{}]: "".format(z, i+1), str(dp[z][i+1]))
				else:
					dp[z][i+1] = min(dp[z][i+1],nd)
					print(""dp[{}][{}]: "".format(z, i+1), str(dp[z][i+1]))
for j in range(n*n-1,n*n):
	qq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]
	print(""qq: "", str(qq))
	qm = min(qq)
	#print(j,qm)
	print(qm[0], qm[1])
</ans>",0,{}
158,"<ans>
def increasing(arr):
    n = len(arr)
    print(""n: "", str(n))
    for i in range(n-1):
        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
            return False

    return True

def getFacts(n,mod):
    facts = [1]*n
    print(""facts: "", str(facts))
    for i in range(1,n):
        facts[i] = facts[i-1]*i
        facts[i] %= mod
        print(""facts[{}]: "".format(i), str(facts[i]))

    return facts

def solve(arr1,arr2,n,mod):
    facts = getFacts(4*10**5+1,mod)
    print(""facts: "", str(facts))
    total = facts[n]
    print(""total: "", str(total))
    dist1 = {}
    for i in arr1:
        if i[0] not in list(dist1.keys()):
            dist1[i[0]] = 1
            print(""dist1[{}]: "".format(i[0]), str(dist1[i[0]]))
        else:
            dist1[i[0]] += 1
            print(""dist1[{}]: "".format(i[0]), str(dist1[i[0]]))

    dist2 = {}
    for i in arr2:
        if i[0] not in list(dist2.keys()):
            dist2[i[0]] = 1
            print(""dist2[{}]: "".format(i[0]), str(dist2[i[0]]))
        else:
            dist2[i[0]] += 1
            print(""dist2[{}]: "".format(i[0]), str(dist2[i[0]]))

    count = 1
    print(""count: "", str(count))
    for i in dist1:
        count *= facts[dist1[i]]
        count = count%mod
        print(""count after dist1[{}]: "".format(i), str(count))

    total -= count
    print(""total after dist1: "", str(total))
    count = 1
    print(""count reset: "", str(count))
    
    for i in dist2:
        count *= facts[dist2[i]]
        count = count%mod
        print(""count after dist2[{}]: "".format(i), str(count))

    total -= count
    print(""total after dist2: "", str(total))

    arr1.sort()
    if increasing(arr1):
        count = 1
        print(""count set to 1 after increasing check"")
    else:
        count = 0
        print(""count set to 0 after increasing check"")
    dist3 = {}
    for i in arr1:
        if i not in list(dist3.keys()):
            dist3[i] = 1
            print(""dist3[{}]: "".format(i), str(dist3[i]))
        else:
            dist3[i] += 1
            print(""dist3[{}]: "".format(i), str(dist3[i]))
        
    for i in dist3:
        count *= facts[dist3[i]]
        count = count%mod
        print(""count after dist3[{}]: "".format(i), str(count))

    total += count
    print(""total after dist3: "", str(total))
    total = total%mod
    print(""final total: "", str(total))
    

def main():
    mod = 998244353
    print(""mod: "", str(mod))
    n = int(input())
    print(""n: "", str(n))
    first = []
    second = []
    for i in range(n):
        a,b = list(map(int,input().split()))
        first.append((a,b))
        second.append((b,a))
        print(""first: "", str(first))
        print(""second: "", str(second))
    
    solve(first,second,n,mod)


main()
</ans>",0,{}
159,"<ans>
import sys

#縦k、横kのマスに移動させて考える
n, k = map(int, sys.stdin.readline().strip().split())
print(""n: "", str(n), ""k: "", str(k))
x = []
print(""x: "", str(x))
y = []
print(""y: "", str(y))
mx = []
print(""mx: "", str(mx))
my = []
print(""my: "", str(my))
for _ in range(n):
    xx, yy, c = sys.stdin.readline().strip().split()
    xx = int(xx)
    print(""xx: "", str(xx))
    yy = int(yy)
    print(""yy: "", str(yy))
    if c == 'W':
        xx += k
        print(""xx: "", str(xx))
    xx %= 2 * k
    print(""xx: "", str(xx))
    yy %= 2 * k
    print(""yy: "", str(yy))
    if xx >= k:
        if yy >= k:
            x.append(xx - k)
            print(""x: "", str(x))
            y.append(yy - k)
            print(""y: "", str(y))
        else:
            mx.append(xx - k)
            print(""mx: "", str(mx))
            my.append(yy)
            print(""my: "", str(my))
    else:
        if yy >= k:
            mx.append(xx)
            print(""mx: "", str(mx))
            my.append(yy - k)
            print(""my: "", str(my))
        else:
            x.append(xx)
            print(""x: "", str(x))
            y.append(yy)
            print(""y: "", str(y))

graph = [[0 for _ in range(k)] for __ in range(k)]
print(""graph: "", str(graph))

#累積和
#lx + lmx = n
lx = len(x)
print(""lx: "", str(lx))
graph[0][0] += lx
for i in range(lx):
    graph[x[i]][0] -= 1
    graph[0][y[i]] -= 1
    graph[x[i]][y[i]] += 2

lmx = len(mx)
print(""lmx: "", str(lmx))
graph[0][0] -= lmx
for i in range(lmx):
    graph[mx[i]][0] += 1
    graph[0][my[i]] += 1
    graph[mx[i]][my[i]] -= 2

for i in graph:
    for j in range(k-1):
        i[j+1] += i[j]

for i in range(k):
    for j in range(k-1):
        graph[j+1][i] += graph[j][i]

#最大値、最小値を取得
big = max([max(i) for i in graph]) + lmx
print(""big: "", str(big))
small = min([min(i) for i in graph]) - lx
print(""small: "", str(small))

if big + small >= 0:
    print(big)
else:
    print(-small)
</ans>",1,{}
160,"<ans>
# coding: utf-8
import sys
#from operator import itemgetter
sysread = sys.stdin.buffer.readline
read = sys.stdin.buffer.read
#from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque
#from decimal import Decimal
#from numba import jit

INF = 1 << 50
EPS = 1e-8
mod = 10 ** 9 + 7

def run():
    N = int(input())
    print(""N: "", str(N))
    nines = [9 ** i for i in range(1, 10) if 9 ** i <= N]
    print(""nines: "", str(nines))
    sixes = [6 ** i for i in range(1, 10) if 6 ** i <= N][::-1]
    print(""sixes: "", str(sixes))
    L = len(nines)
    print(""L: "", str(L))
    #print(nines, sixes)
    min_ans = INF
    print(""min_ans: "", str(min_ans))
    for K in product(list(range(9)), repeat = L):
        #print(K, '----------------')
        ans = 0
        print(""ans: "", str(ans))
        s = 0
        print(""s: "", str(s))
        for k, x in zip(K, nines):
            if k:
                ans += k
                print(""ans: "", str(ans))
                s += x * k
                print(""s: "", str(s))
        #print(ans, s)

        if s > N:continue
        resid = N - s
        print(""resid: "", str(resid))
        for six in sixes:
            #print(resid)
            tmp = resid // six
            print(""tmp: "", str(tmp))
            if tmp:
                ans += tmp
                print(""ans: "", str(ans))
                resid -= six * tmp
                print(""resid: "", str(resid))
        #print(resid, ans)
        #if resid >= 6:
        #    print(resid)
        ans += resid
        print(""ans: "", str(ans))
        min_ans = min(min_ans,ans)
        print(""min_ans: "", str(min_ans))

    print(min_ans)

def __starting_point():
    run()

__starting_point()
</ans>",0,{}
161,"<ans>
# -*- coding: utf-8 -*-
import sys
# from operator import itemgetter
# from fractions import gcd
# from math import ceil, floor
# from copy import deepcopy
# from itertools import accumulate
from collections import deque
# import math
# from functools import reduce
input = sys.stdin.readline
def ii(): return int(input())
def mi(): return list(map(int, input().rstrip().split()))
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())
# template

# BEGIN CUT HERE


class BIT:
    def __init__(self, x, d=0):
        if isinstance(x, int):
            self.size = x
            self.tree = [d for _ in range(self.size + 1)]
        elif isinstance(x, list):
            self.size = len(x)
            self.tree = [d for _ in range(self.size + 1)]
            self.build(x)
        else:
            raise TypeError

    def build(self, arr):
        if not isinstance(arr, list):
            raise TypeError
        for num, x in enumerate(arr):
            self.add0(num, x)

    def sum(self, i):
        s = self.tree[0]
        while i > 0:
            s += self.tree[i]
            i -= (i & -i)
        return s

    def add(self, i, a):
        if(i == 0):
            return
        while (i <= self.size):
            self.tree[i] += a
            i += (i & -i)

    def bisect_left(self, w):
        if w <= 0:
            return 0
        x = 0
        r = 1
        while (r < self.size):
            r <<= 1
        k = r
        while (k > 0):
            if x + k <= self.size and self.tree[x + k] < w:
                w -= self.tree[x + k]
                x += k
            k >>= 1
        return x + 1

    def query(self, l, r):
        return self.sum(r - 1) - self.sum(l - 1)

    def sum0(self, i):
        return self.sum(i + 1)

    def add0(self, i, a):
        self.add(i + 1, a)

    def query0(self, l, r):
        return self.sum(r) - self.sum(l)

    def __getitem__(self, item):
        _tmp = item.indices(self.size + 1)
        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]

    def __str__(self):
        return str(self[1:self.size + 1])

# END CUT


def main():
    n = ii()
    print(""n: "", str(n))
    a = lmi()
    print(""a: "", str(a))
    q = ii()
    print(""q: "", str(q))
    bit = BIT(a)
    print(""bit: "", str(bit))
    # print(bit)
    for i in range(q):
        l, r = mi()
        print(""l: "", str(l), ""r: "", str(r))
        a = bit.query(l, r+1)
        print(""a: "", str(a))
        print((a-a % 10)//10)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
162,"<ans>
""""""Problem B - Bus of Characters.

http://codeforces.com/contest/982/problem/B

In the Bus of Characters there are `n` rows of seat, each having `2` seats.
The width of both seats in the `i`-th row is `w_i` centimeters. All integers
`w_i` are distinct.

Initially the bus is empty. On each of `2n` stops one passenger enters the
bus. There are two types of passengers:

- an introvert always chooses a row where both seats are empty. Among these
rows he chooses the one with the smallest seats width and takes one of the
seats in it;

- an extrovert always chooses a row where exactly one seat is occupied (by an
introvert). Among these rows he chooses the one with the largest seats width
and takes the vacant place in it.

You are given the seats width in each row and the order the passengers enter
the bus. Determine which row each passenger will take.

Input:

The first line contains a single integer `n` (`1 <= n <= 200\,000`) — the
number of rows in the bus.

The second line contains the sequence of integers `w_1, w_2, ..., w_n` (`1 <=
w_i <= 10^{9}`), where `w_i` is the width of each of the seats in the `i`-th
row. It is guaranteed that all `w_i` are distinct.

The third line contains a string of length `2n`, consisting of digits '0' and
'1' — the description of the order the passengers enter the bus. If the `j`-th
character is '0', then the passenger that enters the bus on the `j`-th stop is
an introvert. If the `j`-th character is '1', the the passenger that enters the
bus on the `j`-th stop is an extrovert. It is guaranteed that the number of
extroverts equals the number of introverts (i. e. both numbers equal `n`), and
for each extrovert there always is a suitable row.

Output:

Print `2n` integers — the rows the passengers will take. The order of
passengers should be the same as in input.

""""""
import logging
import collections


fmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'
formatter = logging.Formatter(fmt)

ch = logging.StreamHandler()
ch.setLevel(logging.NOTSET)
ch.setFormatter(formatter)

logger = logging.getLogger('bus_of_characters')
logger.setLevel(logging.NOTSET)
logger.addHandler(ch)


def solve(w, s):
    free = collections.deque()
    print(""free: "", str(free))
    used = collections.deque()
    print(""used: "", str(used))

    for w in sorted(enumerate(w), key=lambda x: x[1]):
        free.append([w[0] + 1, w[1]])
        print(""free: "", str(free))
    
    ids = [-1] * len(s)
    print(""ids: "", str(ids))

    order = []
    for pid, p in enumerate(s):
        logger.debug('pid: %s', pid)
        if p == '0':
            taken = free.popleft(), 
            print(""taken: "", str(taken))
            used.appendleft(taken)
            # order.append(pid, taken[0])
        else:
            logger.debug('used %s', used)
            taken = used.popleft()
            print(""taken: "", str(taken))
        #order.append([pid, taken[0]])
        ids[pid] = taken[0]
        print(""ids: "", str(ids))

    return [x for x, y in ids]



def main():
    n = int(input().strip())
    print(""n: "", str(n))
    w = [int(x) for x in input().strip().split()]
    print(""w: "", str(w))
    s = input().strip()
    print(""s: "", str(s))

    result = solve(w, s)
    print(' '.join(map(str, result)))


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
163,"<ans>
#!/usr/bin/env python3
from sys import stdin
from bisect import bisect_left, bisect_right
    
INF = int(1e9)

def find(par, a):
    if par[a] == a:
        return a
    par[a] = find(par, par[a])
    return par[a]

def union(par, rnk, a, b):
    a = find(par,a)
    b = find(par,b)
    if a==b:
        return
    
    if rnk[a]<rnk[b]:
        par[a] = b
    else:
        par[b] = a
        if rnk[a]==rnk[b]:
            rnk[a] += 1
    
def solve():
    n, m, k = map(int, stdin.readline().split())
    print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
    cnts = list(map(int, stdin.readline().split()))
    print(""cnts: "", str(cnts))
    for i in range(1,k):
        cnts[i] += cnts[i-1]
        print(""cnts[{}]: "".format(i), str(cnts[i]))
    
    group = list(range(n))
    print(""group: "", str(group))
    rnk = [0 for i in range(n)]
    print(""rnk: "", str(rnk))
    adj = [[INF for j in range(k)] for i in range(k)]
    print(""adj: "", str(adj))
    for i in range(m):
        u, v, x = map(int, stdin.readline().split())
        print(""u: "", str(u), ""v: "", str(v), ""x: "", str(x))
        if x==0:
            union(group, rnk, u-1, v-1)
        tu = bisect_left(cnts, u)
        tv = bisect_left(cnts, v)
        print(""tu: "", str(tu), ""tv: "", str(tv))
        adj[tu][tv] = min(adj[tu][tv], x)
        adj[tv][tu] = min(adj[tv][tu], x)
    
    p = 0
    print(""p: "", str(p))
    for i in range(k):
        cur = group[p]
        print(""cur: "", str(cur))
        while p<cnts[i]:
            if group[p]!=cur:
                print(""No"")
                return
            p += 1
    print(""Yes"")
    
    for p in range(k):
        for i in range(k):
            for j in range(k):
                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])
    
    for i in range(k):
        adj[i][i] = 0
        for j in range(k):
            if adj[i][j] == INF:
                adj[i][j] = -1
    
    for i in range(k):
        print(' '.join(map(lambda x: str(x), adj[i])))
    
    
solve()
</ans>",0,{}
164,"<ans>
from sys  import stdin,stdout

st=lambda:list(stdin.readline().strip())
li=lambda:list(map(int,stdin.readline().split()))
mp=lambda:list(map(int,stdin.readline().split()))
inp=lambda:int(stdin.readline())
pr=lambda n: stdout.write(str(n)+""\n"")

def valid(x,y):
    if x>=n or y>=m or x<0 or y<0:
        return False
    if v[x][y] or l[x][y]=='*':
        return False
    return True

dx=[-1,1,0,0]
dy=[0,0,1,-1]

def DFS(i,j,val):
    ans=1
    print(""ans: "", str(ans))
    connected=[(i,j)]
    print(""connected: "", str(connected))
    stack=[(i,j)]
    v[i][j]=True
    while stack:
        a,b=stack.pop()
        for x in range(4):
            newX,newY=a+dx[x], b+dy[x]
            if valid(newX,newY):
                stack.append((newX,newY))
                v[newX][newY]=True
                connected.append((newX,newY))
                ans= (ans%10 + 1%10) % 10
                print(""ans: "", str(ans))
                
    for i in connected:
        a,b=i
        l[a][b]=(ans,val)
    
        
    
n,m=mp()
print(""n: "", str(n), ""m: "", str(m))
l=[st() for i in range(n)]
print(""l: "", str(l))
val=0
print(""val: "", str(val))
k=[list(i) for i in l]
print(""k: "", str(k))
v=[[False for i in range(m)] for j in range(n)]
print(""v: "", str(v))
for i in range(n):
    for j in range(m):
        if l[i][j]=='.' and not v[i][j]:
            DFS(i,j,val)
            val+=1
            print(""val: "", str(val))

for  i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            k[i][j]=1
            s=set()
            for x in range(4):
                newX,newY= i+dx[x], j+dy[x]
                if newX>=0 and newY>=0 and newX<n and newY<m:
                    if type(l[newX][newY])==tuple:
                        A,B=l[newX][newY]
                        if B not in s:
                            k[i][j]+=A
                            k[i][j]%=10
                            s.add(B)
                
            
print('\n'.join([''.join([str(i) for i in j]) for j in k]))
</ans>",0,{}
165,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]


for _ in range(val()):
    n,l,r = li()
    print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))
    orig = r
    print(""orig: "", str(orig))
    l -= 1
    print(""l: "", str(l))
    r -= l
    print(""r: "", str(r))


    currleft = 0
    curs = n - 1
    while curs and currleft + 2*curs <= l:
        currleft += 2*curs
        curs -= 1
    
    start = n - curs
    print(""start: "", str(start))
    ans = []
    head = start
    print(""head: "", str(head))
    l -= currleft
    print(""l: "", str(l))

    last = head + 1
    print(""last: "", str(last))
    half = 0
    while l:
        half = 1
        start = last
        print(""start: "", str(start))
        last += 1
        l -= 1
        if not l:break
        half = 0
        start = head
        print(""start: "", str(start))
        l -= 1

    if half:
        ans.append(start)
        if last == n + 1:
            head += 1
            last = head + 1
        start = head
        print(""start: "", str(start))
        r -= 1
        print(""r: "", str(r))

    while r:
        ans.append(start)
        r -= 1
        if not r:break
        start = last
        ans.append(start)
        last += 1
        if last == n + 1:
            head += 1
            last = head + 1
        r -= 1
        start = head
        print(""start: "", str(start))
    
    if orig == n*(n-1) + 1:
        ans[-1] = 1

    print(*ans)
</ans>",0,{}
166,"<ans>
array2=input("""").split(' ')
print(""array2: "", str(array2))
summ=0
print(""summ: "", str(summ))
array=list()
print(""array: "", str(array))
for t in range (0,int(array2[0])):
    g=input("""")
    array.append(g)
    print(""g: "", str(g))
if (int(array2[1])==0):
    for b in range (0,int(array2[0])):
        if '0' in array[b]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==1):
    for c in range (0,int(array2[0])):
        if '0' in array[c] and '1' in array[c]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==2):
    for d in range (0,int(array2[0])):
        if '0' in array[d] and '1' in array[d] and '2' in array[d]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==3):
    for e in range (0,int(array2[0])):
        if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==4):
    for f in range (0,int(array2[0])):
        if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==5):
    for g in range (0,int(array2[0])):
        if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==6):
    for h in range (0,int(array2[0])):
        if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==7):
     for i in range (0,int(array2[0])):
                if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:
                    summ=summ+1
                    print(""summ: "", str(summ))
     print(summ)
if (int(array2[1])==8):
    for j in range (0,int(array2[0])):
        if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
if (int(array2[1])==9):
    for k in range (0,int(array2[0])):
        if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:
            summ=summ+1
            print(""summ: "", str(summ))
    print(summ)
</ans>",0,{}
167,"<ans>
import sys
import random
from math import *
 
def input():
    return sys.stdin.readline().strip()
 
def iinput():
    return int(input())

def finput():
    return float(input())

def tinput():
    return input().split()

def linput():
    return list(input())
 
def rinput():
    return map(int, tinput())

def fiinput():
    return map(float, tinput())
 
def rlinput():
    return list(map(int, input().split()))
def trinput():
    return tuple(rinput())

def srlinput():
    return sorted(list(map(int, input().split())))

def NOYES(fl):
    if fl:
        print(""NO"")
    else:
        print(""YES"")
def YESNO(fl):
    if fl:
        print(""YES"")
    else:
        print(""NO"")
    
def main():  
    #n = iinput()
    #k = iinput() 
    #m = iinput() 
    #n = int(sys.stdin.readline().strip()) 
    #n, k = rinput()
    #n, m = rinput()
    #m, k = rinput()
    #n, k, m = rinput()
    #n, m, k = rinput()
    #k, n, m = rinput()
    #k, m, n = rinput() 
    #m, k, n = rinput()
    #m, n, k = rinput()
    #q = srlinput()
    #q = linput()
    x, y, n = rinput()
    print(""x: "", str(x), ""y: "", str(y), ""n: "", str(n))
    res = n - y
    print(""res: "", str(res))
    print(x * (res // x) + y)

    
for inytd in range(iinput()):
    main()
</ans>",1,{}
168,"<ans>
def bitmake(digit):#bit文字列生成（取り扱い注意）
    bit_list =list()
    print(""bit_list: "", str(bit_list))

    for i in range(2 ** digit):
        bit = []
        print(""bit: "", str(bit))
        for j in range(digit):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                bit.append(j)
        bit_list.append(bit)
    print(""bit_list: "", str(bit_list))
    return bit_list
h,w,k = list(map(int,input().split()))
print(""h: "", str(h), ""w: "", str(w), ""k: "", str(k))
grid = [""""]*h
print(""grid: "", str(grid))
for i in range(h):
    grid[i] = list(map(str,input()))
    print(""grid[{}]: "".format(i), str(grid[i]))

bit_list = bitmake(h+w)
print(""bit_list: "", str(bit_list))
blackh = [0]*h#横
print(""blackh: "", str(blackh))
blackw = [0]*w#縦
print(""blackw: "", str(blackw))
blacksum = 0
print(""blacksum: "", str(blacksum))
for i in range(h):
    for j in range(w):
        if(grid[i][j] == ""#""):
            blackh[i]+=1
            blackw[j]+=1
            grid[i][j] = 1
            blacksum += 1
        else:
            grid[i][j] = 0
# print(blackh,blackw)
ans = 0
print(""ans: "", str(ans))
for i in range(2**(h+w)):
    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1
    print(""bit: "", str(bit))
    remove = 0
    print(""remove: "", str(remove))
    hight = []
    print(""hight: "", str(hight))
    width = []
    print(""width: "", str(width))
    for j in range(len(bit)):
        l = bit[j]
        if(l <= h-1):
            remove += blackh[l]
            hight.append(l)
            print(""hight after append: "", str(hight))
        else:
            ind = l - h
            remove += blackw[ind]
            width.append(ind)
            print(""width after append: "", str(width))
    # print(hight,width)
    rid = 0
    print(""rid: "", str(rid))
    for j in range(len(hight)):
        for l in range(len(width)):
            if(grid[hight[j]][width[l]] == 1):
                rid += 1
                print(""rid incremented: "", str(rid))
    
    if((blacksum - remove) + rid == k):
        # print(blacksum,remove,rid,""___"",blacksum-remove+rid)  
        ans += 1
        print(""ans incremented: "", str(ans))
print(ans)

# 2 3 2
# ..#
# ###
</ans>",0,{}
169,"<ans>
n=int(input())
print(""n: "", str(n))
if (n == 1) :
 print (""Washington"")
elif (n == 2):
 print (""Adams"")
elif (n == 3):
 print (""Jefferson"")
elif (n == 4):
 print (""Madison"")
elif (n == 5):
 print (""Monroe"")
elif (n == 6):
 print (""Adams"")
elif (n == 7):
 print (""Jackson"")
elif (n == 8):
 print (""Van Buren"")
elif (n == 9):
 print(""Harrison"")
elif (n == 10):
 print(""Tyler"")
elif (n == 11):
 print(""Polk"")
elif (n == 12):
 print(""Taylor"")
elif (n == 13):
 print(""Fillmore"")
elif (n == 14):
 print(""Pierce"")
elif (n == 15):
 print(""Buchanan"")
elif (n == 16):
 print (""Lincoln"")
elif (n == 17):
 print (""Johnson"")
elif (n == 18):
 print (""Grant"")
elif (n == 19):
 print (""Hayes"")
elif (n == 20):
 print (""Garfield"")
elif (n == 21):
 print (""Arthur"")
elif (n == 22):
 print (""Cleveland"")
elif (n == 23):
 print (""Harrison"")
elif (n == 24):
 print (""Cleveland"")
elif (n == 25):
 print (""McKinley"")
elif (n == 26):
 print (""Roosevelt"")
elif (n == 27):
 print (""Taft"")
elif (n == 28):
 print (""Wilson"")
elif (n == 29):
 print ('Harding')
elif (n == 30):
 print (""Coolidge"")
elif (n == 31):
 print (""Hoover"")
elif (n == 32):
 print (""Roosevelt"")
elif (n == 33):
 print (""Truman"")
elif (n == 34):
 print (""Eisenhower"")
elif (n == 35):
 print (""Kennedy"")
elif (n == 36):
 print (""Johnson"")
elif (n == 37):
 print (""Nixon"")
elif n == 38:
 print (""Ford"")
elif n == 39:
 print (""Carter"")
elif n == 40:
 print (""Reagan"")
</ans>",1,{}
170,"<ans>
import math
from decimal import Decimal
import heapq
def na():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,b
 
 
def nab():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,c
 
 
def dv():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	return n,m
 
 
def dva():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	a = [int(x) for x in input().split()]
	print(""a: "", str(a))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,m,b
 
 
def eratosthenes(n): 
	sieve = list(range(n + 1))
	print(""sieve: "", str(sieve))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
def lol(lst,k):
	k=k%len(lst)
	print(""k: "", str(k))
	ret=[0]*len(lst)
	for i in range(len(lst)):
		if i+k<len(lst) and i+k>=0:
			ret[i]=lst[i+k]
		if i+k>=len(lst):
			ret[i]=lst[i+k-len(lst)]
		if i+k<0:
			ret[i]=lst[i+k+len(lst)]
	return(ret)
def nm():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	m = int(input())
	print(""m: "", str(m))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,m,c
 
 
def dvs():
	n = int(input())
	print(""n: "", str(n))
	m = int(input())
	print(""m: "", str(m))
	return n, m 
def Factor(n):
	Ans = []
	d = 2
	while d * d <= n:
		if n % d == 0:
			Ans.append(d)
			n //= d
		else:
			d += 1
	if n > 1:
		Ans.append(n)
	return Ans


s = input()
a1 = 'Mike'
a2 = 'Ann'
if len(s) == 1:
	print(a1)
	return
print(a1)
tc = s[0]
print(""tc: "", str(tc))
pre = []
print(""pre: "", str(pre))
n = len(s)
print(""n: "", str(n))
for i in range(1, n):
	d = min(s[i], tc)
	print(""d: "", str(d))
	pre.append(d)
	tc = d
for i in range(1, n):
	if pre[i - 1] < s[i]:
		print(a2)
	else:
		print(a1)
</ans>",0,{}
171,"<ans>
t,sx,sy,ex,ey=map(int,input().split())
print(""t: "", str(t), ""sx: "", str(sx), ""sy: "", str(sy), ""ex: "", str(ex), ""ey: "", str(ey))
w=input()
n=len(w)
print(""n: "", str(n))
w+="" ""
ans=-1
print(""ans: "", str(ans))
i=0
print(""i: "", str(i))
dx=ex-sx
print(""dx: "", str(dx))
dy=ey-sy
print(""dy: "", str(dy))
if abs(dx)+abs(dy)>t:
    pass
else:
    while i<=t and i<n:
        if dx==0 and dy==0:
            ans=i
            print(""ans: "", str(ans))
            break
        if dx>=0 and dy>=0:
            if ((w[i]!=""E"" and w[i]!=""N"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
                print(""i: "", str(i))
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                print(""i: "", str(i))
                dx-=1
                print(""dx: "", str(dx))
            if dy>0 and w[i]==""N""and i<n:
                i+=1
                print(""i: "", str(i))
                dy-=1
                print(""dy: "", str(dy))
        elif dx>=0 and dy<=0:
            if ((w[i]!=""E"" and w[i]!=""S"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
                print(""i: "", str(i))
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                print(""i: "", str(i))
                dx-=1
                print(""dx: "", str(dx))
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                print(""i: "", str(i))
                dy+=1
                print(""dy: "", str(dy))
        elif dx<=0 and dy>=0:
            if ((w[i]!=""W"" and w[i]!=""N"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
                print(""i: "", str(i))
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                print(""i: "", str(i))
                dx+=1
                print(""dx: "", str(dx))
            if dy>0 and w[i]==""N"" and i<n:
                i+=1
                print(""i: "", str(i))
                dy-=1
                print(""dy: "", str(dy))
        elif dx<=0 and dy<=0:
            if ((w[i]!=""W"" and w[i]!=""S"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
                print(""i: "", str(i))
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                print(""i: "", str(i))
                dx+=1
                print(""dx: "", str(dx))
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                print(""i: "", str(i))
                dy+=1
                print(""dy: "", str(dy))
if dx==0 and dy==0:
            ans=i
            print(""ans: "", str(ans))
print(ans)  
</ans>",0,{}
172,"<ans>
def __starting_point():
    inp = input()
    arr = inp.split(' ')
    print(""arr: "", str(arr))
    L = [int(x) for x in arr]
    print(""L: "", str(L))
    ans = [0,0,0]
    print(""ans: "", str(ans))
    s = 0
    for l in L:
        s+=l
    imp = False
    for l in L:
        if l>s/2:
            imp = True
    if imp:
        print('Impossible')
    else:
##        m = min(L)//2
##        for i in (0,1,2):
##            ans[i]+=m
##            L[i]-=m*2
####        print(ans)
        imp = False
        if L[0]==min(L):
            if L[1]>L[2]:
                bonds = L[1]-L[2]
                ans[0] += bonds
                print(""bonds: "", str(bonds))
                L[0]-= bonds
                L[1] -=bonds
            else:
                bonds = L[2]-L[1]
                ans[2] += bonds
                print(""bonds: "", str(bonds))
                L[0] -= bonds
                L[2] -= bonds
            if L[0]%2==1:
                imp = True
            else:
                bonds = L[0]//2
                ans[0] += bonds
                print(""bonds: "", str(bonds))
                ans[2] += bonds
                ans[1] += (L[1]+L[2])//2 - bonds
        elif L[1]==min(L):
            if L[0]>L[2]:
                bonds = L[0]-L[2]
                ans[0] += bonds
                print(""bonds: "", str(bonds))
                L[1]-= bonds
                L[0] -= bonds
            else:
                bonds = L[2]-L[0]
                ans[1] += bonds
                print(""bonds: "", str(bonds))
                L[1] -= bonds
                L[2] -= bonds 
            if L[1]%2==1:
                imp = True
            else:
                bonds = L[1]//2
                ans[0] += bonds
                print(""bonds: "", str(bonds))
                ans[1] += bonds
                ans[2] += (L[0]+L[2])//2 - bonds

        else:
            if L[0]>L[1]:
                bonds = L[0]-L[1]
                ans[2] += bonds
                print(""bonds: "", str(bonds))
                L[2]-= bonds
                L[0]-=bonds
            else:
                bonds = L[1]-L[0]
                ans[1] += bonds
                print(""bonds: "", str(bonds))
                L[2] -= bonds
                L[1] -= bonds
            if L[2]%2==1:
                imp = True
            else:
                bonds = L[2]//2
                ans[2] += bonds
                print(""bonds: "", str(bonds))
                ans[1] += bonds
                ans[0] += (L[0]+L[1])//2 - bonds
            
        for i in ans:
            if i<0:
                imp = True
        if imp:
            print('Impossible')
        else:
            for i in range(3):
                print(ans[i],end=' ')
            print()

__starting_point()
</ans>",0,{}
173,"<ans>
import math as ma
import sys
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))


# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/
def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	print(""m0: "", str(m0), ""y: "", str(y), ""x: "", str(x))
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
		print(""q: "", str(q), ""t: "", str(t), ""m: "", str(m), ""a: "", str(a), ""y: "", str(y), ""x: "", str(x))
	if (x < 0):
		x = x + m0
	return x


def num():
	return map(int , input().split())


def nu():
	return int(input())


def find_gcd(x , y):
	while (y):
		x , y = y , x % y
		print(""x: "", str(x), ""y: "", str(y))
	return x


n,k=num()
print(""n: "", str(n), ""k: "", str(k))
h=li()
print(""h: "", str(h))
a=[0]*(max(h)+5)
print(""a: "", str(a))
mx=max(h)
print(""mx: "", str(mx))
mn=min(h)
print(""mn: "", str(mn))
fo=True
for i in range(1,n):
	if(h[i]!=h[i-1]):
		fo=False
		break
for i in range(n):
	a[0]+=1
	a[h[i]+1]-=1
for i in range(1,len(a)):
	a[i]=a[i]+a[i-1]
s=a[mx]
print(""s: "", str(s))
cc=0
fl=False
for i in range(mx-1,mn,-1):
	if(s+a[i]>k):
		fl=True
		s=a[i]
		cc+=1
		print(""fl: "", str(fl), ""s: "", str(s), ""cc: "", str(cc))
	else:
		fl=False
		s+=a[i]
if(s<=k and fo==False):
	cc+=1
print(cc)
</ans>",0,{}
174,"<ans>
MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]
def check(a):
    return 0<=a<8
set1 = set()
print(""set1: "", str(set1))
set2 = set()
print(""set2: "", str(set2))
dic1 = dict()
print(""dic1: "", str(dic1))
dic2 = dict()
print(""dic2: "", str(dic2))
def cango1(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check (nx) or not check(ny):
            continue
        if (nx,ny) in set1:
            continue
        dic1[(nx,ny)]=lap%2
        print(""dic1: "", str(dic1))
        set1.add((nx,ny))
        print(""set1: "", str(set1))
        cango1(matrix,(nx,ny),lap+1)
def cango2(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check(nx) or not check(ny):
            continue
        if (nx,ny) in set2:
            continue
        dic2[(nx,ny)]=lap%2
        print(""dic2: "", str(dic2))
        set2.add((nx,ny))
        print(""set2: "", str(set2))
        cango2(matrix,(nx,ny),lap+1)
q = int(input())
for ww in range(q):
    matrix = [input().strip() for i in range(8)]
    print(""matrix: "", str(matrix))
    pos = []
    print(""pos: "", str(pos))
    bad = set()
    print(""bad: "", str(bad))
    for i in range(8):
        for j in range(8):
            if matrix[i][j] == 'K':
                pos.append((i,j))
                print(""pos: "", str(pos))
            if matrix[i][j]=='#':
                bad.add((i,j))
                print(""bad: "", str(bad))
    set1,set2,dic1,dic2=set(),set(),dict(),dict()
    print(""set1: "", str(set1))
    print(""set2: "", str(set2))
    print(""dic1: "", str(dic1))
    print(""dic2: "", str(dic2))
    cango1(matrix, pos[0],0)
    cango2(matrix,pos[1],0)
    if ww!=q-1:
        input()
    sec = (set1&set2) - bad
    for x,y in sec:
        if dic1[(x,y)]==dic2[(x,y)]:
            print(""YES"")
            break
    else:
        print(""NO"")
</ans>",0,{}
175,"<ans>
'''input
3
0 2 0
1 0 3
'''
from sys import stdin
from copy import deepcopy
from collections import deque



def find_start(pile):
	start = 1
	index = -1

	for i in range(len(pile)):
		if pile[i] == start:
			index = i
			break
	latest = start
	if index != -1:
		flag = True
		for i in range(index, len(pile)):
			if pile[i] == latest:
				latest += 1
			else:
				flag = False
				break

		if flag:
			start = latest
	return start


# 
def check_start(num, op):
	op[0] = 0
	nonlocal arr
	nonlocal barr

	mydict = [0] * (n + 1)
	print(""mydict: "", str(mydict))
	for i in range(len(arr)):
		mydict[arr[i]] += 1
		
	# print(mydict)
	zeroes = mydict[0]
	print(""zeroes: "", str(zeroes))

	pile = deque(barr[:])
	print(""pile: "", str(pile))


	# inserting the zeroes initially
	for i in range(num):
		if zeroes > 0:
			op[0] += 1
			pile.append(0)
			zeroes -= 1
			mydict[0] -= 1
		else:
			return False

		element = pile.popleft()
		print(""element: "", str(element))


		# updating the dictionary
		mydict[element] += 1
	
		# checking if it is zero
		if element == 0:
			zeroes += 1
	# print(mydict)

	# inserting the numbers
	start = find_start(barr)
	print(""start: "", str(start))
	# print(start)
	for i in range(start, n + 1):
		# print(pile)
		if mydict[i] > 0:
			op[0] += 1
			pile.append(i)
			mydict[i] -= 1
			element = pile.popleft()
			mydict[element] += 1
		else:
			return False
	return True


# main starts
n = int(stdin.readline().strip())
print(""n: "", str(n))
arr = list(map(int, stdin.readline().split()))
print(""arr: "", str(arr))
barr = list(map(int, stdin.readline().split()))
print(""barr: "", str(barr))
start = 0
print(""start: "", str(start))
end = 2 * n
print(""end: "", str(end))
op = [0]
print(""op: "", str(op))

if check_start(0, op):
	print(op[0])
	return

pos = [0] * (n + 1)
print(""pos: "", str(pos))
for i in range(n):
	pos[barr[i]] = i + 1
	print(""pos: "", str(pos))

ans = -float('inf')
for i in range(1, n + 1):	
	ans = max(pos[i] - i  + 1 + n, ans)
print(""ans: "", str(ans))
</ans>",0,{}
176,"<ans>
def xmax(x, y):
    if x[1] > y[1]:
        return x
    return y

class SegTree:
    def __init__(self, init_val, n, ide_ele, seg_func):
        self.segfunc = seg_func
        self.num = 2**(n-1).bit_length()
        print(""self.num: "", str(self.num))
        self.ide_ele = ide_ele
        print(""self.ide_ele: "", str(self.ide_ele))
        self.seg=[self.ide_ele]*2*self.num
        print(""self.seg: "", str(self.seg))
        for i in range(n):
            self.seg[i+self.num-1]=init_val[i]    
        for i in range(self.num-2,-1,-1) :
            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) 
        
    def update(self, k, x):
        ll = k
        print(""ll: "", str(ll))
        k += self.num-1
        print(""k: "", str(k))
        self.seg[k] = (ll, self.seg[k][1] + x)
        print(""self.seg[k]: "", str(self.seg[k]))
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
            print(""self.seg[k]: "", str(self.seg[k]))

    def update2(self, k, x):
        k += self.num-1
        print(""k: "", str(k))
        self.seg[k] = x
        print(""self.seg[k]: "", str(self.seg[k]))
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
            print(""self.seg[k]: "", str(self.seg[k]))
        
    def query(self, p, q):
        if q<=p:
            return self.ide_ele
        p += self.num-1
        print(""p: "", str(p))
        q += self.num-2
        print(""q: "", str(q))
        res=self.ide_ele
        print(""res: "", str(res))
        while q-p>1:
            if p&1 == 0:
                res = self.segfunc(res,self.seg[p])
                print(""res: "", str(res))
            if q&1 == 1:
                res = self.segfunc(res,self.seg[q])
                print(""res: "", str(res))
                q -= 1
            p = p//2
            q = (q-1)//2
        if p == q:
            res = self.segfunc(res,self.seg[p])
            print(""res: "", str(res))
        else:
            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])
            print(""res: "", str(res))
        return res

import sys;input=sys.stdin.readline
N, M = map(int, input().split())
print(""N: "", str(N), ""M: "", str(M))
X = list(map(int, input().split()))
print(""X: "", str(X))
sts = [[] for _ in range(N)]
print(""sts: "", str(sts))
for i in range(1, M+1):
    a, b = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b))
    sts[a-1].append((i, b-1))
    sts[b-1].append((i, a-1))
    X[a-1] -= 1
    print(""X[a-1]: "", str(X[a-1]))
    X[b-1] -= 1
    print(""X[b-1]: "", str(X[b-1]))
minf = -(10 ** 18)-1
print(""minf: "", str(minf))
ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)
f = False
R = []
vs = set()
while True:
    j, mx = ss.query(0, N)
    print(""j: "", str(j), ""mx: "", str(mx))
    if mx<0:
        f=True
        break
    while sts[j]:
        i, co = sts[j].pop()
        print(""i: "", str(i), ""co: "", str(co))
        if i in vs:
            continue
        vs.add(i)
        ss.update(co, 1)
        R.append(i)
    if len(R) == M:break
    ss.update2(j, (j, minf))

if f or len(R) != M:print(""DEAD"")
else:print(""ALIVE"");print(*R[::-1])
</ans>",0,{}
177,"<ans>
import sys
import math

def ii():
    return sys.stdin.readline().strip()

def idata():
    return [int(x) for x in ii().split()]

def bfs(graph1, root1):
    visited1 = set()
    queue1 = [[root1, 0]]
    visited1.add(root1)
    qw, ver = 0, 1
    print(""qw: "", str(qw), ""ver: "", str(ver))
    while queue1:
        vertex1 = queue1[0]
        queue1 = queue1[1:]
        for neig1 in graph1[vertex1[0]]:
            if neig1 not in visited1:
                visited1.add(neig1)
                queue1 += [[neig1, vertex1[1] + 1]]
                if qw < vertex1[1] + 1:
                    ver, qw = neig1, vertex1[1] + 1
                    print(""ver: "", str(ver), ""qw: "", str(qw))
    return ver, qw

def dfs(graph, ver):
    used_v = set()
    depth = [0] * (len(graph) + 1)
    level = [ver]
    num_of_level = 0
    print(""depth: "", str(depth), ""level: "", str(level), ""num_of_level: "", str(num_of_level))
    while level:
        new_level = []
        for v in level:
            depth[v] = num_of_level
            used_v.add(v)
            for v1 in graph[v]:
                if v1 not in used_v:
                    new_level += [v1]
        level = new_level
        num_of_level += 1
        print(""new_level: "", str(new_level), ""num_of_level: "", str(num_of_level))
    return depth

def binary_search(array, x):
    left, right = -1, len(array)
    print(""left: "", str(left), ""right: "", str(right))
    while left + 1 != right:
        middle = (left + right) // 2
        if array[middle] >= x:
            right = middle
        elif array[middle] < x:
            left = middle
        print(""left: "", str(left), ""right: "", str(right), ""middle: "", str(middle))
    return right

def c_mod(n1, k1, mod1):
    num = den = 1
    print(""num: "", str(num), ""den: "", str(den))
    for i in range(n1 - k1):
        num = (num * (n1 - i)) % mod1
        den = (den * (i + 1)) % mod1
        print(""num: "", str(num), ""den: "", str(den))
    return (num * pow(den, mod1 - 2, mod1)) % mod1

def c(n1, k1):
    num = den = 1
    print(""num: "", str(num), ""den: "", str(den))
    for i in range(n1 - k1):
        num = num * (n1 - i)
        den = den * (i + 1)
        print(""num: "", str(num), ""den: "", str(den))
    return num // den

def v_sistemu(x, k):
    x = int(x)
    z = ''
    print(""x: "", str(x), ""k: "", str(k), ""z: "", str(z))
    while x:
        z += str(x % k)
        x //= k
    return z[::-1]

def iz_sistemi(x, k):
    x = str(x)[::-1]
    ans = 0
    print(""x: "", str(x), ""k: "", str(k), ""ans: "", str(ans))
    for i in range(len(x)):
        ans += int(x[i]) * pow(k, i)
        print(""ans: "", str(ans))
    return ans

def solve_of_problem():
    n = int(ii())
    ans = 2
    print(""n: "", str(n), ""ans: "", str(ans))
    for i in range(n):
        ans *= 2
        print(""ans: "", str(ans))
        if n % (ans - 1) == 0:
            print(n // (ans - 1))
            return
    return

for ______ in range(int(ii())):
    solve_of_problem()
</ans>",0,{}
178,"<ans>
import sys

def Min(x, y):
    if x > y:
        return y
    else:
        return x

def Gcd(x, y):
    if x == 0:
        return y
    else:
        return Gcd(y % x, x)

def Lcm(x, y):
    return x * y // Gcd(x, y)

n = int(input())
print(""n: "", str(n))
a = [int(i) for i in input().split()]
print(""a: "", str(a))
d = [int(0) for i in range(0, n)]
print(""d: "", str(d))

ok = 0
print(""ok: "", str(ok))

cur = 0
print(""cur: "", str(cur))

len = Lcm(7, n)
print(""len: "", str(len))

for i in range(0, 7 * n):
    if a[i % n] == 0 :
        print(i % n + 1)
        ok = 1
        break
    if cur != 6:
        a[i % n] -= 1
        d[i % n] += 1
    cur = (cur + 1) % 7

if ok == 0:
    k = 10**20
    print(""k: "", str(k))

    for i in range(0, n):
        a[i] += d[i]
        print(""a[{}]: "".format(i), str(a[i]))
        if d[i] == 0: continue
        if a[i] % d[i] > 0:
            k = Min(k, a[i] // d[i])
            print(""k: "", str(k))
        else:
            k = Min(k, a[i] // d[i] - 1)
            print(""k: "", str(k))

    if k == 10**20:
        k = 0
        print(""k: "", str(k))

    for i in range(0, n):
        a[i] -= k * d[i]
        print(""a[{}]: "".format(i), str(a[i]))

    iter = 0
    print(""iter: "", str(iter))
    cur = 0
    print(""cur: "", str(cur))

    while True:
        if a[iter] == 0:
            print(iter % n + 1)
            break
        else:
            if cur != 6:
                a[iter] -= 1
            cur = (cur + 1) % 7
            iter = (iter + 1) % n
            print(""iter: "", str(iter), ""cur: "", str(cur))
</ans>",0,{}
179,"<ans>
# import itertools
# import math
# from functools import reduce
# import sys
# sys.setrecursionlimit(500*500)
# import numpy as np
# import heapq
# from collections import deque

# N = int(input())
# S = input()
# n, *a = map(int, open(0))
A, B, C, X, Y = map(int, input().split())
print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# tree = [[] for _ in range(N + 1)]
# B_C = [list(map(int,input().split())) for _ in range(M)]
# S = input()

# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])
# all_cases = list(itertools.permutations(P))
# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))
# itertools.product((0,1), repeat=n)

# A = np.array(A)
# cum_A = np.cumsum(A)
# cum_A = np.insert(cum_A, 0, 0)

# def dfs(tree, s):
#     for l in tree[s]:
#         if depth[l[0]] == -1:
#             depth[l[0]] = depth[s] + l[1]
#             dfs(tree, l[0])
# dfs(tree, 1)

# def factorization(n):
#     arr = []
#     temp = n
#     for i in range(2, int(-(-n**0.5//1))+1):
#         if temp%i==0:
#             cnt=0
#             while temp%i==0:
#                 cnt+=1
#                 temp //= i
#             arr.append([i, cnt])
#     if temp!=1:
#         arr.append([temp, 1])
#     if arr==[]:
#         arr.append([n, 1])
#     return arr

# def gcd_list(numbers):
#     return reduce(math.gcd, numbers)

# if gcd_list(A) > 1:
#     print(""not coprime"")
#     return

# 高速素因数分解準備
#MAXN = 10**6+10
#sieve = [i for i in range(MAXN+1)]
#p = 2
#while p*p <= MAXN:
#    if sieve[p] == p:
#        for q in range(2*p, MAXN+1, p):
#            if sieve[q] == q:
#                sieve[q] = p
#    p += 1

if 2 * C > A + B:
    print(A * X + B * Y)
else:
    if X > Y:
        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))
    else:
        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))
</ans>",1,{}
180,"<ans>
import sys
sys.setrecursionlimit(10**9)
N,M=map(int,input().split())
print(""N: "", str(N), ""M: "", str(M))

def find_negative_loop(n,w,es):
  dist=[float(""inf"")]*n
  print(""dist: "", str(dist))
  #この始点はどこでもよい
  dist[1]=0
  print(""dist[1]: "", str(dist[1]))
  
  for i in range(n):
    for j in range(w):
      e=es[j]
      if dist[e[1]]>dist[e[0]]+e[2]:
        dist[e[1]]=dist[e[0]]+e[2]
        print(""dist[e[1]]: "", str(dist[e[1]]))
        if i==n-1:
          return True
  return False

def shortest_path(s,n,w,es):
  #s→iの最短距離
  #s:始点, n:頂点数, w:辺の数, es[i]:[辺の始点,辺の終点,辺のコスト]
  dist=[float(""inf"")]*n
  print(""dist: "", str(dist))
  #d[i]: s→iの最短距離
  dist[s]=0
  print(""dist[s]: "", str(dist[s]))

  while True:
    update=False
    for p,q,r in es:
      # e: 辺iについて [from,to,cost]
      if dist[p]!=float(""inf"") and dist[q]>dist[p]+r:
        dist[q]=dist[p]+r
        print(""dist[q]: "", str(dist[q]))
        update=True
    if not update:
      break
      
  return dist

graph=[[] for _ in range(N+1)]
print(""graph: "", str(graph))
elist=[]
for _ in range(M):
  a,b,c=map(int,input().split())
  print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
  graph[a].append(b)
  elist.append((a,b,-c))
  
#remove unnecessary vertex and edge
visited=[None]*(N+1)
print(""visited: "", str(visited))
def check_reachable(u):
  visited[u]=True
  if u==N:
    reachable[u]=True
    return True
  elif reachable[u]!=None:
    return reachable[u]  

  cnt=0
  for v in graph[u]:
    if not visited[v]:
      ret=check_reachable(v)
      if ret:
        cnt+=1
        
  if cnt>0:
    reachable[u]=True
    return True
  else:
    reachable[u]=False
    return False

reachable=[None]*(N+1)
print(""reachable: "", str(reachable))
for i in range(1,N+1):
  if reachable[i]==None:
    visited=[False]*(N+1)
    print(""visited: "", str(visited))
    check_reachable(i)
#print(reachable)
  
elist2=[]
for a,b,nc in elist:
  if reachable[b]:
    elist2.append((a,b,nc))
print(""elist2: "", str(elist2))
  
M2=len(elist2)
print(""M2: "", str(M2))
res1=find_negative_loop(N+1,M2,elist2)

if res1:
  print(""inf"")
else:
  res2=shortest_path(1,N+1,M2,elist2)
  print(""res2: "", str(res2))
  print(-res2[N])
</ans>",0,{}
181,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    print(""prime: "", str(prime))
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    print(""r: "", str(r))
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    print(""divisors: "", str(divisors))
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    print(""divs_number: "", str(divs_number))
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
        print(""divs_number: "", str(divs_number))
    return divs_number

def flin(d, x, default=-1):
    left = right = -1
    print(""left: "", str(left), ""right: "", str(right))
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            right = i
    if left == -1:
        return default, default
    else:
        return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, k = mi()
    print(""n: "", str(n), ""k: "", str(k))
    even = n - 2*(k - 1)
    print(""even: "", str(even))
    odd = n - (k - 1)
    print(""odd: "", str(odd))
    if odd > 0 and odd % 2:
        res = [1]*(k - 1) + [odd]
        print(""res: "", str(res))
        print('YES')
        prr(res, ' ')
    elif even > 0 and even % 2 == 0:
        res = [2] * (k - 1) + [even]
        print(""res: "", str(res))
        print('YES')
        prr(res, ' ')
    else:
        print('NO')
</ans>",0,{}
182,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
import math

def isSubSequence(str1,str2):
    m = len(str1)
    n = len(str2)
    j = 0    # Index of str1 
    i = 0    # Index of str2 
    while j<m and i<n: 
        if str1[j] == str2[i]:     
            j = j+1    
        i = i + 1
    return j==m
    

T = int(input())
print(""T: "", str(T))
 
#A,H,Q = [int(x) for x in stdin.readline().split()] 
for t in range(T):
    print(""t: "", str(t))
    #N,M = [int(x) for x in stdin.readline().split()]
    s = input()
    print(""s: "", str(s))
    t = input()
    print(""t: "", str(t))
    p = input()
    print(""p: "", str(p))
    
    freq_s = {}
    print(""freq_s: "", str(freq_s))
    freq_t = {}
    print(""freq_t: "", str(freq_t))
    freq_p = {}
    print(""freq_p: "", str(freq_p))
    for i in range(26):
        freq_s[chr(97+i)] = 0
        print(""freq_s[chr(97+i)]: "", str(freq_s[chr(97+i)]))
        freq_t[chr(97+i)] = 0
        print(""freq_t[chr(97+i)]: "", str(freq_t[chr(97+i)]))
        freq_p[chr(97+i)] = 0
        print(""freq_p[chr(97+i)]: "", str(freq_p[chr(97+i)]))
        
    for letter in s:
        freq_s[letter] += 1
        print(""freq_s[letter]: "", str(freq_s[letter]))
    for letter in t:
        freq_t[letter] += 1
        print(""freq_t[letter]: "", str(freq_t[letter]))
    for letter in p:
        freq_p[letter] += 1
        print(""freq_p[letter]: "", str(freq_p[letter]))
    
    # check s is subsequence of t, if not, print no    
    sub = isSubSequence(s,t)
    print(""sub: "", str(sub))
    if sub==0:
        print('NO')
    else:
        flag = 0
        print(""flag: "", str(flag))
        for i in range(26):
            d = freq_t[chr(97+i)] - freq_s[chr(97+i)]
            print(""d: "", str(d))
            if d>0:
                #print(chr(97+i))
                if freq_p[chr(97+i)]<d and flag==0:
                    print('NO')
                    flag = 1
                    print(""flag: "", str(flag))
                    
        if flag==0:
            print('YES')
</ans>",0,{}
183,"<ans>
#
# abc147 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
1
2 1
1
1 1
1
2 0""""""
        output = """"""2""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""3
2
2 1
3 0
2
3 1
1 0
2
1 1
2 0""""""
        output = """"""0""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""2
1
2 0
1
1 0""""""
        output = """"""1""""""
        self.assertIO(input, output)


def resolve():
    N = int(input())
    print(""N: "", str(N))
    C = []
    print(""C: "", str(C))
    for i in range(N):
        a = int(input())
        print(""a: "", str(a))
        C.append([list(map(int, input().split())) for j in range(a)])
        print(""C: "", str(C))

    ans = 0
    print(""ans: "", str(ans))
    for bit in range(1 << N):
        f = True
        print(""bit: "", str(bit))
        for i in range(N):
            if bit & (1 << i):
                for c in C[i]:
                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
                        f = False
                        break
        if f == True:
            ans = max(ans, bin(bit).count(""1""))
            print(""ans: "", str(ans))
    print(ans)


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",0,{}
184,"<ans>
# alpha = ""abcdefghijklmnopqrstuvwxyz""
prime = 998244353
print(""prime: "", str(prime))
t = 1#int(input())
from heapq import heappop, heappush
for test in range(t):
    n = int(input())
    print(""n: "", str(n))
    # n,m = (map(int, input().split()))
    s = input()
    print(""s: "", str(s))
    # ans = 1
    # start = 1
    # cur = s[0]
    # tmp = 0
    # while s[start]==cur:
    #     start+=1
    #     tmp+=1
    # end = n-1
    # tmp = 1
    # while s[end]==cur:
    #     end-=1
    #     tmp+=1
    grp = []
    cnt = []
    tmp = 0
    print(""tmp: "", str(tmp))
    cur = s[0]
    print(""cur: "", str(cur))
    for i in s:
        if i==cur:
            tmp+=1
        else:
            grp.append(cur)
            cnt.append(tmp)
            cur = i
            tmp = 1
            print(""cur: "", str(cur))
            print(""tmp: "", str(tmp))
    grp.append(cur)
    cnt.append(tmp)
    print(""grp: "", str(grp))
    print(""cnt: "", str(cnt))
    if len(grp)==1:
        print(((n*(n+1))//2)%prime)
    else:
        if grp[0]==grp[-1]:
            ans = ((cnt[0]+1)*(cnt[-1]+1))%prime
            print(""ans: "", str(ans))
            # print(""here"", ans)
            # if cnt[0]+cnt[-1]==n-1:
            #     ans-=1
            #     ans = ans%prime
            print(ans)
        else:
            ans = cnt[0]+1+cnt[-1]
            ans = ans%prime
            print(""ans: "", str(ans))
            # if cnt[0]+cnt[-1]==n-1:
            #     ans-=1
            #     ans = ans%prime
            print(ans)
</ans>",0,{}
185,"<ans>
n, l, r = [int(i) for i in input().split()]
print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))

number_of_zeros = 0
print(""number_of_zeros: "", str(number_of_zeros))
number_of_ones = 0
print(""number_of_ones: "", str(number_of_ones))
number_of_twos = 0
print(""number_of_twos: "", str(number_of_twos))

if l%3 == 0:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3 + 1
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3 + 1
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
elif l%3 == 1:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3 + 1
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3 + 1
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3 + 1
        print(""number_of_twos: "", str(number_of_twos))
elif l%3 == 2:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3 + 1
        print(""number_of_twos: "", str(number_of_twos))
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3
        print(""number_of_twos: "", str(number_of_twos))
    elif r%3 == 2:
        number_of_zeros = (r-l+1)//3 
        print(""number_of_zeros: "", str(number_of_zeros))
        number_of_ones = (r-l+1)//3
        print(""number_of_ones: "", str(number_of_ones))
        number_of_twos = (r-l+1)//3 + 1
        print(""number_of_twos: "", str(number_of_twos))

dp = [[-1 for i in range(3)] for j in range(n+1)]
print(""dp: "", str(dp))

MOD = 10**9 + 7
print(""MOD: "", str(MOD))
dp[1][0] = number_of_zeros%MOD
print(""dp[1][0]: "", str(dp[1][0]))
dp[1][1] = number_of_ones%MOD
print(""dp[1][1]: "", str(dp[1][1]))
dp[1][2] = number_of_twos%MOD
print(""dp[1][2]: "", str(dp[1][2]))

for i in range(2,n+1):
    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD
    print(""dp[{}][0]: "".format(i), str(dp[i][0]))
    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD
    print(""dp[{}][1]: "".format(i), str(dp[i][1]))
    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD
    print(""dp[{}][2]: "".format(i), str(dp[i][2]))

if dp[n][0]!=-1:
    print(dp[n][0]%MOD)
else:
    print(0)
</ans>",0,{}
186,"<ans>
from sys import stdin, stdout 
from bisect import bisect_left, bisect_right
from collections import defaultdict
import math
from fractions import Fraction as frac
from random import random
cin = stdin.readline
def cout(x):
	stdout.write(str(x)+'\n')
def var(type = int):
    return type(stdin.readline())
def readline(type = int):
    return list(map(type,stdin.readline().split()))
def readlist(type = int):
    return list(map(type,stdin.readline().split()))
def sorted_indexes(arr):
    return sorted(list(range(len(arr))),key=arr.__getitem__)
def printr(arr):
    [stdout.write(str(x)+' ')   for x in arr]
    cout('')
def find_lt(a, x):#'Find rightmost value less than x'
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError
def find_gt(a, x):#'Find leftmost value greater than x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError
def dist(x,y):
    return math.sqrt(x*x + y*y)
def binary_search(arr, x):
    i = bisect_left(arr, x)
    if i == len(arr) or arr[i] != x:
        return -1
    return i

# ---------------------Template ends-------------sdpt,sdpt131[Sudipta Banik]---------------------

# mp = [0]*201
# ops = [0]*201
# def go(arr,i,j ,dp):
#     if i==j and ops[i] is None:
#         return [mp[i],mp[i]]
#     if i>j:
#         return [0,0]
#     if dp[i][j]:
#         return dp[i][j]
#     mx = -1000000000
#     mn = 1000000000
#     for k in range(i+1,j,2):
#         if ops[k]:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] + right[0])
#             mn = min(mn,left[1] + right[1])
#         else:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] - right[1])
#             mn = min(mn,left[1] - right[0])
#     dp[i][j] = [mx,mn]
#     return [mx,mn]

    
n , a , b = readline(int)
print(""n: "", str(n), ""a: "", str(a), ""b: "", str(b))
price = [a,b]
print(""price: "", str(price))
arr = readlist(int)
print(""arr: "", str(arr))
half = n//2
print(""half: "", str(half))
cost = 0
print(""cost: "", str(cost))
flg = True
print(""flg: "", str(flg))
for i in range(half):
    if arr[i] == arr[n-1-i] == 2:
        cost += 2*min(a,b)
    elif arr[i] ==2 and arr[n-1-i] <= 1:
        cost += price[arr[n-1-i]]
    elif arr[i] <= 1 and arr[n-1-i] == 2:
        cost += price[arr[i]]
    elif arr[i] != arr[n-1-i]:
        flg = False
        break
if n%2 == 1:
    if arr[half] == 2:
        cost += min(a,b)
if not flg:
    print(-1)
else:
    print(cost)
</ans>",0,{}
187,"<ans>
from sys import stdin
import sys
import numpy as np
import collections
from functools import cmp_to_key
import heapq
sys.setrecursionlimit(100000)

##  input functions for me
def rsa(sep = ''):
    if sep == '' :
        return input().split() 
    else: return input().split(sep)
def rip(sep = ''):
    if sep == '' :
        return list(map(int, input().split())) 
    else: return list(map(int, input().split(sep)))
def ria(sep = ''): 
    return list(rip(sep))
def ri(): return int(input())
def rd(): return float(input())
def rs(): return input()
##
class mint:
    mod = int(1e9 + 7)
    def __init__(self, v = 0):
        if not ((v >= 0) and (v < mint.mod)):
            v %= mint.mod
            if v < 0: v += mint.mod
        self.V = v
    def __add__(self, other):
        v = self.V + (other.V if isinstance(other, mint) else other)
        return mint(v)
    def __sub__(self, other):
        v = self.V - (other.V if isinstance(other, mint) else other)
        return mint(v)
    def __mul__(self, other):
        v = self.V * (other.V if isinstance(other, mint) else other)
        return mint(v)
    def __floordiv__(self, other):
        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))
        return mint(v)
    def __truediv__(self, other):
        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))
        return mint(v)
    
    def __eq__(self, other):
        return self.V == (other.V if isinstance(other, mint) else mint(other).V)
    def __ne__(self, other):
        return self.V != (other.V if isinstance(other, mint) else other)
    def __int__(self): return self.V
    # right operand
    def __radd__(self, other):
        v = (other.V if isinstance(other, mint) else other) + self.V
        return mint(v)
    def __rsub__(self, other):
        v = (other.V if isinstance(other, mint) else other) - self.V
        return mint(v)
    def __rmul__(self, other):
        v = (other.V if isinstance(other, mint) else other) * self.V
        return mint(v)
    def __rfloordiv__(self, other):
        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
        return mint(v)
    def __rtruediv__(self, other):
        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
        return mint(v)

    @staticmethod
    def inv(x):
        a, _, _ = mint.extGCD(x, mint.mod)
        return (a + mint.mod) % mint.mod
    @staticmethod
    def extGCD(x, y):
        r0 = x
        r1 = y
        a0 = 1
        a1 = 0
        b0 = 0
        b1 = 1
        while(r1 > 0):
            q1 = r0 // r1
            r2 = r0 % r1
            a2 = a0 - q1 * a1
            b2 = b0 - q1 * b1
            r0 = r1; r1 = r2
            a0 = a1; a1 = a2
            b0 = b1; b1 = b2
        c = r0
        a = a0
        b = b0       
        return a, b, c
    @staticmethod
    def pow(x, k):
        x = x.V if isinstance(x, mint) else x
        return pow(x, k, mint.mod)

    
    def __str__(self):
        return str(self.V)
    def __repr__(self):
        return str(self.V)

def main():
    N = ri()
    print(""N: "", str(N))
    A = ria()
    print(""A: "", str(A))
    A = sorted(A)
    A = list(reversed(A))
    print(""A: "", str(A))
    Pow2 = [mint(0)] * (N + 1)
    print(""Pow2: "", str(Pow2))
    Pow2[0] = mint(1)
    print(""Pow2[0]: "", str(Pow2[0]))
    for i in range(1,N+1): 
        Pow2[i] = Pow2[i-1] * 2
        print(""Pow2[{}]: "".format(i), str(Pow2[i]))

    tot = mint(0)
    print(""tot: "", str(tot))
    for i in range(N):
        tot += mint(A[i]) * Pow2[N-1]
        print(""tot after adding A[{}]: "".format(i), str(tot))
        if i > 0: 
            tot += mint(A[i]) * i * Pow2[N-2]
            print(""tot after adding A[{}] * {} * Pow2[{}]: "".format(i, i, N-2), str(tot))
    tot *= Pow2[N]
    print(""tot after multiplying by Pow2[{}]: "".format(N), str(tot))
    print(tot)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
188,"<ans>
r1=input()
r2=input()
n=len(r1)
print(""n: "", str(n))
l=[0]
print(""l: "", str(l))
for i in range(n):
	if r1[i]=='0':
		if r2[i]=='0':
			l.append(2)
			print(""l: "", str(l))
		else:
			l.append(1)
			print(""l: "", str(l))
	else:
		if r2[i]=='X':
			l.append(0)
			print(""l: "", str(l))
		else:
			l.append(-1)
			print(""l: "", str(l))
l.append(0)
print(""l: "", str(l))
s=len(l)
print(""s: "", str(s))
count=0
print(""count: "", str(count))
u=1
print(""u: "", str(u))
e=1
print(""e: "", str(e))
while(u<s-1):
	if l[u]==2 and e==1:
		if l[u+1]==2:
			e=2
			u=u+1
			print(""u: "", str(u))
			continue
		elif (l[u+1]==1 or l[u+1]==-1):
			count=count+1
			print(""count: "", str(count))
			u=u+2
			print(""u: "", str(u))
			continue
		else:
			u=u+2
			print(""u: "", str(u))
			continue
	if l[u]==2 and e==2:
		if l[u+1]==2:
			count=count+2
			print(""count: "", str(count))
			u=u+2
			print(""u: "", str(u))
			e=1
			continue
		else:
			count=count+1
			print(""count: "", str(count))
			u=u+1
			print(""u: "", str(u))
			e=1
			continue
	if l[u]==1 or l[u]==-1:
		if l[u+1]==2:
			count=count+1
			print(""count: "", str(count))
			u=u+2
			print(""u: "", str(u))
			continue
		else:
			u=u+1
			print(""u: "", str(u))
			continue
	if l[u]==0:
		u=u+1
		print(""u: "", str(u))
print (count)
</ans>",0,{}
189,"<ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

opr = ['#', '^', '&', '$']
namespace = { ""res"" : (False, ""res"") }
rules = dict()
lookup = dict()
cnt = -1

def get_tag(var):
    if var in namespace:
        return namespace[var][1]
    else:
        return var

N = int(input())
print(""N: "", str(N))
for _ in range(N):
    lval, rval = input().split('=')
    print(""lval: "", str(lval), ""rval: "", str(rval))
    for c in opr:
        if c in rval:
            arg1, arg2 = list(map(get_tag, rval.split(c)))
            print(""arg1: "", str(arg1), ""arg2: "", str(arg2))
            rule = (arg1, arg2, c)
            print(""rule: "", str(rule))
            if rule in rules:
                namespace[lval] = (True, rules[rule])
                print(""namespace[lval]: "", str(namespace[lval]))
            else:
                cnt += 1
                namespace[lval] = (True, cnt)
                print(""namespace[lval]: "", str(namespace[lval]))
                rules[rule] = cnt
                print(""rules[rule]: "", str(rules[rule]))
                lookup[cnt] = rule
                print(""lookup[cnt]: "", str(lookup[cnt]))
            break
    else:
        if rval in namespace:
            namespace[lval] = namespace[rval]
            print(""namespace[lval]: "", str(namespace[lval]))
        else:
            namespace[lval] = (False, rval)
            print(""namespace[lval]: "", str(namespace[lval]))

if namespace[""res""] == (False, ""res""):
    print(""0"")
    return

program = []
myvars = dict()

def reserve():
    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) 

def implement(rule, final):
    if type(rule) == str:
        return rule
    elif rule in myvars:
        return myvars[rule]
    else:
        if final:
            name = ""res""
        else:
            name = reserve()
            print(""name: "", str(name))
        myvars[rule] = name
        print(""myvars[rule]: "", str(myvars[rule]))
        arg1, arg2, op = lookup[rule]
        var1, var2 = implement(arg1, False), implement(arg2, False)
        program.append(name + ""="" + var1 + op + var2)
        print(""program: "", str(program))
        return name

seed(123)
if namespace[""res""][0]:
    implement(namespace[""res""][1], True)
else:
    program.append(""res="" + namespace[""res""][1])
print(len(program))
print(""\n"".join(program))

#print(namespace)
#print(rules)

</ans>",0,{}
190,"<ans>
''' CODED WITH LOVE BY SATYAM KUMAR '''

from sys import stdin, stdout
import heapq
import cProfile, math
from collections import Counter, defaultdict, deque
from bisect import bisect_left, bisect, bisect_right
import itertools
from copy import deepcopy
from fractions import Fraction
import sys, threading
import operator as op
from functools import reduce
import sys

sys.setrecursionlimit(10 ** 6)  # max depth of recursion
threading.stack_size(2 ** 27)  # new thread will get stack of such size
fac_warm_up = False
printHeap = str()
memory_constrained = False
P = 10 ** 9 + 7


class MergeFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n
        self.lista = [[_] for _ in range(n)]

    def find(self, a):
        to_update = []
        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]
        for b in to_update:
            self.parent[b] = a
        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return
        if self.size[a] < self.size[b]:
            a, b = b, a
        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]
        self.lista[a] += self.lista[b]

    def set_size(self, a):
        return self.size[self.find(a)]

    def __len__(self):
        return self.num_sets


def display(string_to_print):
    stdout.write(str(string_to_print) + ""\n"")


def prime_factors(n):  # n**0.5 complex
    factors = dict()
    for i in range(2, math.ceil(math.sqrt(n)) + 1):
        while n % i == 0:
            if i in factors:
                factors[i] += 1
            else:
                factors[i] = 1
            n = n // i
    if n > 2:
        factors[n] = 1
    return (factors)


def all_factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


def fibonacci_modP(n, MOD):
    if n < 2: return 1
    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(
        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD


def factorial_modP_Wilson(n, p):
    if (p <= n):
        return 0
    res = (p - 1)
    for i in range(n + 1, p):
        res = (res * cached_fn(InverseEuler, i, p)) % p
    return res


def binary(n, digits=20):
    b = bin(n)[2:]
    b = '0' * (digits - len(b)) + b
    return b


def is_prime(n):
    """"""Returns True if n is prime.""""""
    if n < 4:
        return True
    if n % 2 == 0:
        return False
    if n % 3 == 0:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w
    return True


def generate_primes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    return prime


factorial_modP = []


def warm_up_fac(MOD):
    nonlocal factorial_modP, fac_warm_up
    if fac_warm_up: return
    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]
    for i in range(2, fac_warm_up_size):
        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD
    fac_warm_up = True


def InverseEuler(n, MOD):
    return pow(n, MOD - 2, MOD)


def nCr(n, r, MOD):
    nonlocal fac_warm_up, factorial_modP
    if not fac_warm_up:
        warm_up_fac(MOD)
        fac_warm_up = True
    return (factorial_modP[n] * (
            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD


def get_int():
    return int(stdin.readline().strip())


def get_tuple():
    return list(map(int, stdin.readline().split()))


def get_list():
    return list(map(int, stdin.readline().split()))


memory = dict()


def clear_cache():
    nonlocal memory
    memory = dict()


def cached_fn(fn, *args):
    nonlocal memory
    if args in memory:
        return memory[args]
    else:
        result = fn(*args)
        memory[args] = result
        return result


def ncr(n, r):
    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))


def binary_search(i, li):
    fn = lambda x: li[x] - x // i
    x = -1
    b = len(li)
    while b >= 1:
        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like
            x += b
        b = b // 2
    return x


# -------------------------------------------------------------- MAIN PROGRAM


TestCases = True
optimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3


def main():
    a, b, c, d, k = get_tuple()
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c), ""d: "", str(d), ""k: "", str(k))
    x = (a+c-1)//c
    print(""x: "", str(x))
    y = (b+d-1)//d
    print(""y: "", str(y))
    if x+y<=k:
        print(x, y)
    else: print(-1)
# --------------------------------------------------------------------- END=


if TestCases:
    for i in range(get_int()):
        main()
else:
    main() if not optimise_for_recursion else threading.Thread(target=main).start()

</ans>",0,{}
191,"<ans>
import sys
input = sys.stdin.readline

# def find(a):
#     if par[a] == a:
#         return a
#     par[a] = find(par[a])
#     return par[a]

def find(a):
    upd = []
    cur = a
    while par[cur] != cur:
        upd.append(cur)
        cur = par[cur]
    for x in upd:
        par[x] = cur
    return cur

def union(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return
    par[a] = b


def mst():
    ret = []
    for edge in edges:
        u, v, w = edge
        u = find(u)
        v = find(v)
        if u != v:
            union(u, v)
            ret.append(edge)
    return ret


def dfs(u, par):
    for v, w in adj[u]:
        if v != par:
            dist[v] = max(dist[u], w)
            dfs(v, u)

def bfs(u):
    visit = [False] * (n+1)
    from collections import deque

    dq = deque()
    dq.append(u)
    visit[u] = True
    while dq:
        u = dq.popleft()
        for v, w in adj[u]:
            if not visit[v]:
                dist[v] = max(dist[u], w)
                dq.append(v)
                visit[v] = True


n, m, k = list(map(int, input().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
a = list(map(int, input().split()))
print(""a: "", str(a))
# n = 50000
# m = 2 * n
# k = n
# a = [i for i in range(1, n+1)]
# import random

par = [0] * (n+1)
print(""par: "", str(par))
for i in range(1, n+1):
    par[i] = i
    print(""par[{}]: "".format(i), str(par[i]))
edges = []
# for i in range(1, n+1):
#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))
#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))
#     edges.append(edge)
for i in range(m):
    edge = tuple(map(int, input().split()))
    edges.append(edge)
print(""edges: "", str(edges))
edges.sort(key=lambda x: x[2])
edges = mst()
print(""edges after mst: "", str(edges))
adj = [list() for i in range(n+1)]
print(""adj: "", str(adj))
for edge in edges:
    u, v, w = edge
    adj[u].append((v, w))
    adj[v].append((u, w))

dist = [0] * (n+1)
print(""dist: "", str(dist))
# dfs(a[0], -1)
bfs(a[0])
ans = 0
print(""ans before loop: "", str(ans))
for x in a:
    ans = max(ans, dist[x])
print(""ans after loop: "", str(ans))
ans = [ans] * k
print(""ans after list multiplication: "", str(ans))
print(*ans)
</ans>",0,{}
192,"<ans>
n=int(input())
print(""n: "", str(n))
s1=[int(x) for x in input().split()]
print(""s1: "", str(s1))
s2=[int(x) for x in input().split()]
print(""s2: "", str(s2))
S1=sorted(s1)
print(""S1: "", str(S1))
S2=sorted(s2)
print(""S2: "", str(S2))
S1=[0]+S1
print(""S1: "", str(S1))
S2=[0]+S2
print(""S2: "", str(S2))
S1=S1[::-1]
print(""S1: "", str(S1))
S2=S2[::-1]
print(""S2: "", str(S2))
pta=0
print(""pta: "", str(pta))
ptb=0
print(""ptb: "", str(ptb))
sm1=0
print(""sm1: "", str(sm1))
sm2=0
print(""sm2: "", str(sm2))
for j in range(0,(2*n)+1):
    if(j%2==0):
        if(S2[ptb]>S1[pta]):
            ptb=ptb+1
            print(""ptb: "", str(ptb))
        else:
            sm1=sm1+S1[pta]
            print(""sm1: "", str(sm1))
            pta=pta+1
            print(""pta: "", str(pta))
    else:
        if(S1[pta]>S2[ptb]):
            pta=pta+1
            print(""pta: "", str(pta))
        else:
            sm2=sm2+S2[ptb]
            print(""sm2: "", str(sm2))
            ptb=ptb+1
            print(""ptb: "", str(ptb))
    if(pta==n+1 and ptb==n+1):
        break
print(sm1-sm2)
</ans>",0,{}
193,"<ans>
import sys
# from collections import deque
input=sys.stdin.readline
def binary_search(org,arr,l,r,n,L,value):
	mid=(l+r)//2
	# print(mid,""ppppp"")
	if(mid>0 and arr[mid]-value>=org and arr[mid-1]-value<org):
		return mid
	elif(mid==0 and arr[mid]-value>=org ):
		return mid
	elif(mid==L and arr[mid]-value>=org ):
		return mid
	
	elif(mid==n):
		return mid

	elif(mid>0 and arr[mid]-value>org and arr[mid-1]-value>=org):
		return binary_search(org,arr,l,mid,n,L,value)
	
	elif(arr[mid]-value<org):
		# print(""dddddd"")
		return binary_search(org,arr,mid+1,r,n,L,value)
	return mid
	





n=int(input())
print(""n: "", str(n))
l= list(map(int,input().split())) 
print(""l: "", str(l))
u= list(map(int,input().split())) 
print(""u: "", str(u))
extra=[0]*n
print(""extra: "", str(extra))
pre=[0]*n
print(""pre: "", str(pre))
t=[0]*n
print(""t: "", str(t))
t[0]=u[0]
print(""t[0]: "", str(t[0]))
for i in range(1,n):
	t[i]+=t[i-1]+u[i]
	print(""t[{}]: "".format(i), str(t[i]))
# print(t)
for i in range(n):
	if(i>0):
		v=t[i-1]
	else:
		v=0
	print(""v: "", str(v))
	index=binary_search(l[i],t,i,n-1,n-1,i,v)
	# print(i,index)
	if(index>0 and index!=i):
		value=t[index]-t[index-1]
		print(""value: "", str(value))
		remain=l[i]-(t[index-1]-v)
		print(""remain: "", str(remain))
	elif(index>0 and index==i):
		value=t[index]-t[index-1]
		print(""value: "", str(value))
		remain=l[i]
		print(""remain: "", str(remain))


	else:
		value=t[index]
		print(""value: "", str(value))
		remain=l[i]
		print(""remain: "", str(remain))
	if(value>=remain):
		extra[index]+=remain
		print(""extra[{}]: "".format(index), str(extra[index]))
		# print(extra[index],""ooooo"")
	elif(remain>value):
		extra[index]+=value
		print(""extra[{}]: "".format(index), str(extra[index]))
		# print(extra[index],""oooooopp"")
	if(i>0 and index>0):
		pre[i-1]-=1
		print(""pre[{}]: "".format(i-1), str(pre[i-1]))
		pre[index-1]+=1
		print(""pre[{}]: "".format(index-1), str(pre[index-1]))
	elif(i==0 and index>0):
		pre[index-1]+=1
		print(""pre[{}]: "".format(index-1), str(pre[index-1]))
	elif(i==0 and index==0):
		continue
	# print(extra,pre)
# print(extra,pre)
for i in range(n-2,-1,-1):
	pre[i]+=pre[i+1]
	print(""pre[{}]: "".format(i), str(pre[i]))
# print(extra,pre)
r=[0]*n
print(""r: "", str(r))
for i in range(n):
	r[i]=(u[i]*pre[i])+extra[i]
	print(""r[{}]: "".format(i), str(r[i]))
		
for i in r:
	print (i,end="" "")
</ans>",0,{}
194,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
from math import *
from decimal import *
from copy import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def dis(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n,k = arrIN()
    print(""n: "", str(n), ""k: "", str(k))
    ans = 0
    print(""ans: "", str(ans))
    while 1:
        if n%k==0:
            n//=k
            print(""n: "", str(n))
            ans+=1
            print(""ans: "", str(ans))
        else:
            x = n%k
            print(""x: "", str(x))
            ans+=x
            print(""ans: "", str(ans))
            n-=x
            print(""n: "", str(n))
        if n==0:
            print(ans)
            break
</ans>",0,{}
195,"<ans>
MOD = 1000000007


def isSubset(a, b):
	return (a & b) == a


def isIntersect(a, b):
	return (a & b) != 0


# Solve for each weakly connected component (WCC)
def cntOrder(s, t):
	p = len(s)
	m = len(t)

	inMask = [0 for i in range(m)]
	print(""inMask: "", str(inMask))

	for x in range(p):
		for i in range(m):
			if t[i] % s[x] == 0:
				inMask[i] |= 1 << x

	cnt = [0 for mask in range(1<<p)]
	print(""cnt: "", str(cnt))
	for mask in range(1<<p):
		for i in range(m):
			if isSubset(inMask[i], mask):
				cnt[mask] += 1

	dp = [[0 for mask in range(1<<p)] for k in range(m+1)]
	print(""dp: "", str(dp))
	for i in range(m):
		dp[1][inMask[i]] += 1
	for k in range(m):
		for mask in range(1<<p):
			for i in range(m):
				if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
					dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
			dp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD

	return dp[m][(1<<p)-1]


def dfs(u):
	nonlocal a, graph, degIn, visited, s, t

	visited[u] = True
	if degIn[u] == 0:
		s.append(a[u])
	else:
		t.append(a[u])

	for v in graph[u]:
		if not visited[v]:
			dfs(v)


def main():
	nonlocal a, graph, degIn, visited, s, t

	# Reading input
	n = int(input())
	print(""n: "", str(n))
	a = list(map(int, input().split()))
	print(""a: "", str(a))

	# Pre-calculate C(n, k)
	c = [[0 for j in range(n)] for i in range(n)]
	print(""c: "", str(c))
	for i in range(n):
		c[i][0] = 1
		for j in range(1, i+1):
			c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD	
	print(""c after filling: "", str(c))

	# Building divisibility graph
	degIn = [0 for u in range(n)]
	print(""degIn: "", str(degIn))
	graph = [[] for u in range(n)]
	print(""graph: "", str(graph))
	for u in range(n):
		for v in range(n):
			if u != v and a[v] % a[u] == 0:
				graph[u].append(v)
				graph[v].append(u)
				degIn[v] += 1

	# Solve for each WCC of divisibility graph and combine result
	ans = 1
	print(""ans: "", str(ans))
	curLen = 0
	print(""curLen: "", str(curLen))
	visited = [False for u in range(n)]
	print(""visited: "", str(visited))
	for u in range(n):
		if not visited[u]:
			s = []
			print(""s: "", str(s))
			t = []
			print(""t: "", str(t))
			dfs(u)

			if len(t) > 0:
				sz = len(t) - 1
				print(""sz: "", str(sz))
				cnt = cntOrder(s, t)
				print(""cnt after cntOrder: "", str(cnt))

				# Number of orders for current WCC
				ans = (ans * cnt) % MOD
				# Number of ways to insert <sz> number to array of <curLen> elements
				ans = (ans * c[curLen + sz][sz]) % MOD
				curLen += sz		
				print(""ans after calculations: "", str(ans))
				print(""curLen after increment: "", str(curLen))

	print(ans)

def __starting_point():
	main()
__starting_point()
</ans>",0,{}
196,"<ans>
N=int(input())
print(""N: "", str(N))
S=input()
print(""S: "", str(S))
S=[1 if S[i]=='o' else -1 for i in range(N)]
print(""S: "", str(S))

#0番目は羊のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=1
print(""tmp[0]: "", str(tmp[0]))
if S[0]==1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  tmp[1]=-1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=-1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=-1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
#0番目は狼のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=-1
print(""tmp[0]: "", str(tmp[0]))
if S[0]==-1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  tmp[1]=-1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=-1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=-1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  print(""tmp[1]: "", str(tmp[1]))
  tmp[N-1]=1
  print(""tmp[N-1]: "", str(tmp[N-1]))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp[{}]: "".format(i), str(tmp[i]))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(""ans: "", str(ans))
    print(''.join(ans))
    return
  
print(-1)
</ans>",1,{}
197,"<ans>
```
n=int(input())
print(""n: "", str(n))
l=list(map(int,input().split()))
print(""l: "", str(l))
s=input()
water=0
print(""water: "", str(water))
grass=0
print(""grass: "", str(grass))
cgrass=0
print(""cgrass: "", str(cgrass))
time=0
print(""time: "", str(time))
seen=False
print(""seen: "", str(seen))
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
            print(""water: "", str(water))
            print(""time: "", str(time))
            print(""cgrass: "", str(cgrass))
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            print(""water: "", str(water))
            print(""time: "", str(time))
            print(""cgrass: "", str(cgrass))
            water=0
            print(""water: "", str(water))
            time+=3*dist
            print(""time: "", str(time))
            grass+=dist
            print(""grass: "", str(grass))
    elif s[i]==""W"":
        water+=l[i]
        print(""water: "", str(water))
        time+=2*l[i]
        print(""time: "", str(time))
        seen=True
        print(""seen: "", str(seen))
    else:
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            time+=2*dist
            print(""water: "", str(water))
            print(""time: "", str(time))
        else:
            dist-=water
            time+=2*water
            print(""water: "", str(water))
            print(""time: "", str(time))
            water=0
            print(""water: "", str(water))
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
                print(""cgrass: "", str(cgrass))
                print(""grass: "", str(grass))
                print(""time: "", str(time))
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                print(""cgrass: "", str(cgrass))
                print(""grass: "", str(grass))
                print(""time: "", str(time))
                cgrass=0
                print(""cgrass: "", str(cgrass))
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                    print(""grass: "", str(grass))
                    print(""time: "", str(time))
                else:
                    dist-=grass
                    time+=3*grass
                    print(""grass: "", str(grass))
                    print(""time: "", str(time))
                    grass=0
                    print(""grass: "", str(grass))
                    if seen:
                        time+=4*dist
                        print(""time: "", str(time))
                    else:
                        time+=6*dist
                        print(""time: "", str(time))
print(time)
```
</ans>",0,{}
198,"<ans>
from math import gcd

m,a,b = list(map(int,input().split()))
print(""m: "", str(m), ""a: "", str(a), ""b: "", str(b))

g = gcd(a,b)
print(""g: "", str(g))

vis = [0]*(a+b+1)
print(""vis: "", str(vis))
vis[0] = 1
print(""vis[0]: "", str(vis[0]))

nvis = 1
print(""nvis: "", str(nvis))

count = 0
print(""count: "", str(count))
last = 0
print(""last: "", str(last))
t = 0
print(""t: "", str(t))

while True:
    #print(t, vis)
    if t >= b:
        #print('back')
        t -= b
        if vis[t]:
            break
        vis[t] = 1
        print(""vis[t]: "", str(vis[t]))
        nvis += 1
        print(""nvis: "", str(nvis))
    else:
        t += a
        print(""t: "", str(t))
        if t > m:
            break
        if t > last:
            #print('forward', t - last, 'with', nvis)
            count += (t - last)*nvis
            print(""count: "", str(count))
            last = t
            print(""last: "", str(last))
        if vis[t]:
            break
        vis[t] = 1
        print(""vis[t]: "", str(vis[t]))
        nvis += 1
        print(""nvis: "", str(nvis))
    #print(nvis,count)
    #print('---')

if t > m:
    # we're done
    count += (m - last + 1)*nvis
    print(""count: "", str(count))
else:
    def sumto(n):
        whole = n//g + 1
        print(""whole: "", str(whole))
        r = whole*(whole+1)//2 * g
        print(""r: "", str(r))
        corr = whole * (g-1 - (n%g))
        print(""corr: "", str(corr))
        r -= corr
        return r

    #S = 0
    #for i in range(last, m+1):
    #    S += i//g + 1
    #count += S
    #assert S == sumto(m) - sumto(last-1)

    count += sumto(m) - sumto(last-1)
    print(""count: "", str(count))

#print(vis)
print(count)
</ans>",1,{}
