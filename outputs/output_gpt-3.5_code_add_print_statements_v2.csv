index,generated,result,format_properties
0,"<ans>
def process_offer(offers):
    aux = []
    for i in offers:
        temp = offers[i]
        temp.sort()
        aux.append([i, temp[-1]])
    print(""aux: "", str(aux))
    
    aux = sorted(aux, key = lambda x: x[0])
    return aux


def make(first, second):
    print(""first: "", str(first), ""second: "", str(second))
    return str(first) + ' ' + str(second)


def brute(arr, dp, offers, index, remain):
    print(""index: "", str(index), ""remain: "", str(remain))
    # base case:
    if remain == 0:
        return 0

    if make(index, remain) in dp:
        return dp[make(index, remain)]

    min_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)
    print(""min_cost: "", str(min_cost))
    for i in range(len(offers)):
        cost = 0
        if offers[i][0] <= remain:
            free = offers[i][1]
            for  j in range(index + free, index + offers[i][0]):
                cost += arr[j]
            cost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])
            min_cost = min(min_cost, cost)
        else:
            break
    dp[make(index, remain)] = min_cost
    return min_cost



# main starts
n, m, k = list(map(int, stdin.readline().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
arr = list(map(int, stdin.readline().split()))
arr.sort()
print(""arr: "", str(arr))
offers = defaultdict(list)
for _ in range(m):
    x, y = list(map(int, stdin.readline().split()))
    print(""x: "", str(x), ""y: "", str(y))
    offers[x].append(y)

offers = process_offer(offers)
dp = dict()
print(brute(arr, dp, offers, 0, k))
</ans>",0,{}
1,"<ans>
def PrimeDecomp(N,ConcFlag):
    if ConcFlag:
        if N<=1:
            return [1],1
        else:
            I = 2
            PrimeDec = []
            DivCount = 1
            while I*I<=N:
                Cnt = 0
                while N%I==0:
                    N //= I
                    PrimeDec.append(I)
                    print(""PrimeDec: "", str(PrimeDec))
                DivCount *= (Cnt+1)
                I += 1
            if N>=2:
                PrimeDec.append(N)
                print(""PrimeDec: "", str(PrimeDec))
                DivCount *= 2
            return PrimeDec,DivCount        
    else:
        if N<=1:
            return [1],[1],1
        else:
            I = 2
            PrimeDec = []
            PrimeCnt = []
            DivCount = 1
            while I*I<=N:
                Cnt = 0
                while N%I==0:
                    N //= I
                    Cnt += 1
                if Cnt>=1:
                    PrimeDec.append(I)
                    PrimeCnt.append(Cnt)
                    print(""PrimeDec: "", str(PrimeDec))
                    print(""PrimeCnt: "", str(PrimeCnt))
                    DivCount *= (Cnt+1)
                I += 1
            if N>=2:
                PrimeDec.append(N)
                PrimeCnt.append(1)
                print(""PrimeDec: "", str(PrimeDec))
                print(""PrimeCnt: "", str(PrimeCnt))
                DivCount *= 2
            return PrimeDec,PrimeCnt,DivCount

def DivisorFactorial(N,FactDec,FactCnt,MemoFlag,Mod,ModFlag):
    if MemoFlag:
        if N<=1:
            FDivCnt = 1
            return FactDec,FactCnt,FDivCnt
        else:
            PrimeDec,PrimeCnt,_ = PrimeDecomp(N,False)
            for TP in range(0,len(PrimeDec)):
                if PrimeDec[TP] in set(FactDec):
                    FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                else:
                    FactDec.append(PrimeDec[TP])
                    FactCnt.append(PrimeCnt[TP])
            FDivCnt = 1
            for TF in FactCnt:
                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,FDivCnt
    else:
        if N<=1:
            FDivCnt = 1
            return FactDec,FactCnt,FDivCnt
        else:
            for TN in range(2,N+1): 
                PrimeDec,PrimeCnt,_ = PrimeDecomp(TN,False)
                for TP in range(0,len(PrimeDec)):
                    if PrimeDec[TP] in set(FactDec):
                        FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
                    else:
                        FactDec.append(PrimeDec[TP])
                        FactCnt.append(PrimeCnt[TP])
            FDivCnt = 1
            for TF in FactCnt:
                FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,FDivCnt
FactDec,FactCnt,FDivCnt = DivisorFactorial(int(input()),[],[],False,10**9+7,True)
print(FDivCnt)
</ans>",0,{}
2,"<ans>
from math import sqrt,gcd


def gen_primes():
    """""" Generate an infinite sequence of prime numbers.
    """"""
    #
    D = {}
    print(""D: "", str(D))

    # The running integer that's checked for primeness
    q = 2
    print(""q: "", str(q))

    while True:
        if q not in D:
            # q is a new prime.
            # Yield it and mark its first multiple that isn't
            # already marked in previous iterations
            #
            yield q
            D[q * q] = [q]
            print(""D: "", str(D))
        else:
            # q is composite. D[q] is the list of primes that
            # divide it. Since we've reached q, we no longer
            # need it in the map, but we'll mark the next
            # multiples of its witnesses to prepare for larger
            # numbers
            #
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
            del D[q]
            print(""D: "", str(D))

        q += 1
        print(""q: "", str(q))


def is_prime(n):
    if n<=1:
        return False
    if n == 2:
        return True
    if n % 2 ==0:
        return False
    return all(n%i for i in range(3,int(sqrt(n))+1)


def calculate_colors(n):
    primes = gen_primes()
    print(""primes: "", str(primes))
    sqr_n = int(sqrt(n)) + 1
    print(""sqr_n: "", str(sqr_n))
    if n == 1:
        return 1
    for p in primes:
        if n % p == 0:
            while n % p == 0:
                g= gcd(p,n)
                n = int(n//g)
            if n > 1:
                return 1
            else:
                return p
        if p > sqr_n:
            return n



n = int(input())
print(calculate_colors(n))
</ans>",0,{}
3,"<ans>
import numpy as np
print(""mod: "", str(mod))

def poly_mul(f, g):
    # 参考: https://judge.yosupo.jp/submission/2380
    Lf = len(f); Lg = len(g); L = Lf + Lg - 1
    if Lf <= 16 or Lg <= 16:
        if Lf == 0 or Lg == 0:
            return np.zeros((0,), dtype=np.int64)
        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)
    fft = np.fft.rfft; ifft = np.fft.irfft
    fft_len = 1 << L.bit_length()
    fl = f & (1 << 15) - 1; fh = f >> 15
    gl = g & (1 << 15) - 1; gh = g >> 15
    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod
    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
    return (x + ((y - x - z) << 15) + (z << 30)) % mod

def poly_inv(fps, n=None):
    assert fps[0] != 0
    if n is None:
        n = len(fps)
    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)
    res[0] = pow(int(fps[0]), mod-2, mod)
    i = 1
    while i < n:
        i <<= 1
        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod
    return res[:n]

def poly_div(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    if n1 < n2:
        return np.zeros((0,), dtype=np.int64)
    n = n1 - n2 + 1
    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]
    return res

def poly_mod(fps1, fps2):
    n1, n2 = len(fps1), len(fps2)
    if n1 < n2:
        return fps1
    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]
    return res % mod

def multipoint_evaluation(fps, xs):
    threshold = 8
    n_xs = len(xs)
    bit = (n_xs-1).bit_length()
    if bit <= threshold:
        res = np.zeros_like(xs)
        xs_cumprod = np.ones_like(xs)
        for coef in fps:
            res += xs_cumprod * coef
            xs_cumprod *= xs
            xs_cumprod %= mod
        return res
    k = 1<<bit
    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)
    fpss[0, :n_xs] = -xs % mod
    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod
    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod
    for i in range(1, bit):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+step] = f[:-1]
    f = poly_mod(fps, f)
    fpss[-1, :len(f)] = f
    fpss[-1, len(f):] = 0
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, k, step):
            f = fpss[i+1, j:j+step]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss[i, j:j+half] = poly_mod(f, f1)
            fpss[i, j+half:j+step] = poly_mod(f, f2)
    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)
    xs_cumprod = np.ones_like(xs)
    res = np.zeros_like(xs)
    for i in range(1<<threshold):
        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    return res.reshape(-1)[:n_xs] % mod

def poly_differential(fps):
    return fps[1:] * np.arange(1, len(fps)) % mod

def lagrange_interpolation(X, Y, mod):
    # old
    n = len(X)
    g = [0]*(n+1)
    g[0] = 1
    for i, x in enumerate(X):
        for j in range(i, -1, -1):
            g[j+1] += g[j] * (-x) % mod
    res = [0]*n
    for x, y in zip(X, Y):
        f = g[:]
        denom = 0
        v = 1
        pow_x = [1]  # x の idx 乗
        for _ in range(n-1):
            v = v * x % mod
            pow_x.append(v)
        pow_x.reverse()  # n-1 乗 ~ 0 乗
        for i, po in enumerate(pow_x):
            f_i = f[i]
            f[i+1] += f_i * x % mod  # f = g / (x - x_i) を組立除法で求める
            denom = (denom + f_i * po) % mod
        denom_inv = pow(denom, mod-2, mod)
        for i, f_i in enumerate(f[:n]):
            res[i] += (f_i * y * denom_inv)# % mod  # mod が大きいと 64bit に収まらなくなるのでひとつずつ mod 取った方がいいか？
    return [v % mod for v in res]

def polynomial_interpolation(xs, ys):
    # 参考: https://rsk0315.hatenablog.com/entry/2020/04/05/203210
    assert len(xs) == len(ys)
    threshold = 8
    as_strided = np.lib.stride_tricks.as_strided
    n = len(xs)
    if n==1:
        return ys.copy()
    bit = (n-1).bit_length()
    if bit <= threshold:
        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)
        return np.array(res[::-1], dtype=np.int64)
    k = 1<<bit
    fpss = np.zeros((bit+1, n+1), dtype=np.int64)
    fpss[0, :n] = -xs % mod
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, n, step):
            if j+half >= n:
                fpss[i+1, j:n] = fpss[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            f = poly_mul(f1, f2)
            fpss[i+1, j:j+len(f)-1] = f[:-1]
    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)
    fpss2[bit, :n] = poly_differential(f)
    for i in range(bit-1, threshold-1, -1):
        step = 2<<i
        half = step>>1
        for j in range(0, n, step):
            if j+half >= n:
                fpss2[i, j:n] = fpss2[i+1, j:n]
                continue
            f = fpss2[i+1, j:min(j+step, n)]
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:min(j+step, n)+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i, j:j+half] = poly_mod(f, f1)
            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)
    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))
    xs_cumprod = np.ones_like(xs)
    f = np.zeros_like(xs)
    for i in range(1<<threshold):
        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
        xs_cumprod *= xs
        xs_cumprod %= mod
    f = f.ravel()
    for j in range(n):
        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod
    for i in range(bit):
        step = 2 << i
        half = step >> 1
        for j in range(0, k, step):
            if j+half >= n:
                fpss2[i+1, j:n] = fpss2[i, j:n]
                continue
            f1 = fpss[i, j:j+half+1].copy()
            f2 = fpss[i, j+half:j+step+1].copy()
            f1[-1] = f2[-1] = 1
            fpss2[i+1, j:min(j+step, n)] = (
                poly_mul(fpss2[i, j:j+half], f2)
                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)
            ) % mod
    return fpss2[bit, :n]

mod = int(input())
print(""mod: "", str(mod))
A = np.array(input().split(), dtype=np.int64)
print(""A: "", str(A))
X = np.arange(mod, dtype=np.int64)
print(""X: "", str(X))
Ans = polynomial_interpolation(X, A)
print(""Ans: "", str(Ans))
print(("" "".join(map(str, Ans.tolist())))
</ans>",0,{}
4,"<ans>
import math
from collections import defaultdict
import sys
#input = sys.stdin.readline

def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    k = list(map(int, input().split()))
    print(""k: "", str(k))
    sales = [(0, 0)] * m
    print(""sales: "", str(sales))
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        sales[i] = (b, a)

    def check(days):
        last_sale = {}
        for sale in sales:
            if sale[1] <= days:
                if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:
                    last_sale[sale[0]] = sale[1]
        print(""last_sale: "", str(last_sale))

        date_last_sales = {}
        for t, d in list(last_sale.items()):
            if d not in date_last_sales:
                date_last_sales[d] = [t]
            else:
                date_last_sales[d].append(t)
        print(""date_last_sales: "", str(date_last_sales))

        balance = 0
        required = [0] + k.copy()
        print(""balance: "", str(balance), ""required: "", str(required))

        end = 0
        for d in range(1, days+1):
            balance += 1
            if d in date_last_sales:
                for t in date_last_sales[d]:
                    if required[t] > 0:
                        if required[t] > balance:
                            end += required[t] - balance
                        balance -= min(required[t], balance)
                        required[t] = 0
            if d == days:  # last day
                for r in required:
                    if r > 0:
                        end += r
        print(""end: "", str(end))

        return 2*end <= balance

    total = sum(k)
    hi = 2*total
    lo = 1
    print(""total: "", str(total), ""hi: "", str(hi), ""lo: "", str(lo))

    while lo + 1 < hi:
        mid = (lo + hi) // 2
        if check(mid):
            hi = mid
        else:
            lo = mid

    if check(lo):
        print(lo)
    else:
        print(hi)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
5,"<ans>
import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]
print(""EDGE: "", str(EDGE))

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

REDG=[None for i in range(N+1)]
print(""REDG: "", str(REDG))
QUE=deque([1])
print(""QUE: "", str(QUE))
check=[0]*(N+1)
print(""check: "", str(check))
DEPTH=[None]*(N+1)
print(""DEPTH: "", str(DEPTH))
i=0
while QUE:
    NQUE=deque()
    i+=1
    
    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE

LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))
print(""LEAF: "", str(LEAF))

QUE=LEAF
heapq.heapify(QUE)
print(""QUE: "", str(QUE))
ANS=0

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]=1
    check[REDG[x]]=2   
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

print(""ANS: "", str(ANS))
</ans>",0,{}
6,"<ans>
class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        print(""_parent: "", str(self._parent), ""_size: "", str(self._size)

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

    def calc_group_num(self):
        N = len(self._parent)
        ans = 0
        for i in range(N):
            if self.find_root(i) == i:
                ans += 1
        return ans

import sys

input=sys.stdin.readline

n,m=list(map(int,input().split()))
t=list(map(int,input().split()))
t=[t[i]-1 for i in range(n)]
query=[]
for i in range(m-1):
    a,b=list(map(int,input().split()))
    query.append((a-1,b-1))

tower=[[] for i in range(m)]
for i in range(n):
    id=t[i]
    if not tower[id]:
        tower[id].append((i+1,i+1))
    else:
        start,end=tower[id].pop()
        if end+1==i+1:
            tower[id].append((start,i+1))
        else:
            tower[id].append((start,end))
            tower[id].append((i+1,i+1))

print(""tower: "", str(tower))
test=[]
for i in range(m):
    for start,end in tower[i]:
        if end!=n:
            test.append((t[start-1],t[end]))

print(""test: "", str(test))
start=[-1]*len(test)
end=[m-1]*len(test)
temp=[[] for i in range(m)]
for i in range(len(test)):
    T=(end[i]+start[i])//2
    temp[T].append(i)


def parabisect():
    uf=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=query[i]
        uf.unite(a,b)
        while temp[i]:
            j=temp[i].pop()
            id1,id2=test[j]
            if uf.is_same_group(id1,id2):
                end[j]=i
            else:
                start[j]=i
            if end[j]-start[j]>1:
                T=(end[j]+start[j])//2
                temp[T].append(j)

for i in range(20):
    parabisect()

res=[0]*m
for i in range(len(test)):
    res[end[i]+1]-=1

for i in range(1,m):
    res[i]+=res[i-1]

for i in range(m):
    print(len(test)+res[i])
</ans>",0,{}
7,"<ans>
inc = {
    # chr(97+i):0 for i in range(26)
}
print(""inc: "", str(inc))

l = [None for i in range(n*m)]
print(""l: "", str(l))

for i in range(n):
    t = int(input())
    print(""t: "", str(t))
    for j in range(m):
        ipt = input()
        print(""ipt: "", str(ipt))
        l[t*m+j] = ipt
        print(""l: "", str(l))
        if len(inc)==26:continue
        for q in ipt:
            inc.setdefault(q, 0)
        print(""inc: "", str(inc))

d = {}
print(""d: "", str(d))

def ae(u, v):
    t = d.setdefault(u, set())
    if v not in t:
        t.add(v)
        inc[v] = inc.get(v, 0) + 1
    print(""d: "", str(d))
    print(""inc: "", str(inc))

for p, i in enumerate(l[1:]):
    for j in range(min(len(l[p]), len(i))):
        if l[p][j] != i[j]:
            ae(i[j], l[p][j])
            break
        if len(i)-1==j and len(l[p])-1 > j:
            print(""IMPOSSIBLE"")
            return
    print(""l: "", str(l))

ans = []
dq = []
ptr = 0
ninc = {}

for k, v in inc.items():
    if v == 0:
        dq.append(k)
    else:
        ninc[k] = v
print(""dq: "", str(dq))
print(""ninc: "", str(ninc))

inc = ninc
print(""inc: "", str(inc))

while ptr != len(dq):
    fst = dq[ptr]
    ans.append(fst)
    print(""ans: "", str(ans))

    for i in d.get(fst, []):
        inc[i] -= 1
        if inc[i] == 0:
            dq.append(i)
            inc.pop(i)
    print(""inc: "", str(inc))
    print(""dq: "", str(dq))
    ptr += 1

if len(inc):
    print(""IMPOSSIBLE"")
    return

print(*reversed(ans), sep='')
</ans>",0,{}
8,"<ans>
t = ii()
print(""t: "", str(t))
for _ in range(t):
    r, g, b = sorted(mi())
    print(""r: "", str(r), ""g: "", str(g), ""b: "", str(b))
    if b > r + g + 1:
        print('No')
    else:
        print('Yes')
</ans>",0,{}
9,"<ans>
class Art:
    """""" Art representation """"""

    def __init__(self, args):
        """""" Default constructor """"""
        print(""numa: "", str(args[0]), ""numb: "", str(args[1]))

        self.numa, self.numb = args

        self.r = self.rect(self.numa[0], self.numb[0])
        self.rmax = self.rect(self.numa[1], self.numb[1])
        self.rmin = self.rect(self.numa[2], self.numb[2])
        if self.rmax[0] < self.rmax[1]:
            self.rmax, self.rmin = self.rmin, self.rmax

        self.remain = []
        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))
        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))

        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))
        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))

    def calculate(self):
        """""" Main calcualtion function of the class """"""
        print(""r: "", str(self.r), ""rmax: "", str(self.rmax), ""rmin: "", str(self.rmin), ""remain: "", str(self.remain))

        for rec in self.remain:
            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:
                return ""YES""
            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:
                return ""YES""
        return ""NO""
</ans>",0,{}
10,"<ans>
import sys
from collections import defaultdict
 
class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * n
        print(""n: "", str(n)
    
    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        result = 0
        while r > 0:
            result += self.tree[r-1]
            r &= (r - 1)
        return result
    
    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)
    
    def add(self, i, value=1):
        while i < self.n:
            self.tree[i] += value
            i |= (i + 1)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
swaps = []
for _ in range(n):
    i, j = list(map(int, input().split()))
    print(""i: "", str(i), ""j: "", str(j))
    swaps.append(i)
    swaps.append(j)

pos = defaultdict(list)
for i, val in enumerate(swaps):
    pos[val].append(i)

c = 0
prev = -1
compr = [0] * (2*n)
decompr = {}
for val in sorted(swaps):
    if prev == val: continue
    for j in pos[val]:
        compr[j] = c
    decompr[c] = val
    c += 1
    prev = val

arr = list(range(c))
for t in range(n):
    i, j = compr[t<<1], compr[t<<1|1]
    arr[i], arr[j] = arr[j], arr[i]

bit = BIT(c)
total_inv = 0
for i, val in enumerate(arr):
    total_inv += bit.get_sum(val+1, c)
    if i != val:
        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)
    bit.add(val)
print(total_inv)
</ans>",0,{}
11,"<ans>
def mysqrt(x):
    print(""x: "", str(x))
    if x <= 0:
        return 0
    return sqrt(x)

def good(R):
    print(""R: "", str(R))
    nonlocal xs
    nonlocal ys
    nonlocal n
    
    left = -10**20
    right = 10**20
    
    for i in range(n):
        # (x - xi)**2 + (y - yi)**2 = R**2
        # y = R
        xi = xs[i]
        yi = abs(ys[i])
        
        D = 2 * R * yi - yi**2
        
        if D + eps < 0:
            return False
        
        sD = mysqrt(D)
        
        new_left = xi - sD
        new_right = xi + sD
        
        left = max(left, new_left)
        right = min(right, new_right)
        
        if left + eps > right:
            return False
    
    return True

def solve(lower, high, md):
    print(""lower: "", str(lower), ""high: "", str(high))
    R = 0
    for _ in range(150):
        R = md(lower, high)
        
        if good(R):
            high = R
        else:
            lower = R
        
    return R

n = int(input())

xs = [0.0 for _ in range(n)]
ys = [0.0 for _ in range(n)]

for i in range(n):
    xs[i], ys[i] = list(map(float, input().split()))
    if i > 0:
        if ys[i] * ys[0] < 0:
            print(-1)
            return

R = None
if good(1):
    R = solve(0, 1, lambda x, y: (x + y) / 2)
else:
    R = solve(1, 1e16, lambda x, y: sqrt(x * y))

print('{:.16}'.format(R))
</ans>",0,{}
12,"<ans>
def bin_pow(num, degree , module):
    if degree == 0:
        return 1
    if degree == 1:
        return num % module

    if degree % 2 == 0:
        val = bin_pow(num, degree // 2, module)
        return (val * val) % module
    
    return (num * bin_pow(num , degree - 1, module)) % module

print(""x: "", str(x), ""y: "", str(y))

if y % x != 0:
    print(0)
    return

y //= x

divs = set()
to_gen = []

num = 2
val = y

while num * num <= val:
    degree = 0
    while y % num == 0:
        degree+=1
        y //= num
    if degree != 0:
        to_gen.append((num, degree))

    if num == 2:
        num += 1
    else:
        num += 2

if y != 1:
    to_gen.append((y, 1))

    
to_gen_len = len(to_gen)

def generate(ind):
    if ind == to_gen_len:
        yield 1
        return 
    gen_val = to_gen[ind][0]
    
    for deg in range(1 + to_gen[ind][1]):
        for each in generate(ind  + 1):
            yield gen_val**deg * each

for each in generate(0):
    divs.add(each)

divs = list(divs)
divs.sort()
divs_answers = {}
mod = 10**9 + 7
ans = bin_pow(2, val - 1, mod)

for el in divs:
    if el == 1:
        divs_answers[el] = 1
        ans -= 1
    else:
        curr_val = bin_pow(2, el - 1 ,mod)
        for other_el in divs:
            if other_el >= el:
                break
            if el % other_el !=0:
                continue
            
            curr_val -= divs_answers[other_el]

        divs_answers[el] = curr_val % mod
        ans -= curr_val

print(""divs_answers[val]: "", str(divs_answers[val]))
</ans>",0,{}
13,"<ans>
def main():
    n = int(input())
    print(""n: "", str(n))
    p = list(map(int, input().split()))
    print(""p: "", str(p))
    idx = [0] * n
    print(""idx: "", str(idx))
    for i in range(0, n):
        idx[i] = i
    print(""idx: "", str(idx))
    idx.sort(key=lambda i: - p[i])
    print(""idx: "", str(idx))
    t = BTree()
    print(""t: "", str(t))
    t.insert(-1)
    t.insert(n)
    ans = 0
    print(""ans: "", str(ans))
    for i in idx:
        print(""i: "", str(i))
        nex = t.search_higher(i)
        print(""nex: "", str(nex))
        nexnex = t.search_higher(nex)
        print(""nexnex: "", str(nexnex))
        pre = t.search_lower(i)
        print(""pre: "", str(pre))
        prepre = t.search_lower(pre)
        print(""prepre: "", str(prepre))
        if prepre != None:
            ans += p[i] * (pre - prepre) * (nex - i)
        if nexnex != None:
            ans += p[i] * (i - pre) * (nexnex - nex)
        t.insert(i)
    print(""ans: "", str(ans))


main()
</ans>",0,{}
14,"<ans>
k = 72
print(""k: "", str(k))
K = 1<<k
print(""K: "", str(K)
nu = lambda L: int("""".join([bin(K+a)[-k:] for a in L[::-1]]), 2)
print(""nu: "", str(nu))
st = lambda n: bin(n)[2:] + ""0""
print(""st: "", str(st))
li = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]
print(""li: "", str(li))

def grow(d, v, h):
    h += [0] * d
    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]
    print(""f: "", str(f))
    
    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):
        t = [1] * (2*d+2)
        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P
        ti = [1] * (2*d+2)
        ti[-1] = pow(t[-1], P-2, P)
        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P
        
        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]
        fg = li(st(nu(f) * nu(g)), d * 2 + 2)
        print(""fg: "", str(fg))
            
        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
    print(""h: "", str(h))
    return h

def create_table(v):
    s = 1
    X = [1, v+1]
    while s < v:
        X = grow(s, v, X)
        s *= 2
    table = [1]
    for x in X:
        table.append(table[-1] * x % P)
    return table

def fact(i, table):
    a = table[i//v]
    for j in range(i//v*v+1, i+1):
        a = a * j % P
    return a

P = 10**9+7
v = 1 << 11
fa = [1] * (2*v+2)
fainv = [1] * (2*v+2)
for i in range(2*v+1):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(2*v+1)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

T = create_table(v)

f = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P
r1, c1, r2, c2 = list(map(int, input().split()))
print(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))
</ans>",0,{}
15,"<ans>
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n
        print(""parent: "", str(self.parent))
        print(""size: "", str(self.size))
        print(""num_sets: "", str(self.num_sets)

    def find(self, a):
        to_update = []

        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]

        for b in to_update:
            self.parent[b] = a

        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)

        if a == b:
            return

        if self.size[a] < self.size[b]:
            a, b = b, a

        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]

    def set_size(self, a):
        return self.size[self.find(a)]


def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n, m = read_int_array()
    uf = UnionFind(n)
    for _ in range(m):
        nums = read_int_array()
        sz = nums[0]
        leader = None
        for i in range(sz):
            p = nums[1 + i] - 1
            if leader is None:
                leader = p
            else:
                uf.merge(p, leader)

    ans = [uf.set_size(i) for i in range(n)]
    write(*ans)

main()
</ans>",0,{}
16,"<ans>
class Sponge:
    """""" Sponge representation """"""

    def __init__(self, test_inputs=None):
        """""" Default constructor """"""
        print(""test_inputs: "", str(test_inputs)
        it = iter(test_inputs.split(""\n"")) if test_inputs else None

        def uinput():
            return next(it) if it else sys.stdin.readline().rstrip()

        # Reading single elements
        [self.n, self.m] = list(map(int, uinput().split()))
        print(""n: "", str(self.n), ""m: "", str(self.m))

        # Reading a single line of multiple elements
        self.numf = list(map(int, uinput().split()))
        print(""numf: "", str(self.numf))

        # Reading a single line of multiple elements
        self.numb = list(map(int, uinput().split()))
        print(""numb: "", str(self.numb))

        self.fd = {}
        self.fdn = {}
        for (i, n) in enumerate(self.numf):
            self.fd[n] = self.fd.setdefault(n, 0) + 1
            self.fdn[n] = i + 1
        print(""fd: "", str(self.fd), ""fdn: "", str(self.fdn))

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        result = []
        for n in self.numb:
            if n not in self.fd:
                return ""Impossible""
            result.append(self.fdn[n])
        for n in self.numb:
            if self.fd[n] > 1:
                return ""Ambiguity""

        return ""Possible\n"" + "" "".join(map(str, result))
</ans>",0,{}
17,"<ans>
n=input().split()
print(""n: "", str(n))
r=int(n[0])
print(""r: "", str(r))
k=int(n[1])
print(""k: "", str(k))
l=[]
for i in range(r):
    li=input()
    print(""li: "", str(li))
    l.append(li)
rl=[]
for i in range(r):
    x=[]
    for j in range(r):
        x.append(0)
    rl.append(x)
for i in range(r):
    for j in range(len(l[i])):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[i][j+q:j+q+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[i][j+q]=rl[i][j+q]+1
            if flag==1:
                j=q+1
for i in range(r):
    for j in range(r):
        flag=0
        f=0
        if j+k<=r:
            for q in range(k):
                if l[j+q][i:i+1]=='.':
                    continue
                else:
                    flag=1
                    break
            if flag==0:
                for q in range(k):
                    rl[j+q][i]=rl[j+q][i]+1
            if flag==1:
                j=q+1
maxi=0
maxj=0
m=0
for i in range(r):
    for j in range(r):
        if rl[i][j]>m:
            m=rl[i][j]
            maxi=i
            maxj=j
print(maxi+1,maxj+1)
</ans>",0,{}
18,"<ans>
n,x = parse_int()
print(""n: "", str(n), ""x: "", str(x)
st = [0]*100500
print(""st: "", str(st))
xored = [0]*100500
print(""xored: "", str(xored))
for _ in range(n): st[int_reader.get()] += 1
for idx in range(100500):
    pair = idx^x
    if pair < 100500:
        xored[pair] = st[idx]
print(""pair: "", str(pair))
print(""idx: "", str(idx))
print(""st: "", str(st))
print(""xored: "", str(xored))
ans = 0
print(""ans: "", str(ans))
for idx in range(100500):
    ans += st[idx]*xored[idx]
print(""idx: "", str(idx))
print(""ans: "", str(ans))
if x == 0: ans -= n
print(""x: "", str(x))
print(""ans: "", str(ans))
print(ans//2)
</ans>",0,{}
19,"<ans>
def VI(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
def ELIST(n): return [[] for i in range(n)]
def MI(n=None,m=None): # input matrix of integers
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = VI()
    return arr
def MS(n=None,m=None): # input matrix of strings
    if n is None: n,m = VI()
    arr = LIST(n)
    for i in range(n): arr[i] = input()
    return arr
def MIT(n=None,m=None): # input transposed matrix/array of integers
    if n is None: n,m = VI()
    a = MI(n,m)
    arr = LIST(m,n)
    for i,l in enumerate(a):
        for j,x in enumerate(l):
            arr[j][i] = x
    return arr

def run(n,a):
    for i in range(n+1):
        if a[0]==0:
            if sum([i==a[i] for i in range(n)])==n:
                print(""Yes"")
            else:
                print(""No"")
            return
        for j in range(n):
            if j%2==0:
                a[j] = (a[j]+1)%n
            else:
                a[j] = (a[j]-1)%n

def main(info=0):
    n = I()
    print(""n: "", str(n))
    a = VI()
    print(""a: "", str(a))
    run(n,a)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
20,"<ans>
def getIntList():
    return list(map(int, input().split()))    

def e_gcd(a, b ):
    if a==0 and b==0:
        return -1, 0, 0
    if b==0:
        return a, 1,0
    d, y,x = e_gcd(b, a%b )
    y-=  a //b *x
    return d , x,y

def m_reverse(a,n):
    d,x,y = e_gcd(a,n)
    print(""d: "", str(d), ""x: "", str(x), ""y: "", str(y), ""a: "", str(a), ""n: "", str(n))
    assert x*a + y*n == d
    if d==1:
        if x%n<=0:
           return x%n+n
        else:
            return x%n
    else:
        return -1

base = 998244353
d = 1233
t = m_reverse( d, base)
print(""t: "", str(t))
z = t * d % base
print(""z: "", str(z))
N, M, K= getIntList()

J = N-1 - K   # same
Z = N - J
print(""Z: "", str(Z))
R = M
for i in range(Z-1):
    R *= M-1
    R%= base
print(""R: "", str(R))
n0 = J
m0 = Z
print(""n0: "", str(n0), ""m0: "", str(m0))
for i in range(m0 -1):
    g = n0 + m0 -1  -i
    R*= g
    R%= base

for i in range(2, m0):
    t = m_reverse(i,base)
    R*=t
    R%=base

print(R)
</ans>",0,{}
21,"<ans>
import math
import bisect
import itertools
import sys
mod=10**9 +7
def mindiff(a):
    b=a[:]
    print(""b: "", str(b))
    b.sort()
    print(""b: "", str(b))
    m=10000000000
    for i in range(len(b)-1):
        if b[i+1]-b[i]<m:
            m=b[i+1]-b[i]
    return m
    
def lcm(a,b):
    return a*b//math.gcd(a,b)

    
def merge(a,b):
    i=0;j=0
    c=0
    ans=[]
    while i<len(a) and j<len(b):
        if a[i]<b[j]:
            ans.append(a[i])
            i+=1
        else:
            ans.append(b[j])
            c+=len(a)-i
            j+=1
    ans+=a[i:]
    ans+=b[j:]
    return ans,c
def mergesort(a):
    if len(a)==1:
        return a,0
    mid=len(a)//2   
    left,left_inversion=mergesort(a[:mid])
    right,right_inversion=mergesort(a[mid:])
    m,c=merge(left,right)
    c+=(left_inversion+right_inversion)
    return m,c
    
def is_prime(num):
    if num == 1: return False
    if num == 2: return True
    if num == 3: return True
    if num%2 == 0: return False
    if num%3 == 0: return False
    t = 5
    a = 2
    while t <= int(math.sqrt(num)):
        if num%t == 0: return False
        t += a
        a = 6 - a
    return True
    
  
def ceil(a,b):
    if a%b==0:
        return a//b
    else:
        return (a//b + 1)

def binsearch(arr,b,low,high):
    if low==high:
        return low
    if arr[math.ceil((low+high)/2)]<b:
        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )
    else:
        return binsearch(arr,b,math.ceil((low+high)/2),high)
def ncr1(n,r):
    s=1
    for i in range(min(n-r,r)):
        s*=(n-i)
        s%=mod
        s*=pow(i+1,mod-2,mod)
        s%=mod
    return s
    
def calc(n,m,r):
    s=0
    for i in range(0,r+1,2):
        s+=ncr1(n,i)*ncr1(m,i)
        s%=mod
    return s    
    
def modu(a,n):
    if a%n==0:
        return n
    return a%n

#/////////////////////////////////////////////////////////////////////////////////////////////////

for i in range(1):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    s=input()
    c=1;b=[]
    for i in range(1,n):
        if s[i-1]==s[i]:
            c+=1
            f=True
        else:
            b.append(c)
            c=1
            f=False
    if True:
        b.append(c)
    print(""b: "", str(b))
    ans=0
    su=0
    for i in b:
        c=a[su:min(su+i,10**9)]
        print(""c: "", str(c))
        c.sort(reverse=True)
        print(""c: "", str(c))
        c=c[:min(i,k)]
        su+=i
        ans+=sum(c)
        
    print(ans)
</ans>",0,{}
22,"<ans>
def solve(printing):

    n = int(input())
    nums = [int(st)-1 for st in input().split("" "")]
    print(""nums: "", str(nums))
    numdupe = [0] * n
    dupeindex = []
    dupeindexindv = {}
    missing = []

    if printing:
        print(""nums""); print(nums)

    for i in range(n):
        numdupe[nums[i]] += 1

    for i in range(n):
        if numdupe[i] == 0:
            missing.append(i)
            
        if numdupe[nums[i]] >= 2:
            dupeindex.append(i)
            if nums[i] in dupeindexindv:
                dupeindexindv[nums[i]][1].append(i)
            else:
                dupeindexindv[nums[i]] = [0, [i], False]
                # left location, dupe indexs, if already located original

    for num in dupeindexindv:
        dupeindexindv[num][0] = len(dupeindexindv[num][1])

    if printing:
        print(""missing""); print(missing)
        print(""dupeindexindv""); print(dupeindexindv)

    misslen = len(missing)
    misindex = 0
    #answer = 0
    for index in dupeindex:

        if misslen <= misindex:
            break

        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:
            # one spot left but original not located yet.
            # locate original.
            dupeindexindv[nums[index]][0] -= 1
            dupeindexindv[nums[index]][2] = True
        
        elif dupeindexindv[nums[index]][0] > 0:
            
            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:
                # num is smaller or original is already located.
                # locate missing number.
                dupeindexindv[nums[index]][0] -= 1
                nums[index] = missing[misindex]
                misindex += 1
                #answer += 1

            else: # locate original
                dupeindexindv[nums[index]][0] -= 1
                dupeindexindv[nums[index]][2] = True

    print(misslen)
    for num in nums:
        print(num+1, end = "" "")

solve(False)
</ans>",0,{}
23,"<ans>
def main():
 try:
  n,Q=In()
  print(""n: "", str(n), ""Q: "", str(Q))
  l=list(In())
  print(""l: "", str(l))
  l.sort()
  print(""l: "", str(l))
  pre=[0]
  print(""pre: "", str(pre))
  su=0
  for x in range(n):
   su+=l[x]
   pre.append(su)
  print(""su: "", str(su), ""pre: "", str(pre))
  for x in range(Q):
   q=I()
   print(""q: "", str(q))
   q*=2
   print(""q: "", str(q))
   pos=find_ge(l,q)
   print(""pos: "", str(pos))
   if pos==-1:
    print(0)
   else:
    print(""pos: "", str(pos))
    ans=pre[-1]-pre[pos]
    print(""ans: "", str(ans))
    print(ans)
 except:
  pass
</ans>",0,{}
24,"<ans>
def gcd(l):
	if len(l)==0:
		return 0
	if len(l)==1:
		return l[0]
	if len(l)==2:                                   
		if l[1]==0:
			return l[0]  
		return gcd([l[1],l[0]%l[1]])
	return gcd([gcd(l[:-1]),l[-1]])
	print(""l: "", str(l))

def brute_force(l1,l2,l,sol):                   
	if len(l)==0:
		g1=gcd(l1)
		g2=gcd(l2)
		return g1==1 and g2==1,sol
	print(""l1: "", str(l1), ""l2: "", str(l2), ""sol: "", str(sol))
	
	res,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])
	if res:
		return True,s
	return brute_force(l1,l2+[l[0]],l[1:],sol+[2])

def factor(n):
	res=[]
	i=2
	while i*i<=n:
		if n%i==0:
			res.append(i)
		while n%i==0:
			n=int(n/i)
		i+=1
	print(""res: "", str(res))

	if n!=1:
		res.append(n)

	return res

def dumpsol(sol):
	for v in sol:
		print(v,end=' ')
	print(""sol: "", str(sol))

n=int(sys.stdin.readline())
l=sys.stdin.readline().strip().split("" "")[0:n]
l=[int(x) for x in l]
print(""n: "", str(n), ""l: "", str(l))

if n<12:
	ret,sol=brute_force([],[],l,[])
	if ret:
		print(""YES"")
		dumpsol(sol)
	else:
		print(""NO"")
	return

factors={}
for i in range(10):
	for key in factor(l[i]):
		factors[key]=0
	print(""factors: "", str(factors))

flists={}
for f in factors:
	flists[f]=[]
	pos=0
	found=False
	for v in l:
		if v%f!=0:
			found=True
			factors[f]+=1
			flists[f].append(pos)
			if (factors[f]>9):
				break
		pos+=1
	if not found:
		print(""NO"")
		return
	print(""flists: "", str(flists))

oftf=[]
isoftf={}
for f in factors:
	if factors[f]==0:
		print(""NO"")
		return
	print(""f: "", str(f), ""factors[f]: "", str(factors[f]))

	if factors[f]<10:
		oftf.append(f)
		isoftf[f]=1
	print(""oftf: "", str(oftf), ""isoftf: "", str(isoftf))

sol=[1 for i in range(len(l))]
x=l[0]
sol[0]=2
oxf=factor(x)
print(""sol: "", str(sol), ""x: "", str(x), ""oxf: "", str(oxf))

xf=[]
nxf=0
isxoftf={}
for f in oxf:
	if f in isoftf:
		nxf+=1
		isxoftf[f]=1
		xf.append(f)
	else:
		sol[flists[f][0]]=2
	print(""xf: "", str(xf), ""nxf: "", str(nxf), ""isxoftf: "", str(isxoftf))

nonxf=[]
for f in oftf:
	if not f in isxoftf:
		nonxf.append(f)
	print(""nonxf: "", str(nonxf))

masks={}
pos=0

for f in xf+nonxf:
	for v in flists[f]:
		if not v in masks:	
			masks[v]=0
		masks[v]|=1<<pos
	pos+=1
	print(""masks: "", str(masks))

vals=[{} for i in range(len(masks)+1)]
vals[0][0]=0
pos=0
mlist=[]
for mask in masks:
	mlist.append(mask)
	cmask=masks[mask]
	cmask1=cmask<<10
	for v in vals[pos]:
		vals[pos+1][v|cmask]=v
		if (mask!=0):
			vals[pos+1][v|cmask1]=v
	pos+=1
	print(""vals: "", str(vals))

test_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
for v in vals[pos]:
	if (v&test_val)==test_val:
		print(""YES"")
		while (pos!=0):
			nv=vals[pos][v]
			if (nv^v<1024 and nv^v!=0):
				sol[mlist[pos-1]]=2
			v=nv
			pos-=1
		dumpsol(sol)
		return

print(""NO"")
</ans>",0,{}
25,"<ans>
a, b, f, k = [int(i) for i in input().split()]
print(""a: "", str(a), ""b: "", str(b), ""f: "", str(f), ""k: "", str(k)

if b < f:
    print(-1)
    return

journeys = 0
previous = 0
refuels1 = 0
tank = b-f
print(""journeys: "", str(journeys), ""previous: "", str(previous), ""refuels1: "", str(refuels1), ""tank: "", str(tank))
while(journeys != k): ## necessary? while(True) ?
    if previous == 0:
        if tank >= a-f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= a-f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*(a-f):
            tank -= 2*(a-f)
        elif b >= 2*(a-f):
            refuels1 += 1
            tank = b - 2*(a-f)
        else:
            print(-1)
            return
        
        journeys += 1
        previous = a
        
    if previous == a:
        if tank >= f + a*(k-journeys-1):
            print(refuels1)
            return
        if b >= f + a*(k-journeys-1):
            print(refuels1+1)
            return
        if tank >= 2*f:
            tank -= 2*f
        elif b >= 2*f:
            refuels1 += 1
            tank = b-2*f
        else:
            print(-1)
            return
        
        journeys += 1
        previous = 0

if journeys == k:
    print(refuels1)
else:
    print(-1)
</ans>",0,{}
26,"<ans>
import heapq
n,m,k = list(map(int,input().split()))
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
connectionList = []
for _ in range(n):
    connectionList.append([])
edgeList = []
for _ in range(m):
    x,y,w = list(map(int,input().split()))
    edgeList.append((x,y,w))
    print(""x: "", str(x), ""y: "", str(y), ""w: "", str(w))
edgeList.sort(key = lambda x: x[2])
if k < m:
    maxDist = edgeList[min(m,k) - 1][2]
else:
    maxDist = sum([x[2] for x in edgeList])
colorList = {}
colorVertex = []
for i in range(n):
    colorList[i] = [i]
    colorVertex.append(i)

for i in range(min(m,k)):
    x,y,w = edgeList[i]
    connectionList[x-1].append((y-1,w))
    connectionList[y-1].append((x-1,w))
    print(""x: "", str(x), ""y: "", str(y), ""w: "", str(w))
    if colorVertex[x-1] != colorVertex[y-1]:
        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):
            prevColor = colorVertex[y-1]
            for elem in colorList[colorVertex[y-1]]:
                colorVertex[elem] = colorVertex[x-1]
                colorList[colorVertex[x-1]].append(elem)
            del colorList[prevColor]
        else:
            prevColor = colorVertex[x-1]
            for elem in colorList[colorVertex[x-1]]:
                colorVertex[elem] = colorVertex[y-1]
                colorList[colorVertex[y-1]].append(elem)
            del colorList[prevColor]

pathList = []
for key in colorList:
    vertexList = colorList[key]
    for mainVertex in vertexList:
        vertexPQueue = []
        isCovered = {}
        distanceDic = {}
        for elem in vertexList:
            isCovered[elem] = False
            distanceDic[elem] = maxDist
        isCovered[mainVertex] = True
        for elem in connectionList[mainVertex]:
            heapq.heappush(vertexPQueue,(elem[1],elem[0]))
            distanceDic[elem[0]] = elem[1]
        while vertexPQueue:
            distance, curVertex = heapq.heappop(vertexPQueue)
            if isCovered[curVertex]:
                continue
            elif distance >= maxDist:
                break
            for elem in connectionList[curVertex]:
                if distance + elem[1] < distanceDic[elem[0]]:
                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))
                    distanceDic[elem[0]] = distance + elem[1]
        for key in distanceDic:
            if distanceDic[key] <= maxDist and key > mainVertex:
                pathList.append(distanceDic[key])
        if len(pathList) > k:
            pathList.sort()
            pathList = pathList[0:k]
            if pathList[-1] < maxDist:
                maxDist = pathList[-1]
pathList.sort()
print(pathList[k-1])
</ans>",0,{}
27,"<ans>
class Ddict:
    def __init__(self):
        self.dicts={}
        print(""self.dicts: "", str(self.dicts))
    def add(self,key):
        d=self.dicts
        print(""d: "", str(d))
        for i in key:
            if i not in d:
                d[i]={}
                print(""d: "", str(d))
            d=d[i]
        d[' ']=''
        print(""d: "", str(d))
    def find(self,key):
        if key=='':
            return '',''
        d=self.dicts
        print(""d: "", str(d))
        q=[]
        h=[key[0]]
        for i in key:
            if i not in d:
                if ' ' in d and len(d)==1:
                    return ''.join(q),''.join(h)
                return '',''
            q.append(i)
            if len(d)!=1:
                h=q[:]
            d=d[i]
        if ' ' in d and len(d)==1:
            return ''.join(q),''.join(h)
        return '',''
        print(""q: "", str(q))
        print(""h: "", str(h))
words = Ddict()
ans=0
print(""ans: "", str(ans))
while True:
    try:
        x=input()
        print(""x: "", str(x))
        if not x:
            break
    except:
        break
    ans+=len(x)+1
    print(""ans: "", str(ans))
    ws=[[]]
    for i in x:
        if i in '.,?!\'- ':
            if ws[-1]:
                ws.append([])
        else:
            ws[-1].append(i)
    ws=list([''.join(e) for e in ws])
    for w in ws:
        next_word,helped_word = words.find(w)
        print(""next_word: "", str(next_word))
        print(""helped_word: "", str(helped_word))
        if next_word and next_word!=helped_word:
            ans-=len(next_word)-len(helped_word)-1
        words.add(w)
print(ans)
</ans>",0,{}
28,"<ans>
n = I()
print(""n: "", str(n))
ans = 0
print(""ans: "", str(ans))

def dfs(v):
    if len(v) != 0:
        if int(v) > n:
            return
    if v.count('3') and v.count('5') and v.count('7'):
        nonlocal ans
        ans += 1
    for s in ""357"":
        v += s
        dfs(v)
        v = v[:-1]
dfs("""")
print(""ans: "", str(ans))
</ans>",0,{}
29,"<ans>
def computeGCD(x, y):
    print(""x: "", str(x), ""y: "", str(y)

record = {}

for x in range(10):
    for y in range(10):
        for d in range(10):
            m = 9999
            if (x==0 or y==0) and d==0:
                record[(x,y,d)] = 0
            elif x==0 and y==0 and d!=0:
                record[(x,y,d)] = -1
            else:
                for k in range(10):
                    d_tmp = d + 10*k
                    if x==0:
                        if d_tmp%y==0:
                            record[(x,y,d)] = d_tmp//y - 1
                            break

                    elif y==0:
                        if d_tmp%x==0:
                            record[(x,y,d)] = d_tmp//x - 1
                            break

                    else:
                        for a in range((d_tmp//x)+1):
                            for b in range((d_tmp//y)+1):
                                if x*a+y*b==d_tmp and d_tmp!=0:
                                    m = min(m,a+b-1)

                if (x,y,d) not in record:
                    if m==9999:
                        m = -1
                    record[(x,y,d)] = m
            print(""x: "", str(x), ""y: "", str(y), ""d: "", str(d), ""record[(x,y,d)]: "", str(record[(x,y,d)]))

data = [[0]*10 for _ in range(10)]

len_s = len(s)
s = list(s)
freq = [0]*10
for i in range(len_s-1):
    A = s[i]
    B = s[i+1]

    d = ord(B)-ord(A)
    if d<0:
        d += 10

    freq[d] += 1

for x in range(10):
    for y in range(10):
        for d in range(10):
            if freq[d]==0:
                data[x][y] += 0
            elif record[(x,y,d)]==-1:
                data[x][y] = -10000000
            else:
                data[x][y] += freq[d]*record[(x,y,d)]

for x in range(10):
    for y in range(10):
        if data[x][y]<0:
            print(-1,end=' ')
        else:
            print(data[x][y],end=' ')
    print('',end='\n')
</ans>",0,{}
30,"<ans>
N:  3 r:  0
a:  [0, 0, 0]
b:  [0, 0, 0]
pos:  0
idx:  -1 start:  0 gain:  -50000
idx:  -1 start:  0 gain:  -50000
idx:  -1 start:  0 gain:  -50000
</ans>",0,{}
31,"<ans>
n = int(input()) * 2
print(""n: "", str(n))
A = list(map(int, input().split()))
print(""A: "", str(A))
amount = [0] * 101
print(""amount: "", str(amount))

B = []
for i in range(n):
    if amount[A[i]] < 2:
        amount[A[i]] += 1
        B += [(A[i], i)]
print(""B: "", str(B))
B.sort()
x, y = [], []
print(""x: "", str(x), ""y: "", str(y))
for i in range(len(B)):
    if(i % 2 == 0):
        x.append(B[i][1])
    else:
        y.append(B[i][1])
print(""x: "", str(x), ""y: "", str(y))
lolka = 0
aaa = 0
print(""lolka: "", str(lolka), ""aaa: "", str(aaa))
print(""len(x) * len(y): "", str(len(x) * len(y))
for i in range(n):
    if i in x:
        lolka += 1
        aaa += 1
        print(1, end = ' ')
    elif i in y:
        print(2, end = ' ')
    else:
        if len(x) - lolka + aaa < n // 2:
            print(1, end = ' ')
            aaa += 1
        else:
            print(2, end = ' ')
print()
</ans>",0,{}
32,"<ans>
def check(mid):
    ans = []
    res = 0
    for c, count in d:
        tmp = count // mid
        if (count % mid != 0):
            tmp += 1
        ans.append((c, tmp))
        res += tmp
    return res <= n, ans

a = input()
print(""a: "", str(a))
n = int(input())
print(""n: "", str(n))
d = dict()
print(""d: "", str(d))
t = 0
for i in a:
    if i not in d:
        d[i] = 1
        t += 1
    else: d[i] += 1
ans = []
res = """"
for i in d:
    ans.append(i)
    res = i
if n >= len(a):
    print(1)
    print(a, end = '')
    n -= len(a)
    for u in range(n):
        print(res, end ='')
else:
    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))
    l = 1
    r = len(a)
    res = []
    count_res = 0
    while (l <= r):
        mid = (l + r) // 2
        flag, tmp = check(mid)
        if (flag):
            r = mid - 1
            count_res = mid
            res = tmp
        else:
            l = mid + 1
        #print(l, r, tmp)
    if (len(res) == 0):
        print(-1)
    else:
        ttt = 0
        print(count_res)
        for c, sl in res:
            for j in range(sl):
                print(c, end = '')
                ttt += 1
        n -= ttt
        for i in range(n):
            print(a[0], end = '')
</ans>",0,{}
33,"<ans>
def main():
    n, = read()
    print(""n: "", str(n))
    p = read()
    print(""p: "", str(p))
    dsu = DSU()
    for i in range(n):
        a = read(0)
        print(""a: "", str(a))
        dsu.make()
        for j in range(i):
            if a[j] == ""1"":
                dsu.union(j, i)
    used = [0] * n
    print(""used: "", str(used))
    res = [0] * n
    print(""res: "", str(res))
    for i in range(n):
        if not used[i]:
            pr = dsu.find(i)
            indices = []
            elements = []
            for j in range(n):
                if dsu.find(j) == pr:
                    used[j] = 1
                    indices.append(j)
                    elements.append(p[j])
            elements.sort()
            for i,e in zip(indices, elements):
                res[i] = e
    write(res)

class DSU(object):
    def __init__(self):
        self._parent = []
        self._rank = []

    def make(self):
        i = len(self._parent)
        self._parent.append(i)
        self._rank.append(0)
        return i

    def find(self, x):
        if self._parent[x] != x:
            self._parent[x] = self.find(self._parent[x])
        return self._parent[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        if xr == yr: return
        if self._rank[xr] < self._rank[yr]:
            self._parent[xr] = yr
        elif self._rank[yr] < self._rank[xr]:
            self._parent[yr] = xr
        else:
            self._parent[yr] = xr
            self._rank[xr] += 1

def read(mode=2):
    inputs = input().strip()
    if mode == 0: return inputs
    if mode == 1: return inputs.split()
    if mode == 2: return list(map(int, inputs.split()))

def write(s=""\n""):
    if s is None: s = """"
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

write(main())
</ans>",0,{}
34,"<ans>
from math import log2, floor

def is_power2(num):
    print(""num: "", str(num))
    return num != 0 and ((num & (num - 1)) == 0)


def next_two_pow(val):
    print(""val: "", str(val))
    pw=0
    while 2**pw <= val:
        pw=+1
    return pw        

n = int(input())
print(""n: "", str(n))
arr=[int(x) for x in input().split()]
print(""arr: "", str(arr))

win_idx =-1
selected=[]

for i in range(1,n+1):
    val = arr[i-1]
    print(""i: "", str(i), ""val: "", str(val))
    if win_idx ==-1:
       if  val == -1: 
           win_idx =i
    else:
         if is_power2(i):
             selected.append(val)
             selected.sort()
         else:
             if len(selected) > 0 and val < selected[-1]:
                 selected.pop()
                 selected.append(val)
                 selected.sort()

print(""sum(selected): "", str(sum(selected)))
</ans>",0,{}
35,"<ans>
def go():
    n = int(input())
    print(""n: "", str(n))
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    e = {i: set() for i in range(n)}
    print(""e: "", str(e))
    for _ in range(n - 1):
        u, v = list(map(int, input().split()))
        print(""u: "", str(u), ""v: "", str(v))
        u, v = u - 1, v - 1
        e[u].add(v)
        e[v].add(u)
    ranks = [len(e[i]) for i in range(n)]
    print(""ranks: "", str(ranks))
    leafs = [i for i in range(n) if ranks[i] == 1]
    print(""leafs: "", str(leafs))
    index = 0
    vs = {i: {} for i in range(n)}
    print(""vs: "", str(vs))
    done = set()
    while index < len(leafs):
        cur = leafs[index]
        mysum = sum(vs[cur].values())

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        for i in e[cur] - done:
            vs[i][cur] = max(mysum, 0)
            ranks[i] -= 1
            if ranks[i] == 1:
                leafs.append(i)
        done.add(cur)
        index += 1

    sums = [0] * n
    que = [ranks.index(0)]
    print(""que: "", str(que))
    done = set()
    index = 0
    while index < len(que):
        cur = que[index]

        mysum = sum(vs[cur].values())

        if a[cur] == 0:
            mysum -= 1
        else:
            mysum += 1

        sums[cur] = mysum

        for i in e[cur] - done:
            vs[i][cur] = max(mysum - vs[cur][i], 0)
            que.append(i)

        done.add(cur)
        index += 1

    return ' '.join(map(str,sums))


# t = int(input())
for _ in range(1):
    print(go())
</ans>",0,{}
36,"<ans>
n = I()
print(""n: "", str(n))
A = readInts()
print(""A: "", str(A))
B = readInts()
print(""B: "", str(B))
ans = 0
for i in range(n):
    v = B[i]
    print(""v: "", str(v))
    nya = min(v, A[i])
    print(""nya: "", str(nya))
    A[i] -= nya
    print(""A: "", str(A))
    v -= nya
    ans += nya
    print(""ans: "", str(ans))
    nya = min(A[i+1], v)
    print(""nya: "", str(nya))
    ans += nya
    A[i+1] -= nya
    print(""A: "", str(A))
print(ans)
</ans>",0,{}
37,"<ans>
def solve(s,t):
    hash_s = [False] * 256
    hash_t = [False] * 256
    arr = []
    n = len(s)
    for c in s:
        hash_s[ord(c)] = True
    print(""hash_s: "", str(hash_s))
    for c in t:
        hash_t[ord(c)] = True
    print(""hash_t: "", str(hash_t))
    for i in range(256):
        if not hash_s[i] and hash_t[i]:
            print(-1)
            return
    rev = s[::-1]
    i,j = 0,0
    while i < len(t):
        flag = True
        temp = t[i]
        j = i + 1
        while j < len(t):
            temp += t[j]
            if temp not in s and temp not in rev:
                flag = False
                break
            j += 1
        if flag:
            x = s.find(temp)
            if x != -1:
                arr.append((x + 1,x + len(temp)))
                print('1',x + 1,x + len(temp))
            else:
                y = rev.find(temp)
                arr.append((n - y,n - y - len(temp) + 1))
                print('2',n - y,n - y - len(temp) + 1)
        else:
            x = s.find(temp[:-1])
            if x != -1:
                arr.append((x + 1,x + len(temp) - 1))
                print('3',x + 1,x + len(temp) - 1)
            else:
                x = rev.find(temp[:-1])
                arr.append((n - x,n - x - len(temp) + 2))
                print('4',n - x,n - x - len(temp) + 2)
        i = j
    print(len(arr))
    for x,y in arr:
        print(x,y)

s = input()
t = input()

solve(s,t)
</ans>",0,{}
38,"<ans>
def main():
    N = int(input())
    print(""N: "", str(N))
    # TLEs were caused mostly by slow input (1s+)
    # S = list(input() for _ in range(N))
    S = sys.stdin.read().split('\n')
    print(""S: "", str(S))
    print((solve(S)))

def get_count(args):
    s, result = args # messy input to work with map.
    print(""s: "", str(s))
    print(""result: "", str(result))
    cum_sum = 0
    for c in s:
        if c == ')':
            cum_sum -= 1
        else:
            cum_sum += 1
        result[0] = max(result[0], -cum_sum)
    result[1] = result[0] + cum_sum
    return result

# Made-up name, don't remember what to call this. Radix-ish
def silly_sort(array, value_min, value_max, get_value):
    if len(array) == 0:
        return
    cache = [None for _ in range(value_max - value_min + 1)]
    for elem in array:
        # Assume elem[0] is the value
        value = get_value(elem) - value_min
        if cache[value] is None:
            cache[value] = []
        cache[value].append(elem)
    for values in cache:
        if values is None:
            continue
        for value in values:
            yield value

def solve(S):
    counts = [[0,0] for _ in range(len(S))]
    print(""counts: "", str(counts))
    counts = list(map(get_count, list(zip(S,counts))))
    print(""counts: "", str(counts))
    first_group = []
    second_group = []
    min_first_group = float('inf')
    max_first_group = 0
    min_second_group = float('inf')
    max_second_group = 0

    for c in counts:
        if c[0] - c[1] <= 0:
            first_group.append(c)
            max_first_group = max(max_first_group, c[0])
            min_first_group = min(min_first_group, c[0])
        else:
            second_group.append(c)
            max_second_group = max(max_second_group, c[1])
            min_second_group = min(min_first_group, c[1])
    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])
    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))

    order = chain(first_group, second_group)

    cum_sum = 0
    for c in order:
        cum_sum -= c[0]
        if cum_sum < 0:
            return 'No'
        cum_sum += c[1]
    if cum_sum == 0:
        return 'Yes'
    return 'No'

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
39,"<ans>
import math
from functools import reduce
class SegmentTree():
    def __init__(self, L, function = lambda x,y: x+y):
        self.function = function
        N = self.size = len(L)
        M = 1 << N.bit_length()
        self.margin = 2*M - N
        self.L = [None for i in range(self.margin)] + L
        for i in range(M-1, 0, -1):
            x, y = self.L[i<<1], self.L[i<<1|1]
            self.L[i] = None if x is None or y is None else function(x, y)
    def modify(self, pos, value):
        p = pos + self.margin
        self.L[p] = value 
        while p > 1:
            x, y = self.L[p], self.L[p^1]
            if p&1: x, y = y, x
            self.L[p>>1] = None if x is None or y is None else self.function(x, y)
            p>>=1
    def query(self, left, right):
        l, r = left + self.margin, right + self.margin
        stack = []
        void = True
        while l < r:
            if l&1:
                if void:
                    result = self.L[l]
                    void = False
                else:
                    result = self.function(result, self.L[l])
                l+=1
            if r&1:
                r-=1
                stack.append(self.L[r])
            l>>=1
            r>>=1
        init = stack.pop() if void else result
        return reduce(self.function, reversed(stack), init)

n = int(input())
pies, index, first_equal = [0]*n, [0]*n, [0]*n
for i in range(n):
    r, h = [int(x) for x in input().split()]
    pies[i] = r*r*h
    print(""pies: "", str(pies))
s_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))
for i in range(n): index[s_pies[i][0]] = i
for i in range(1, n):
    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]
    print(""first_equal: "", str(first_equal))
towers = SegmentTree([0]*(n+1), max)
for j, pie in enumerate(pies):
    i, k = index[j], first_equal[j]
    q = towers.query(0, k+1)
    towers.modify(i+1, q + pie)
    print(""q: "", str(q))
    print(""towers: "", str(towers.L))
print(math.pi * towers.query(0, n+1))
</ans>",0,{}
40,"<ans>
memo = {}
def f(dat, rewards, start, end, extra):
    curr = (start, end, extra)
    if curr in memo:
        return memo[curr]
    
    if start > end:
        return 0
    if start == end:
        memo[curr] = rewards[dat[start] + extra]
        return memo[curr]
    
    # test all possible ""cut points"".
    # ""cut"" is the earliest index to die in the same deletion as ""end"".
    out = 0
    for cut in range(end, start-1, -2):
        if cut == end:
            # in this case, we're deleting the last interval right away.
            out_curr = rewards[dat[cut] + extra]
            out_curr += f(dat, rewards, start, cut-1, 0)
        else:
            # split into 2 pieces:
            # 1) slots [start, cut] plus [end + extra]
            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).
            out_curr = f(dat, rewards, start, cut, extra + dat[end])
            out_curr += f(dat, rewards, cut+1, end-1, 0)
        
        out = max(out, out_curr)
    
    memo[curr] = out
    return memo[curr]

def solve(dat_str, rewards_orig):
    # break into intervals.
    dat = []
    pos = 0
    while pos < len(dat_str):
        end = pos
        while end < len(dat_str) and dat_str[pos] == dat_str[end]:
            end += 1

        dat.append(end - pos)
        pos = end
    
    print(""dat: "", str(dat))
    
    # compute the highest-value way to remove a run of size k.
    # (google translated from C++ thinking)
    rewards = [0, rewards_orig[0]]
    for k in range(2, len(rewards_orig) + 1):
        print(
            ""{}: {}"".format(
                k,
                [
                    rewards[k-j] + rewards_orig[j-1]
                    for j in range(1, k+1)
                ]
            )
        )
        rewards.append(
            max(
                rewards[k-j] + rewards_orig[j-1]
                for j in range(1, k+1)
            )
        )
    
    print(""rewards: "", str(rewards))
    
    return f(dat, rewards, 0, len(dat)-1, 0)

int_dummy = input()
dat_str = input().strip()
rewards_input = input().strip().split()
rewards_ints = [int(x) for x in rewards_input]

print((
    solve(
        dat_str,
        rewards_ints,
    )
))
</ans>",0,{}
41,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

class RAQ_RMQ():
    def __init__(self, n, inf=2**31-1):
        self.n0 = 1<<(n-1).bit_length()
        self.INF = inf
        self.data = [0]*(2*self.n0)
        self.lazy = [0]*(2*self.n0)

    def getIndex(self, l, r):
        l += self.n0; r += self.n0
        lm = (l // (l & -l)) >> 1
        rm = (r // (r & -r)) >> 1
        while l < r:
            if r <= rm:
                yield r
            if l <= lm:
                yield l
            l >>= 1; r >>= 1
        while l:
            yield l
            l >>= 1

    def propagates(self, *ids):
        for i in reversed(ids):
            v = self.lazy[i-1]
            if not v:
                continue
            self.lazy[2*i-1] += v; self.lazy[2*i] += v
            self.data[2*i-1] += v; self.data[2*i] += v
            self.lazy[i-1] = 0

    def update(self, l, r, x):
        *ids, = self.getIndex(l, r)

        l += self.n0; r += self.n0
        while l < r:
            if r & 1:
                r -= 1
                self.lazy[r-1] += x; self.data[r-1] += x
            if l & 1:
                self.lazy[l-1] += x; self.data[l-1] += x
                l += 1
            l >>= 1; r >>= 1
        for i in ids:
            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]

    def query(self, l, r):
        self.propagates(*self.getIndex(l, r))
        l += self.n0; r += self.n0

        s = self.INF
        while l < r:
            if r & 1:
                r -= 1
                s = min(s, self.data[r-1])
            if l & 1:
                s = min(s, self.data[l-1])
                l += 1
            l >>= 1; r >>= 1
        return s

n,m,k = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
l = [0]*(n+1)
now = k
point = [0]*n
for i in range(n):
    a,b,c = map(int, input().split())
    point[i] = c
    now = now-a
    l[i] = now
    now += b+a
l[n] = now

RMQ = RAQ_RMQ(n+1)
for i in range(n+1):
    RMQ.update(i,i+1,l[i])

portal = list(range(n))
for i in range(m):
    u,v = map(int, input().split())
    u,v = u-1, v-1
    if portal[v]<u:
        portal[v] = u

if RMQ.query(0, n+1) < 0:
    print(-1)
    return

heap = [(-point[i], -portal[i]) for i in range(n)]
from heapq import heapify, heappop
heapify(heap)

ans = 0
while heap:
    p,i = heappop(heap)
    p,i = -p,-i
    if RMQ.query(i+1, n+1)>0:
        ans += p
        RMQ.update(i+1, n+1, -1)

print(ans)
</ans>",0,{}
42,"<ans>
import sys
from collections import deque

t=1
print(""t: "", str(t)
for _ in range(int(input())):
    n=int(input())
    print(""n: "", str(n))
    val=set([0,2*10**5+1])
    print(""val: "", str(val))
    seg=[(0,2*10**5+1)]
    print(""seg: "", str(seg))
    for i in range(n):
        l,r=map(int,input().split())
        print(""l: "", str(l), ""r: "", str(r))
        val.add(l)
        val.add(r)
        seg.append((l,r))
    val=list(val)
    val.sort()
    print(""val: "", str(val))
    comp={i:e+1 for e,i in enumerate(val)}
    print(""comp: "", str(comp))
    for i in range(n+1):
        l,r=seg[i]
        seg[i]=(comp[l],comp[r])
    print(""seg: "", str(seg))

    deg=[0]*(n+1)
    print(""deg: "", str(deg))
    out=[[] for i in range(n+1)]
    print(""out: "", str(out))
    for i in range(n+1):
        for j in range(i+1,n+1):
            l,r=seg[i]
            L,R=seg[j]
            if L<=l and r<=R:
                out[j].append(i)
                deg[i]+=1
            elif l<=L and R<=r:
                out[i].append(j)
                deg[j]+=1

    ans=[0]
    print(""ans: "", str(ans))
    deq=deque(ans)
    print(""deq: "", str(deq))

    while deq:
        v=deq.popleft()
        print(""v: "", str(v))
        for nv in out[v]:
            deg[nv]-=1
            if deg[nv]==0:
                deq.append(nv)
                ans.append(nv)

    dp=[0]*(n+1)
    print(""dp: "", str(dp))

    def solve(v):
        query=[[] for i in range(2*n+3)]
        for nv in out[v]:l,r=seg[nv];query[r].append((l,dp[nv]))
        subdp=[0]*(2*n+3)
        for i in range(1,2*n+3):
            res=subdp[i-1]
            for l,val in query[i]:test=subdp[l-1]+val;res=max(test,res)
            subdp[i]=res

        dp[v]=subdp[-1]+1

    for v in ans[::-1]:solve(v)

    print(dp[0]-1)
</ans>",0,{}
43,"<ans>
n=int(input())
print(""n: "", str(n))
arr=list(map(int,input().split()))
print(""arr: "", str(arr))
dict1={}
print(""dict1: "", str(dict1))
for i in range(2*n):
    try:
        dict1[arr[i]].append(i+1)
        dict1[arr[i]].sort()
        print(""dict1: "", str(dict1))
    except:
        KeyError
        dict1[arr[i]]=[i+1]
        print(""dict1: "", str(dict1))
ans=0
print(""ans: "", str(ans))
curr1=1
print(""curr1: "", str(curr1))
curr2=1
print(""curr2: "", str(curr2))
for i in range(1,n+1):
    if(i==1):
        ans+=(dict1[i][0]-curr1)
        ans+=(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    elif(dict1[i][0]>curr1 and dict1[i][0]>curr2):
        ans+=(dict1[i][0]-curr1)
        ans+=(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    elif(dict1[i][1]<curr1<curr2):
        ans+=abs(dict1[i][0]-curr1)
        ans+=abs(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    elif(dict1[i][0]<curr1 and curr1<dict1[i][1]<curr2):
        ans+=abs(dict1[i][0]-curr1)
        ans+=abs(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    elif(dict1[i][0]<curr1 and dict1[i][1]<curr2):
        ans+=abs(dict1[i][0]-curr1)
        ans+=abs(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    elif(curr1<dict1[i][0]<dict1[i][1]<curr2):
        ans+=abs(dict1[i][0]-curr1)
        ans+=abs(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
    else:
        ans+=abs(dict1[i][0]-curr1)
        ans+=abs(dict1[i][1]-curr2)
        curr1=dict1[i][0]
        curr2=dict1[i][1]
print(ans)
</ans>",0,{}
44,"<ans>
def gcd(a,b):
    while b:
        a, b = b, a%b
    return a

n = int(input())
print(""n: "", str(n))
P = [[int(x) for x in input().split()] for _ in range(n)]
print(""P: "", str(P))

L = []
def addLine(x,y,dx,dy):
    if dx < 0:
        dx *= -1
        dy *= -1
    elif dx == 0:
        if dy < 0:
            dy *= -1
    g = gcd(dx,dy)
    dx //= g
    dy //= g

    x += dx * (10**9)
    y += dy * (10**9)
    if dx:
        k = x//dx
    else:
        k = y//dy
    x -= k*dx
    y -= k*dy
    L.append((x,y,dx,dy))
    print(""x: "", str(x), ""y: "", str(y), ""dx: "", str(dx), ""dy: "", str(dy)

for i in range(n):
    for j in range(i+1,n):
        xi,yi = P[i]
        xj,yj = P[j]
        dx,dy = xi-xj,yi-yj
        addLine(xi,yi,dx,dy)

from collections import defaultdict as dd, deque

L = list(set(L))
res = 0

C = dd(int)
for x,y,dx,dy in L:
    C[dx,dy] += 1

ss = sum(C.values())

for x in C.values():
    res += (ss-x)*x

print(""res: "", str(res))

#for i in range(len(L)):
#    for j in range(i+1, len(L)):
#        x1,y1,dx1,dy1 = L[i]
#        x2,y2,dx2,dy2 = L[j]
#        if dx1 != dx2 or dy1 != dy2:
#            #print(L[i])
#            #print(L[j])
#            #print('---')
#            res += 1

print(res//2)
</ans>",0,{}
45,"<ans>
import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
A=[list(map(int,input().split())) for i in range(n)]

for i in range(m):
    #一行目をi-1まで0にする
    print(""i: "", str(i))

    ANSR=[0]*n
    ANSC=[0]*m

    for j in range(i):
        if A[0][j]==1:
            ANSC[j]=1

    for j in range(i,m):
        if A[0][j]==0:
            ANSC[j]=1

    for r in range(1,n):
        B=set()
        for c in range(m):
            if ANSC[c]==0:
                B.add(A[r][c])
            else:
                B.add(1-A[r][c])

        if len(B)>=2:
            break
        if max(B)==0:
            ANSR[r]=1

    else:
        print(""YES"")
        print("""".join(map(str,ANSR)))
        print("""".join(map(str,ANSC)))
        return

ANSR=[0]*n
ANSC=[0]*m

for j in range(m):
    if A[0][j]==1:
        ANSC[j]=1

flag=0
for r in range(1,n):
    if flag==0:
        B=[]
        for c in range(m):
            if ANSC[c]==0:
                B.append(A[r][c])
            else:
                B.append(1-A[r][c])

        if max(B)==0:
            continue
        elif min(B)==1:
            ANSR[r]=1
            continue
        else:
            OI=B.index(1)
            if min(B[OI:])==1:
                flag=1
                continue

            OO=B.index(0)
            if max(B[OO:])==0:
                flag=1
                ANSR[r]=1
                continue

            else:
                print(""NO"")
                return

    else:

        B=set()
        for c in range(m):
            if ANSC[c]==0:
                B.add(A[r][c])
            else:
                B.add(1-A[r][c])

        if len(B)>=2:
            break
        if max(B)==0:
            ANSR[r]=1

else:
    print(""YES"")
    print("""".join(map(str,ANSR)))
    print("""".join(map(str,ANSC)))
    return

print(""NO"")
</ans>",0,{}
46,"<ans>
def convert_to_float(poly):
    """"""convert polygon vertex to float type""""""
    poly_float = []
    for x, y, z in poly:
        vertex = (float(x),
                  float(y),
                  float(z))
        poly_float.append(vertex)
    print(""poly_float: "", str(poly_float))
    return poly_float


def is_well_connected(a, b):
    """"""Two planar polygons are bind together in 3D

    Arguments:
        a_poly,
        b_poly -- lists of vertex triples
    """"""
    a = convert_to_float(a)
    print(""a: "", str(a))
    b = convert_to_float(b)
    print(""b: "", str(b))

    a_norm = poly_normal(a)
    print(""a_norm: "", str(a_norm))
    b_norm = poly_normal(b)
    print(""b_norm: "", str(b_norm))

    common_dir = cross_product(a_norm, b_norm)
    print(""common_dir: "", str(common_dir))
    if not any(common_dir):
        return False

    a_list = intersect_list(a, b_norm, b[0], common_dir)
    print(""a_list: "", str(a_list))
    b_list = intersect_list(b, a_norm, a[0], common_dir)
    print(""b_list: "", str(b_list))

    char_str = points_to_str(a_list, b_list)
    print(""char_str: "", str(char_str))
    return not recognize_str(char_str)
</ans>",0,{}
47,"<ans>
for _ in range(ii()):
    n = ii()
    print(""n: "", str(n))
    a = li()
    print(""a: "", str(a))
    if n == 1 and a[0] & 1:
        print(-1)
    else:
        for i in range(n):
            if a[i] % 2 == 0:
                print(1)
                print(i + 1)
                break
        else:
            print(2)
            print(1, 2)
</ans>",0,{}
48,"<ans>
n, k = list(map(int, input().split()))
print(""n: "", str(n), ""k: "", str(k))
p  = {}
print(""p: "", str(p))
np = {}
print(""np: "", str(np))
pair    = []
print(""pair: "", str(pair))
used    = {}
print(""used: "", str(used))
rev_d   = {}
print(""rev_d: "", str(rev_d))

def push(d, s, v):
    if s not in d:
        d[s] = []
    d[s].append(v)

def is_pal(s):
    n = len(s)
    flg=True
    for i in range(n//2):
        if s[i] != s[n-1-i]:
            flg = False
            break
    return flg        

def rev(s):
    return s[::-1]

for _ in range(n):
    s, val = input().split()
    print(""s: "", str(s), ""val: "", str(val))
    val    = int(val
    
    if is_pal(s):
        push(p, s, val)
    else:
        push(np, s, val)
        
        if s not in rev_d:
            rev_d[s] = rev(s)

for k, v in list(p.items()):
    p[k] = sorted(v, reverse=True)
        
for k, v in list(np.items()):
    np[k] = sorted(v, reverse=True)
    
for s in np:
    if s not in used and rev_d[s] in np:
        pair.append([s, rev_d[s]])
        used[s] = True
        used[rev_d[s]] = True
        
max_remain = 0
minus = 0
max_S = 0

for v_arr in list(p.values()):
    n = len(v_arr)
    for i in range(0, n, 2):
        if i+1==n:
            if v_arr[i] > 0:
                max_remain = max(max_remain, v_arr[i]) 
            
        else:
            if v_arr[i] + v_arr[i+1] >= 0:
                max_S += v_arr[i] + v_arr[i+1]
                
                if v_arr[i+1] < 0:
                    minus = min(minus, v_arr[i+1])
            else:
                if v_arr[i] > 0:
                    max_remain = max(max_remain, v_arr[i]) 

for [u, v] in pair:
    n = min(len(np[u]), len(np[v]))
        
    for x, y in  zip(np[u][:n], np[v][:n]):
        if x+y > 0:
            max_S += x+y
            
print(max(max_S+max_remain, max_S-minus))            
</ans>",0,{}
49,"<ans>
def grundy(a,k): #石 a 個、最大 x//k までとれる
    print(""a: "", str(a), ""k: "", str(k))
    if a < k:
        return 0
    q = a//k
    r = (a-q*k)%(q+1)
    if r==0:
        return a//k
    v = (a-q*k)//(q+1) + 1
    print(""q: "", str(q), ""v: "", str(v))
    return grundy(a-(q+1)*v,k)

import sys
readline = sys.stdin.readline
read = sys.stdin.read
sys.setrecursionlimit(10**8)

n, = list(map(int,readline().split()))
print(""n: "", str(n))
g = 0
for _ in range(n):
    a,k = list(map(int,readline().split()))
    print(""a: "", str(a), ""k: "", str(k))
    g ^= grundy(a,k)
    print(""g: "", str(g))
if g:
    print(""Takahashi"")
else:
    print(""Aoki"")
</ans>",0,{}
50,"<ans>
a = input()
print(""a: "", str(a))
ans=[]
t=''
qoute =0
space =0
start =1 if a[0]=='""' else 0
for i in range(len(a)):
    v= a[i]
    print(""v: "", str(v))
    if start:
        if t=='':
            if v=='""':
                qoute+=1
                t = '<'
            elif v==' ':
                pass
            else:
                space+=1
                t='<'+v
        elif qoute>0:
            if v =='""':
                t+='>'
                qoute=0
                ans.append(t)
                t=''
                start=0
            else:
                t+=v
        else:
            if v ==' ':
                if t!='<':
                    t+='>'
                    ans.append(t)
                    t=''
                    start=0
            else:
                t+=v
    else:
        if v==' ':
            start=1
        elif v=='""':
            start=1
            t='<'
            qoute=1
        else:
            t='<'+v
            start=1
if t!='':
    t+='>'
    ans.append(t)
for v in ans:
    print(v)
</ans>",0,{}
51,"<ans>
def main1():
    buf = input()
    print(""buf: "", str(buf))
    buflist = buf.split()
    print(""buflist: "", str(buflist))
    n = int(buflist[0])
    print(""n: "", str(n))
    M = int(buflist[1])
    print(""M: "", str(M))
    buf = input()
    print(""buf: "", str(buf))
    buflist = buf.split()
    print(""buflist: "", str(buflist))
    t = list(map(int, buflist))
    print(""t: "", str(t))
    student = []
    minimum = []
    for i in range(n):
        count = 0
        pointer = 0
        while pointer < i:
            if count + student[pointer] <= M - t[i]:
                count += student[pointer]
                pointer += 1
            else:
                break
        minimum.append(i - pointer)
        student.append(t[i])
        student.sort()
    print(' '.join(list(map(str, minimum))))

def main2():
    buf = input()
    print(""buf: "", str(buf))
    buflist = buf.split()
    print(""buflist: "", str(buflist))
    n = int(buflist[0])
    print(""n: "", str(n))
    M = int(buflist[1])
    print(""M: "", str(M))
    buf = input()
    print(""buf: "", str(buf))
    buflist = buf.split()
    print(""buflist: "", str(buflist))
    t = list(map(int, buflist))
    print(""t: "", str(t))
    bucket = []
    for i in range(101):
        bucket.append(0)
    minimum = []
    for i in range(n):
        target = M - t[i]
        count = 0
        subtotal = 0
        for j in range(1, 101):
            if subtotal + bucket[j] * j > target:
                count += (target - subtotal) // j
                break
            else:
                count += bucket[j]
                subtotal += bucket[j] * j
        minimum.append(i - count)
        bucket[t[i]] += 1
    print(' '.join(list(map(str, minimum))))

def __starting_point():
    #main1() # for C1
    main2() # for C2

__starting_point()
</ans>",0,{}
52,"<ans>
def main():  #startline-------------------------------------------
    n = int(input())
    print(""n: "", str(n))
    a = list(map(int, input().split()))
    print(""a: "", str(a))
    d = defaultdict(int)
    print(""d: "", str(d))
    ans = 0
    for i in range(n):
        l = i - a[i]
        print(""l: "", str(l))
        ans += d[l]
        print(""ans: "", str(ans))
        d[a[i] + i] += 1
        print(""d: "", str(d))
        
    print(ans)
</ans>",0,{}
53,"<ans>
def GCD(a:int,b:int)->int:
    '''
    ユークリッドの互除法による最大公約数/O(log min(a,b))
    '''
    if b==0:
        return a
    else:
        return GCD(b,a%b)

def GCD_multi(vec:list)->int:
    '''
    数列の要素の最大公約数を求める/O(N log(a'))
    '''
    l = vec[0]
    for i in range(len(vec)-1):
        l = GCD(l,vec[i+1])
    return l

def main():
    #input data
    n = read_int()
    print(""n: "", str(n))
    A = read_ints_list()
    print(""A: "", str(A))

    #solve
    print(GCD_multi(A))

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
54,"<ans>
n = int(input())
print(""n: "", str(n))
snekovik = Stack()
print(""snekovik: "", str(snekovik))
wrong_snaks = set()
print(""wrong_snaks: "", str(wrong_snaks))
the_biggest_snek = n
print(""the_biggest_snek: "", str(the_biggest_snek))
sneks = list(map(int, input().split()))
print(""sneks: "", str(sneks))
for i in sneks:
    printing = []
    print(""printing: "", str(printing))
    if i == the_biggest_snek:
        snekovik.push(i)
        print(""snekovik: "", str(snekovik))
        printing.append(i)
        print(""printing: "", str(printing))
        the_biggest_snek -= 1
        print(""the_biggest_snek: "", str(the_biggest_snek))
        while the_biggest_snek in wrong_snaks:
            snekovik.push(the_biggest_snek)
            print(""snekovik: "", str(snekovik))
            wrong_snaks.remove(the_biggest_snek)
            print(""wrong_snaks: "", str(wrong_snaks))
            printing.append(the_biggest_snek)
            print(""printing: "", str(printing))
            the_biggest_snek -= 1
            print(""the_biggest_snek: "", str(the_biggest_snek))
    else:
        wrong_snaks.add(i)
        print(""wrong_snaks: "", str(wrong_snaks))
    print(*printing)
</ans>",0,{}
55,"<ans>
H,W=map(int,input().split())
print(""H: "", str(H), ""W: "", str(W))
List = [list(input()) for i in range(H)]
print(""List: "", str(List))
res = ""Yes""
print(""res: "", str(res))
flag = True
print(""flag: "", str(flag))

def checkAround(ListX,i,j):
  if i == 0 and j ==0:
    if List[i+1][j] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j !=0 and j != W-1:
    if List[i+1][j] == ""#"" or List[i][j-1] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j == W-1:
    if List[i+1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == 0:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == W-1:
    if List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j !=0 and j != W-1:
    if List[i-1][j] == ""#"" or List[i][j+1] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == 0:
    if List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == W-1:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j-1] == ""#"":
      return True
    else: 
      return False
  else:
    if List[i+1][j] == ""#"" or List[i-1][j] == ""#"" or List[i][j-1] == ""#"" or List[i][j+1] == ""#"":
      return True
    else: 
      return False

for k in range(H):
  for l in range(W):
    if List[k][l] == ""."":
      pass
    else:
      flag = checkAround(List,k,l)
      if not flag:
        res = ""No""
        break
  if not flag:
    break
print(res)
</ans>",0,{}
56,"<ans>
def main():
    (n, m) = tuple([int(x) for x in input().split()])
    print(""n: "", str(n), ""m: "", str(m))
    r = []
    xs = set()
    ys = set()
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))
        r.append((x1, y1, x2, y2))
        xs.add(x1)
        xs.add(x2 + 1)
        ys.add(y1)
        ys.add(y2 + 1)

    xx = sorted(xs)
    yy = sorted(ys)
    xsize = len(xs)
    ysize = len(ys)
    grid = []
    for i in range(ysize):
        grid.append([False] * xsize)

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    grid[i][j] = True

    f = MaxFlow()
    for i in range(len(yy)):
        for j in range(len(xx)):
            if grid[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i)

    print(""f: "", str(f))
    print(f.solve(0, len(xx) + len(yy) + 1))


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
57,"<ans>
def solve():
    N, K = getInts()
    print(""N: "", str(N), ""K: "", str(K))
    graph = dd(set)
    print(""graph: "", str(graph))
    for i in range(N-1):
        A, B = getInts()
        print(""A: "", str(A), ""B: "", str(B))
        graph[A].add(B)
        graph[B].add(A)
    dp_count = [[0 for j in range(5)] for i in range(N+1)]
    print(""dp_count: "", str(dp_count))
    dp_total = [0 for j in range(N+1)]
    print(""dp_total: "", str(dp_total))
    nonlocal ans
    ans = 0
    print(""ans: "", str(ans))
    @bootstrap
    def dfs(node,parent,depth):
        nonlocal ans
        dp_count[node][depth % K] = 1
        print(""node: "", str(node), ""parent: "", str(parent), ""depth: "", str(depth))
        print(""dp_count[node]: "", str(dp_count[node]))
        dp_total[node] = 1
        print(""dp_total[node]: "", str(dp_total[node]))
        for neigh in graph[node]:
            if neigh != parent:
                yield dfs(neigh,node,depth+1)
                for i in range(K):
                    for j in range(K):
                        diff = (i+j-2*depth)%K
                        req = (-diff)%K
                        ans += req * dp_count[node][i] * dp_count[neigh][j]
                for i in range(K):
                    dp_count[node][i] += dp_count[neigh][i]
                dp_total[node] += dp_total[neigh]
        ans += dp_total[node] * (N - dp_total[node])
        yield
    dfs(1,-1,0)
    return ans//K
print(solve())
</ans>",0,{}
58,"<ans>
N:  0 K:  0 L:  0 road:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] rail:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] share:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] roads:  [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19], [20, 21]] rails:  [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19], [20, 21]] m:  {}
</ans>",0,{}
59,"<ans>
import sys

MOD = (int)(1e9+7)
print(""MOD: "", str(MOD))

def add(a, b):
    a += b
    if a >= MOD: a -= MOD
    return a

def mul(a, b):
    return (a * b) % MOD

class fenwickTree:
    def __init__(self, max_val):
        self.max_val = max_val + 5
        self.tree = [0] * self.max_val
        print(""max_val: "", str(max_val)

    def update(self, idx, value):
        idx += 1
        while idx < self.max_val:
            self.tree[idx] = add(self.tree[idx], value)
            idx += (idx & (-idx))

    def read(self, idx):
        idx += 1
        res = 0
        while idx > 0:
            res = add(res, self.tree[idx])
            idx -= (idx & (-idx))
        return res

inp = [int(x) for x in sys.stdin.read().split()]
print(""inp: "", str(inp))

n = inp[0]
print(""n: "", str(n))
a = []
for i in range(1, n + 1):
    a.append(inp[i])
print(""a: "", str(a))

sorted_array = sorted(a)
print(""sorted_array: "", str(sorted_array))
dict = {}
for i in range(n):
    dict[sorted_array[i]] = i
    print(""dict: "", str(dict))

factor = [0] * n
print(""factor: "", str(factor))
for i in range(0, n):
    factor[i] = mul(i + 1, n - i)
    print(""factor: "", str(factor))

left_tree = fenwickTree(n)
print(""left_tree: "", str(left_tree))
for i in range(0, n):
    element_idx = dict[a[i]]
    factor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))
    print(""factor: "", str(factor))
    left_tree.update(element_idx, i + 1)

right_tree = fenwickTree(n)
print(""right_tree: "", str(right_tree))
for i in range(n - 1, -1, -1):
    element_idx = dict[a[i]]
    factor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))
    print(""factor: "", str(factor))
    right_tree.update(element_idx, n - i)

ans = 0
for i in range(n):
    ans = add(ans, mul(a[i], factor[i]))
    print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
60,"<ans>
def f(A, r, c, l):
  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]
  print(""q: "", str(q), ""w: "", str(w), ""e: "", str(e))
  print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
  if x != y and y != z and e >= l and  w == q == l:
    return (l, z, y, x)
  else:
    return 0

r, c = list(map(int, input().split()))
print(""r: "", str(r), ""c: "", str(c))
s = """"
for i in range(r):
  s += input()

arr = []
narr = [[0]*r for i in range(c)]
for i in range(c):
  arr.append(s[i:r*c:c])

r, c = c, r 
print(""r: "", str(r), ""c: "", str(c))

length_str = [ [0] * c for i in range(r) ]
for i in range(r):
  for j in range(c):
    if j == 0:
      length_str[i][j] = (1, arr[i][j])
    elif arr[i][j-1] == arr[i][j]:
      length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])
    else:
      length_str[i][j] = (1, arr[i][j])

for i in range(r):
  for j in range(c):
    l, _ = length_str[i][j] 
    if j - l*3 + 1 < 0:
      continue 
    else:
      narr[i][j] = f(length_str, i, j, l)
      print(""l: "", str(l))

dp =[ [0] * c for i in range(r) ]

for j in range(c):
  cnt = 1
  for i in range(r):
    if narr[i][j] == 0:
      cnt = 1
      continue 
    else:
      if i == 0:
        dp[i][j] = 1

      elif narr[i][j] == narr[i-1][j]:
        cnt += 1
        dp[i][j] = cnt
        dp[i-1][j] = 0

      else:
        cnt = 1
        dp[i][j] = 1 

ans = 0
for i in dp:
  for j in i:
    ans += ((j)*(j+1))//2

print(ans)
</ans>",0,{}
61,"<ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)


class TreapNode:
    _value = None
    _priority = None
    _count = None
    _left = None
    _right = None

    def __init__(self, value):
        self._value = value
        self._priority = random()
        self._count = 1
        print(""_value: "", str(self._value), ""_priority: "", str(self._priority), ""_count: "", str(self._count))


def treap_rotate_right(n):
    l = n._left
    n._left = l._right
    l._right = n
    return l


def treap_rotate_left(n):
    r = n._right
    n._right = r._left
    r._left = n
    return r


def treap_insert(n, v):
    if n is None:
        return TreapNode(v)
    if n._value == v:
        n._count += 1
        return n
    if n._value > v:
        n._left = treap_insert(n._left, v)
        if n._priority > n._left._priority:
            n = treap_rotate_right(n)
    else:
        n._right = treap_insert(n._right, v)
        if n._priority > n._right._priority:
            n = treap_rotate_left(n)
    return n


def treap_delete(n, v):
    if n is None:
        raise Exception('no nodes')
    if n._value > v:
        n._left = treap_delete(n._left, v)
        return n
    if n._value < v:
        n._right = treap_delete(n._right, v)
        return n

    # n._value == v
    if n._count > 1:
        n._count -= 1
        return n

    if n._left is None and n._right is None:
        return None

    if n._left is None:
        n = treap_rotate_left(n)
    elif n._right is None:
        n = treap_rotate_right(n)
    else:
        # n._left is not None and n._right is not None
        if n._left._priority < n._right._priority:
            n = treap_rotate_right(n)
        else:
            n = treap_rotate_left(n)
    return treap_delete(n, v)


def treap_size(n):
    if n is None:
        return 0
    return n._count + treap_size(n._left) + treap_size(n._right)


def treap_str(n):
    if n is None:
        return """"
    result = []
    if n._left is not None:
        result.append(treap_str(n._left))
    result.append(""%d:%d"" % (n._value, n._count))
    if n._right is not None:
        result.append(treap_str(n._right))
    return ' '.join(result)


def treap_search(n, v):
    # v 未満で最大のノードを検索する. v 未満のノードがなければ None を返す
    if n is None:
        return None
    if n._value >= v:
        if n._left is None:
            return None
        return treap_search(n._left, v)
    # n._value < v
    if n._right is None:
        return n
    r = treap_search(n._right, v)
    if r is None:
        return n
    return r


class Treap:
    _root = None
    _size = 0

    def insert(self, v):
        self._root = treap_insert(self._root, v)
        self._size += 1

    def delete(self, v):
        self._root = treap_delete(self._root, v)
        self._size -= 1

    def __len__(self):
        return self._size

    def __str__(self):
        return treap_str(self._root)

    def search(self, v):
        return treap_search(self._root, v)


N = int(input())
A = [int(input()) for _ in range(N)]
print(""N: "", str(N), ""A: "", str(A))

t = Treap()
for a in A:
    n = t.search(a)
    if n is not None:
        t.delete(n._value)
    t.insert(a)
    print(""a: "", str(a))
print((len(t)))
</ans>",0,{}
62,"<ans>
def _3():
    from collections import defaultdict

    def can_pair(s1, s2):
        l = []
        for c1, c2 in zip(s1, s2):
            c = sorted([c1, c2])
            if c in l:
                l.remove(c)
            else:
                l.append(c)

        if len(s1) % 2 == 0:
            return len(l) == 0
        else:
            return len(l) == 1 and l[0][0] == l[0][1]

    def pair_graph(s1, s2):
        N = len(s1)
        G = np.zeros([N, N])
        for i in range(N):
            for j in range(i+1, N):
                if s1[i] == s2[j] and s1[j] == s2[i]:
                    G[i, j] = 1
                    G[j, i] = 1
        return G

    import numpy as np
    H, W = list(map(int, input().split(' ')))
    print(""H: "", str(H), ""W: "", str(W))
    S = []
    d = defaultdict(list)

    for h in range(H):
        s = input()
        S.append(s)
        d[''.join(sorted(S))].append(h)

    already_paired = np.zeros(H)

    Gs = []

    for i in range(H):
        if already_paired[i]:
            continue

        for j in range(i+1, H):
            if already_paired[j]:
                continue

            if can_pair(S[i], S[j]):
                already_paired[i] = 1
                already_paired[j] = 1
                G = pair_graph(S[i], S[j])
                Gs.append(G)
                break

    if already_paired.sum() < H - 1:
        print('NO')
        return

    elif already_paired.sum() == H - 1:
        for i in range(H):
            if already_paired[i] == 0:
                G = pair_graph(S[i], S[i])
                Gs.append(G)
                break

    G = np.array(Gs).sum(axis=0) // len(Gs)

    def is_perfect_matching(G):
        N = len(G)
        if N == 1:
            return True

        for i in range(N):
            for j in range(i+1, N):
                if G[i, j] == 1:
                    l = list(range(N))
                    l.remove(i)
                    l.remove(j)
                    if len(l) == 0:
                        return True
                    if is_perfect_matching(G[l][:, l]):
                        return True
        return False

    if is_perfect_matching(G):
        print('YES')
    else:
        print('NO')

def __starting_point():
    _3()
__starting_point()
</ans>",0,{}
63,"<ans>
import sys
readline = sys.stdin.readline

def accumulate2d(X):
    N = len(X)
    M = len(X[0])
    print(""N: "", str(N), ""M: "", str(M)
    
    for i in range(0, N):
        for j in range(1, M):
            X[i][j] += X[i][j-1]
    
    for j in range(0, M):
        for i in range(1, N):
            X[i][j] += X[i-1][j]
    
    return X

N, M, Q = map(int, readline().split())
print(""N: "", str(N), ""M: "", str(M), ""Q: "", str(Q))
table = [None]*100
table[ord('R')] = 0
table[ord('G')] = 1
table[ord('B')] = 2
table[ord('Y')] = 3
print(""table: "", str(table))

INF = 10**3
D = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]
print(""D: "", str(D))
G = [[0]*M for _ in range(N)]
print(""G: "", str(G))

BS = 25
candi = []
geta = M
for i in range(N-1):
    for j in range(M-1):
        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:
            G[i][j] = 1
            nh, nw = i, j
            while True:
                k = G[nh][nw]
                fh, fw = nh-k, nw-k
                k2 = 2*(k+1)
                kh = k+1
                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:
                    break
                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\
                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\
                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):
                    break
                G[nh][nw] += 1
            if G[nh][nw] > BS:
                candi.append((nh, nw))
print(""candi: "", str(candi))

Gnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]
for h in range(N):
    for w in range(M):
        if G[h][w] > 0:
            for k in range(1, min(BS, G[h][w])+1):
                Gnum[k][h][w] = 1
print(""Gnum: "", str(Gnum))

Gnum = [None] + [accumulate2d(g) for g in Gnum[1:]]
print(""Gnum: "", str(Gnum))

Ans = [None]*Q
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())
    res = 0
    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+k-1, w1+k-1
        he, we = h2-k, w2-k
        if hs <= he and ws <= we:
            cnt = Gnum[k][he][we]
            if hs:
                cnt -= Gnum[k][hs-1][we]
            if ws:
                cnt -= Gnum[k][he][ws-1]
            if hs and ws:
                cnt += Gnum[k][hs-1][ws-1]
            if cnt:
                res = k
                break
    
    for nh, nw in candi:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))
    Ans[qu] = 4*res**2
print('\n'.join(map(str, Ans))
</ans>",0,{}
64,"<ans>
def find_loop(g, w, k, n):
    visited = [False] * n
    print(""visited: "", str(visited))
    visited_int = [False] * n
    print(""visited_int: "", str(visited_int))
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        print(""stack: "", str(stack))
        path = [i]
        print(""path: "", str(path))
        visited[i] = True
        visited_int[i] = True
        while stack:
            if not stack[-1]:
                stack.pop()
                visited_int[path[-1]] = False
                path.pop()
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited_int[nxt]:
                return True
            if visited[nxt]:
                continue
            visited[nxt] = True
            visited_int[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)
    return False

def top_sort(g, w, k, n):
    visited = [False] * n
    print(""visited: "", str(visited))
    order = [-1] * n
    print(""order: "", str(order))
    cnt = 0
    for i in range(n):
        if visited[i]:
            continue
        stack = [g[i][:]]
        print(""stack: "", str(stack))
        path = [i]
        print(""path: "", str(path))
        visited[i] = True
        while stack:
            if not stack[-1]:
                order[path[-1]] = cnt
                path.pop()
                stack.pop()
                cnt += 1
                continue
            nxt = stack[-1][-1]
            stack[-1].pop()
            if w[(path[-1], nxt)] <= k:
                continue
            if visited[nxt]:
                continue
            visited[nxt] = True
            stack.append(g[nxt][:])
            path.append(nxt)

    to_reverse = []
    for a, b in list(w.items()):
        if b > k:
            continue
        if order[a[0]] < order[a[1]]:
            to_reverse.append(a)
    return to_reverse

def __starting_point():
    n, m = list(map(int, input().split()))
    w = {}
    print(""w: "", str(w))
    g = [[] for _ in range(n)]
    print(""g: "", str(g))
    w_tmp = {}
    print(""w_tmp: "", str(w_tmp))
    c_m = 0
    print(""c_m: "", str(c_m))
    kk = [0]
    print(""kk: "", str(kk))
    lines = sys.stdin.readlines()
    print(""lines: "", str(lines))
    for i, line in enumerate(lines): #range(1, m + 1):
        u, v, c = list(map(int, line.split()))
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in list(w.keys()):
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
        else:
            w[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in list(w_tmp.keys()):
            w_tmp[(u - 1, v - 1)].append(str(i + 1))
        else:
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
        kk.append(c)
        print(""g: "", str(g))
        print(""w: "", str(w))
        print(""w_tmp: "", str(w_tmp))
        print(""kk: "", str(kk))

    kk.sort()
    print(""kk: "", str(kk))
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(0, 0)
        return
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):
            if find_loop(g, w, kk[m], n):
                l = m
            else:
                r = m
        kkk = kk[l+1]

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(kkk, num)
    print("" "".join(s))

__starting_point()
</ans>",0,{}
65,"<ans>
a = list(map(int,input().split()))
print(""a: "", str(a))
b = [0,0,0,0,0];
print(""b: "", str(b))
c = [0,0,0,0,0];
print(""c: "", str(c))
ipt = [];
print(""ipt: "", str(ipt))
ans = [];
print(""ans: "", str(ans))
d = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}
print(""d: "", str(d))

n = int(input())
print(""n: "", str(n))

for i in range(1,n+1) :
    j = input()
    print(""j: "", str(j))
    ipt.append(j)
    print(""ipt: "", str(ipt))
    ans.append(j)
    print(""ans: "", str(ans))
    if j.find(',') == -1 :
        a[d[j]] -= 1
    else :
        b[d[j[0:j.find(',')]]] += 1

ans = False;
print(""ans: "", str(ans))

for i in range(0,6) :
    if (a[i] < 0) and ans == False:
        ans = True
    elif i < 5:
        if i==0 :
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                b[i] -= a[i];
                a[i] = 0;
            else :
                c[i] = 0;
                a[i] -= b[i];
                b[i] = 0;

        else :
            if b[i-1] > 0 :
                if b[i-1] > a[i] :
                    ans = True
                else :
                    a[i] -= b[i-1];
            if b[i] > a[i] :
                c[i] = b[i] - a[i];
                b[i] -= a[i];
                a[i] = 0;
            else :
                c[i] = 0;
                a[i] -= b[i];
                b[i] = 0;
    elif i==5 :
        if a[i] < b[i-1]:
            ans = True

if ans == True :
    print(""NO"");

else :
    print(""YES"")
    for i in ipt :
        if i.find(',') == -1 :
            print(i)
        else :
            tmp = i[0:i.find(',')];
            if (c[d[tmp]] > 0) :
                print(i[i.find(',')+1:])
                c[d[tmp]] -= 1
            else :
                print(tmp)
</ans>",0,{}
66,"<ans>
n, m = list(map(int, input().split()))
print(""n: "", str(n), ""m: "", str(m))
A = list(map(int, input().split()))
print(""A: "", str(A))
if n > 300:
    lst = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        lst.append([a, b])
    answer = 0
    answer_1 = []
    m300 = [[-1, -10**6]]
    for i in range(max(0, m-1)):
        m300.append([-1, -10**6])
    for u in range(n):
        if A[u] > min(m300)[1]:
            m300[m300.index(min(m300))] = [u, A[u]]
    for i, mi in m300:
        B = A.copy()
        kek = []
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
        elem = max(B)
        if answer < elem - mi:
            answer = elem - mi
            answer_1 = kek.copy()
    print(answer)
    print(len(answer_1))
    print(' '.join(map(str, answer_1)))
else:
    lst = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        lst.append([a, b])
    answer = 0
    answer_1 = []
    for i in range(n):
        B = A.copy()
        kek = []
        for j in range(m):
            a, b = lst[j][0], lst[j][1]
            if a <= i + 1 <= b:
                kek.append(j + 1)
                for q in range(a - 1, b):
                    B[q] -= 1
        elem = max(B)
        if answer < elem - B[i]:
            answer = elem - B[i]
            answer_1 = kek.copy()
    print(answer)
    print(len(answer_1))
    print(' '.join(map(str, answer_1))
</ans>",0,{}
67,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
        
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True
#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b
#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag
#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)
#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)
#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""
#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1
#####quadratic#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####taking an array/list as input#####
def inp():
    ls=list(map(int,input().split()))
    return ls
#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))
#####Main function starts from here#####
n=int(input())
d={}
while(n%2==0):
    if 2 in d:
        d[2]+=1
    else:
        d[2]=1
    n/=2
print(""d: "", str(d), ""n: "", str(n))
for i in range(3,int(n**0.5)+1,2):
    while(n%i==0):
        if i in d:
            d[i]+=1
        else:
            d[i]=1
        n/=i
n=int(n)
if n>1:
    d[n]=1
n=1
print(""d: "", str(d), ""n: "", str(n))
ans=0
for i in d:
    c=-2*d[i]
    a=b=1
    ls=qdrt(a,b,c)
    if ls[0]>=0:
        ans+=ls[0]
    elif ls[1]>=0:
        ans+=ls[1]
print(ans)
</ans>",0,{}
68,"<ans>
N:  0 S:  0 ans:  0
for i in range(N):
    a:  0 t:  0 c:  0 g:  0
    for j in range(i,N):
        if S[j] == 'A':
            a += 1
        elif S[j] == 'T':
            t += 1
        elif S[j] == 'C':
            c += 1
        else:
            g += 1
        if a == t and c == g:
            ans += 1
print(ans)
</ans>",0,{}
69,"<ans>
n,m,p = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m), ""p: "", str(p))
dist  = []
print(""dist: "", str(dist))
edge1 = [[] for _ in range(n)]
print(""edge1: "", str(edge1))
edge2 = [[] for _ in range(n)]  # rev_edge
print(""edge2: "", str(edge2))
for _ in range(m):
    u,v,c = map(int, input().split())
    print(""u: "", str(u), ""v: "", str(v), ""c: "", str(c))
    u -= 1
    v -= 1
    dist.append((u,v,(c-p)*-1))
    print(""dist: "", str(dist))
    edge1[u].append(v)
    print(""edge1: "", str(edge1))
    edge2[v].append(u)
    print(""edge2: "", str(edge2))
use = dfs(edge1, 0) & dfs(edge2, n-1)
print(""use: "", str(use))
dist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]
print(""dist2: "", str(dist2))
print(bellman(dist2))
</ans>",0,{}
70,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
        print(""Nodes: "", str(Nodes), ""is_directed: "", str(is_directed))
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b

#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(n-r+1,n+1):
        ans*=i
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(r):
        ans*=(n-i)
    div=1
    for i in range(2,r+1):
        div*=i
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    return ls

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    n,m=mult_inp()
    print((combination(n,2)+combination(m,2)))
    print(""n: "", str(n), ""m: "", str(m))
def __starting_point():
    main()
    print(""main: "", str(main))
    
    

    
    
    
            
    
    

__starting_point()
</ans>",0,{}
71,"<ans>
import math
import bisect
import sys

def flrt(exp,x):
    l=max(0,math.floor(x**(1/exp))-3)
    print(""l: "", str(l))
    r= math.floor(x**(1/exp))+3
    print(""r: "", str(r))
    while l<r:
        mid=(l+r)//2
        print(""mid: "", str(mid))
        if mid**exp<=x:
            l=mid+1
        else: 
            r=mid
    return l-1
   
    
def c1(r):
    ans=set()
    pr = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
    print(""ans: "", str(ans))
    for i in pr:
        x=2
        print(""x: "", str(x))
        while x**i <= r:
            val=x**i
            print(""val: "", str(val))
            b2=flrt(2,val)
            print(""b2: "", str(b2))
            b3=flrt(3,val)
            print(""b3: "", str(b3))
            if b2**2 != val and b3**3 != val:
                ans.add(val)
            x+=1
    return ans
    
def solve(r, pc):
    if r==0:
        return 0
    
    a=[2,3]
    print(""a: "", str(a))
    ans=0
    for i in range(1,2**len(a)):
        tot=0
        mult=1
        for j,x in enumerate(a):
            if i&(1<<j):
                mult*=x
                tot+=1
        d=  flrt(mult,r)      
        print(""d: "", str(d))
        ans+= d if tot%2 else -d
        
    return ans + bisect.bisect_right(pc,r)    
       
    lp=0 
    rp=len(pc)
    while lp<rp:
        mid = (lp+rp)//2
        if pc[mid] <= r:
            lp = mid+1
        else:
            rp = mid
        
    
    return ans + lp
q = int(input())

pc= c1(1e18+1)
print(""pc: "", str(pc))

pca=list(pc)
pca.sort()
print(""pca: "", str(pca))
        
 
for i in range(q):
    l,r = [int(x) for x in sys.stdin.readline().split()]
    print(""l: "", str(l))
    print(""r: "", str(r))
    ans=solve(r,pca)-solve(l-1,pca)
    print(""ans: "", str(ans))
    sys.stdout.write(str(ans)+'\n')
</ans>",0,{}
72,"<ans>
def solve():
    n,m,w=mi()
    print(""n: "", str(n), ""m: "", str(m), ""w: "", str(w))
    a=li()
    print(""a: "", str(a)
    
    def fessible(mid):
        print(""mid: "", str(mid))
        b=[0]*n
        print(""b: "", str(b))
        moves=0
        print(""moves: "", str(moves))
        if(a[0]<mid):
            b[0]+=(mid-a[0])
            print(""b[0]: "", str(b[0]))
            if(w<n):
                b[w]-=(mid-a[0])
                print(""b[w]: "", str(b[w]))
            moves+=(mid-a[0])
            print(""moves: "", str(moves))
            if(moves>m):
                return 0
        for i in range(1,n):
            b[i]+=b[i-1]
            print(""b[i]: "", str(b[i]))
            x=a[i]+b[i]
            print(""x: "", str(x))
            if(x<mid):
                b[i]+=(mid-x)
                print(""b[i]: "", str(b[i]))
                if(i+w<n):
                    b[i+w]-=(mid-x)
                    print(""b[i+w]: "", str(b[i+w]))
                moves+=(mid-x)
                print(""moves: "", str(moves))
            if(moves>m):
                return 0
        return 1

    l=1
    r=1e10
    while(l<=r):
        mid=l+(r-l)//2
        print(""mid: "", str(mid))
        if(fessible(mid)):
            l=mid+1
            ans=mid
            print(""l: "", str(l), ""ans: "", str(ans))
        else:
            r=mid-1
            print(""r: "", str(r))

    print(int(ans))

def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
73,"<ans>
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

S=lambda x:sum(map(int,str(x)))

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	z=S(x)%a
	if z:
		z=a-z
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(z,9-int(digit))
			z-=diff
			tail.append(str(int(digit)+diff))
			if z==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert S(x)%a==0
	x=int(x)
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	while a%5==0: a//=5
	return a==1

def solve(a):
	for first in range(1,60): # 120
		q=str((first*10**3000+a-1) // a) # 5000
		for s1 in range(1,200):
			i=1
			s2=int(q[0])
			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,a)
					if S(small*a)*a==S(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

if 0:
	#for a in (a for a in range(2,1000)):
	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
	#for a in [32]:

		def work():
			nonlocal x
			x=solve(a)

		t=timeit(work,number=1)
		if t>0.5 or x==None:
			if x!=None:
				print(a,t,'>>',powform(a*x))
			else:
				print(a,t,'>> ?????')

	#print(solve(int(input())))


special='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104
582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003
636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5475810970001476 >> 2 * 10 ** 2140 + 439
64 0.5633312410000144 >> ?????
200 0.5639609099998779 >> ?????
100 0.565854023000611 >> ?????
125 0.5663040710005589 >> ?????
160 0.5668467480008985 >> ?????
800 0.5676178080002501 >> ?????
128 0.5676772269998764 >> ?????
80 0.5682811480000964 >> ?????
256 0.5685735130000467 >> ?????
250 0.5691464900000938 >> ?????
512 0.569266141999833 >> ?????
32 0.5692826909998985 >> ?????
50 0.5692834940000466 >> ?????
25 0.5696684799995637 >> ?????
400 0.5703751219998594 >> ?????
20 0.5706145570002263 >> ?????
500 0.5742691679997733 >> ?????
640 0.5749700739997934 >> ?????
40 0.5768258159996549 >> ?????
625 0.5775357299999087 >> ?????
16 0.5789494729997386 >> ?????
833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008
320 0.6031684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.045185064999714 >> 22 * 10 ** 1822 + 1130
990 6.413724044000446 >> 39 * 10 ** 2970 + 302010
666 6.967028857000514 >> 33 * 10 ** 2997 + 32934
941 6.982767053000316 >> 21 * 10 ** 1885 + 312
924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152
858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142
939 8.241953895999359 >> 33 * 10 ** 1879 + 20001
813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314
921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008
831 1.683305384999585 >> 1 * 10 ** 3702 + 1646
846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234
888 6.891388972000641 >> 3 * 10 ** 3998 + 27672
909 11.340291348999926 >> 7 * 10 ** 4673 + 17201
957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403
933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234
891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079
783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814
999 102.2252583720001 >> 89 * 10 ** 4760 + 20071
777 37.847382832999756 >> 24 * 10 ** 4661 + 474123
855 0.934857464999368 >> 1 * 10 ** 3420 + 21545
942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058
807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123
'''

a=int(input())
print(""a: "", str(a))
for line in special.splitlines():
	if line:
		expr,out=line.split('>>')
		expr=expr.split()[0]
		if int(expr)==a:
			print(-1 if out.strip()=='?????' else eval(out)//a)
			break
else:
	print(solve(a))
</ans>",0,{}
74,"<ans>
def parser():
    return map(int, stdin.readline().split())

def DFS_Discriminiting():
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    print(""stack: "", str(stack))
    while len(stack)>0:
        v=stack.pop()
        print(""v: "", str(v))
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                if attacked_city[u]:
                    count_attacked_cities_subtree[u]+=1
                stack.append(u)
                intrudoction_order.append(u)
        print(""pi: "", str(pi))
        print(""visited: "", str(visited))
        print(""count_attacked_cities_subtree: "", str(count_attacked_cities_subtree))
        print(""intrudoction_order: "", str(intrudoction_order))
    for v in intrudoction_order[::-1]:
        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]
        if count_attacked_cities_subtree[v]==0:
            important_cities[v]=False
        print(""count_attacked_cities_subtree: "", str(count_attacked_cities_subtree))
        print(""important_cities: "", str(important_cities))

def DFS_Heigths():
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    stack=[]
    intrudoction_order=[]
    stack.append(numbers_of_attacked_cities[0])
    print(""stack: "", str(stack))
    while len(stack)>0:
        v=stack.pop()
        print(""v: "", str(v))
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                stack.append(u)
                intrudoction_order.append(u)
        print(""pi: "", str(pi))
        print(""visited: "", str(visited))
        print(""intrudoction_order: "", str(intrudoction_order))
    for v in intrudoction_order[::-1]:
        if heights1[pi[v]] < heights1[v]+1:
            heights2[pi[v]]=heights1[pi[v]]
            heights1[pi[v]]=heights1[v]+1
        elif heights2[pi[v]]<heights1[v]+1:
            heights2[pi[v]]=heights1[v]+1
        print(""heights1: "", str(heights1))
        print(""heights2: "", str(heights2))

def Distance_Root(s):
    for v in adjacents_list[s]:
        if heights1[v]+1>distances1[s]:
            distances2[s]=distances1[s]
            distances1[s]=heights1[v]+1
        elif heights1[v]+1>distances2[s]:
            distances2[s]=heights1[v]+1
        print(""distances1: "", str(distances1))
        print(""distances2: "", str(distances2))

def DFS_Distances():
    visited=[False for x in range(n)]
    print(""visited: "", str(visited))
    stack=[]
    stack.append(numbers_of_attacked_cities[0])
    Distance_Root(numbers_of_attacked_cities[0])
    print(""stack: "", str(stack))
    while len(stack)>0:
        v=stack.pop()
        print(""v: "", str(v))
        for u in adjacents_list[v]:
            if not visited[u]:
                pi[u]=v
                visited[u]=True
                determinate=False
                stack.append(u)
                if heights1[u]+1==distances1[v]:
                    if heights1[u]+1>distances2[v]:
                        determinate=True
                        distances1[u]=max(heights1[u],distances2[v]+1)
                        if distances1[u]==heights1[u]:
                            distances2[u]=max(distances2[v]+1,heights2[u])
                        else:
                            distances2[u]=heights1[u]
                    print(""distances1: "", str(distances1))
                    print(""distances2: "", str(distances2))
                if not determinate:
                    distances1[u]=distances1[v]+1
                    distances2[u]=heights1[u]
                    print(""distances1: "", str(distances1))
                    print(""distances2: "", str(distances2))
</ans>",0,{}
75,"<ans>
n, k, m, a = [int(i) for i in input().split()]
print(""n: "", str(n), ""k: "", str(k), ""m: "", str(m), ""a: "", str(a))
cn = [0] * (n + 1)
print(""cn: "", str(cn))
last = [-1] * (n + 1)
print(""last: "", str(last))
v = [int(i) for i in input().split()]
print(""v: "", str(v))

for i in range(len(v)):
    last[v[i]] = i
    cn[v[i]] += 1
    print(""last: "", str(last), ""cn: "", str(cn)

cn1 = deepcopy(cn)
print(""cn1: "", str(cn1))
last1 = deepcopy(last)
print(""last1: "", str(last1)

for i in range(1, n + 1):
    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last))
    res = [i1 for i1 in range(1, n + 1)]
    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    #print(res)
    
    for j in range(len(res)):
        if res[j] != i:
            continue
        j1 = j + 1
        lft = m - a
        while j1 < n and lft:
            pls = min(lft, cn[i] - cn[res[j1]] + 1)
            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)
            last[res[j1]] = m
            lft -= pls
            j1 += 1
        print(""cn: "", str(cn), ""last: "", str(last)

    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
    sans = 0
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break
    print(""sans: "", str(sans))

    if sans == 1:
        print(1, end= ' ')
        continue
    
    cn = deepcopy(cn1)
    print(""cn: "", str(cn))
    last = deepcopy(last1)
    print(""last: "", str(last)

    if m - a:
        cn[i] += m - a
        last[i] = m - 1

    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)
    for j in range(len(res)):
        if res[j] != i:
            continue
        if cn[i] == 0 or j >= k:
            sans = 0
        else:
            sans = 1
        break
    print(""sans: "", str(sans))
    
    if sans:
        print(2, end=' ')
    else:
        print(3, end=' ')
</ans>",0,{}
76,"<ans>
a=input()
print(""a: "", str(a))
a=list(map(int,input().split("" "")))
print(""a: "", str(a))

if len(a) == 1:
    print (""yes"")
    print (""1 1"")
else:
    reversed_indeks1=-1
    print(""reversed_indeks1: "", str(reversed_indeks1))
    for x in range(len(a)-1):
        if a[x] > a[x+1]:
            reversed_indeks1=x
            break
    print(""reversed_indeks1: "", str(reversed_indeks1))
    if reversed_indeks1 == -1:
        print (""yes"")
        print (""1 1"")
    else:
        reversed_indeks2=len(a)-1
        print(""reversed_indeks2: "", str(reversed_indeks2))
        for x in range(reversed_indeks1,len(a)-1):
            if a[x] < a[x+1]:
                reversed_indeks2=x
                break
        print(""reversed_indeks2: "", str(reversed_indeks2))
        asc=True
        if reversed_indeks2 != len(a)-1:
            asc=menaik(a,reversed_indeks2+1)
        print(""asc: "", str(asc))
        if asc:
            kiri=True
            kanan=True
            if reversed_indeks1 != 0:
                if a[reversed_indeks2] < a[reversed_indeks1-1]:
                    kiri=False
            print(""kiri: "", str(kiri))
            if reversed_indeks2 != len(a)-1:
                if a[reversed_indeks1] > a[reversed_indeks2+1]:
                    kanan=False
            print(""kanan: "", str(kanan))
            if kiri and kanan:
                print (""yes"")
                print (""%d %d""%(reversed_indeks1+1,reversed_indeks2+1))
            else:
                print (""no"")
        else:
            print (""no"")
</ans>",0,{}
77,"<ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
    if i == 2 * n + 1:
        nonlocal ans
        ans = ""Yes""
        return
    if ans == ""No"":
        if y[i] == 0:
            for k in range(1, n):
                if ok(k, i):
                    dfs(i + 2 * k)
        else:
            if ok(y[i], i):
                dfs(i + 2 * y[i])
    return

def ok(k, i):
    if k + i >= 2 * n + 1:
        return 0
    f = 1
    for l in range(k):
        if k + i + l >= 2 * n + 1:
            f = 0
            break
        if x[i + l] == 2 or x[k + i + l] == 1:
            f = 0
            break
        if not (y[i + l] == 0 or y[i + l] == k):
            f = 0
            break
        if not z[i + l] == z[k + i + l] and min(z[i + l], z[k + i + l]) >= 1:
            f = 0
            break
    return f

n = int(input())
print(""n: "", str(n))
ans = ""Yes""
x = [0] * (2 * n + 2)
y = [0] * (2 * n + 2)
z = [0] * (2 * n + 2)
for i in range(1, n + 1):
    a, b = map(int, input().split())
    print(""a: "", str(a), ""b: "", str(b))
    if a >= b and not (a == -1 or b == -1):
        ans = ""No""
    if not (x[a] == 0 and x[b] == 0):
        ans = ""No""
    if not a == -1:
        x[a] = 1
        z[a] = i
    if not b == -1:
        x[b] = 2
        z[b] = i
    if not (a == -1 or b == -1):
        y[a] = b - a
if ans == ""No"":
    print(ans)
    return
ans = ""No""
dfs(1)
print(ans)
</ans>",0,{}
78,"<ans>
n, m = map(int, input().split())
print(""n: "", str(n), ""m: "", str(m)

t = [0] * (n + 1)
print(""t: "", str(t))
p = [0] * (n + 1)
print(""p: "", str(p))
q = [[] for i in range(n + 1)] 
print(""q: "", str(q))

def f(x):
    for i in q[x]:
        u, v = i[0], i[1]
        if t[u] and t[v]: continue
        if t[u] and not t[v]:
            t[v] = 7 - t[x] - t[u]
            for j in q[v]:
                p[j[0]] |= t[v]
                p[j[1]] |= t[v]
            #f(u)
            f(v)
        elif not t[u] and t[v]:
            t[u] = 7 - t[x] - t[v]
            for j in q[u]:
                p[j[0]] |= t[u]
                p[j[1]] |= t[u]
            f(u)
            #f(v)
        else:
            for k in [1, 2, 4]:                
                t[u], t[v] = k, 7 - t[x] - k
                if not (p[u] & t[u] or p[v] & t[v]): break                    
            
            for j in q[v]:
                p[j[0]] |= t[v]
                p[j[1]] |= t[v]                
            for j in q[u]:
                p[j[0]] |= t[u]
                p[j[1]] |= t[u]
            f(u)
            f(v)

if m == 49999:
    for j in range(m):
        a, b, c = map(int, input().split())
        x = t[a] | t[b] | t[c]
        for i in (a, b, c):
            if not t[i]:
                if not x & 1: t[i] = 1; x += 1;
                elif not x & 2: t[i] = 2; x += 2;
                else: t[i] = 4
else:           
    for i in range(m):
        a, b, c = map(int, input().split())

        q[a].append((b, c))
        q[b].append((a, c))
        q[c].append((a, b))
        
    for x in range(1, n + 1):
        if not t[x]:
            t[x] = 1
            for j in q[x]:
                p[j[0]] |= 1
                p[j[1]] |= 1
            f(x)
        
p = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(''.join(p[x] for x in t[1:]))
</ans>",0,{}
79,"<ans>
def good(nums):
    for num in nums:
        if nums[num] > 1:
            return True
    return False

n = int(input())
print(""n: "", str(n))

a = [int(i) for i in input().split()]
print(""a: "", str(a))

s = []
print(""s: "", str(s))

l, r = 0, 0
print(""l: "", str(l), ""r: "", str(r))
nums = {}

for i in range(n):
    num = a[i]
    print(""num: "", str(num))

    if num in nums:
        break
    else:
        nums[num] = True
else:
    print(-1)
    return

nums = {}

while r < n:
    while r < n:
        num = a[r]
        print(""num: "", str(num))

        if num in nums:
            r += 1
            break
        else:
            nums[num] = True

        r += 1

    r -= 1

    s.append([l, r])
    r += 1
    l = r

    nums = {}

length = len(s)
print(""length: "", str(length))

last = s[length-1]
print(""last: "", str(last))

for i in range(last[0], last[1]+1):
    num = a[i]
    if num in nums:
        print(length)
        break
    else:
        nums[num] = True
else:
    s.pop()

    s[length-2][1] = n-1

    print(length-1)

for st in s:
    for c in st:
        print(c+1, end="" "")
    print()
</ans>",0,{}
80,"<ans>
import sys
input = sys.stdin.readline

G0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G0: "", str(G0))
G1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G1: "", str(G1))
G2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
print(""G2: "", str(G2))

for x in range(1,6):
    for y in range(1,6):
        for z in range(1,6):
            
            for i in range(1,5500):
                s=G0[x][y][z][max(0,i-x)]
                t=G1[x][y][z][max(0,i-y)]
                u=G2[x][y][z][max(0,i-z)]

                for j in range(5):
                    if j==s or j==t or j==u:
                        continue
                    else:
                        G0[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==s or j==u:
                        continue
                    else:
                        G1[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==s or j==t:
                        continue
                    else:
                        G2[x][y][z][i]=j
                        break

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

t=int(input())
for tests in range(t):
    n,x,y,z=list(map(int,input().split()))
    B=list(map(int,input().split()))
    A=[]
    for a in B:
        if a<=5400:
            A.append(a)
        else:
            A.append(a%2520+2520)

    XOR=0

    for a in A:
        XOR^=G0[x][y][z][a]

    ANS=0
    for a in A:
        k=XOR^G0[x][y][z][a]

        if G0[x][y][z][max(0,a-x)]==k:
            ANS+=1

        if G1[x][y][z][max(0,a-y)]==k:
            ANS+=1

        if G2[x][y][z][max(0,a-z)]==k:
            ANS+=1

    print(ANS)
</ans>",0,{}
81,"<ans>
x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
print(""x0: "", str(x0), ""y0: "", str(y0), ""a1: "", str(a1), ""a2: "", str(a2), ""b1: "", str(b1), ""b2: "", str(b2))
xs, ys, t = list(map(int, input().split()))
print(""xs: "", str(xs), ""ys: "", str(ys), ""t: "", str(t))
arr = []
print(""arr: "", str(arr))
arr.append((x0, y0))
print(""arr: "", str(arr))
now1 = x0
now2 = y0
print(""now1: "", str(now1), ""now2: "", str(now2))
while (1):
    now1 = a1 * now1 + b1
    now2 = a2 * now2 + b2
    print(""now1: "", str(now1), ""now2: "", str(now2))
    if (now1 < xs or now2 < ys):
        arr.append((now1, now2))
        print(""arr: "", str(arr))
        continue
    arr.append((now1, now2))
    print(""arr: "", str(arr))
    if (dist(now1, now2, xs, ys) > t):
        break
ans = 0
print(""ans: "", str(ans))
N = len(arr)
print(""N: "", str(N))
for i in range(N):
    need = dist(arr[i][0], arr[i][1], xs, ys)
    print(""need: "", str(need))
    if (need > t):
        continue
    left = t - need
    now = 1
    flag = 1
    now1 = arr[i][0]
    now2 = arr[i][1]
    for j in range(i - 1, -1, -1):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        if (d > left):
            flag = 0
            break
        left -= d
        now1 = arr[j][0]
        now2 = arr[j][1]
        now += 1
    if (not flag):
        ans = max(ans, now)
        print(""ans: "", str(ans))
        continue
    for j in range(i + 1, N):
        d = dist(now1, now2, arr[j][0], arr[j][1])
        if (d > left):
            break
        left -= d
        now1 = arr[j][0]
        now2 = arr[j][1]
        now += 1
    ans = max(ans, now)
    print(""ans: "", str(ans))
print(ans)
</ans>",0,{}
82,"<ans>
a, b, c = list(map(int, input().split()))
print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

def ct(a, b):
    if a > b:
        a, b = b, a
    L=998244353
    s=1
    sx=1
    for k in range(1,a+1):
        s = s*(a+1-k)*(b+1-k)//k
        sx += s % L
    return sx

L=998244353

print(ct(a,b)*ct(a,c)*ct(b,c)%L)
</ans>",0,{}
83,"<ans>
zz=1
di=[[-1,0],[1,0],[0,1],[0,-1]]
</ans>",0,{}
84,"<ans>
def local_right_to_global(test, local_right):
    return(len(test) + local_right)
    print(""local_right: "", str(local_right))

def local_left_to_global(test, local_left):
    return(local_left)
    print(""local_left: "", str(local_left))

def check_left(test, template, good_symbols):
    left_idx = -1
    print(""left_idx: "", str(left_idx))
    for symbol in template:
        left_idx += 1
        print(""left_idx: "", str(left_idx))
        if symbol == '*':
            return(local_left_to_global(test, left_idx))
        try:
            if test[left_idx] != template[left_idx]:
                if template[left_idx] != '?':
                    return('NO')
                elif test[left_idx] not in good_symbols:
                    return('NO')
        except:
            return('NO')

def check_right(test, template, good_symbols):
    right_idx = 0
    print(""right_idx: "", str(right_idx))
    for symbol in reversed(template):
        right_idx -= 1
        print(""right_idx: "", str(right_idx))
        if symbol == '*':
            return(local_right_to_global(test, right_idx))
        try:
            if test[right_idx] != template[right_idx]:
                if template[right_idx] != '?':
                    return('NO')
                elif test[right_idx] not in good_symbols:
                    return('NO')            
        except:
            return('NO')

good_symbols = set(list(input()))
print(""good_symbols: "", str(good_symbols))
template = input()
print(""template: "", str(template))
tests_nr = int(input())
print(""tests_nr: "", str(tests_nr))
tests = []
for _ in range(tests_nr):
    tests.append(input())
    print(""tests: "", str(tests))

abaca = '*' not in template
print(""abaca: "", str(abaca))
for test in tests:
    if abaca:
        pos = -1
        print(""pos: "", str(pos))
        flag = True
        if len(test) != len(template):
            print('NO')
            continue
        for symbol in template:
            pos += 1
            print(""pos: "", str(pos))
            try:
                if test[pos] != template[pos]:
                    if template[pos] != '?':
                        print('NO')
                        flag = False
                        break
                    elif test[pos] not in good_symbols:
                        print('NO')
                        flag = False
                        break
            except:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')
        continue
    left_idx = check_left(test, template, good_symbols)
    print(""left_idx: "", str(left_idx))
    right_idx = check_right(test, template, good_symbols)
    print(""right_idx: "", str(right_idx))
    # print(left_idx, right_idx)
    if left_idx == 'NO':
        print('NO')
    elif right_idx == 'NO':
        print('NO')
    else:
        if right_idx < left_idx - 1:
            print('NO')
            continue
        flag = True
        for pos in range(left_idx, right_idx + 1):
            if test[pos] in good_symbols:
                print('NO')
                flag = False
                break
        if flag:
            print('YES')
</ans>",0,{}
85,"<ans>
n = int(input())
print(""n: "", str(n))
x0, y0 = map(int, input().split())
print(""x0: "", str(x0), ""y0: "", str(y0))
Nord = 10 ** 9 + 1
print(""Nord: "", str(Nord))
fNord = '-'
print(""fNord: "", str(fNord))
East = 10 ** 9 + 1
print(""East: "", str(East))
fEast = '-'
print(""fEast: "", str(fEast))
South = -10 ** 9 - 1
print(""South: "", str(South))
fSouth = '-'
print(""fSouth: "", str(fSouth))
West = -10 ** 9 - 1
print(""West: "", str(West))
fWest = '-'
print(""fWest: "", str(fWest))

NE = 10 ** 9 + 1
print(""NE: "", str(NE))
fNE = '-'
print(""fNE: "", str(fNE))
NW = 10 ** 9 + 1
print(""NW: "", str(NW))
fNW = '-'
print(""fNW: "", str(fNW))
SE = -10 ** 9 - 1
print(""SE: "", str(SE))
fSE = '-'
print(""fSE: "", str(fSE))
SW = -10 ** 9 - 1
print(""SW: "", str(SW))
fSW = '-'
print(""fSW: "", str(fSW))

for i in range(n):
    f, x, y = input().split()
    print(""f: "", str(f), ""x: "", str(x), ""y: "", str(y))
    x = int(x)
    y = int(y)
    if x == x0:
        if y0 < y < Nord:
            fNord = f
            Nord = y
        elif y0 > y > South:
            fSouth = f
            South = y
    if y == y0:
        if x0 < x < East:
            fEast = f
            East = x
        elif x0 > x > West:
            fWest = f
            West = x
            
    if x + y == x0 + y0:
        if y0 < y < NW:
            fNW = f
            NW = y
        elif y0 > y > SE:
            fSE = f
            SE = y
    if x - y == x0 - y0:
        if y0 < y < NE:
            fNE = f
            NE = y
        elif y0 > y > SW:
            fSW = f
            SW = y
ans  = False
if fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':
    ans = True
if fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':
    ans = True
if fSW == 'B' or fSE == 'B' or fNW == 'B' or fNE == 'B':
    ans = True
if fNord == 'R' or fSouth == 'R' or fWest == 'R' or fEast == 'R':
    ans = True

#print(fSW, fSE, fNW, fNE) 
#print(fNord, fSouth, fWest, fEast)
print('YES' if ans else 'NO')
</ans>",0,{}
86,"<ans>
n = int(input())
print(""n: "", str(n)

s = input()
print(""s: "", str(s))

ans = int(n * (n - 1) / 2)
print(""ans: "", str(ans))
c = 0

for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0

for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0

s = s[::-1]

c = 0
for i in range(n):
    if s[i] == 'A':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0

for i in range(n):
    if s[i] == 'B':
        c += 1
    else:
        if c > 1:
            ans -= (c - 1)
        c = 0
c = 0

if s[0] == 'A':
    c += 1
for i in range(n):
    if s[i] == 'A':
        c += 1
    elif c >= 1:
        ans -= 1
        c = 0

c = 0
if s[0] == 'B':
    c += 1
for i in range(n):
    if s[i] == 'B':
        c += 1
    elif c >= 1:
        ans -= 1
        c = 0

print(ans)
</ans>",0,{}
87,"<ans>
def odd_v(value):
    print(""value: "", str(value))
    return 1 if value % 2 == 1 else -1

change_idx = 1
print(""change_idx: "", str(change_idx))

acceptable = {-1: set(), 1: set()}

def change(card_values, oddv, m):
    nonlocal change_idx
    print(""oddv: "", str(oddv))
    print(""m: "", str(m))
    print(""card_values: "", str(card_values))

    if acceptable[oddv]:
        res = acceptable[oddv].pop()
        card_values.add(res)
        return res

    change_idx_start = change_idx

    while change_idx in card_values or odd_v(change_idx) != oddv:
        if change_idx not in card_values:
            acceptable[odd_v(change_idx)].add(change_idx)
        change_idx += 1
        if change_idx > m:
            change_idx = 1
        if change_idx == change_idx_start:
            raise CantException()

    res = change_idx
    card_values.add(res)

    change_idx += 1
    if change_idx > m:
        change_idx = 1
    return res

def solve():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n))
    print(""m: "", str(m))
    cards = list(map(int, input().split()))
    print(""cards: "", str(cards))

    odd_balance = 0
    card_values = set()
    indices_to_be_changed = set()

    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
        if c in card_values:
            indices_to_be_changed.add(i)
        card_values.add(c)

    print(""indices to be changed: "", str(indices_to_be_changed))
    change_count = len(indices_to_be_changed)

    for i in indices_to_be_changed:
        if odd_v(cards[i]) * odd_balance <= 0:
            print(""Changing "", str(cards[i]))
            cards[i] = change(card_values, odd_v(cards[i]), m)
            print(""Changed to "", str(cards[i]))
        else:
            print(""For teh balance changing "", str(cards[i]))
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, - odd_v(cards[i]), m)
            print(""Changed to "", str(cards[i]))

    print(""current odd balance:"", str(odd_balance))
    for i in range(len(cards)):
        if odd_balance == 0:
            break
        if odd_v(cards[i]) * odd_balance > 0:
            print(""gonna change"")
            change_count += 1
            odd_balance -= 2 * odd_v(cards[i])
            cards[i] = change(card_values, -odd_v(cards[i]), m)

    odd_balance = 0
    for i, c in enumerate(cards):
        odd_balance += odd_v(c)
    if odd_balance != 0:
        print(odd_balance)
        print(""WTFFFFF"")

    return change_count, cards

def __starting_point():
    try:
        change_cnt, cards = solve()
        print(change_cnt)
        print("" "".join(map(str, cards)))
    except CantException:
        print(""-1"")

__starting_point()
</ans>",0,{}
88,"<ans>
def dp(ind, max_covered):
	print(""max_covered: "", str(max_covered))

	max_covered = min(m, max_covered)

	if ind not in cache:
		cache[ind] = {}

	d = cache[ind]
	if max_covered in d:
		return d[max_covered]

	ans = blah(ind, max_covered)

	d[max_covered] = ans
	return ans

class Node:
	def __init__(self, key, val, next=None):
		self.key = key
		self.val = val
		self.next = next

def blah(ind, max_covered):
	x, s = antenna[ind]
	print(""x: "", str(x), ""s: "", str(s))

	if max_covered >= m:
		return 0

	if ind == len(antenna) - 1:
		if max_covered < x - s - 1:
			left_needed = x - s - (max_covered + 1)
			right_needed = max(m - (x + s), 0)
			ans = max(left_needed, right_needed)
			return ans
		else:
			right_boundary = max(max_covered, x + s)
			ans = max(0, m - right_boundary)
			return ans

	if max_covered < x - s - 1:
		num_needed = x - s - (max_covered + 1)
		new_boundary = min(x + s + num_needed, m)
		use_i = num_needed + dp(ind + 1, new_boundary)
		dont_use_i = dp(ind + 1, max_covered)

		return min(use_i, dont_use_i)
	else:
		new_boundary = min(max(max_covered, x + s), m)
		ans = dp(ind + 1, new_boundary)
		return ans

import sys

cache = {}

n, m = [int(x) for x in sys.stdin.readline().split("" "")]

antenna = []

for i in range(n):
	x, s = [int(x) for x in sys.stdin.readline().split("" "")]
	print(""x: "", str(x), ""s: "", str(s))

	antenna.append((x, s))

antenna.sort(key=lambda a: a[0])

print(dp(0, 0))
</ans>",0,{}
89,"<ans>
import math;
#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(gx, gy, alpha, x, y):
    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);
    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);
    print(""x1: "", str(x1), ""y1: "", str(y1))
    return x1, y1
#Вычисление угла, на который надо повернуть точку с координатами x, y,
#чтобы она оказалась прямо над gx, gy
def getAngle(gx, gy, x, y):
    x=x-gx;
    y=y-gy;
    cos=x/math.sqrt(x**2+y**2);
    alpha=math.acos(cos);
    if y<0:
        alpha=-alpha;
    return math.pi/2-alpha;
n, q = list(map(int, input().split(' ')));
x=[0]*n;
y=[0]*n;
for i in range(n):
    x[i], y[i]=list(map(int, input().split(' ')));
r=[0]*q;
f=[0]*q;
t=[0]*q;
v=[0]*q;
for i in range(q):
    l=list(map(int, input().split(' ')));
    r[i]=l[0];
    if r[i]==1:
        f[i]=l[1]-1;
        t[i]=l[2]-1;
    else:
        v[i]=l[1]-1;
gx=0;
gy=0;
s=0;
for i in range(n):
    ip=i+1;
    if ip==n:
        ip=0;
    ds=x[i]*y[ip]-x[ip]*y[i];
    s+=ds;
    gx+=(x[i]+x[ip])*ds;
    gy+=(y[i]+y[ip])*ds;
s/=2;
gx/=6*s;
gy/=6*s;
angles=[0]*n;
for i in range(n):
    angles[i]=getAngle(gx, gy, x[i], y[i]);
for i in range(n):
    x[i]-=gx;
    y[i]-=gy;
alpha=0;
print('pos',gx, gy, alpha);
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
fix={0, 1}
for i in range(q):
    if r[i]==2:
        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);
        print(""%.6f %.6f""%(currX, currY))
    else:
        if len(fix)==2:
            fix.remove(f[i]);
        print('remove',f[i])
        #j - единственный элемент в множестве
        for j in fix:
            print(j);
            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);
            print('fix:', currX, currY)
            #dalpha=getAngle(gx, gy, currX, currY);
            #alpha+=dalpha;
            alpha=angles[j];
            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол
            #dalpha относительно currX, currY
            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);
            
            print('pos',gx, gy, alpha/math.pi)
        fix.add(t[i]);
</ans>",0,{}
90,"<ans>
import collections, atexit, math, sys, bisect 
print(""collections: "", str(collections), ""atexit: "", str(atexit), ""math: "", str(math), ""sys: "", str(sys), ""bisect: "", str(bisect))

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    
print(""getIntList: "", str(getIntList))

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    print(""numpy: "", str(numpy), ""dprint: "", str(dprint))
except Exception:
    def dprint(*args, **kwargs):
        pass
    print(""dprint: "", str(dprint)

inId = 0
outId = 0
print(""inId: "", str(inId), ""outId: "", str(outId))

if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
print(""N: "", str(N))

re = 1
mc = 1
zc = []
print(""re: "", str(re), ""mc: "", str(mc), ""zc: "", str(zc))

for i in range(2, 10000):
    if N%i != 0 : continue
    re *= i
    c = 0
    while N%i==0:
        N//=i
        c+=1
    
    zc.append(c)
print(""re: "", str(re), ""zc: "", str(zc))

if N>1:
    re*=N
    zc.append(1
print(""re: "", str(re), ""zc: "", str(zc))

if zc:
    mc = max(zc)
print(""mc: "", str(mc))

t =1 
for i in range(100):
    if mc<=t:
        break
    t*=2
print(""t: "", str(t))

print(""zc: "", str(zc))

g = i
for x in zc:
    if x<t:
        g+=1
        break

print(re,g)
</ans>",0,{}
91,"<ans>
n,m,o=value()
print(""n: "", str(n), ""m: "", str(m), ""o: "", str(o))

for i in range(n):
    input()

print(m*(m-1)//2)
for i in range(1,m+1):
    for j in range(i+1,m+1):
        if(o==0):
            print(i,j)
        else:
            print(m-i+1,m-j+1)
</ans>",0,{}
92,"<ans>
def solve1(a, n):  
    left=[]
    st=[]
    i=0
    while i<(n):
        if not st:
            left.append(-1)
            st.append(i)
            print(""left: "", str(left), ""st: "", str(st))
        elif st and a[i]<a[st[-1]]:
            left.append(st[-1])
            st.append(i)
            print(""left: "", str(left), ""st: "", str(st))
        else:
            while st and a[i]>a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                left.append(-1)
                print(""left: "", str(left), ""st: "", str(st))
            else:
                left.append(st[-1])
                st.append(i)
                print(""left: "", str(left), ""st: "", str(st))
        i+=1
    right=[]
    st=[]
    i=n-1
    while i>(-1):
        if not st:
            right.append(n)
            st.append(i)
            print(""right: "", str(right), ""st: "", str(st))
        elif st and a[i]<a[st[-1]]:
            right.append(st[-1])
            st.append(i)
            print(""right: "", str(right), ""st: "", str(st))
        else:
            while st and a[i]>=a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                right.append(n)
                print(""right: "", str(right), ""st: "", str(st))
            else:
                right.append(st[-1])
                st.append(i)
                print(""right: "", str(right), ""st: "", str(st))
        i-=1
    right=right[::-1]
    c=0
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        if x==0:
            c+=a[i]
        else:
            c+=x
    return c

def solve2(a, n): 
    left=[]
    st=[]
    i=0
    while i<(n):
        if not st:
            left.append(-1)
            st.append(i)
            print(""left: "", str(left), ""st: "", str(st))
        elif st and a[i]>a[st[-1]]:
            left.append(st[-1])
            st.append(i)
            print(""left: "", str(left), ""st: "", str(st))
        else:
            while st and a[i]<a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                left.append(-1)
                print(""left: "", str(left), ""st: "", str(st))
            else:
                left.append(st[-1])
                st.append(i)
                print(""left: "", str(left), ""st: "", str(st))
        i+=1
    right=[]
    st=[]
    i=n-1
    while i>(-1):
        if not st:
            right.append(n)
            st.append(i)
            print(""right: "", str(right), ""st: "", str(st))
        elif st and a[i]>a[st[-1]]:
            right.append(st[-1])
            st.append(i)
            print(""right: "", str(right), ""st: "", str(st))
        else:
            while st and a[i]<=a[st[-1]]:
                st.pop()
            if not st:
                st.append(i)
                right.append(n)
                print(""right: "", str(right), ""st: "", str(st))
            else:
                right.append(st[-1])
                st.append(i)
                print(""right: "", str(right), ""st: "", str(st))
        i-=1
    right=right[::-1]
    c=0
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        if x==0:
            c+=a[i]
        else:
            c+=x
    return c

n=int(input())
arr=[int(x) for x in input().split()]
print(solve1(arr,n)-solve2(arr,n))
</ans>",0,{}
93,"<ans>
import math
N=int(input())

def get_circle_2p(p1,p2):
  x1,y1=p1
  x2,y2=p2
  print(""x1: "", str(x1), ""y1: "", str(y1))
  print(""x2: "", str(x2), ""y2: "", str(y2))
  
  x=(x1+x2)/2
  y=(y1+y2)/2  
  r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
  print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
  return x,y,r

def get_circle_3p(p1,p2,p3):
  x1,y1=p1
  x2,y2=p2
  x3,y3=p3
  print(""x1: "", str(x1), ""y1: "", str(y1))
  print(""x2: "", str(x2), ""y2: "", str(y2))
  print(""x3: "", str(x3), ""y3: "", str(y3))
  d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))  
  print(""d: "", str(d))
  
  if d==0:
    rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
    rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2
    rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2
    print(""rad1: "", str(rad1), ""rad2: "", str(rad2), ""rad3: "", str(rad3)
    
    if rad1>=rad2 and rad1>=rad3:
      x=(x1+x2)/2
      y=(y1+y2)/2
      print(""x: "", str(x), ""y: "", str(y), ""rad1: "", str(rad1))
      return x,y,rad1
    elif rad2>=rad1 and rad2>=rad3:
      x=(x1+x3)/2
      y=(y1+y3)/2
      print(""x: "", str(x), ""y: "", str(y), ""rad2: "", str(rad2))
      return x,y,rad2
    elif rad3>=rad1 and rad3>=rad2:
      x=(x2+x3)/2
      y=(y2+y3)/2
      print(""x: "", str(x), ""y: "", str(y), ""rad3: "", str(rad3))
      return x,y,rad3      
  else:
    x=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/d
    y=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-d
    r=math.sqrt((x-x1)**2+(y-y1)**2)
    print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
    return x,y,r
  
xylist=[]
for i in range(N):
  xi,yi=map(int,input().split())
  xylist.append((xi,yi))
  print(""xi: "", str(xi), ""yi: "", str(yi)
  
#print(xylist)

if N==2:
  x,y,r=get_circle_2p(xylist[0],xylist[1])
  print(r)
else:
  min_radius=float(""inf"")
  for i in range(N):
    for j in range(i+1,N):
      #print(xylist[i],xylist[j])
      x,y,r=get_circle_2p(xylist[i],xylist[j])
      print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
      if r>min_radius:
        continue
      
      for l in range(N):
        if l==i or l==j:
          continue
          
        xl,yl=xylist[l]
        diff_xl=xl-x
        diff_yl=yl-y
        if math.sqrt(diff_xl**2+diff_yl**2)>r:
          break
      else:
        min_radius=r
  
  for i in range(N):
    for j in range(i+1,N):
      for k in range(j+1,N):
        #print(xylist[i],xylist[j],xylist[k])
        x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])
        print(""x: "", str(x), ""y: "", str(y), ""r: "", str(r))
        if r>min_radius:
          continue
        
        for l in range(N):
          if l==i or l==j or l==k:
            continue
            
          xl,yl=xylist[l]
          diff_xl=xl-x
          diff_yl=yl-y
          if math.sqrt(diff_xl**2+diff_yl**2)>r:
            break
        else:
          min_radius=r
  
  print(min_radius)
</ans>",0,{}
94,"<ans>
def fact(a, b):
	c = []
	ans = 0
	f = int(math.sqrt(a))
	for i in range(1, f + 1):
		if a % i == 0:
			c.append(i)
	l = len(c)
	for i in range(l):
		c.append(a // c[i])
	for i in range(len(c)):
		if c[i] <= b:
			ans += 1
	if a / f == f and b >= f:
		return ans - 1
	return ans

t = int(input())
print(""t: "", str(t))
for i in range(t):
	x, y = list(map(int, input().split()))
	print(""x: "", str(x), ""y: "", str(y))
	if x >= y:
		print('YES')
		continue
	if x == 2 and y == 3:
		print('YES')
		continue
	elif x <= 3 and y > 3:
		print('NO')
		continue
	if x == 1:
		print('NO')
	else:
		print('YES')
</ans>",0,{}
95,"<ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(x) for x in input().split('')]
print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k)

if k&1:
  print('IMPOSSIBLE')
  return

s = [None]*n
print(""s: "", str(s))
for i in range(n):
  s[i] = [None]*m
  t = input()
  print(""t: "", str(t))
  for j in range(m):
    s[i][j] = t[j]
    if t[j] == 'X': x, y = j, i
    print(""s[i][j]: "", str(s[i][j]), ""x: "", str(x), ""y: "", str(y))

def bfs(x, y):
  res = [[10000000]*m for i in range(n)]
  print(""res: "", str(res))
  if s[y][x] == '*': return res
  q = Queue()
  q.put((x, y))
  step = 0

  def add(x, y):
    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return
    q.put((x, y))
    res[y][x] = step+1
    print(""x: "", str(x), ""y: "", str(y))

  res[y][x] = step

  while not q.empty():
    x, y = q.get()
    step = res[y][x]
    #print('-')
    if y < n-1: add(x, y+1) #D
    if x > 0: add(x-1, y)   #L
    if x < m-1: add(x+1, y) #R
    if y > 0: add(x, y-1)   #U
  return res

res = bfs(x, y)
print(""res: "", str(res))

path = []
add = lambda s: path.append(s)
for i in range(k):
  step = k-i
  #print(step, (y, x), k-i)
  if y < n-1 and res[y+1][x] <= step: #D
    add('D')
    y = y+1
  elif x > 0 and res[y][x-1] <= step: #L
    add('L')
    x = x-1
  elif x < m-1 and res[y][x+1] <= step: #R
    add('R')
    x = x+1
  elif y > 0 and res[y-1][x] <= step: #U
    add('U')
    y = y-1
  else:
    print('IMPOSSIBLE')
    return

print(str.join('', path))
</ans>",0,{}
96,"<ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

inf = float('inf')
Edge = namedtuple('Edge', 'start, end, cost')
print(""Edge: "", str(Edge))

def make_edge(start, end, cost=1):
    return Edge(start, end, cost)
print(""make_edge: "", str(make_edge))

class Graph:
    def __init__(self, edges, bi=True):
        wrong_edges = [i for i in edges if len(i) not in [2, 3]]
        if wrong_edges:
            raise ValueError('Wrong edges data: {}'.format(wrong_edges))
        self.edges = [make_edge(*edge) for edge in edges]
        print(""self.edges: "", str(self.edges))
        self.vertices = set(
            sum(
                ([edge.start, edge.end] for edge in self.edges), []
            ))
        print(""self.vertices: "", str(self.vertices))
        self.neighbors = {vertex: set() for vertex in self.vertices}
        print(""self.neighbors: "", str(self.neighbors))
        for edge in self.edges:
            self.neighbors[edge.start].add(edge.end)
            print(""edge.start: "", str(edge.start))
            print(""edge.end: "", str(edge.end))

    def get_node_pairs(self, n1, n2, both_ends=True):
        if both_ends:
            node_pairs = [[n1, n2], [n2, n1]]
        else:
            node_pairs = [[n1, n2]]
        print(""node_pairs: "", str(node_pairs))
        return node_pairs

    def remove_edge(self, n1, n2, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        edges = self.edges[:]
        for edge in edges:
            if[edge.start, edge.end] in node_pairs:
                self.edges.remove(edge)
                print(""edge.start: "", str(edge.start))
                print(""edge.end: "", str(edge.end))

    def add_edge(self, n1, n2, cost=1, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        for edge in self.edges:
            if [edge.start, edge.end] in node_pairs:
                return ValueError('Edge {} {} already exists'.format(n1, n2))
        print(""n1: "", str(n1))
        print(""n2: "", str(n2))
        print(""cost: "", str(cost))

        self.edges.append(Edge(start=n1, end=n2, cost=cost))
        if both_ends:
            self.edges.append(Edge(start=n2, end=n1, cost=cost))

    def dijkstra(self, source, dest):
        assert source in self.vertices, 'Such source node doesn\'t exist'
        distances = {vertex: inf for vertex in self.vertices}
        distances[source] = 0
        print(""distances: "", str(distances))

        q, seen = [(0, source)], set()
        while q:
            (curr_cost, current_vertex) = heappop(q)
            if current_vertex in seen:
                continue
            seen.add(current_vertex)
            for neighbor in self.neighbors[current_vertex]:
                cost = 1
                if neighbor in seen:
                    continue
                alternative_route = distances[current_vertex] + cost
                if alternative_route < distances[neighbor]:
                    distances[neighbor] = alternative_route
                    heappush(q, (alternative_route, neighbor))
                    print(""alternative_route: "", str(alternative_route))
                    print(""neighbor: "", str(neighbor))

        return distances
        print(""distances: "", str(distances))


n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]
print(""n: "", str(n))
print(""m: "", str(m))
print(""s: "", str(s))
print(""t: "", str(t))

verts = []
for i in range(m):
    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
    print(""verts: "", str(verts))
rev_verts = []
for i in verts:
    rev_verts.append((i[1], i[0]))
    print(""rev_verts: "", str(rev_verts))
for i in rev_verts:
    verts.append(i)
    print(""verts: "", str(verts))
graph = Graph(verts)
s_dist = graph.dijkstra(s, t)
t_dist = graph.dijkstra(t, s)
SHORTEST_DIST = s_dist[t]
count = 0
print(""SHORTEST_DIST: "", str(SHORTEST_DIST))

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        if j not in graph.neighbors[i] and \
                i not in graph.neighbors[j] and \
                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \
                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:
            count = count + 1
            print(""count: "", str(count))

print(count)
</ans>",0,{}
97,"<ans>
N,K = readInts()
print(""N: "", str(N), ""K: "", str(K))
def calc(n):
    if n <= 0 or n > 2*N:
        return 0
    else:
        return min(n-1, 2*N-n+1)
ans = 0
for AB in range(2*N+1):
    print(""AB: "", str(AB))
    ans += calc(AB) * calc(AB-K)
print(""ans: "", str(ans))
</ans>",0,{}
98,"<ans>
def solve():
    N, K = MI()
    print(""N: "", str(N), ""K: "", str(K))
    A = LI()
    print(""A: "", str(A))

    M = sum(A)
    print(""M: "", str(M))
    divs = []
    for i in range(1, int(pow(M, 0.5))+1):
        if M % i: continue
        divs.append(i)
        if i != M//i: divs.append(M//i)
    divs.sort(reverse=True)

    for d in divs:
        B = list([x%d for x in A])
        print(""d: "", str(d), ""B: "", str(B))
        B.sort()
        C = list([d-x for x in B])
        print(""C: "", str(C))
        Ba = list(accumulate(B))
        print(""Ba: "", str(Ba))
        Ca = list(accumulate(C))
        print(""Ca: "", str(Ca))
        for i in range(0, N-1):
            b = Ba[i]
            c = Ca[-1] - Ca[i]
            print(""b: "", str(b), ""c: "", str(c))
            if b == c and b <= K:
                print(d)
                return
    print((1))


def __starting_point():
    solve()

__starting_point()
</ans>",0,{}
99,"<ans>
import sys

def matching(node, visited, adj, assigned):
	print(""node: "", str(node), ""visited: "", str(visited))
	if node == -1:
		return True
	if visited[node]:
		return False
	visited[node] = True
	for neighbor in adj[node]:
		if matching(assigned[neighbor], visited, adj, assigned):
			assigned[neighbor] = node
			return True
	return False

INF = 1000 * 1000

inp = [int(x) for x in sys.stdin.read().split()]
print(""inp: "", str(inp))

n, m = inp[0], inp[1]
print(""n: "", str(n), ""m: "", str(m))
inp_idx = 2

G = [[INF] * n for _ in range(n)]
print(""G: "", str(G))

for _ in range(m):
	a, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1
	inp_idx += 2
	G[a][b] = G[b][a] = 1

for v in range(n):
	G[v][v] = 0
	
for k in range(n): 
	for i in range(n): 
		for j in range(n): 
			G[i][j] = min(G[i][j], G[i][k] + G[k][j])
	
s, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]
print(""s: "", str(s), ""b: "", str(b), ""k: "", str(k), ""h: "", str(h))
inp_idx += 4

spaceships = []
for _ in range(s):
	x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]
	inp_idx += 3
	spaceships.append((x, a, f))
print(""spaceships: "", str(spaceships))
	
bases = []
for _ in range(b):
	x, d = inp[inp_idx] - 1, inp[inp_idx + 1]
	inp_idx += 2
	bases.append((x, d))
print(""bases: "", str(bases))
	
adj = [[] for _ in range(s)]
assigned = [[] for _ in range(b)]
for i in range(s):
	space = spaceships[i]
	for j in range(b):
		base = bases[j]
		u, v = space[0], base[0]
		fuel = space[2]
		if G[u][v] <= fuel and space[1] >= base[1]:
			adj[i].append(j)

visited = [False] * s
assigned = [-1] * b

matched = 0
for i in range(s):
	visited = [False] * s
	if matching(i, visited, adj, assigned):
		matched += 1


print(min(matched * k, h * s))
</ans>",0,{}
100,"<ans>
def iin(): 
    print(""n: "", str(n))
    return int(input())

def lin(): 
    print(""a: "", str(a), ""t: "", str(t))
    return list(map(int, input().split()))

def main():
    import heapq as hq
    n = iin()
    print(""n: "", str(n))
    a = lin()
    print(""a: "", str(a))
    t = lin()
    print(""t: "", str(t))
    dc = {}
    for i in range(n):
        try:
            dc[a[i]].append(t[i])
        except:
            dc[a[i]] = [t[i], ]
    print(""dc: "", str(dc))
    sa = list(dc.keys())
    sa.sort()
    n = len(sa)
    ch = 0
    pt = sa[ch]
    temp = []
    sm = 0
    ans = 0
    hq.heapify(temp)
    done = 0
    while ch < n:
        print(""temp: "", str(temp), ""sa[ch]: "", str(sa[ch]))
        pt = sa[ch]
        if len(dc[pt]) > 1 or done:
            a1 = sorted(dc[pt])
            for item in a1:
                hq.heappush(temp, -item)
                sm += item
            x = hq.heappop(temp) * (-1)
            dc[pt] = [x]
            sm -= x
            while len(temp):
                print('A', ch, pt, temp )
                ans += sm
                pt += 1
                if pt in dc:
                    ch += 1
                    done = 1
                    break
                else:
                    x = hq.heappop(temp) * (-1)
                    sm -= x
            else:
                done = 0
        else:
            ch += 1
            done = 0
    print(""dc: "", str(dc))
    print(ans)

main()
</ans>",0,{}
101,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
print(""ORDA: "", str(ORDA))
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return [int(i) for i in input().split()]
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=1):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

for _ in range(ii()):
    a, b = mi()
    print(""a: "", str(a), ""b: "", str(b))
    print(b - a % b) if a % b else print(0)
</ans>",0,{}
102,"<ans>
def add(a,b):
    a = a%(1000000000+7)
    b=b%(1000000000+7)
    return (a+b)%(1000000000+7)

n  =int(input())
print(""n: "", str(n))
i=1
statements = []
dp = [[0 for i in range(n)] for i in range(n)]
prefix = [[0 for i in range(n)] for i in range(n)]
while(i<=n):
    s = input()
    print(""s: "", str(s))
    statements.append(s)
    i+=1

dp[0][0]=1
prefix[0][0]=1
j=1
while(j<n):
    dp[0][j]=0
    prefix[0][j] = dp[0][j] + prefix[0][j-1]
    j+=1

i=1
while(i<n):
    if(statements[i-1]=='f'):
        j=1
        while(j<n):
            dp[i][0]=0
            prefix[i][0]=0
            dp[i][j] = dp[i-1][j-1]
            prefix[i][j] = add(prefix[i][j-1],dp[i][j])
            j+=1
    else:
        j=0
        while(j<n):
            if(j==0):
                dp[i][j] = prefix[i-1][n-1]
            else:
                dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
            prefix[i][j] = add(prefix[i][j-1],dp[i][j])
            j+=1
        # print(prefix)
    i+=1

ans = 0
j=0
while(j<n):
    ans=add(ans,dp[n-1][j])
    j+=1

print(ans%(1000000000+7))
</ans>",0,{}
103,"<ans>
def compute():
    n, m = [int(s) for s in input().split()]
    print(""n: "", str(n), ""m: "", str(m)
    p = {}
    for i in range(m):
        u, v = [int(s) for s in input().split()]
        print(""u: "", str(u), ""v: "", str(v))
        if u > v:
            if p.get(u) == 2:
                return 0
            if p.get(v) == 1:
                return 0
            p[u] = 1
            p[v] = 2
        else:
            if p.get(v) == 2:
                return 0
            if p.get(u) == 1:
                return 0
            p[v] = 1
            p[u] = 2
    div1, div2 = [], []
    for k, v in list(p.items()):
        if v == 1:
            div1.append(k)
        else:
            div2.append(k)
    p_left = [i for i in range(1, n + 1) if i not in p]
    print(""div1: "", str(div1), ""div2: "", str(div2), ""p_left: "", str(p_left))
    if not div1:
        if p_left:
            div1.append(p_left[-1])
            p_left.remove(p_left[-1])
        else:
            return 0
    if not div2:
        if p_left:
            div2.append(p_left[0])
            p_left.remove(p_left[0])
        else:
            return 0
    div1_easiest = min(div1)
    div2_hardest = max(div2)
    if div2_hardest > div1_easiest:
        return 0

    res = 1
    for i in range(len(p_left)):
        if p_left[i] > div1_easiest:
            pass
        elif p_left[i] < div2_hardest:
            pass
        else:
            res += 1

    return res
res = compute()
print(res)
</ans>",0,{}
104,"<ans>
class SolutionImpossible(Exception):
    pass

blocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]
print(""blocks_cnt: "", str(blocks_cnt), ""finish: "", str(finish), ""min_sprint: "", str(min_sprint), ""max_jump: "", str(max_jump)

def read_blocks_coords():
    it = (int(x) for x in input().split())
    return (x for x in it if x < finish)

def _grouper(value):
    if _grouper._prev_value is not None:
        if value - _grouper._prev_value - 1 <= min_sprint:
            _current_key = _grouper._current_key
        else:
            _current_key = id(value)
    else:
        _current_key = id(_grouper)

    _grouper._prev_value = value
    _grouper._current_key = _current_key

    return _current_key

def check_chunk(run_from, block=None):
    if block is None:
        return

    next_run_from = block[-1] + 1
    if next_run_from - block[0] >= max_jump:
        raise SolutionImpossible

    if abs(run_from - block[0]) <= min_sprint:
        raise SolutionImpossible

def solve_chunk(run_from, block=None):
    if block is not None:
        run_len = block[0] - run_from - 1
        jump_len = block[-1] - block[0] + 2
        print(
            ""RUN {run_len}\n""
            ""JUMP {jump_len}"".format(
                run_len=run_len,
                jump_len=jump_len,
            )
        )

    else:
        run_len = finish - run_from
        if run_len > 0:
            print(""RUN {run_len}"".format(run_len=run_len))

def main():
    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))

    chunks = []

    run_from = 0
    while True:
        block = next(blocks, None)

        chunk = (run_from, block)
        check_chunk(*chunk)

        chunks.append(chunk)

        if block is None:
            break

        run_from = block[-1] + 1

    for chunk in chunks:
        solve_chunk(*chunk)

def __starting_point():
    try:
        main()
    except SolutionImpossible:
        print(""IMPOSSIBLE"")

__starting_point()
</ans>",0,{}
105,"<ans>
def isPrefix(sa, sb):
    if len(sa) <= len(sb):
        return False
    return sa[0:len(sb)] == sb

def getOrder(sa, sb):
    for i in range(0, min(len(sa), len(sb))):
        if sa[i] != sb[i]: 
            return sa[i], sb[i]

test = False
if test:
    fp = open(""in.txt"", 'r')
    n = int(fp.readline().strip())
    names = [fp.readline().strip() for i in range(0, n)]
    fp.close()
else:
    n = int(input().strip())
    names = [input().strip() for i in range(0, n)]
print(""n: "", str(n), ""names: "", str(names))
 
g = [[False] * 26 for i in range(0, 26)]

res = True
for i in range(1, n):
    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):
        continue
    elif isPrefix(names[i - 1], names[i]):
        res = False
        break
    else:
        ca, cb = getOrder(names[i - 1], names[i])
        print(""ca: "", str(ca), ""cb: "", str(cb))
        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:
            res = False
            break
        else:
            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True

def printG():
    print(""   abcdefghijklmnopqrstuvwxyz"")
    for i in range(0, 26):
        print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in g[i]]), sep = """")

if not res:
    print(""Impossible"")
else:
    
    def getZeroIndegreeNode():
        for i in range(0, 26):
            if not used[i] and indegree[i] == 0:
                return i
        return -1
    #topo sort
    theOrder = []
    indegree = [0] * 26
    used = [False] * 26
    
    #calc indegree
    for i in range(0, 26):
        ithIndegree = 0
        for j in range(0, 26):
           if g[j][i]: ithIndegree += 1
        indegree[i] = ithIndegree
    for i in range(0, 26):
        zeroIndegreeNode = getZeroIndegreeNode()
        if zeroIndegreeNode == -1:
            res = False
            break
        else:
            used[zeroIndegreeNode] = True
            theOrder.append(chr(ord('a') + zeroIndegreeNode))
            for j in range(0, 26):
                if g[zeroIndegreeNode][j]:
                    indegree[j] -= 1
    if not res:
        print(""Impossible"")
    else:
        print("""".join(theOrder))
</ans>",0,{}
106,"<ans>
class UnionFind:
    # 作りたい要素数nで初期化
    # 使用するインスタンス変数の初期化
    def __init__(self, n):
        self.n = n
        print(""n: "", str(n))
        # root[x]<0ならそのノードが根かつその値が木の要素数
        # rootノードでその木の要素数を記録する
        self.root = [-1] * (n + 1)
        print(""root: "", str(self.root))
        # 木をくっつける時にアンバランスにならないように調整する
        self.rnk = [0] * (n + 1)
        print(""rnk: "", str(self.rnk))

    # ノードxのrootノードを見つける
    def Find_Root(self, x):
        if self.root[x] < 0:
            return x
        else:
            # ここで代入しておくことで、後の繰り返しを避ける
            self.root[x] = self.Find_Root(self.root[x])
            return self.root[x]

    # 木の併合、入力は併合したい各ノード
    def Unite(self, x, y):
        # 入力ノードのrootノードを見つける
        x = self.Find_Root(x)
        y = self.Find_Root(y)
        # すでに同じ木に属していた場合
        if x == y:
            return
        # 違う木に属していた場合rnkを見てくっつける方を決める
        elif self.rnk[x] > self.rnk[y]:
            self.root[x] += self.root[y]
            self.root[y] = x

        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            # rnkが同じ（深さに差がない場合）は1増やす
            if self.rnk[x] == self.rnk[y]:
                self.rnk[y] += 1

    # xとyが同じグループに属するか判断
    def isSameGroup(self, x, y):
        return self.Find_Root(x) == self.Find_Root(y)

    # ノードxが属する木のサイズを返す
    def Count(self, x):
        return -self.root[self.Find_Root(x)]


def main():
    n, m = list(map(int, input().split()))
    print(""n: "", str(n), ""m: "", str(m))
    uf = UnionFind(n)

    for i in range(m):
        a, b = list(map(int, input().split()))
        print(""a: "", str(a), ""b: "", str(b))
        uf.Unite(a, b)

    for i in range(n):
        i += 1
        uf.isSameGroup(i, i)

    ans = 0
    for i in range(n):
        ans = max(ans, -uf.root[i + 1])

    # print(uf.root)
    print(""ans: "", str(ans))


main()
</ans>",0,{}
107,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    a,b,c = arrIN()
    print((a+b+c)//2)
</ans>",0,{}
108,"<ans>
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))

flag = True
if n == 1:
    if s == '0':
        print(pow(10, 10))
    elif s == '1':
        print(pow(10, 10) * 2)
elif n == 2:
    if s in ['11', '10']:
        print(pow(10, 10))
    elif s == '01':
        print(pow(10, 10) - 1)
    else:
        print(0)
else:
    flag = True
    f = n // 3
    r = n % 3
    for i in range(0, n, 3):
        if i == 0:
            ans = s[0:3]
            if ans not in ['110', '101', '011']:
                flag = False
                break
        elif i < 3 * f:
            tmp = s[i:i + 3]
            if tmp != ans:
                flag = False
                break
        else:
            tmp = s[i:n]
            if tmp != ans[0:n - i]:
                flag = False
                break
    if not flag:
        print(0)
    else:
        if ans == '110':
            if r == 0:
                print(pow(10, 10) - f + 1)
            else:
                print(pow(10, 10) - f)
        elif ans == '101':
            print(pow(10, 10) - f)
        elif ans == '011':
            if r < 2:
                print(pow(10, 10) - f)
            else:
                print(pow(10, 10) - f - 1)
</ans>",0,{}
109,"<ans>
def smart(x):
    if x in d:
        return d[x]
    if (x & (x+1)) == 0:
        i = 0
        while ((1<<i)-1) != x:
            i += 1
        if i % 2 == 0:
            z = 0
            for i in range(0,i,2):
                z += (1<<i)
            return z
        else:
            return 1
    else:
        i = 1
        z = 0
        while i < x:
            if (i & x) == 0:
                z += i
            i *= 2
        return x+z

q = mint()
print(""q: "", str(q))
for i in range(q):
    x = mint()
    print(""x: "", str(x))
    print(smart(x))
    #if (x & (x+1)) == 0:
    #    a = stupid(x)
    #    b = smart(x)
    #    if a != b:
    #        print(x,a,b)
</ans>",0,{}
110,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 1000010
MOD = 10**9+7
spf = [i for i in range(MAXN)]
print(""spf: "", str(spf))
spf[0]=spf[1] = -1
def sieve():
    for i in range(2,MAXN,2):
        spf[i] = 2
    for i in range(3,int(MAXN**0.5)+1):
        if spf[i]==i:
            for j in range(i*i,MAXN,i):
                if spf[j]==j:
                    spf[j]=i
def fib(n,m):
    if n == 0:
        return [0, 1]
    else:
        a, b = fib(n // 2)
        c = ((a%m) * ((b%m) * 2 - (a%m)))%m
        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m
        if n % 2 == 0:
            return [c, d]
        else:
            return [d, c + d]
 
def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))
 
def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x))
 
def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD
 
    return (num*(pow(den,MOD-2,MOD)))%MOD
 
def flush():
    return sys.stdout.flush()
 
'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n = int(input())
    if n%2:
        print(n//2)
    else:
        print(n//2-1)
</ans>",0,{}
111,"<ans>
def a1(x, y, z):
    return (y ** z) * Decimal(log(x))
print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))

def s1(x, y, z):
    return ""x^y^z""

def a2(x, y, z):
    return (z ** y) * Decimal(log(x))

def s2(x, y, z):
    return ""x^z^y""

def a3(x, y, z):
    return (y * z) * Decimal(log(x))

def s3(x, y, z):
    return ""(x^y)^z""

def a4(x, y, z):
    return (y * z) * Decimal(log(x))

def s4(x, y, z):
    return ""(x^z)^y""

def a5(x, y, z):
    return (x ** z) * Decimal(log(y))

def s5(x, y, z):
    return ""y^x^z""

def a6(x, y, z):
    return (z ** x) * Decimal(log(y))

def s6(x, y, z):
    return ""y^z^x""

def a7(x, y, z):
    return (x * z) * Decimal(log(y))

def s7(x, y, z):
    return ""(y^x)^z""

def a8(x, y, z):
    return (z * x) * Decimal(log(y))

def s8(x, y, z):
    return ""(y^z)^x""

def a9(x, y, z):
    return (x ** y) * Decimal(log(z))

def s9(x, y, z):
    return ""z^x^y""

def a10(x, y, z):
    return (y ** x) * Decimal(log(z))

def s10(x, y, z):
    return ""z^y^x""

def a11(x, y, z):
    return (x * y) * Decimal(log(z))

def s11(x, y, z):
    return ""(z^x)^y""

def a12(x, y, z):
    return (y * x) * Decimal(log(z))

def s12(x, y, z):
    return ""(z^y)^x""

x, y, z = list(map(Decimal, input().split()))
print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
ans = s1(x, y, z)
a = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]
s = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]
max = a1(x, y, z)
for i in range (12):
    if max < a[i](x, y, z):
        ans = s[i](x, y, z)
        max = a[i](x, y, z)
print(ans)
</ans>",0,{}
112,"<ans>
s = input()

cur_len = 1
print(""cur_len: "", str(cur_len))
a = []
print(""a: "", str(a))
char = []
print(""char: "", str(char))
for i in range(1, len(s)):
    if s[i] == s[i-1]: cur_len += 1
    else:
      a.append(cur_len)
      print(""a: "", str(a))
      char.append(s[i-1])
      print(""char: "", str(char))
      cur_len = 1
      
a.append(cur_len)
print(""a: "", str(a))
char.append(s[len(s)-1])
print(""char: "", str(char))

ans = 0
print(""ans: "", str(ans))
while len(a) > 1:
    n = len(a)
    inner_min = 100000000
    print(""inner_min: "", str(inner_min))
    for i in range(1,n-1):
        if a[i] < inner_min: inner_min = a[i]
    print(""inner_min: "", str(inner_min))
        
    k = min(a[0], a[n-1],(inner_min + 1)//2)
    print(""k: "", str(k))
    b = []
    print(""b: "", str(b))
    new_char = []
    print(""new_char: "", str(new_char))
    for i in range(n):
        if i == 0 or i == n-1:
            if a[i] > k:
                b.append(a[i]-k)
                print(""b: "", str(b))
                new_char.append(char[i])
                print(""new_char: "", str(new_char))
        else:
            if a[i] > 2*k:
                b.append(a[i] - 2*k)
                print(""b: "", str(b))
                new_char.append(char[i])
                print(""new_char: "", str(new_char))
##    print(b)
    ans += k
    print(""ans: "", str(ans))
    if len(b) > 1:
        c = [0]*n
        print(""c: "", str(c))
        newnew_char = [new_char[0]]
        print(""newnew_char: "", str(newnew_char))
        count = 0
        print(""count: "", str(count))
    
        for i in range(0,len(b)-1):
            c[count] += b[i]
            if new_char[i] == new_char[i+1]: continue
            else:
                count += 1
                newnew_char.append(new_char[i+1])
        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]
        else:
            #count += 1
            newnew_char.append(new_char[i+1])
            c[count] = b[len(b)-1]
        a = c[:count+1]
        print(""a: "", str(a))
        char = newnew_char[:]
        print(""char: "", str(char))
    else:
        a = b[:]
        print(""a: "", str(a))

print(ans)
</ans>",0,{}
113,"<ans>
a,r,l,m = list(map(int,input().split()))
print(""a: "", str(a), ""r: "", str(r), ""l: "", str(l), ""m: "", str(m))
_l = list(map(int,input().split()))
print(""_l: "", str(_l))
s = set(_l)
print(""s: "", str(s))
if(abs(a)>l):
    print(0)
    return
if(a==0):
    if(0 in s):
        print(0)
        return
    else:
        print(""inf"")
        return
if(r==0):
    if(a==0):
        if(0 in s):
            print(0)
            return
        else:
            print(""inf"")
            return
    else:
        if(a not in s):
            if(abs(a)<=l):
                if(0 in s):
                    print(1)
                    return
                else:
                    print(""inf"")
                    return
            else:
                print(0)
                return
        else:
            if(0 in s):
                print(0)
                return
            else:
                print(""inf"")
                return
if(r==1):
    if(a in s or abs(a)>l):
        print(0)
        return
    else:
        print(""inf"")
        return
if(r==-1):
    if(a in s):
        if(0-a in s):
            print(0)
            return
        else:
            if(abs(a)<=l):
                print(""inf"")
                return
            else:
                print(0)
                return
    else:
        if(abs(a)<=l):
            print(""inf"")
            return
        else:
            print(0)
            return
tot = 0
while(abs(a)<=l):
    if(a not in s):
        tot+=1
    a*=r
print(tot)
</ans>",0,{}
114,"<ans>
    def readInput(self):
        self.N = int(input())
        print(""N: "", str(self.N))
        self.boards = []
        print(""boards: "", str(self.boards))
        for i in range(self.N):
            self.boards.append(list(input()))
</ans>",0,{}
115,"<ans>
def solve():
    S = Scanner.string()
    print(""S: "", str(S)
    N = len(S)
    print(""N: "", str(N))
    K = Scanner.int()
    print(""K: "", str(K))
    dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]
    print(""dp: "", str(dp))
    dp[0][0][0] = 1
    for i in range(N):
        for j in range(4):
            for k in range(2):
                nd = int(S[i])
                for d in range(10):
                    ni, nj, nk = i + 1, j, k
                    if d != 0:
                        nj += 1
                    if nj > K:
                        continue
                    if k == 0:
                        if d > nd:
                            continue
                        if d < nd:
                            nk += 1
                    dp[ni][nj][nk] += dp[i][j][k]
    print((dp[N][K][0] + dp[N][K][1]))
</ans>",0,{}
116,"<ans>
import heapq


INF = float('inf')
N, M = map(int, input().split())
to = [[] for _ in range(N)]
print(""N: "", str(N), ""M: "", str(M))

#sides[i][j] : i-->jへ向かう辺を通るかどうかを保持
# 1 : 通る、0 : 通らない
sides = [[0] * N for _ in range(N)]
print(""sides: "", str(sides))

for _ in range(M):
    a, b, c = map(int, input().split())
    a, b = a - 1, b - 1
    to[a].append((c, b))
    to[b].append((c, a))
    sides[a][b] = 1 #a, b間に辺がある
    sides[b][a] = 1
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

# dijkstraで最短経路木をつくる
def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq) 
    cost = [[INF, []] for i in range(N)]
    cost[s][0] = 0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v][0]:
            continue
        for d, u in to[v]:
            tmp = d + cost[v][0]
            if tmp < cost[u][0]:
                cost[u][0] = tmp
                cost[u][1] = [v] # 更新する場合は直前の頂点を保持
                heapq.heappush(hq, (tmp, u))
            elif tmp == cost[u][0]:
                cost[u][1].append(v) # 距離が等しい場合はリストで直前の頂点を保持  
                heapq.heappush(hq, (tmp, u))
    return cost


# 作成した最短経路木を探索して、通る辺を調べる
def dfs(v, tree, p=-1):
    if p >= 0:
        sides[v][p] = 0
        sides[p][v] = 0
    for nv in tree[v][1]:
        dfs(nv, tree, v)


def main():
    for s in range(N):
        tree = dijkstra(s)
        for g in range(N):
            dfs(g, tree)

    print(sum(sum(column) for column in sides) // 2)


def __starting_point():
    main()
__starting_point()
</ans>",0,{}
117,"<ans>
n, k = mints()
print(""n: "", str(n), ""k: "", str(k)
q = list(mints())
print(""q: "", str(q))
for i in range(n):
	q[i] -= 1
s = list(mints())
print(""s: "", str(s))
a = [i for i in range(1,n+1)]
print(""a: "", str(a))
d = [0]*n
print(""d: "", str(d))
b = [False]*(k+1)
print(""b: "", str(b))
c = [False]*(k+1)
print(""c: "", str(c))
e = [10000]*2
print(""e: "", str(e))
f = [10000]*2
print(""f: "", str(f))
for i in range(k+1):
	b[i] = (a == s)
	print(""b["", i, ""]: "", str(b[i]))
	if b[i]:
		e[i%2] = min(e[i%2], i)
for j in range(n):
	d[j] = a[q[j]]
a,d = d,a
a = [i for i in range(1,n+1)]
for i in range(k+1):
	c[i] = (a == s)
	print(""c["", i, ""]: "", str(c[i]))
	if c[i]:
		f[i%2] = min(f[i%2], i)
	for j in range(n):
		d[q[j]] = a[j]
a,d = d,a
if e[0] == 0:
	print('NO')
elif e[1] == 1:
	if f[1] == 1 and k > 1:
		print('NO')
	elif k%2 == 1 or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
elif f[1] == 1:
	if k%2 == 1 or e[k%2] <= k:
		print('YES')
	else:
		print('NO')
else:
	if e[k%2] <= k or f[k%2] <= k:
		print('YES')
	else:
		print('NO')
</ans>",0,{}
118,"<ans>
for _ in range(ii()):
    n, m = mi()
    print(""n: "", str(n), ""m: "", str(m))
    if n == 1:
        print(0)
    elif n == 2:
        print(m)
    else:
        print(2*m)
</ans>",0,{}
119,"<ans>
def factMod(n, mod):
    res = 1
    for i in range(2, n+1):
        res = (res * i) % mod
    print(""res: "", str(res))
    return res

def powMod(n, p, mod):
    res = 1

    while p > 0:
        if p % 2 == 1:
            res = (res * n) % mod
        print(""res: "", str(res))
        p //= 2
        n = (n * n) % mod

    return res

def invMod(n, mod):
    return powMod(n, mod - 2, mod)

def CnkMod(n, k, mod):
    return (
        factMod(n, mod) *
        invMod(factMod(k, mod) * factMod(n-k, mod), mod)
    ) % mod

def computeCnksMod(N, mod):
    res = [[0] * (N+1) for i in range(N+1)]
    res[0][0] = 1
    for n in range(1, N+1):
        res[n][0] = res[n-1][0]
        for k in range(1, n+1):
            res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod

    return res

magic = 998244353

n = int(input()) + 1
print(""n: "", str(n))
aa = [1] + [int(s)+1 for s in input().split(' ')]
print(""aa: "", str(aa))

cnks = computeCnksMod(n, magic)

d = [0] * (n + 1)
d[n] = 1

for i in reversed(list(range(n))):
    if i != 0 and aa[i] < 2:
        continue
    
    cur = 0

    tosel = aa[i] - 1
    for j in range(i + tosel + 1, n + 1):
        avail = j - i - 1
        cur = (cur + cnks[avail][tosel] * d[j]) % magic
    
    d[i] = cur

print(""d: "", str(d))
print(d[0] - 1)
</ans>",0,{}
120,"<ans>
n = it()
step = lt()
print(""n: "", str(n), ""step: "", str(step))
dict = {}
print(""dict: "", str(dict))

def explosion(start,s,d):
    (i,j) = start
    t = s+1
    if d == 0:
        for k in range(j+1,j+t):
            dict[(i,k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)
    if d == 1:
        for k in range(1,t):
            dict[(i+k,j+k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)
    if d == 2:
        for k in range(1,t):
            dict[(i+k,j)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)
    if d == 3:
        for k in range(1,t):
            dict[(i+k,j-k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)
    if d == 4:
        for k in range(1,t):
            dict[(i,j-k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i,j-t+1),(d+7)%8),((i,j-t+1),(d+1)%8)
    if d == 5:
        for k in range(1,t):
            dict[(i-k,j-k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i-t+1,j-t+1),(d+7)%8),((i-t+1,j-t+1),(d+1)%8)
    if d == 6:
        for k in range(1,t):
            dict[(i-k,j)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i-t+1,j),(d+7)%8),((i-t+1,j),(d+1)%8)
    if d == 7:
        for k in range(1,t):
            dict[(i-k,j+k)] = True
        print(""i: "", str(i), ""j: "", str(j), ""t: "", str(t), ""d: "", str(d))
        print(""dict: "", str(dict))
        return ((i-t+1,j+t-1),(d+7)%8),((i-t+1,j+t-1),(d+1)%8)

start = [((0,0),0)]
print(""start: "", str(start))
for i in range(n):
    l = []
    for p,q in start:
        a,b = explosion(p,step[i],q)
        l.append(a)
        l.append(b)
    start = set(l)
    print(""i: "", str(i), ""start: "", str(start))
pt(len(dict))
</ans>",0,{}
121,"<ans>
n=I()
print(""n: "", str(n))
m=LI()
print(""m: "", str(m))
tot=0
for i in range(n):
    l,r=[],[]
    
    tmp=m[i]
    print(""tmp: "", str(tmp))
    p=m[i]
    print(""p: "", str(p))
    
    # right
    for j in range(i+1,n):
        if m[j]<p:
            p=m[j]
        tmp+=p
        r+=[p]
    
    p=m[i]
    print(""p: "", str(p))
    # left
    for j in range(i-1,-1,-1):
        if m[j]<p:
            p=m[j]
        tmp+=p
        l+=[p]
    
    if tmp>tot:
        tot=tmp
        ans=l[::-1]+[m[i]]+r
print(""tot: "", str(tot))
print(""ans: "", str(ans))
</ans>",0,{}
122,"<ans>
import sys
sys.setrecursionlimit(10000)

#file = open(""btest"", ""r"")
#f = lambda:file.readline()
f = lambda:input()

n,m = list(map(int, f().split()))
print(""n: "", str(n), ""m: "", str(m))

matrix = []
print(""matrix: "", str(matrix))

disco = [[0 for _ in range(m)] for _ in range(n)]
print(""disco: "", str(disco))

for i in range(n):
    matrix.append(f())
    print(""matrix: "", str(matrix))

def valid_node(i, j):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, k, cc = 0):
    if disco[i][j] == k:
        return True
    
    disco[i][j] = k

    res = False
    dd = [[0,1], [1,0], [-1,0], [0,-1]]
    for d in dd:
        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:
                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)

    return res

ok = False
k = 1
for i in range(n):
    for j in range(m):
        if disco[i][j] == 0:
            ok = ok or dfs(i, j, [i, j], k)
            k += 1

if ok:
    print(""Yes"")
else:
    print(""No"")
</ans>",0,{}
123,"<ans>
D = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100}

k = int(input())
print(""k: "", str(k))
start = k - k%100
print(""start: "", str(start))
i = D[start]
print(""i: "", str(i))
j = start

while j < k:
    i += 1
    if sum(int(d) for d in str(i))==10:
        j += 1
print(i)
</ans>",0,{}
124,"<ans>
MOD = 998244353

def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)] 
    n = len(sx) 
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) : 
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) : 
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) : 
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = list(map(int, input().split()))
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)
</ans>",0,{}
125,"<ans>
def main():
    N, M = (int(i) for i in input().split())
    print(""N: "", str(N), ""M: "", str(M)

    par = [i for i in range(N)]
    size = [1 for i in range(N)]
    print(""par: "", str(par), ""size: "", str(size))

    def find(x):
        if par[x] == x:
            return x
        else:
            par[x] = find(par[x])
            size[x] = size[par[x]]
            return par[x]
    print(""x: "", str(x))

    def same(x, y):
        return find(x) == find(y)

    def union(x, y):
        x = find(x)
        y = find(y)
        if x == y:
            return
        if size[x] < size[y]:
            x, y = y, x
        size[x] += size[y]
        par[y] = x
    print(""x: "", str(x), ""y: "", str(y))

    def get_size(x):
        return size[find(x)]

    G = [[] for _ in range(N)]
    for _ in range(M):
        a, b = (int(i) for i in input().split())
        G[a-1].append(b-1)
        G[b-1].append(a-1)
        union(a-1, b-1)
    print(""a: "", str(a), ""b: "", str(b))

    S = [False]*4
    for i in range(N):
        S[min(3, get_size(i))] = True
        if S[3]:
            break
    t = 0
    if S[3]:
        t = 1
    elif S[2]:
        t = 2
    else:
        t = 3
    print(""S: "", str(S), ""t: "", str(t))

    color = [-1]*N

    def dfs(s):
        stack = [s]
        color[s] = 0
        b = 1
        w = 0
        while stack:
            v = stack.pop()
            for u in G[v]:
                if color[u] != -1:
                    if color[u] == color[v]:
                        return False, b*w
                    continue
                color[u] = color[v] ^ 1
                if color[u] == 0:
                    b += 1
                else:
                    w += 1
                stack.append(u)
        return True, b*(b-1)//2 + w*(w-1)//2

    is_bipartite, _ = dfs(0)
    if is_bipartite:
        w = 0
        if t == 3:
            w = N*(N-1)*(N-2)//3//2
        elif t == 2:
            used = [False]*N
            for i in range(N):
                if not used[find(i)] and get_size(i) == 2:
                    w += (N-2)
                    used[find(i)] = True
        elif t == 1:
            used = [False]*N
            color = [-1]*N
            for i in range(N):
                if not used[find(i)] and get_size(i) >= 3:
                    _, ways = dfs(i)
                    w += ways
                    used[find(i)] = True
        print(t, w)
    else:
        print(0, 1)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
126,"<ans>
def dist(x1, y1, x2, y2):
    print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))
    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2)

def get_y(x1, y1, x2, y2, x):
    print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2), ""x: "", str(x))
    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1

first = firstLine.split()
print(""first: "", str(first))
n = float(first[0])
m = float(first[1])
a = float(first[2])
b = float(first[3])

A = [float(x) for x in secondLine.split()]
print(""A: "", str(A))
B = [float(x) for x in thirdLine.split()]
print(""B: "", str(B))
L = [float(x) for x in fourthLine.split()]
print(""L: "", str(L))

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
    d = dist(0, 0, b, bi) + L[i]
    if d <= optimalLen:
        optimalLen = d
        optimalBIdx = i
    print(""i: "", str(i), ""bi: "", str(bi), ""d: "", str(d), ""optimalLen: "", str(optimalLen), ""optimalBIdx: "", str(optimalBIdx))

intersectY = get_y(0, 0, b, B[optimalBIdx], a)
print(""intersectY: "", str(intersectY))

pointDist = float(""inf"")
optimalAIdx = -1
for i, ai in enumerate(A):
    d = dist(a, ai, a, intersectY)
    if d < pointDist:
        pointDist = d
        optimalAIdx = i
    print(""i: "", str(i), ""ai: "", str(ai), ""d: "", str(d), ""pointDist: "", str(pointDist), ""optimalAIdx: "", str(optimalAIdx))

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
    d = dist(a, A[optimalAIdx], b, bi) + L[i]
    if d <= optimalLen:
        optimalLen = d
        optimalBIdx = i
    print(""i: "", str(i), ""bi: "", str(bi), ""d: "", str(d), ""optimalLen: "", str(optimalLen), ""optimalBIdx: "", str(optimalBIdx)

print(optimalAIdx + 1, optimalBIdx + 1)
</ans>",0,{}
127,"<ans>
def li():return [int(i) for i in input().rstrip('\n').split(' ')]
def val():return int(input().rstrip('\n'))
n = val()
l = li()
l1 = l[:]
l2 = l[:]
i = 0
l1 = sorted(list(set(l1)))
print(""l1: "", str(l1))
doit = tot1 = 0
cn = Counter(l1)
l = l1[:]
while i < len(l1):
    if cn[l[i] - 1] > 0:
        cn[l[i]] -= 1
        cn[l[i] - 1] += 1
        l[i] -= 1
        i += 1
    else:
        cn[l[i]] -= 1
        cn[l[i] + 1] += 1
        l[i] += 1
        if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2
        else:i += 1
tot1 = sum(1 for i in cn if cn[i])
print(""tot1: "", str(tot1))

i = 0
cnt = Counter(l2)
l2 = sorted(l2)
l = l2[:]
for i in range(n):
    if cnt[l[i] - 1] == 0:
        cnt[l[i] - 1] += 1
        cnt[l[i]] -= 1
        l[i] -= 1
    elif cnt[l[i]] > 1:
        cnt[l[i] + 1] += 1
        cnt[l[i]] -= 1
        l[i] += 1
tot2 = sum(1 for i in cnt if cnt[i])
print(""tot2: "", str(tot2))
</ans>",0,{}
128,"<ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush

input = sys.stdin.readline
def RD(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]

def main():
    N = I()
    print(""N: "", str(N))
    if N == 0:
        print(0)
        return
    if N < 0:
        N = -N
        print(""N: "", str(N))
        D = defaultdict(int)
        print(""D: "", str(D))
        index = 0
        while N >= 1:
            if N & 1 == 1:
                if index % 2 == 0:
                    D[index] += 1
                    D[index+1] += 1
                else:
                    D[index] += 1
            else:
                D[index] = D[index]
            N = N>>1
            index += 1
        print(""index: "", str(index))
    else:
        D = defaultdict(int)
        print(""D: "", str(D))
        if N & 1 == 1:
            D[0] = 1
        else:
            D[0] = 0
        index = 1
        N = N >> 1

        while N >= 1:
            if N & 1 == 1:
                if index % 2 == 1:
                    D[index] += 1
                    D[index+1] += 1
                else:
                    D[index] += 1
            else:
                D[index] = D[index]
            N = N>>1
            index += 1
        print(""index: "", str(index))

    index = 0
    while True:
        if not index in D.keys():
            break
        if D[index] <= 1:
            pass
        else:
            temp = D[index]
            D[index] = temp % 2
            D[index+1] += (temp // 2)
            D[index+2] += (temp // 2)
            if D[index+1] >= D[index+2] * 2:
                temp = D[index+2]
                D[index+2] -= temp
                D[index+1] -= temp * 2
        index += 1
    res = True

    for i in reversed(D.values()):
        if res and i == 1:
            res = False
        if not res:
            print(i, end="""")
    print()

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
129,"<ans>
n, k = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k))
XY = [list(map(int, input().split())) for _ in range(n)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[0])
print(""XY: "", str(XY))
XY = [xy + [x] for x, xy in enumerate(XY)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[1])
print(""XY: "", str(XY))
XY = [xy + [y] for y, xy in enumerate(XY)]
print(""XY: "", str(XY))

gr = [[0] * n for _ in range(n)]
print(""gr: "", str(gr))
for _, _, i, j in XY:
  gr[i][j] = 1
  print(""gr: "", str(gr))

rui = [[0] * (n + 1) for _ in range(n + 1)]
print(""rui: "", str(rui))
for i in range(n):
  for j in range(n):
    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]
    print(""rui: "", str(rui))

ans = 10 ** 21
print(""ans: "", str(ans))
for i in range(n - 1):
  for j in range(i + 1, n):
    x = [XY[m][0] for m in [i, j]]
    y = [XY[m][1] for m in [i, j]]
    ii = [XY[m][2] for m in [i, j]]
    jj = [XY[m][3] for m in [i, j]]
    innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                + rui[min(ii)][min(jj)] \
                - rui[min(ii)][max(jj) + 1] \
                - rui[max(ii) + 1][min(jj)]
    if innerPoints >= k:
      area = (max(x) - min(x)) * (max(y) - min(y)) 
      if area < ans:
        ans = area
        print(""ans: "", str(ans))

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        x = [XY[m][0] for m in [i, j, l]]
        y = [XY[m][1] for m in [i, j, l]]
        ii = [XY[m][2] for m in [i, j, l]]
        jj = [XY[m][3] for m in [i, j, l]]
        innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                    + rui[min(ii)][min(jj)] \
                    - rui[min(ii)][max(jj) + 1] \
                    - rui[max(ii) + 1][min(jj)]
        if innerPoints >= k:
          area = (max(x) - min(x)) * (max(y) - min(y)) 
          if area < ans:
            ans = area
            print(""ans: "", str(ans))

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          x = [XY[m][0] for m in [i, j, o, l]]
          y = [XY[m][1] for m in [i, j, o, l]]
          ii = [XY[m][2] for m in [i, j, o, l]]
          jj = [XY[m][3] for m in [i, j, o, l]]
          innerPoints = rui[max(ii) + 1][max(jj) + 1] \
                      + rui[min(ii)][min(jj)] \
                      - rui[min(ii)][max(jj) + 1] \
                      - rui[max(ii) + 1][min(jj)]
          if innerPoints >= k:
            area = (max(x) - min(x)) * (max(y) - min(y)) 
            if area < ans:
              ans = area
              print(""ans: "", str(ans))

print(ans)
</ans>",0,{}
130,"<ans>
import math
from fractions import gcd

def primes(limit):
    Ans=[]
    C=[True]*(limit+1)
    L=list(range(2,limit+1))
    for item in L:
        if(C[item]):
            i=2
            while(item*i<=limit):
                C[item*i]=False
                i+=1
    for item in L:
        if(C[item]):
            Ans+=[item]
    return Ans


a,b=list(map(int,input().split()))
print(""a: "", str(a), ""b: "", str(b))
aa=a
bb=b
A=[]
B=[]

p=primes(int(math.sqrt(10**9)))
print(""p: "", str(p))

for i in range(len(p)):
    if(p[i]>a):
        break
    while(a%p[i]==0):
        A.append(p[i])
        a//=p[i]
if(a!=1):
    A.append(a)
print(""A: "", str(A))

for i in range(len(p)):
    if(p[i]>b):
        break
    while(b%p[i]==0):
        B.append(p[i])
        b//=p[i]
if(b!=1):
    B.append(b)
print(""B: "", str(B))

if(aa==1 and bb==1):
    print(0)

elif(aa==1):
    Done=True
    for item in B:
        if(item>5):
            Done=False
            break
    if(Done):
        print(len(B))
    else:
        print(-1)
elif(bb==1):
    Done=True
    for item in A:
        if(item>5):
            Done=False
            break
    if(Done):
        print(len(A))
    else:
        print(-1)

else:

    B.sort()
    A.sort()
    Done=True
    ind=0
    ans=0
    while(A!=B):
        if(ind>=len(A) and ind>=len(B)):
            Done=False
            break
        elif(ind>=len(A)):
            if(B[-1]>5):
                Done=False
                break
            else:
                ans+=len(B)-ind
                break
        elif(ind>=len(B)):
            if(A[-1]>5):
                Done=False
                break
            else:
                ans+=len(A)-ind
                break
        if(A[ind]==B[ind]):
            ind+=1
            continue
        
        if(A[ind]<B[ind]):
            if(A[ind]>5):
                Done=False
                break
            else:
                ans+=1
                A.pop(ind)
        else:
            if(B[ind]>5):
                Done=False
                break
            else:
                ans+=1
                B.pop(ind)
    if(Done):
        print(ans)
    else:
        print(-1)
</ans>",0,{}
131,"<ans>
def solve():
    N = Scanner.int()
    print(""N: "", str(N))
    A = [0 for _ in range(N)]
    print(""A: "", str(A))
    B = [0 for _ in range(N)]
    print(""B: "", str(B))
    for i in range(N):
        A[i], B[i] = Scanner.map_int()
    A.sort()
    B.sort()
    if N % 2 == 0:
        mA = A[N // 2] + A[N // 2 - 1]
        mB = B[N // 2] + B[N // 2 - 1]
        print(""mA: "", str(mA), ""mB: "", str(mB))
        print((mB - mA + 1))
    else:
        mA = A[N // 2]
        mB = B[N // 2]
        print(""mA: "", str(mA), ""mB: "", str(mB))
        print((mB - mA + 1))


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
132,"<ans>
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))

c=[0]*1001
print(""c: "", str(c))

for i in range (len(a)):
	c[a[i]]+=1

sym=0
sin=0

for i in range (1001):
	sym+=(c[i]//4)
	if(c[i]%2==1):
		sin+=1

if(n%2==0 and sym==((n*n)//4)):
	mat= [([0]*(n//2)) for i in range (n//2)]
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	
	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			k+=1

	newm=[([0]*n) for i in range (n)]
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]

	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

	
elif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):
	mat= [([0]*(n//2)) for i in range (n//2)]
	ar=[]
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	
	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			ar.pop(k)

	newm=[([0]*n) for i in range (n)]
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]

	na=len(ar)
	ar2=[]
	for i in range (na):
		ar2.append(ar[i])
		ar2.append(ar[i])

	for i in range (1001):
		while(c[i]>=2):
			ar2.append(i)
			c[i]-=2

	#print(ar)
	for i in range (n//2):
		newm[n//2 ][i]=ar2[0]
		newm[n//2 ][n-i-1]=ar2[0]
		ar2.pop(0)
		newm[i][n//2 ]=ar2[0]
		newm[n-i-1][n//2 ]=ar2[0]
		ar2.pop(0)

	for i in range (1001):
		if(c[i]==1):
			newm[n//2][n//2]=i
	
	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

else:
	print(""NO"")
</ans>",0,{}
133,"<ans>
import sys
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))
height=n
print(""height: "", str(height))
ans=[]
print(""ans: "", str(ans))
last3=-1
print(""last3: "", str(last3))
fail=0
print(""fail: "", str(fail))
used=-1
print(""used: "", str(used))
for i in range(n):
    if a[i]==3:
        if height==n:
            ans.append((n-height+1,i+1))
            height-=1
        else:
            ans.append((n+1-(height+1),i+1))
            ans.append((n+1-height,i+1))
            height-=1
        last3=i
print(""ans: "", str(ans))
print(""height: "", str(height))
print(""last3: "", str(last3))
if last3==n-1:
    print(-1)
    return
if last3>-1:
    flag=0
    for i in range(last3,n):
        if a[i]==2:
            flag=1
            ans.append((n+1-(height+1),i+1))
            height-=1
            break
    if flag==0:
        flag2=0
        for i in range(last3,n):
            if a[i]==1:
                ans.append((n+1-(height+1),i+1))
                height-=1
                flag2=1
                used=i
                break
        if flag2==0:
            print(-1)
            return
ones=[]
print(""ones: "", str(ones))
if used==-1:
    height-=1
for i in range(n-1,-1,-1):
    if a[i]==1 and i!=used:
        ones.append(i)
    if a[i]==2:
        if len(ones)==0:
            print(-1)
            return
        k=ones.pop()
        ans.append((n+1-(height+1),i+1))
        ans.append((n+1-(height+1),k+1))
        height-=1
if used>-1:
    ones.append(used)
for i in ones:
    ans.append((n+1-(height+1),i+1))
    height-=1
print(""ans: "", str(ans))
print(""len(ans): "", str(len(ans)))
for x,y in ans:
    print(x,y)
</ans>",0,{}
134,"<ans>
import time
print(""t0: "", str(t0))
q1 = [[a1, b1, 0]]
print(""q1: "", str(q1))
q2 = [[a2, b2, 0]]
print(""q2: "", str(q2))
tested1 = []
print(""tested1: "", str(tested1))
tested2 = []
print(""tested2: "", str(tested2))
tested_total1 = []
print(""tested_total1: "", str(tested_total1))
tested_total2 = []
print(""tested_total2: "", str(tested_total2))
</ans>",0,{}
135,"<ans>
n = I()
print(""n: "", str(n))
s = input()
print(""s: "", str(s))
ans = """"
print(""ans: "", str(ans))
prv = None
print(""prv: "", str(prv))
for i in range(n):
    if i == 0:
        prv = s[i]
        print(""prv: "", str(prv))
        ans += s[i]
        print(""ans: "", str(ans))
        continue
    if s[i] == prv:
        continue
    else:
        prv = s[i]
        print(""prv: "", str(prv))
        ans += s[i]
        print(""ans: "", str(ans))
print((len(ans)))
</ans>",0,{}
136,"<ans>
class Polynomial:
    def __init__(self, coef):
        first_nonzero = False
        index = len(coef) - 1
        while not first_nonzero:
            if not coef[index] == 0:
                first_nonzero = True
            else:
                if index == 0:
                    first_nonzero = True
                else:
                    index -= 1
        self.degree = index
        self.coef = [coef[j] for j in range(index + 1)]
        print(""degree: "", str(self.degree), ""coef: "", str(self.coef))
    def multiply_by_x(self):
        new_coef = [0]
        for j in range(self.degree + 1):
            new_coef.append(self.coef[j])
        return Polynomial(new_coef)
    def minus(self):
        new_coef = [-self.coef[j] for j in range(self.degree + 1)]
        return Polynomial(new_coef)
    def add(self, other):
        other_coef = other.coef
        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]
        m = min(self.degree, other.degree)
        M = max(self.degree, other.degree)
        if self.degree > other.degree:
            bigger_poly = self
        else:
            bigger_poly = other
        for j in range(m + 1):
            new_coef[j] = self.coef[j] + other.coef[j]
        for j in range(m + 1, M+1):
            new_coef[j] = bigger_poly.coef[j]
            
        return Polynomial(new_coef) 
    def is_legal(self):
        result = True
        bools = [None for j in range(self.degree + 1)]
        bools[self.degree] = self.coef[self.degree] == 1
        for j in range(self.degree):
            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1
        for j in range(self.degree + 1):
            result = result and bools[j]
        return result
    def print(self):
        output = """"
        for j in range(self.degree + 1):
            output += str(self.coef[j]) + "" ""
        print(output)
            
        

f = []

f.append(Polynomial([1]))
f.append(Polynomial([0, 1]))

for j in range(2, 151):
    xf = f[j-1].multiply_by_x()
    t_1 = xf.add(f[j - 2])
    t_2 = xf.add(f[j - 2].minus())
    if t_1.is_legal():
        f.append(t_1)
    elif t_2.is_legal():
        f.append(t_2)
    print(""xf: "", str(xf), ""t_1: "", str(t_1), ""t_2: "", str(t_2)


print(f[n].degree)
f[n].print()
print(f[n-1].degree)
f[n-1].print()

#for j in range(len(f)):
    #f[j].print()
</ans>",0,{}
137,"<ans>
class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    comb = Combination(1000000)
    print(comb(5, 3))  # 10
    """"""
    def __init__(self, n_max, mod=10**9+7):
        self.mod = mod
        self.modinv = self.make_modinv_list(n_max)
        self.fac, self.facinv = self.make_factorial_list(n_max)
        print(""mod: "", str(mod), ""n_max: "", str(n_max))

    def __call__(self, n, r):
        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        fac = [1]
        facinv = [1]
        for i in range(1, n+1):
            fac.append(fac[i-1] * i % self.mod)
            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)
        return fac, facinv

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        modinv = [0] * (n+1)
        modinv[1] = 1
        for i in range(2, n+1):
            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod
        return modinv
mod = 998244353
K, N = map(int, input().split())
comb = Combination(10000, mod=mod)
print(""mod: "", str(mod), ""K: "", str(K), ""N: "", str(N))

def C(n, r):
    if n<r or r<0:
        return 0
    else:
        return comb(n, r)
        
def H(n, r):
    return C(n+r-1, r)
    
L = []
for i in range(2, 2*K+1, 2):
    ans = 0
    M = i//2
    b = 1
    for j, a in enumerate(range(M, K)):
        if M-j<0:
            break
        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b
        print(""ans: "", str(ans), ""j: "", str(j), ""a: "", str(a), ""C(M, j): "", str(C(M, j)), ""H(K-a, N): "", str(H(K-a, N)), ""b: "", str(b))
        ans %= mod
        b = -b
    print(ans)
    if i == K+1:
        break
    elif i == K:
        print(ans)
        print(ans)
        break
    L.append(ans)
    print(ans)
    L.append(ans)

print(*L[::-1], sep=""\n"")
</ans>",0,{}
138,"<ans>
import sys
import math
import random
n, k, x = map(int, input().split())
print(""n: "", str(n), ""k: "", str(k), ""x: "", str(x))
a = list(map(int, input().split()))
print(""a: "", str(a))
ans = 0
print(""ans: "", str(ans))
if n == 1:
    print(0)
    return
for i in range(0, n - 1):   
    if a[i] == a[i + 1] == x:
        l = i    
        while l >= 0 and a[i] == a[l]:
            l -= 1
        r = i + 1
        while r < n and a[r] == x:
            r += 1
        while (1):
            if l == -1 or r == n:
                break
            if a[l] != a[r]:
                break
            if l == 0 and r == n - 1:
                break
            if l == 0:
                if a[0] == a[r + 1]:
                    while r < n and a[r] == a[0]:
                        r += 1
                    l -= 1
                    continue
                else:
                    break
            if r == n - 1:
                if a[n - 1] == a[l - 1]:
                    while l >= 0 and a[l] == a[n - 1]:
                        l -= 1
                    r += 1
                    continue
                else:
                    break
            if a[l] == a[r + 1] or a[l - 1] == a[r]:
                t = a[l]
                while l >= 0 and a[l] == t:
                    l -= 1
                while r < n and a[r] == t:
                    r += 1
            else:
                break
        ans = max(ans, r - l - 1)
        print(""l: "", str(l), ""r: "", str(r), ""ans: "", str(ans))
print(ans)
</ans>",0,{}
139,"<ans>
ka, kb = 0, 0

def g(a, b):
    nonlocal ka, kb
    if a == b:
        return
    if abs(a - b) == 2:
        if a == 1:
            ka += 1
        else:
            kb += 1
    else:
        if a > b:
            ka += 1
        else:
            kb += 1

def main():
    nonlocal ka, kb
    k, a, b = list(map(int, input().split()))
    aa = [[] for i in [1, 1, 1]]
    bb = [[] for i in [1, 1, 1]]
    aa[0] = list(map(int, input().split()))
    aa[1] = list(map(int, input().split()))
    aa[2] = list(map(int, input().split()))
    bb[0] = list(map(int, input().split()))
    bb[1] = list(map(int, input().split()))
    bb[2] = list(map(int, input().split()))
    x = a
    y = b
    o = 1
    c = [[x, y]]
    d = [[0, 0]]
    g(x, y)
    print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb)
    if k == 1:
        return
    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
    print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb)
    while [x, y] not in c:
        o += 1
        c += [[x, y]]
        d += [[ka, kb]]
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb)
        if o == k:
            return
    ind = c.index([x, y])
    dka = ka - d[ind][0]
    dkb = kb - d[ind][1]
    delta = o - ind
    kk = (k - ind) // delta - 1
    print(""dka: "", str(dka), ""dkb: "", str(dkb), ""delta: "", str(delta)
    ka += kk * dka
    kb += kk * dkb
    o += kk * delta
    while o != k:
        o += 1
        g(x, y)
        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
        print(""x: "", str(x), ""y: "", str(y), ""ka: "", str(ka), ""kb: "", str(kb)

main()
print(ka, kb)
</ans>",0,{}
140,"<ans>
S = input()
print(""S: "", str(S))

check = len(S)-1
print(""check: "", str(check))

while(check >= 0):

    if S[check] == ""r"":
        if S[check-2] == ""m"":
            remove = S[check-6: check+1]
            if remove == ""dreamer"":
                check -= 7
            else:
                print(""NO"")
                return


        elif S[check-2] == ""s"":
            remove = S[check-5: check+1]
            
            if remove == ""eraser"":
                check -= 6
            else:
                print(""NO"")
                return

        else:
            print(""NO"")
            return

    elif S[check] == ""e"":
        remove = S[check-4: check+1]
            
        if remove == ""erase"":
            check -= 5
        else:
            print(""NO"")
            return

    elif S[check] == ""m"":
        remove = S[check-4: check+1]
            
        if remove == ""dream"":
            check -= 5
        else:
            print(""NO"")
            return

    else:
        print(""NO"")
        return


print(""YES"")
</ans>",0,{}
141,"<ans>
class UnionFind():
    def __init__(self, n):
        self.n = n + 1
        self.parents = [-1] * self.n
        print(""n: "", str(n))

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

        # TODO 根を返す
        return x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
    N, M = list(map(int, input().split()))
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    A.append(0)
    B.append(0)
    uf = UnionFind(N+1)
    for _ in range(M):
        c, d = list(map(int,input().split()))
        uf.union(c, d)
        print(""c: "", str(c), ""d: "", str(d))
    A_sums = defaultdict(int)
    B_sums = defaultdict(int)
    for i in range(1, N+1):
        x = uf.find(i)
        A_sums[x] += A[i-1]
        B_sums[x] += B[i-1]
    for a, b in zip(list(A_sums.values()), list(B_sums.values())):
        if a != b:
            print('No')
            return
    print('Yes')


main()
</ans>",0,{}
142,"<ans>
from sys import stdin, stdout

k = int(stdin.readline())
print(""k: "", str(k)

n, m = list(map(int, stdin.readline().split()))
print(""n: "", str(n), ""m: "", str(m))

left, right, down, up = [], [], [], []
coordinates = []

for i in range(k):
    x1, y1, x2, y2 = list(map(int, stdin.readline().split()))
    print(""x1: "", str(x1), ""y1: "", str(y1), ""x2: "", str(x2), ""y2: "", str(y2))

    if x1 == x2:
        if y1 < y2:
            coordinates.append((x1, y1, x2, y2, i))
        else:
            coordinates.append((x2, y2, x1, y1, i))
    else:
        if x1 < x2:
            coordinates.append((x1, y1, x2, y2, i))
        else:
            coordinates.append((x2, y2, x1, y1, i))

    left.append(coordinates[-1])
    right.append(coordinates[-1])
    up.append(coordinates[-1])
    down.append(coordinates[-1])

left.sort(key = lambda x: (x[0], x[2]))
down.sort(key = lambda x: (x[1], x[3]))

challengers = [[], [], [], []]
cntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))
print(""cntl: "", str(cntl), ""cntr: "", str(cntr), ""cntd: "", str(cntd), ""cntu: "", str(cntu))

label = 1

if cntl or not cntl:
    for i in range(cntl, -1, -1):
        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):
            challengers[0].append(left[i][-1])
        else:
            break

    for i in range(cntl + 1, k):
        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:
            label = 0

        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):
            challengers[0].append(left[i][-1])
        else:
            break

if cntr or not cntr:
    for i in range(k - 1 - cntr, k):
        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):
            challengers[1].append(left[i][-1])
        else:
            break

    for i in range(k - 2 - cntr, -1, -1):
        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:
            label = 0

        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):
            challengers[1].append(left[i][-1])
        else:
            break

if cntd or not cntd:
    for i in range(cntd, -1, -1):
        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):
            challengers[2].append(down[i][-1])
        else:
            break

    for i in range(cntd + 1, k):
        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:
            label = 0

        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):
            challengers[2].append(down[i][-1])
        else:
            break

if cntu or not cntu:
    for i in range(k - 1 - cntu, k):
        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):
            challengers[3].append(down[i][-1])
        else:
            break

    for i in range(k - 2 - cntu, -1, -1):
        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:
            label = 0

        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):
            challengers[3].append(down[i][-1])
        else:
            break

ans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])

if not len(ans) or not label:
    stdout.write('-1')
else:
    stdout.write(str(list(ans)[0] + 1))
</ans>",0,{}
143,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        print(""Nodes: "", str(Nodes), ""is_directed: "", str(is_directed))
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b

#####Primes till Nth O(n)#####
def seive_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(n-r+1,n+1):
        ans*=i
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(r):
        ans*=(n-i)
    div=1
    for i in range(2,r+1):
        div*=i
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    return ls

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    s=input()
    print(""s: "", str(s))
    n=len(s)
    if s==s[::-1] and s[:n//2]==s[n//2+1:]:
        print('Yes')
    else:
        print('No')
def __starting_point():
    main()
    

    
    
    
            
    
    

__starting_point()
</ans>",0,{}
144,"<ans>
from array import array
inf = (1 << 30)

def main():
    (n,k) = [int(x) for x in input().split(' ')]
    print(""n: "", str(n), ""k: "", str(k))
    Matrix = []
    for i in range(n):
        Matrix.append(array('b',[ord(x) for x in input()]))
    print(""Matrix: "", str(Matrix))
    dp = [array('l', [inf for j in range(n)]) for i in range(n)]
    print(""dp: "", str(dp))
    direct = [[ord('d') for j in range(n)] for i in range(n)]
    print(""direct: "", str(direct))
    opt = """"
    for s in range (2 * n - 1):
        opchar = chr(ord('z') + 1)
        positions = []
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(i > 0 and j > 0):
                    if(dp[i-1][j] < dp[i][j-1]):
                        dp[i][j] = dp[i-1][j]
                        direct[i][j] = 'l'
                    else:
                       dp[i][j] = dp[i][j-1]
                       direct[i][j] = 'd'
                elif i > 0:
                    dp[i][j] = dp[i-1][j]
                    direct[i][j] = 'l'
                elif j > 0:
                    dp[i][j] = dp[i][j-1]
                    direct[i][j] = 'd'
                else:
                    dp[i][j] = 0
                    direct[i][j] = 'e'
                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):
                    dp[i][j]+=1
                    Matrix[i][j] = ord('a')
                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):
                     opchar = chr(Matrix[i][j])
        for i in range(0, s+1):
            j = s - i;
            if j < n and i < n:
                if(Matrix[i][j] is not ord(opchar)):
                    dp[i][j] = inf
    ans = """"
    a,b = (n-1,n-1)
    while(direct[a][b] is not 'e'):
        ans += chr(Matrix[a][b])
        if(direct[a][b] is 'l'):
            a-=1
        else:
            b-=1
    ans += chr(Matrix[0][0])
    print(ans[::-1])

main()
</ans>",0,{}
145,"<ans>
def check(cnt):
    if cnt == 0:
        return True
    x = b[-cnt:]
    y = p[:cnt]
    s = a
    i = 0
    while i < cnt and s >= 0:
        s -= max(0, y[i]-x[i])
        i += 1
    return s >= 0

def test():
    nonlocal n, m, a, b, p
    n, m, a = get()
    print(""n: "", str(n), ""m: "", str(m), ""a: "", str(a))
    b = sorted(get())
    print(""b: "", str(b))
    p = sorted(get())
    print(""p: "", str(p)

    left = 0
    right = min(n, m)

    ans = -1

    while left <= right:
        mid = (left + right) // 2
        if check(mid):
            ans = max(ans, mid)
            left = mid + 1
        else:
            right = mid - 1

    if ans == -1:
        print(0, 0)
        return

    # print(ans)

    t = 0
    x = b[-ans:]
    y = p[:ans]
    i = 0
    while i < ans:
        t += min(x[i], y[i])
        a -= max(0, y[i]-x[i])
        i += 1
    print(ans, max(0, t-a))
</ans>",0,{}
146,"<ans>
d1={}
print(""d1: "", str(d1))
for i in range(n):
    s=input()
    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')
    print(""x: "", str(x))
    if x>0:
        
        for c in s[::-1]:
            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':
                break
        print(""c: "", str(c))
        if (x,c) in d1:
            d1[(x,c)].append(s)
        else :
            d1[(x,c)]=[s]
print(""d1: "", str(d1))

d2={}
print(""d2: "", str(d2))
pairs1=[]
print(""pairs1: "", str(pairs1))
pairs2=[]
print(""pairs2: "", str(pairs2))
for k in d1:
    if len(d1[k])%2==1:
        if k[0] in d2:
            d2[k[0]].append(d1[k][0])
        else :
            d2[k[0]]=[d1[k][0]]
        for i in range(1,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
    else :
        for i in range(0,len(d1[k]),2):
            pairs1.append((d1[k][i],d1[k][i+1]))
print(""d2: "", str(d2))
print(""pairs1: "", str(pairs1))

for k in d2:
    if len(d2[k])>1:
        if len(d2[k])%2==1:
            d2[k].pop()
        for i in range(0,len(d2[k]),2):
            pairs2.append((d2[k][i],d2[k][i+1]))
print(""pairs2: "", str(pairs2))

if len(pairs1)<len(pairs2):
    print(len(pairs1))
    for i in range(len(pairs1)):
        print(pairs2[i][0],pairs1[i][0])
        print(pairs2[i][1],pairs1[i][1])
else :
    print(len(pairs2)+(len(pairs1)-len(pairs2))//2)
    for i in range(len(pairs2)):
        print(pairs2[i][0],pairs1[i][0])
        print(pairs2[i][1],pairs1[i][1])
    for j in range(len(pairs2),len(pairs1),2):
        if j==len(pairs1)-1:
            break
        else :
            print(pairs1[j][0],pairs1[j+1][0])
            print(pairs1[j][1],pairs1[j+1][1])
</ans>",0,{}
147,"<ans>
def main():
    N, K, *A = list(map(int, read().split()))
    print(""N: "", str(N), ""K: "", str(K), ""A: "", str(A))

    K = list(map(int, f'{K:>040b}'))
    print(""K: "", str(K))
    
    A2 = [list(map(int, f'{a:>040b}')) for a in A]
    print(""A2: "", str(A2))
    
    B = [0] * 40
    print(""B: "", str(B))
    
    for a in A2:
        for i, bit in enumerate(a):
            B[i] += bit
    print(""B: "", str(B))
    
    for i in range(40):
        if B[i] == N - B[i]:
            B[i] = 2
        elif B[i] < N - B[i]:
            B[i] = 1
        else:
            B[i] = 0
    print(""B: "", str(B))

    @lru_cache(maxsize=None)
    def rec(i, x, smaller):
        if i == 40:
            ans = 0
            for a in A:
                ans += x ^ a
            return ans
        elif smaller:
            if B[i] == 2:
                return rec(i + 1, (x << 1), True)
            else:
                return rec(i + 1, (x << 1) + B[i], True)
        else:
            if B[i] == 2:
                if K[i] == 0:
                    return rec(i + 1, (x << 1), False)
                else:
                    return rec(i + 1, (x << 1), True)
            elif K[i] == B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            elif K[i] < B[i]:
                return rec(i + 1, (x << 1) + K[i], False)
            else:
                return rec(i + 1, (x << 1) + B[i], True)

    print((rec(0, 0, False)))
    return
</ans>",0,{}
148,"<ans>
def resolve():
    N = int(input())
    print(""N: "", str(N))
    A = list(map(int, input().split()))
    print(""A: "", str(A))

    Q = 0
    E = 0
    O = 0
    for a in A:
        if a % 4 == 0:
            Q += 1
        elif a % 2 == 0:
            E += 1
        else:
            O += 1
    print(""Q: "", str(Q))
    print(""E: "", str(E))
    print(""O: "", str(O))

    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:
        print(""Yes"")
    else:
        print(""No"")
</ans>",0,{}
149,"<ans>
def linput(ty=int, cvt=list):
	return cvt(list(map(ty,input().split())))

def vinput(rep=1, ty=int, cvt=list):
	return cvt(ty(input().rstrip()) for _ in ""*""*rep)

def gcd(a: int, b: int):
	while b: a, b = b, a%b
	return a

def lcm(a: int, b: int):
	return a * b // gcd(a, b)

def dist(x1,y1,x2,y2):
	return abs(x1-x2)+abs(y1-y2)

def ran():
	vRan = [random.randint(1, 10),
	        random.randint(0, 10),
	        random.randint(1, 100)]
	return vRan

def bye(res):
	sT = ""No Yes"".split()
	print((sT[res]))
	#return

def sol_n(a,b,c):
	res = 0
	cnt = 0
	while cnt<c:
		res += 1
		cnt += a
		if res%7==0:
			cnt += b
	return res

def sol(a,b,c):
	#a,b,c = linput()
	### 3 6 9 12 15
	### 1 2 3 4  5
	
	res = 0
	L = -(-a//c)
	R = (b//c)
	res = R-L+1
	
	return res

def deb():
	#vI = linput()
	vI = ran()
	print(""vI: "", str(vI))
	I = sol_n(*vI)
	J = sol(*vI)
	if 1:#I!=J:
		print((vI, I, J))

def main():
	vI = linput()
	print(""vI: "", str(vI))
	print((sol(*vI)))

def __starting_point():
	#for _ in ""*""*1000:
	#	deb()
	main()

__starting_point()
</ans>",0,{}
150,"<ans>
l = read_int()
print(""l: "", str(l))
p = read_int()
print(""p: "", str(p))
q = read_int()
print(""q: "", str(q))
t = l / (p + q)
print(""t: "", str(t))
print(t*p)
</ans>",0,{}
151,"<ans>
z=[int(p) for p in input().split()]
print(""z: "", str(z))
m=z[2]
print(""m: "", str(m)
lst=[]
lst.append(z[0])
lst.append(z[1])
print(""lst: "", str(lst))
tempi=min(lst)
print(""tempi: "", str(tempi))
tempa=max(lst)
print(""tempa: "", str(tempa))

count=0
print(""count: "", str(count))
fibo=[]


n=1000000000000000000
print(""n: "", str(n))
def fib(n):
        
        a, b = 0, 1
        while b < n:
                fibo.append(b)
                a, b = b, a+b
    


def add(m):
        n=10**18
        print(""n: "", str(n))
        tempi=min(lst)
        print(""tempi: "", str(tempi))
        tempa=max(lst)
        print(""tempa: "", str(tempa))
        count=0
        print(""count: "", str(count))
        if(tempi>0 and tempa>0 and m>tempa):
                fib(n)
                for p in range(1,len(fibo)+1):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count
        elif(tempi==0 or tempa==0):
                count=1
                fib(n)
                tempi=tempa+(tempi)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count

        elif(tempi<0 and tempa>0):
                val=(-(tempi)//tempa)+1
                count=val
                tempi=tempi+(val*tempa)
                fib(n)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                return count

        





if(tempi>0 and tempa>0 and m>tempa):
        cou=add(m)
        print(cou)

elif(tempi>0 and tempa>0 and m<=tempa):
        print(0)

elif(tempi==0 ):
        if(tempi==0 and tempa==0 and m>0):
                print(-1)
        elif(tempi==0 and tempa==0 and m<=0):
                print(0)
        elif(tempa==0 and tempi<0 and m>0):
                print(-1)
                
        else:
                cou=add(m)
                print(cou)
elif(tempi<0 and tempa>0):
        if(m<=tempa):
                print(0)
        else:
                cou=add(m)
                print(cou)
elif(tempi<0 and tempa==0):
        if(m>0):
                print(-1)
        else:
                print(0)
elif(tempi<0 and tempa<0):
        if(m>=0):
                print(-1)
        elif(m<0 and m<=tempa):
                print(0)
        elif(m<0 and m>tempa):
                print(-1)
</ans>",0,{}
152,"<ans>
d=dd(list)
print(""d: "", str(d))
lol=0
print(""lol: "", str(lol))
vis=[0]*(n+1)
print(""vis: "", str(vis))
rvis=[0]*(n+1)
print(""rvis: "", str(rvis))
cou=[0]
print(""cou: "", str(cou))
dp=[dd(int) for i in range(n+1)]
print(""dp: "", str(dp))
mx=[0]
print(""mx: "", str(mx))
h=[0]
print(""h: "", str(h))
</ans>",0,{}
153,"<ans>
def solve(N: int, X: int, D: int):
    print(""N: "", str(N), ""X: "", str(X), ""D: "", str(D))
    if D == 0:
        if X == 0:
            print((1))
        else:
            print((N+1))
        return

    if D < 0:
        X = X + (N-1)*D
        D = abs(D)

    segs = defaultdict(list)
    for k in range(N+1):
        L = k*(k-1)//2
        R = k*N - k*(k+1)//2
        Ck = k*X + D*L
        Rk = R-L
        seg = (Ck//D, Ck//D+Rk+1)
        s = Ck % D
        segs[s].append(seg)

    tot = 0
    for k in segs:
        event = defaultdict(int)
        for l, r in segs[k]:
            event[l] += 1
            event[r] -= 1

        curr = 0
        pre = -1
        for k in sorted(event.keys()):
            if curr > 0:
                tot += k - pre
            curr += event[k]
            pre = k
    print(tot)

    return

def main():
    print(""N: "", str(N), ""X: "", str(X), ""D: "", str(D))

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    X = int(next(tokens))  # type: int
    D = int(next(tokens))  # type: int
    solve(N, X, D)

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
154,"<ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
p = list(map(int, input().split()))
print(""p: "", str(p))
odd = (n+1)//2
print(""odd: "", str(odd))
even = n-odd
print(""even: "", str(even))
for i in p:
    if i:
        if i%2 == 0:
            even -= 1
        else:
            odd -= 1
print(""even: "", str(even))
print(""odd: "", str(odd))

if even == 0:
    p = [i if i else 1 for i in p]
if odd*even == 0:
    ans = 0
    prev = p[0]
    for pi in p:
        ans += (pi+prev)%2
        prev = pi
    print(ans)
    return

DP = [[float(""inf"")]*(even+1) for i in range(2)]
for i in range(n):
    nxt = [[float(""inf"")]*(even+1) for i in range(2)]
    if i == 0:
        if p[i]:
            if p[i]%2 == 0:
                nxt[0][0] = 0
            else:
                nxt[1][0] = 0
        else:
            nxt[0][1] = 0
            nxt[1][0] = 0
    else:
        if p[i]:
            if p[i]%2 == 0:
                for j in range(even+1):
                    nxt[0][j] = min(DP[0][j], DP[1][j]+1)
            else:
                for j in range(even+1):
                    nxt[1][j] = min(DP[0][j]+1, DP[1][j])
        else:
            for j in range(1, even+1):
                nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)
            for j in range(even+1):
                nxt[1][j] = min(DP[0][j]+1, DP[1][j])
    DP = nxt
print(min(DP[0][-1], DP[1][-1]))
</ans>",0,{}
155,"<ans>
N = int(input())
print(""N: "", str(N))
P_list = list(map(int, input().split()))
print(""P_list: "", str(P_list))
X_list = list(map(int, input().split()))
print(""X_list: "", str(X_list))

child_list = [[] for _ in range(N+1)]
for i in range(2, N+1):
    child_list[P_list[i-2]].append(i)
print(""child_list: "", str(child_list))

color1 = [0]+X_list
print(""color1: "", str(color1))
color2 = [0]*(N+1)
print(""color2: "", str(color2))

def solve_knapsack(L, M):
    min_acc = sum([min(color1[j], color2[j]) for j in L])
    if min_acc > M:
        return -1
    else:
        add_can = M - min_acc
        add_set = set([0])
        for j in L:
            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])
            add_set_ = set(add_set)
            for s in add_set:
                if s + add_j <= add_can:
                    add_set_.add(s + add_j)
            add_set = add_set_
        
        total = sum([color1[j]+color2[j] for j in L])
        return total - max(add_set) - min_acc

res = ""POSSIBLE""

for i in range(N, 0, -1):
    if len(child_list[i]) == 0:
        pass
    elif len(child_list[i]) == 1:
        j = child_list[i][0]
        if min(color1[j], color2[j]) > X_list[i-1]:
            res = ""IMPOSSIBLE""
            break
        elif max(color1[j], color2[j]) > X_list[i-1]:
            color2[i] = max(color1[j], color2[j])
        else:
            color2[i] = min(color1[j], color2[j])
    else:
        c2 = solve_knapsack(child_list[i], X_list[i-1])
        if c2 < 0:
            res = ""IMPOSSIBLE""
            break
        else:
            color2[i] = c2
    
print(res)
</ans>",0,{}
156,"<ans>
def prime_factor(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            while n % i == 0:
                n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors


def divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    divisors.sort()
    return divisors


def mebius(n):
    res = {}
    primes = prime_factor(n)
    m = len(primes)
    for i in range(1 << m):
        mu = 1
        d = 1
        for j in range(m):
            if i >> j & 1:
                mu *= -1
                d *= primes[j]
        res[d] = mu
    return res

mod = 10**9+7
N, K = list(map(int, input().split()))
div = divisors(N)
print(""div: "", str(div))

ans = 0

for x in div:
    div2 = divisors(x)
    print(""div2: "", str(div2))
    mu = mebius(x)
    print(""mu: "", str(mu))
    cnt = 0
    for y in list(mu.keys()):
        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]
    if x % 2 == 0:
        cnt *= pow(2, mod-2, mod)
    ans += x*cnt
    ans %= mod

print(ans)
</ans>",0,{}
157,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

n = int(minp())
print(""n: "", str(n))
m = [None]*n
print(""m: "", str(m))
k = [None]*3
print(""k: "", str(k))
dp = [None]*3
print(""dp: "", str(dp))
dp[0] = [None]*(n*n)
print(""dp[0]: "", str(dp[0]))
dp[1] = [None]*(n*n)
print(""dp[1]: "", str(dp[1]))
dp[2] = [None]*(n*n)
print(""dp[2]: "", str(dp[2]))
path = [None]*(n*n)
print(""path: "", str(path))
for i in range(n):
	m[i] = list(map(int, minp().split()))
	print(""m[""+str(i)+""]: "", str(m[i]))
	for j in range(n):
		path[m[i][j]-1] = (i,j)
		print(""path[""+str(m[i][j]-1)+""]: "", str(path[m[i][j]-1]))
for z in range(3):
	k_ = [None]*n
	print(""k_: "", str(k_))
	for i in range(n):
		kk = [None]*n
		print(""kk: "", str(kk))
		for j in range(n):
			kkk_ = [None]*3
			print(""kkk_: "", str(kkk_))
			for zz in range(3):
				kkk = [None]*n
				print(""kkk: "", str(kkk))
				for w in range(n):
					kkk[w] = [(1000000,0)]*n
				kkk_[zz] = kkk
			kk[j] = kkk_
		k_[i] = kk
	k[z] = k_

q = [0]*(10*n*n)
qr = 0
km = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
sm = [(1,1),(1,-1),(-1,1),(-1,-1)]
lm = [(0,1),(0,-1),(-1,0),(1,0)]
mm = [km,sm,lm]
for z in range(3):
	for i in range(n):
		for j in range(n):
			#print('========')
			ql = 0
			qr = 1
			q[0] = (z, i, j, (0,0))
			kc = k[z][i][j]
			kc[z][i][j] = (0, 0)
			while ql < qr:
				t, x, y, dd = q[ql]
				#print(t,x,y,dd)
				d = kc[t][x][y]
				ql += 1
				if d != dd:
					continue
				dd = (d[0]+1, d[1]+1)
				for tt in range(3):
					if t != tt and kc[tt][x][y] > dd:
						kc[tt][x][y] = dd
						q[qr] = (tt,x,y,dd)
						qr += 1
				dd = (d[0]+1,d[1])
				if t == 0:
					for w in mm[t]:
						xx,yy = w[0]+x,w[1]+y
						if xx >= 0 and xx < n and yy >= 0 and yy < n:
							if kc[t][xx][yy] > dd:
								kc[t][xx][yy] = dd
								q[qr] = (t,xx,yy,dd)
								qr += 1
				else:
					for w in mm[t]:
						for hm in range(n*2):
							xx,yy = w[0]*hm+x,w[1]*hm+y
							if xx >= 0 and xx < n and yy >= 0 and yy < n:
								if kc[t][xx][yy] > dd:
									kc[t][xx][yy] = dd
									q[qr] = (t,xx,yy,dd)
									qr += 1
							else:
								break
dp[0][0] = (0,0)
dp[1][0] = (0,0)
dp[2][0] = (0,0)
for i in range(0,n*n-1):
	x,y = path[i]
	xx,yy = path[i+1]
	for z in range(3):
		for j in range(3):
			dist = k[j][x][y][z][xx][yy]
			if dp[j][i] != None:
				nd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])
				if dp[z][i+1] == None:
					dp[z][i+1] = nd
				else:
					dp[z][i+1] = min(dp[z][i+1],nd)
for j in range(n*n-1,n*n):
	qq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]
	qm = min(qq)
	#print(j,qm)
	print(qm[0], qm[1])
</ans>",0,{}
158,"<ans>
def increasing(arr):
    n = len(arr)
    print(""n: "", str(n)
    for i in range(n-1):
        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
            return False

    return True

def getFacts(n,mod):
    facts = [1]*n
    print(""facts: "", str(facts))
    for i in range(1,n):
        facts[i] = facts[i-1]*i
        facts[i] %= mod

    return facts

def solve(arr1,arr2,n,mod):
    facts = getFacts(4*10**5+1,mod)
    total = facts[n]
    print(""total: "", str(total))
    dist1 = {}
    for i in arr1:
        if i[0] not in list(dist1.keys()):
            dist1[i[0]] = 1
        else:
            dist1[i[0]] += 1

    dist2 = {}
    for i in arr2:
        if i[0] not in list(dist2.keys()):
            dist2[i[0]] = 1
        else:
            dist2[i[0]] += 1

    count = 1
    for i in dist1:
        count *= facts[dist1[i]]
        count = count%mod

    total -= count
    print(""total: "", str(total))
    count = 1
    
    for i in dist2:
        count *= facts[dist2[i]]
        count = count%mod

    #print(count)
    total -= count
    print(""total: "", str(total))

    arr1.sort()
    if increasing(arr1):
        count = 1
    else:
        count = 0
    dist3 = {}
    for i in arr1:
        if i not in list(dist3.keys()):
            dist3[i] = 1
        else:
            dist3[i] += 1
        
    for i in dist3:
        count *= facts[dist3[i]]
        count = count%mod

    #print(count,total)
    total += count
    total = total%mod
    print(""total: "", str(total))
    

def main():
    mod = 998244353
    print(""mod: "", str(mod))
    n = int(input())
    print(""n: "", str(n))
    first = []
    second = []
    for i in range(n):
        a,b = list(map(int,input().split()))
        first.append((a,b))
        second.append((b,a))
    
    solve(first,second,n,mod)


main()
</ans>",0,{}
159,"<ans>
import sys
print(""n: "", str(n), ""k: "", str(k))
x = []
y = []
mx = []
my = []
for _ in range(n):
    xx, yy, c = sys.stdin.readline().strip().split()
    xx = int(xx)
    yy = int(yy)
    if c == 'W':
        xx += k
    xx %= 2 * k
    yy %= 2 * k
    if xx >= k:
        if yy >= k:
            x.append(xx - k)
            y.append(yy - k)
        else:
            mx.append(xx - k)
            my.append(yy)
    else:
        if yy >= k:
            mx.append(xx)
            my.append(yy - k)
        else:
            x.append(xx)
            y.append(yy)
print(""x: "", str(x), ""y: "", str(y), ""mx: "", str(mx), ""my: "", str(my)

graph = [[0 for _ in range(k)] for __ in range(k)]

#累積和
#lx + lmx = n
lx = len(x)
graph[0][0] += lx
for i in range(lx):
    graph[x[i]][0] -= 1
    graph[0][y[i]] -= 1
    graph[x[i]][y[i]] += 2

lmx = len(mx)
graph[0][0] -= lmx
for i in range(lmx):
    graph[mx[i]][0] += 1
    graph[0][my[i]] += 1
    graph[mx[i]][my[i]] -= 2

for i in graph:
    for j in range(k-1):
        i[j+1] += i[j]

for i in range(k):
    for j in range(k-1):
        graph[j+1][i] += graph[j][i]

#最大値、最小値を取得
big = max([max(i) for i in graph]) + lmx
small = min([min(i) for i in graph]) - lx

if big + small >= 0:
    print(big)
else:
    print(-small)
</ans>",0,{}
160,"<ans>
def run():
    N = int(input())
    print(""N: "", str(N))
    nines = [9 ** i for i in range(1, 10) if 9 ** i <= N]
    print(""nines: "", str(nines))
    sixes = [6 ** i for i in range(1, 10) if 6 ** i <= N][::-1]
    print(""sixes: "", str(sixes)
    L = len(nines)
    min_ans = INF
    for K in product(list(range(9)), repeat = L):
        ans = 0
        s = 0
        for k, x in zip(K, nines):
            if k:
                ans += k
                s += x * k

        if s > N:continue
        resid = N - s
        for six in sixes:
            tmp = resid // six
            if tmp:
                ans += tmp
                resid -= six * tmp
        ans += resid
        min_ans = min(min_ans,ans)

    print(min_ans)

def __starting_point():
    run()

__starting_point()
</ans>",0,{}
161,"<ans>
def main():
    n = ii()
    print(""n: "", str(n))
    a = lmi()
    print(""a: "", str(a))
    q = ii()
    print(""q: "", str(q))
    bit = BIT(a)
    print(""bit: "", str(bit))
    for i in range(q):
        l, r = mi()
        print(""l: "", str(l), ""r: "", str(r))
        a = bit.query(l, r+1)
        print(""a: "", str(a))
        print((a-a % 10)//10)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
162,"<ans>
def solve(w, s):
    print(""free: "", str(free))
    print(""used: "", str(used))
    free = collections.deque()
    used = collections.deque()

    for w in sorted(enumerate(w), key=lambda x: x[1]):
        free.append([w[0] + 1, w[1])
        print(""free: "", str(free))
    
    ids = [-1] * len(s)

    order = []
    for pid, p in enumerate(s):
        logger.debug('pid: %s', pid)
        if p == '0':
            taken = free.popleft(), 
            used.appendleft(taken)
            print(""free: "", str(free))
            print(""used: "", str(used))
            # order.append(pid, taken[0])
        else:
            logger.debug('used %s', used)
            taken = used.popleft()
            print(""used: "", str(used))
        #order.append([pid, taken[0]])
        ids[pid] = taken[0]
        print(""ids: "", str(ids))

    return [x for x, y in ids]
</ans>",0,{}
163,"<ans>
def solve():
    n, m, k = map(int, stdin.readline().split())
    print(""n: "", str(n), ""m: "", str(m), ""k: "", str(k))
    cnts = list(map(int, stdin.readline().split()))
    print(""cnts: "", str(cnts))
    for i in range(1,k):
        cnts[i] += cnts[i-1
    
    group = list(range(n))
    print(""group: "", str(group))
    rnk = [0 for i in range(n)]
    print(""rnk: "", str(rnk))
    adj = [[INF for j in range(k)] for i in range(k)]
    print(""adj: "", str(adj))
    for i in range(m):
        u, v, x = map(int, stdin.readline().split())
        print(""u: "", str(u), ""v: "", str(v), ""x: "", str(x))
        if x==0:
            union(group, rnk, u-1, v-1)
        tu = bisect_left(cnts, u)
        tv = bisect_left(cnts, v)
        adj[tu][tv] = min(adj[tu][tv], x)
        adj[tv][tu] = min(adj[tv][tu], x)
    
    p = 0
    for i in range(k):
        cur = group[p]
        while p<cnts[i]:
            if group[p]!=cur:
                print(""No"")
                return
            p += 1
    print(""Yes"")
    
    for p in range(k):
        for i in range(k):
            for j in range(k):
                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])
    
    for i in range(k):
        adj[i][i] = 0
        for j in range(k):
            if adj[i][j] == INF:
                adj[i][j] = -1
    
    for i in range(k):
        print(' '.join(map(lambda x: str(x), adj[i])))
    
    
solve()
</ans>",0,{}
164,"<ans>
def valid(x,y):
    print(""x: "", str(x), ""y: "", str(y))
    if x>=n or y>=m or x<0 or y<0:
        return False
    if v[x][y] or l[x][y]=='*':
        return False
    return True

def DFS(i,j,val):
    print(""i: "", str(i), ""j: "", str(j), ""val: "", str(val))
    ans=1
    connected=[(i,j)]
    stack=[(i,j)]
    v[i][j]=True
    while stack:
        a,b=stack.pop()
        for x in range(4):
            newX,newY=a+dx[x], b+dy[x]
            if valid(newX,newY):
                stack.append((newX,newY))
                v[newX][newY]=True
                connected.append((newX,newY))
                ans= (ans%10 + 1%10) % 10
                
    for i in connected:
        a,b=i
        l[a][b]=(ans,val)
</ans>",0,{}
165,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

M = mod = 998244353
print(""M: "", str(M), ""mod: "", str(mod))
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]


for _ in range(val()):
    n,l,r = li()
    print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))
    orig = r
    print(""orig: "", str(orig))
    l -= 1
    r -= l


    currleft = 0
    curs = n - 1
    while curs and currleft + 2*curs <= l:
        currleft += 2*curs
        curs -= 1
    
    start = n - curs
    ans = []
    head = start
    l -= currleft

    last = head + 1
    half = 0
    while l:
        half = 1
        start = last
        last += 1
        l -= 1
        if not l:break
        half = 0
        start = head
        l -= 1

    if half:
        ans.append(start)
        if last == n + 1:
            head += 1
            last = head + 1
        start = head
        r -= 1

    while r:
        ans.append(start)
        r -= 1
        if not r:break
        start = last
        ans.append(start)
        last += 1
        if last == n + 1:
            head += 1
            last = head + 1
        r -= 1
        start = head
    
    if orig == n*(n-1) + 1:
        ans[-1] = 1

    print(*ans)
</ans>",0,{}
166,"<ans>
array2=input("""").split(' ')
print(""array2: "", str(array2))
summ=0
print(""summ: "", str(summ))
array=list()
print(""array: "", str(array))
for t in range (0,int(array2[0])):
    g=input("""")
    array.append(g)
    print(""g: "", str(g))
if (int(array2[1])==0):
    for b in range (0,int(array2[0])):
        if '0' in array[b]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==1):
    for c in range (0,int(array2[0])):
        if '0' in array[c] and '1' in array[c]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==2):
    for d in range (0,int(array2[0])):
        if '0' in array[d] and '1' in array[d] and '2' in array[d]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==3):
    for e in range (0,int(array2[0])):
        if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==4):
    for f in range (0,int(array2[0])):
        if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==5):
    for g in range (0,int(array2[0])):
        if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==6):
    for h in range (0,int(array2[0])):
        if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==7):
     for i in range (0,int(array2[0])):
                if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:
                    summ=summ+1
     print(""summ: "", str(summ))
if (int(array2[1])==8):
    for j in range (0,int(array2[0])):
        if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:
            summ=summ+1
    print(""summ: "", str(summ))
if (int(array2[1])==9):
    for k in range (0,int(array2[0])):
        if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:
            summ=summ+1
    print(""summ: "", str(summ))
</ans>",0,{}
167,"<ans>
def main():  
    #n = iinput()
    #k = iinput() 
    #m = iinput() 
    #n = int(sys.stdin.readline().strip()) 
    #n, k = rinput()
    #n, m = rinput()
    #m, k = rinput()
    #n, k, m = rinput()
    #n, m, k = rinput()
    #k, n, m = rinput()
    #k, m, n = rinput() 
    #m, k, n = rinput()
    #m, n, k = rinput()
    #q = srlinput()
    #q = linput()
    x, y, n = rinput()
    print(""x: "", str(x), ""y: "", str(y), ""n: "", str(n))
    res = n - y
    print(""res: "", str(res))
    print(x * (res // x) + y)

    
for inytd in range(iinput()):
    main()
</ans>",0,{}
168,"<ans>
def bitmake(digit):#bit文字列生成（取り扱い注意）
    bit_list =list()

    for i in range(2 ** digit):
        bit = []
        for j in range(digit):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                bit.append(j)
        bit_list.append(bit)
    return bit_list
h,w,k = list(map(int,input().split()))
print(""h: "", str(h), ""w: "", str(w), ""k: "", str(k))
grid = [""""]*h
print(""grid: "", str(grid))
for i in range(h):
    grid[i] = list(map(str,input()))
    print(""grid: "", str(grid))
# print(grid)

bit_list = bitmake(h+w)
print(""bit_list: "", str(bit_list))
# print(bit_list)
blackh = [0]*h#横
blackw = [0]*w#縦
blacksum = 0
print(""blackh: "", str(blackh), ""blackw: "", str(blackw), ""blacksum: "", str(blacksum))
for i in range(h):
    for j in range(w):
        if(grid[i][j] == ""#""):
            blackh[i]+=1
            blackw[j]+=1
            grid[i][j] = 1
            blacksum += 1
        else:
            grid[i][j] = 0
print(""blackh: "", str(blackh), ""blackw: "", str(blackw))
# print(blackh,blackw)
ans = 0
print(""ans: "", str(ans))
for i in range(2**(h+w)):
    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1
    remove = 0
    hight = []
    width = []
    for j in range(len(bit)):
        l = bit[j]
        if(l <= h-1):
            remove += blackh[l]
            hight.append(l)
        else:
            ind = l - h
            remove += blackw[ind]
            width.append(ind)
    # print(hight,width)
    rid = 0
    for j in range(len(hight)):
        for l in range(len(width)):
            if(grid[hight[j]][width[l]] == 1):
                rid += 1
    
    if((blacksum - remove) + rid == k):
        # print(blacksum,remove,rid,""___"",blacksum-remove+rid)  
        ans += 1
print(""ans: "", str(ans))
</ans>",0,{}
169,"<ans>
n=int(input())
if (n == 1) :
 print (""Washington"")
elif (n == 2):
 print (""Adams"")
elif (n == 3):
 print (""Jefferson"")
elif (n == 4):
 print (""Madison"")
elif (n == 5):
 print (""Monroe"")
elif (n == 6):
 print (""Adams"")
elif (n == 7):
 print (""Jackson"")
elif (n == 8):
 print (""Van Buren"")
elif (n == 9):
 print(""Harrison"")
elif (n == 10):
 print(""Tyler"")
elif (n == 11):
 print(""Polk"")
elif (n == 12):
 print(""Taylor"")
elif (n == 13):
 print(""Fillmore"")
elif (n == 14):
 print(""Pierce"")
elif (n == 15):
 print(""Buchanan"")
elif (n == 16):
 print (""Lincoln"")
elif (n == 17):
 print (""Johnson"")
elif (n == 18):
 print (""Grant"")
elif (n == 19):
 print (""Hayes"")
elif (n == 20):
 print (""Garfield"")
elif (n == 21):
 print (""Arthur"")
elif (n == 22):
 print (""Cleveland"")
elif (n == 23):
 print (""Harrison"")
elif (n == 24):
 print (""Cleveland"")
elif (n == 25):
 print (""McKinley"")
elif (n == 26):
 print (""Roosevelt"")
elif (n == 27):
 print (""Taft"")
elif (n == 28):
 print (""Wilson"")
elif (n == 29):
 print ('Harding')
elif (n == 30):
 print (""Coolidge"")
elif (n == 31):
 print (""Hoover"")
elif (n == 32):
 print (""Roosevelt"")
elif (n == 33):
 print (""Truman"")
elif (n == 34):
 print (""Eisenhower"")
elif (n == 35):
 print (""Kennedy"")
elif (n == 36):
 print (""Johnson"")
elif (n == 37):
 print (""Nixon"")
elif n == 38:
 print (""Ford"")
elif n == 39:
 print (""Carter"")
elif n == 40:
 print (""Reagan"")
</ans>",0,{}
170,"<ans>
import math
from decimal import Decimal
import heapq
def na():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,b
 
 
def nab():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,c
 
 
def dv():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	return n,m
 
 
def dva():
	n, m = list(map(int, input().split()))
	print(""n: "", str(n), ""m: "", str(m))
	a = [int(x) for x in input().split()]
	print(""a: "", str(a))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	return n,m,b
 
 
def eratosthenes(n): 
	sieve = list(range(n + 1))
	for i in sieve:
		if i > 1:
			for j in range(i + i, len(sieve), i):
				sieve[j] = 0
	return sorted(set(sieve))
 
 
def lol(lst,k):
	k=k%len(lst)
	ret=[0]*len(lst)
	for i in range(len(lst)):
		if i+k<len(lst) and i+k>=0:
			ret[i]=lst[i+k]
		if i+k>=len(lst):
			ret[i]=lst[i+k-len(lst)]
		if i+k<0:
			ret[i]=lst[i+k+len(lst)]
	return(ret)
def nm():
	n = int(input())
	print(""n: "", str(n))
	b = [int(x) for x in input().split()]
	print(""b: "", str(b))
	m = int(input())
	print(""m: "", str(m))
	c = [int(x) for x in input().split()]
	print(""c: "", str(c))
	return n,b,m,c
 
 
def dvs():
	n = int(input())
	print(""n: "", str(n))
	m = int(input())
	print(""m: "", str(m))
	return n, m 
def Factor(n):
	Ans = []
	d = 2
	while d * d <= n:
		if n % d == 0:
			Ans.append(d)
			n //= d
		else:
			d += 1
	if n > 1:
		Ans.append(n)
	return Ans


s = input()
a1 = 'Mike'
print(""a1: "", str(a1))
a2 = 'Ann'
print(""a2: "", str(a2))
if len(s) == 1:
	print(a1)
	return
print(a1)
tc = s[0]
print(""tc: "", str(tc))
pre = []
n = len(s)
print(""n: "", str(n))
for i in range(1, n):
	d = min(s[i], tc)
	pre.append(d)
	tc = d
for i in range(1, n):
	if pre[i - 1] < s[i]:
		print(a2)
	else:
		print(a1)
</ans>",0,{}
171,"<ans>
t,sx,sy,ex,ey=map(int,input().split())
print(""t: "", str(t), ""sx: "", str(sx), ""sy: "", str(sy), ""ex: "", str(ex), ""ey: "", str(ey))
w=input()
print(""w: "", str(w))
n=len(w)
print(""n: "", str(n))
w+="" ""
ans=-1
print(""ans: "", str(ans))
i=0
print(""i: "", str(i))
dx=ex-sx
print(""dx: "", str(dx))
dy=ey-sy
print(""dy: "", str(dy))
if abs(dx)+abs(dy)>t:
    pass
else:
    while i<=t and i<n:
        if dx==0 and dy==0:
            ans=i
            break
        if dx>=0 and dy>=0:
            if ((w[i]!=""E"" and w[i]!=""N"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                dx-=1
            if dy>0 and w[i]==""N""and i<n:
                i+=1
                dy-=1
        elif dx>=0 and dy<=0:
            if ((w[i]!=""E"" and w[i]!=""S"") or (dx==0 and w[i]==""E"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
            if dx>0 and w[i]==""E"" and i<n:
                i+=1
                dx-=1
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                dy+=1
        elif dx<=0 and dy>=0:
            if ((w[i]!=""W"" and w[i]!=""N"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""N"")) and i<n:
                i+=1
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                dx+=1
            if dy>0 and w[i]==""N"" and i<n:
                i+=1
                dy-=1
        elif dx<=0 and dy<=0:
            if ((w[i]!=""W"" and w[i]!=""S"") or (dx==0 and w[i]==""W"") or (dy==0 and w[i]==""S"")) and i<n:
                i+=1
            if dx<0 and w[i]==""W"" and i<n:
                i+=1
                dx+=1
            if dy<0 and w[i]==""S"" and i<n:
                i+=1
                dy+=1
if dx==0 and dy==0:
            ans=i
print(""ans: "", str(ans))
</ans>",1,{}
172,"<ans>
def __starting_point():
    inp = input()
    print(""inp: "", str(inp))
    arr = inp.split(' ')
    print(""arr: "", str(arr))
    L = [int(x) for x in arr]
    print(""L: "", str(L))
    ans = [0,0,0]
    print(""ans: "", str(ans))
    s = 0
    print(""s: "", str(s))
    for l in L:
        s+=l
    print(""s: "", str(s))
    imp = False
    print(""imp: "", str(imp))
    for l in L:
        if l>s/2:
            imp = True
    print(""imp: "", str(imp))
    if imp:
        print('Impossible')
    else:
##        m = min(L)//2
##        for i in (0,1,2):
##            ans[i]+=m
##            L[i]-=m*2
####        print(ans)
        imp = False
        print(""imp: "", str(imp))
        if L[0]==min(L):
            if L[1]>L[2]:
                bonds = L[1]-L[2]
                ans[0] += bonds
                L[0]-= bonds
                L[1] -=bonds
            else:
                bonds = L[2]-L[1]
                ans[2] += bonds
                L[0] -= bonds
                L[2] -= bonds
            if L[0]%2==1:
                imp = True
            else:
                bonds = L[0]//2
                ans[0] += bonds
                ans[2] += bonds
                ans[1] += (L[1]+L[2])//2 - bonds
        elif L[1]==min(L):
            if L[0]>L[2]:
                bonds = L[0]-L[2]
                ans[0] += bonds
                L[1]-= bonds
                L[0] -= bonds
            else:
                bonds = L[2]-L[0]
                ans[1] += bonds
                L[1] -= bonds
                L[2] -= bonds 
            if L[1]%2==1:
                imp = True
            else:
                bonds = L[1]//2
                ans[0] += bonds
                ans[1] += bonds
                ans[2] += (L[0]+L[2])//2 - bonds

        else:
            if L[0]>L[1]:
                bonds = L[0]-L[1]
                ans[2] += bonds
                L[2]-= bonds
                L[0]-=bonds
            else:
                bonds = L[1]-L[0]
                ans[1] += bonds
                L[2] -= bonds
                L[1] -= bonds
            if L[2]%2==1:
                imp = True
            else:
                bonds = L[2]//2
                ans[2] += bonds
                ans[1] += bonds
                ans[0] += (L[0]+L[1])//2 - bonds
            
        for i in ans:
            if i<0:
                imp = True
        print(""imp: "", str(imp))
        if imp:
            print('Impossible')
        else:
            for i in range(3):
                print(ans[i],end=' ')
            print()

__starting_point()
</ans>",0,{}
173,"<ans>
n,k=num()
print(""n: "", str(n), ""k: "", str(k))
h=li()
print(""h: "", str(h))
a=[0]*(max(h)+5)
print(""a: "", str(a))
mx=max(h)
print(""mx: "", str(mx))
mn=min(h)
print(""mn: "", str(mn))
fo=True
print(""fo: "", str(fo))
for i in range(1,n):
	if(h[i]!=h[i-1]):
		fo=False
		break
print(""i: "", str(i))
a[0]+=1
print(""a: "", str(a))
a[h[i]+1]-=1
print(""a: "", str(a))
for i in range(n):
	a[0]+=1
	a[h[i]+1]-=1
print(""i: "", str(i), ""a: "", str(a))
for i in range(1,len(a)):
	a[i]=a[i]+a[i-1]
print(""i: "", str(i), ""a: "", str(a))
s=a[mx]
print(""s: "", str(s))
cc=0
print(""cc: "", str(cc))
fl=False
print(""fl: "", str(fl))
for i in range(mx-1,mn,-1):
	if(s+a[i]>k):
		fl=True
		s=a[i]
		cc+=1
	else:
		fl=False
		s+=a[i]
print(""i: "", str(i), ""s: "", str(s), ""cc: "", str(cc))
if(s<=k and fo==False):
	cc+=1
print(""cc: "", str(cc))
print(cc)
</ans>",0,{}
174,"<ans>
MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]
def check(a):
    return 0<=a<8
set1 = set()
print(""set1: "", str(set1))
set2 = set()
print(""set2: "", str(set2))
dic1 = dict()
print(""dic1: "", str(dic1))
dic2 = dict()
print(""dic2: "", str(dic2))
def cango1(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check (nx) or not check(ny):
            continue
        if (nx,ny) in set1:
            continue
        dic1[(nx,ny)]=lap%2
        set1.add((nx,ny))
        cango1(matrix,(nx,ny),lap+1)
def cango2(matrix,pos,lap):
    for dx,dy in MOVS:
        nx,ny = dx+pos[0],dy+pos[1]
        if not check(nx) or not check(ny):
            continue
        if (nx,ny) in set2:
            continue
        dic2[(nx,ny)]=lap%2
        set2.add((nx,ny))
        cango2(matrix,(nx,ny),lap+1)
q = int(input())
for ww in range(q):
    matrix = [input().strip() for i in range(8)]
    pos = []
    bad = set()
    for i in range(8):
        for j in range(8):
            if matrix[i][j] == 'K':
                pos.append((i,j))
            if matrix[i][j]=='#':
                bad.add((i,j))
    set1,set2,dic1,dic2=set(),set(),dict(),dict()
    cango1(matrix, pos[0],0)
    cango2(matrix,pos[1],0)
    if ww!=q-1:
        input()
    sec = (set1&set2) - bad
    for x,y in sec:
        if dic1[(x,y)]==dic2[(x,y)]:
            print(""YES"")
            break
    else:
        print(""NO"")
</ans>",0,{}
175,"<ans>
def find_start(pile):
    start = 1
    index = -1
    print(""start: "", str(start))
    print(""index: "", str(index))

    for i in range(len(pile)):
        if pile[i] == start:
            index = i
            break
    latest = start
    print(""latest: "", str(latest))
    print(""index: "", str(index))
    if index != -1:
        flag = True
        for i in range(index, len(pile)):
            if pile[i] == latest:
                latest += 1
            else:
                flag = False
                break

        if flag:
            start = latest
    print(""start: "", str(start))

def check_start(num, op):
    op[0] = 0
    print(""op: "", str(op))
    print(""arr: "", str(arr))
    print(""barr: "", str(barr))

    mydict = [0] * (n + 1)
    for i in range(len(arr)):
        mydict[arr[i]] += 1

    zeroes = mydict[0]
    print(""mydict: "", str(mydict))
    print(""zeroes: "", str(zeroes))

    pile = deque(barr[:])
    print(""pile: "", str(pile))

    for i in range(num):
        if zeroes > 0:
            op[0] += 1
            pile.append(0)
            zeroes -= 1
            mydict[0] -= 1
        else:
            return False

        element = pile.popleft()
        mydict[element] += 1

        if element == 0:
            zeroes += 1

    start = find_start(barr)
    print(""start: "", str(start))

    for i in range(start, n + 1):
        if mydict[i] > 0:
            op[0] += 1
            pile.append(i)
            mydict[i] -= 1
            element = pile.popleft()
            mydict[element] += 1
        else:
            return False
    return True

n = int(stdin.readline().strip())
arr = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
start = 0
end = 2 * n
op = [0]

if check_start(0, op):
    print(op[0])
    return

pos = [0] * (n + 1)
for i in range(n):
    pos[barr[i]] = i + 1

ans = -float('inf')
for i in range(1, n + 1):    
    ans = max(pos[i] - i  + 1 + n, ans)
print(ans)
</ans>",0,{}
176,"<ans>
def xmax(x, y):
    if x[1] > y[1]:
        return x
    return y

class SegTree:
    def __init__(self, init_val, n, ide_ele, seg_func):
        self.segfunc = seg_func
        self.num = 2**(n-1).bit_length()
        self.ide_ele = ide_ele
        self.seg=[self.ide_ele]*2*self.num
        for i in range(n):
            self.seg[i+self.num-1]=init_val[i]    
        for i in range(self.num-2,-1,-1) :
            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) 
        print(""seg: "", str(self.seg)

    def update(self, k, x):
        ll = k
        k += self.num-1
        self.seg[k] = (ll, self.seg[k][1] + x)
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
        print(""seg: "", str(self.seg)

    def update2(self, k, x):
        k += self.num-1
        self.seg[k] = x
        while k+1:
            k = (k-1)//2
            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
        print(""seg: "", str(self.seg)
        
    def query(self, p, q):
        if q<=p:
            return self.ide_ele
        p += self.num-1
        q += self.num-2
        res=self.ide_ele
        while q-p>1:
            if p&1 == 0:
                res = self.segfunc(res,self.seg[p])
            if q&1 == 1:
                res = self.segfunc(res,self.seg[q])
                q -= 1
            p = p//2
            q = (q-1)//2
        if p == q:
            res = self.segfunc(res,self.seg[p])
        else:
            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])
        return res

import sys;input=sys.stdin.readline
N, M = map(int, input().split())
X = list(map(int, input().split()))
print(""X: "", str(X))
sts = [[] for _ in range(N)]
for i in range(1, M+1):
    a, b = map(int, input().split())
    sts[a-1].append((i, b-1))
    sts[b-1].append((i, a-1))
    X[a-1] -= 1
    X[b-1] -= 1
    print(""sts: "", str(sts))
    print(""X: "", str(X))
minf = -(10 ** 18)-1
ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)
f = False
R = []
vs = set()
while True:
    j, mx = ss.query(0, N)
    if mx<0:
        f=True
        break
    while sts[j]:
        i, co = sts[j].pop()
        if i in vs:
            continue
        vs.add(i)
        ss.update(co, 1)
        R.append(i)
    if len(R) == M:break
    ss.update2(j, (j, minf))

if f or len(R) != M:print(""DEAD"")
else:print(""ALIVE"");print(*R[::-1])
</ans>",0,{}
177,"<ans>
import sys
import math

def ii():
    return sys.stdin.readline().strip()

def idata():
    return [int(x) for x in ii().split()]

def bfs(graph1, root1):
    visited1 = set()
    queue1 = [[root1, 0]]
    visited1.add(root1)
    qw, ver = 0, 1
    while queue1:
        vertex1 = queue1[0]
        queue1 = queue1[1:]
        for neig1 in graph1[vertex1[0]]:
            if neig1 not in visited1:
                visited1.add(neig1)
                queue1 += [[neig1, vertex1[1] + 1]]
                if qw < vertex1[1] + 1:
                    ver, qw = neig1, vertex1[1] + 1
    return ver, qw

def dfs(graph, ver):
    used_v = set()
    depth = [0] * (len(graph) + 1)
    level = [ver]
    num_of_level = 0
    while level:
        new_level = []
        for v in level:
            depth[v] = num_of_level
            used_v.add(v)
            for v1 in graph[v]:
                if v1 not in used_v:
                    new_level += [v1]
        level = new_level
        num_of_level += 1
    return depth

def binary_search(array, x):
    left, right = -1, len(array)
    while left + 1 != right:
        middle = (left + right) // 2
        if array[middle] >= x:
            right = middle
        elif array[middle] < x:
            left = middle
    return right

def c_mod(n1, k1, mod1):
    num = den = 1
    for i in range(n1 - k1):
        num = (num * (n1 - i)) % mod1
        den = (den * (i + 1)) % mod1
    return (num * pow(den, mod1 - 2, mod1)) % mod1

def c(n1, k1):
    num = den = 1
    for i in range(n1 - k1):
        num = num * (n1 - i)
        den = den * (i + 1)
    return num // den

def v_sistemu(x, k):
    x = int(x)
    z = ''
    while x:
        z += str(x % k)
        x //= k
    return z[::-1]

def iz_sistemi(x, k):
    x = str(x)[::-1]
    ans = 0
    for i in range(len(x)):
        ans += int(x[i]) * pow(k, i)
    return ans

def solve_of_problem():
    n = int(ii())
    ans = 2
    print(""n: "", str(n))
    for i in range(n):
        ans *= 2
        if n % (ans - 1) == 0:
            print(""i: "", str(i))
            print(""ans: "", str(ans))
            print(""n // (ans - 1): "", str(n // (ans - 1)))
            return
    return

for ______ in range(int(ii())):
    solve_of_problem()
</ans>",0,{}
178,"<ans>
n = int(input())
print(""n: "", str(n))
a = [int(i) for i in input().split()]
print(""a: "", str(a))
d = [int(0) for i in range(0, n)]
print(""d: "", str(d))

ok = 0

cur = 0

len = Lcm(7, n)

for i in range(0, 7 * n):
    if a[i % n] == 0 :
        print(i % n + 1)
        ok = 1
        break
    if cur != 6:
        a[i % n] -= 1
        d[i % n] += 1
    cur = (cur + 1) % 7

if ok == 0:
    k = 10**20

    for i in range(0, n):
        a[i] += d[i]
        if d[i] == 0: continue
        if a[i] % d[i] > 0:
            k = Min(k, a[i] // d[i])
        else:
            k = Min(k, a[i] // d[i] - 1)

    if k == 10**20:
        k = 0

    for i in range(0, n):
        a[i] -= k * d[i]

    iter = 0
    cur = 0

    while True:
        if a[iter] == 0:
            print(iter % n + 1)
            break
        else:
            if cur != 6:
                a[iter] -= 1
            cur = (cur + 1) % 7
            iter = (iter + 1) % n
</ans>",0,{}
179,"<ans>
A: 5 B: 10 C: 100 X: 1000 Y: 1000
if 2 * C > A + B:
    print(A * X + B * Y)
else:
    if X > Y:
        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))
    else:
        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))
</ans>",0,{}
180,"<ans>
import sys
print(""N: "", str(N), ""M: "", str(M))

sys.setrecursionlimit(10**9)
N,M=map(int,input().split())

def find_negative_loop(n,w,es):
  dist=[float(""inf"")]*n
  print(""dist: "", str(dist))
  #この始点はどこでもよい
  dist[1]=0
  print(""dist: "", str(dist))
  
  for i in range(n):
    for j in range(w):
      e=es[j]
      if dist[e[1]]>dist[e[0]]+e[2]:
        dist[e[1]]=dist[e[0]]+e[2]
        print(""dist: "", str(dist))
        if i==n-1:
          return True
  return False

def shortest_path(s,n,w,es):
  #s→iの最短距離
  #s:始点, n:頂点数, w:辺の数, es[i]:[辺の始点,辺の終点,辺のコスト]
  dist=[float(""inf"")]*n
  print(""dist: "", str(dist))
  #d[i]: s→iの最短距離
  dist[s]=0
  print(""dist: "", str(dist))

  while True:
    update=False
    for p,q,r in es:
      # e: 辺iについて [from,to,cost]
      if dist[p]!=float(""inf"") and dist[q]>dist[p]+r:
        dist[q]=dist[p]+r
        print(""dist: "", str(dist))
        update=True
    if not update:
      break
      
  return dist

graph=[[] for _ in range(N+1)]
elist=[]
for _ in range(M):
  a,b,c=map(int,input().split())
  graph[a].append(b)
  elist.append((a,b,-c))
  
#remove unnecessary vertex and edge
visited=[None]*(N+1)
def check_reachable(u):
  visited[u]=True
  if u==N:
    reachable[u]=True
    return True
  elif reachable[u]!=None:
    return reachable[u]  

  cnt=0
  for v in graph[u]:
    if not visited[v]:
      ret=check_reachable(v)
      if ret:
        cnt+=1
        
  if cnt>0:
    reachable[u]=True
    return True
  else:
    reachable[u]=False
    return False

reachable=[None]*(N+1)
for i in range(1,N+1):
  if reachable[i]==None:
    visited=[False]*(N+1)
    check_reachable(i)
#print(reachable)
  
elist2=[]
for a,b,nc in elist:
  if reachable[b]:
    elist2.append((a,b,nc))
  
M2=len(elist2)
res1=find_negative_loop(N+1,M2,elist2)

if res1:
  print(""inf"")
else:
  res2=shortest_path(1,N+1,M2,elist2)
  print(-res2[N])
</ans>",0,{}
181,"<ans>
for _ in range(ii()):
    n, k = mi()
    print(""n: "", str(n), ""k: "", str(k))
    even = n - 2*(k - 1)
    print(""even: "", str(even))
    odd = n - (k - 1)
    print(""odd: "", str(odd))
    if odd > 0 and odd % 2:
        res = [1]*(k - 1) + [odd]
        print('YES')
        prr(res, ' ')
    elif even > 0 and even % 2 == 0:
        res = [2] * (k - 1) + [even]
        print('YES')
        prr(res, ' ')
    else:
        print('NO')
</ans>",0,{}
182,"<ans>
def isSubSequence(str1,str2):
    m = len(str1)
    n = len(str2)
    j = 0    # Index of str1 
    i = 0    # Index of str2 
    while j<m and i<n: 
        if str1[j] == str2[i]:     
            j = j+1    
        i = i + 1
    return j==m

T = int(input())

for t in range(T):
    s = input()
    t = input()
    p = input()
    
    freq_s = {}
    freq_t = {}
    freq_p = {}
    for i in range(26):
        freq_s[chr(97+i)] = 0
        freq_t[chr(97+i)] = 0
        freq_p[chr(97+i)] = 0
        
    for letter in s:
        freq_s[letter] += 1
    for letter in t:
        freq_t[letter] += 1
    for letter in p:
        freq_p[letter] += 1
    
    sub = isSubSequence(s,t)
    if sub==0:
        print('NO')
    else:
        flag = 0
        for i in range(26):
            d = freq_t[chr(97+i)] - freq_s[chr(97+i)]
            if d>0:
                if freq_p[chr(97+i)]<d and flag==0:
                    print('NO')
                    flag = 1
                    
        if flag==0:
            print('YES')
</ans>",0,{}
183,"<ans>
def resolve():
    N = int(input())
    print(""N: "", str(N))
    C = []
    for i in range(N):
        a = int(input())
        print(""a: "", str(a))
        C.append([list(map(int, input().split())) for j in range(a])
        print(""C: "", str(C))

    ans = 0
    for bit in range(1 << N):
        f = True
        for i in range(N):
            if bit & (1 << i):
                for c in C[i]:
                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
                        f = False
                        break
        if f == True:
            ans = max(ans, bin(bit).count(""1""))
    print(""ans: "", str(ans))


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",0,{}
184,"<ans>
prime = 998244353
print(""prime: "", str(prime)
t = 1#int(input())
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))
grp = []
cnt = []
tmp = 0
cur = s[0]
print(""cur: "", str(cur))
for i in s:
    if i==cur:
        tmp+=1
    else:
        grp.append(cur)
        cnt.append(tmp)
        cur = i
        tmp = 1
grp.append(cur)
cnt.append(tmp)
print(""grp: "", str(grp))
print(""cnt: "", str(cnt))
if len(grp)==1:
    print(((n*(n+1))//2)%prime)
else:
    if grp[0]==grp[-1]:
        ans = ((cnt[0]+1)*(cnt[-1]+1))%prime
        print(""ans: "", str(ans))
        print(ans)
    else:
        ans = cnt[0]+1+cnt[-1]
        ans = ans%prime
        print(""ans: "", str(ans))
        print(ans)
</ans>",0,{}
185,"<ans>
n, l, r = [int(i) for i in input().split()]
print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r)

#dp = [[0 for i in range(3)] for j in range(3)]

number_of_zeros = 0
number_of_ones = 0
number_of_twos = 0

if l%3 == 0:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
elif l%3 == 1:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3 + 1
elif l%3 == 2:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    elif r%3 == 2:
        number_of_zeros = (r-l+1)//3 
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1

dp = [[-1 for i in range(3)] for j in range(n+1)]
print(""number_of_zeros: "", str(number_of_zeros), ""number_of_ones: "", str(number_of_ones), ""number_of_twos: "", str(number_of_twos))

MOD = 10**9 + 7
dp[1][0] = number_of_zeros%MOD
dp[1][1] = number_of_ones%MOD
dp[1][2] = number_of_twos%MOD

for i in range(2,n+1):
    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD
    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD
    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD

if dp[n][0]!=-1:
    print(dp[n][0]%MOD)
else:
    print(0)
</ans>",0,{}
186,"<ans>
n , a , b = readline(int)
print(""n: "", str(n), ""a: "", str(a), ""b: "", str(b)
price = [a,b]
print(""price: "", str(price))
arr = readlist(int)
print(""arr: "", str(arr))
half = n//2
cost = 0
flg = True
for i in range(half):
    if arr[i] == arr[n-1-i] == 2:
        cost += 2*min(a,b)
    elif arr[i] ==2 and arr[n-1-i] <= 1:
        cost += price[arr[n-1-i]]
    elif arr[i] <= 1 and arr[n-1-i] == 2:
        cost += price[arr[i]]
    elif arr[i] != arr[n-1-i]:
        flg = False
        break
if n%2 == 1:
    if arr[half] == 2:
        cost += min(a,b)
if not flg:
    print(-1)
else:
    print(cost)
</ans>",0,{}
187,"<ans>
def main():
    N = ri()
    print(""N: "", str(N))
    A = ria()
    print(""A: "", str(A))
    A = sorted(A)
    print(""A: "", str(A))
    A = list(reversed(A))
    print(""A: "", str(A))
    Pow2 = [mint(0)] * (N + 1)
    print(""Pow2: "", str(Pow2))
    Pow2[0] = mint(1)
    print(""Pow2: "", str(Pow2))
    for i in range(1,N+1): Pow2[i] = Pow2[i-1] * 2
    print(""Pow2: "", str(Pow2))

    tot = mint(0)
    print(""tot: "", str(tot))
    for i in range(N):
        tot += mint(A[i]) * Pow2[N-1]
        print(""tot: "", str(tot))
        if i > 0: tot += mint(A[i]) * i * Pow2[N-2]
        print(""tot: "", str(tot))
    tot *= Pow2[N]
    print(""tot: "", str(tot))

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
188,"<ans>
r1=input()
print(""r1: "", str(r1))
r2=input()
print(""r2: "", str(r2))
n=len(r1)
l=[0]
print(""n: "", str(n))
print(""l: "", str(l))
for i in range(n):
	if r1[i]=='0':
		if r2[i]=='0':
			l.append(2)
		else:
			l.append(1)
	else:
		if r2[i]=='X':
			l.append(0)
		else:
			l.append(-1)
print(""i: "", str(i))
print(""l: "", str(l))
l.append(0)
s=len(l)
print(""s: "", str(s))
count=0
print(""count: "", str(count))
u=1
print(""u: "", str(u))
e=1
print(""e: "", str(e))
while(u<s-1):
	if l[u]==2 and e==1:
		if l[u+1]==2:
			e=2
			u=u+1
			continue
		elif (l[u+1]==1 or l[u+1]==-1):
			count=count+1
			u=u+2
			continue
		else:
			u=u+2
			continue
	if l[u]==2 and e==2:
		if l[u+1]==2:
			count=count+2
			u=u+2
			e=1
			continue
		else:
			count=count+1
			u=u+1
			e=1
			continue
	if l[u]==1 or l[u]==-1:
		if l[u+1]==2:
			count=count+1
			u=u+2
			continue
		else:
			u=u+1
			continue
	if l[u]==0:
		u=u+1
print(""count: "", str(count))
print (count)
</ans>",0,{}
189,"<ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

opr = ['#', '^', '&', '$']
print(""namespace: "", str({ ""res"" : (False, ""res"") }))
rules = dict()
lookup = dict()
cnt = -1

def get_tag(var):
    if var in namespace:
        return namespace[var][1]
    else:
        return var

N = int(input())
for _ in range(N):
    lval, rval = input().split('=')
    for c in opr:
        if c in rval:
            arg1, arg2 = list(map(get_tag, rval.split(c)))
            rule = (arg1, arg2, c)
            if rule in rules:
                namespace[lval] = (True, rules[rule])
            else:
                cnt += 1
                namespace[lval] = (True, cnt)
                rules[rule] = cnt
                lookup[cnt] = rule
            break
    else:
        if rval in namespace:
            namespace[lval] = namespace[rval]
        else:
            namespace[lval] = (False, rval)

if namespace[""res""] == (False, ""res""):
    print(""0"")
    return

program = []
myvars = dict()

def reserve():
    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) 

def implement(rule, final):
    if type(rule) == str:
        return rule
    elif rule in myvars:
        return myvars[rule]
    else:
        if final:
            name = ""res""
        else:
            name = reserve()
        myvars[rule] = name
        arg1, arg2, op = lookup[rule]
        var1, var2 = implement(arg1, False), implement(arg2, False)
        program.append(name + ""="" + var1 + op + var2)
        return name

seed(123)
if namespace[""res""][0]:
    implement(namespace[""res""][1], True)
else:
    program.append(""res="" + namespace[""res""][1])
print(len(program))
print(""\n"".join(program))

#print(namespace)
#print(rules)
</ans>",0,{}
190,"<ans>
def main():
    a, b, c, d, k = get_tuple()
    print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c), ""d: "", str(d), ""k: "", str(k)
    x = (a+c-1)//c
    y = (b+d-1)//d
    if x+y<=k:
        print(""x: "", str(x), ""y: "", str(y))
    else: print(-1)
</ans>",0,{}
191,"<ans>
import sys
input = sys.stdin.readline

# def find(a):
#     if par[a] == a:
#         return a
#     par[a] = find(par[a])
#     return par[a]

def find(a):
    upd = []
    cur = a
    while par[cur] != cur:
        upd.append(cur)
        cur = par[cur]
    for x in upd:
        par[x] = cur
    return cur

def union(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return
    par[a] = b

print(""par: "", str(par))

def mst():
    ret = []
    for edge in edges:
        u, v, w = edge
        u = find(u)
        v = find(v)
        if u != v:
            union(u, v)
            ret.append(edge)
    return ret

print(""edges: "", str(edges))

def dfs(u, par):
    for v, w in adj[u]:
        if v != par:
            dist[v] = max(dist[u], w)
            dfs(v, u)

def bfs(u):
    visit = [False] * (n+1)
    from collections import deque

    dq = deque()
    dq.append(u)
    visit[u] = True
    while dq:
        u = dq.popleft()
        for v, w in adj[u]:
            if not visit[v]:
                dist[v] = max(dist[u], w)
                dq.append(v)
                visit[v] = True

print(""adj: "", str(adj))
print(""dist: "", str(dist))

n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
# n = 50000
# m = 2 * n
# k = n
# a = [i for i in range(1, n+1)]
# import random

par = [0] * (n+1)
for i in range(1, n+1):
    par[i] = i
edges = []
# for i in range(1, n+1):
#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))
#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))
#     edges.append(edge)
for i in range(m):
    edge = tuple(map(int, input().split()))
    edges.append(edge)
edges.sort(key=lambda x: x[2])
edges = mst()
adj = [list() for i in range(n+1)]
for edge in edges:
    u, v, w = edge
    adj[u].append((v, w))
    adj[v].append((u, w))

dist = [0] * (n+1)
# dfs(a[0], -1)
bfs(a[0])
ans = 0
for x in a:
    ans = max(ans, dist[x])
ans = [ans] * k
print(*ans)
</ans>",0,{}
192,"<ans>
n=int(input())
print(""n: "", str(n))
s1=[int(x) for x in input().split()]
print(""s1: "", str(s1))
s2=[int(x) for x in input().split()]
print(""s2: "", str(s2))
S1=sorted(s1)
print(""S1: "", str(S1))
S2=sorted(s2)
print(""S2: "", str(S2))
S1=[0]+S1
print(""S1: "", str(S1))
S2=[0]+S2
print(""S2: "", str(S2))
S1=S1[::-1]
print(""S1: "", str(S1))
S2=S2[::-1]
print(""S2: "", str(S2))
pta=0
print(""pta: "", str(pta))
ptb=0
print(""ptb: "", str(ptb))
sm1=0
print(""sm1: "", str(sm1))
sm2=0
print(""sm2: "", str(sm2))
for j in range(0,(2*n)+1):
    if(j%2==0):
        if(S2[ptb]>S1[pta]):
            ptb=ptb+1
        else:
            sm1=sm1+S1[pta]
            pta=pta+1
    else:
        if(S1[pta]>S2[ptb]):
            pta=pta+1
        else:
            sm2=sm2+S2[ptb]
            ptb=ptb+1
    if(pta==n+1 and ptb==n+1):
        break
print(sm1-sm2)
</ans>",0,{}
193,"<ans>
import sys
# from collections import deque
input=sys.stdin.readline
def binary_search(org,arr,l,r,n,L,value):
    mid=(l+r)//2
    print(""mid: "", str(mid))
    if(mid>0 and arr[mid]-value>=org and arr[mid-1]-value<org):
        return mid
    elif(mid==0 and arr[mid]-value>=org ):
        return mid
    elif(mid==L and arr[mid]-value>=org ):
        return mid
    
    elif(mid==n):
        return mid

    elif(mid>0 and arr[mid]-value>org and arr[mid-1]-value>=org):
        return binary_search(org,arr,l,mid,n,L,value)
    
    elif(arr[mid]-value<org):
        print(""dddddd"")
        return binary_search(org,arr,mid+1,r,n,L,value)
    return mid

n=int(input())
print(""n: "", str(n))
l= list(map(int,input().split())) 
print(""l: "", str(l))
u= list(map(int,input().split())) 
print(""u: "", str(u))
extra=[0]*n
print(""extra: "", str(extra))
pre=[0]*n
print(""pre: "", str(pre))
t=[0]*n
print(""t: "", str(t))
t[0]=u[0]
print(""t[0]: "", str(t[0]))
for i in range(1,n):
    t[i]+=t[i-1]+u[i]
    print(""t["", str(i), ""]: "", str(t[i]))
for i in range(n):
    if(i>0):
        v=t[i-1]
    else:
        v=0
    index=binary_search(l[i],t,i,n-1,n-1,i,v)
    print(""i: "", str(i), ""index: "", str(index))
    if(index>0 and index!=i):
        value=t[index]-t[index-1]
        remain=l[i]-(t[index-1]-v)
    elif(index>0 and index==i):
        value=t[index]-t[index-1]
        remain=l[i]
    else:
        value=t[index]
        remain=l[i]
    if(value>=remain):
        extra[index]+=remain
        print(""extra["", str(index), ""]: "", str(extra[index]))
    elif(remain>value):
        extra[index]+=value
        print(""extra["", str(index), ""]: "", str(extra[index])
    if(i>0 and index>0):
        pre[i-1]-=1
        pre[index-1]+=1
    elif(i==0 and index>0):
        pre[index-1]+=1
    elif(i==0 and index==0):
        continue
    print(""extra: "", str(extra), ""pre: "", str(pre))
for i in range(n-2,-1,-1):
    pre[i]+=pre[i+1]
print(""extra: "", str(extra), ""pre: "", str(pre))
r=[0]*n
for i in range(n):
    r[i]=(u[i]*pre[i])+extra[i]
        
for i in r:
    print (i,end="" "")
</ans>",0,{}
194,"<ans>
for _ in range(int(input())):
    n,k = arrIN()
    print(""n: "", str(n), ""k: "", str(k))
    ans = 0
    while 1:
        if n%k==0:
            n//=k
            ans+=1
            print(""n: "", str(n), ""ans: "", str(ans))
        else:
            x = n%k
            ans+=x
            n-=x
            print(""x: "", str(x), ""ans: "", str(ans), ""n: "", str(n))
        if n==0:
            print(ans)
            break
</ans>",0,{}
195,"<ans>
def main():
    nonlocal a, graph, degIn, visited, s, t
    print(""a: "", str(a))
    print(""graph: "", str(graph))
    print(""degIn: "", str(degIn))
    print(""visited: "", str(visited))
    print(""s: "", str(s))
    print(""t: "", str(t))

    # Reading input
    n = int(input())
    a = list(map(int, input().split()))
    print(""n: "", str(n))

    # Pre-calculate C(n, k)
    c = [[0 for j in range(n)] for i in range(n)]
    for i in range(n):
        c[i][0] = 1
        for j in range(1, i+1):
            c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD
    print(""c: "", str(c))

    # Building divisibility graph
    degIn = [0 for u in range(n)]
    graph = [[] for u in range(n)]
    for u in range(n):
        for v in range(n):
            if u != v and a[v] % a[u] == 0:
                graph[u].append(v)
                graph[v].append(u)
                degIn[v] += 1
    print(""degIn: "", str(degIn))
    print(""graph: "", str(graph))

    # Solve for each WCC of divisibility graph and combine result
    ans = 1
    curLen = 0
    visited = [False for u in range(n)]
    for u in range(n):
        if not visited[u]:
            s = []
            t = []
            dfs(u)

            if len(t) > 0:
                sz = len(t) - 1
                cnt = cntOrder(s, t)

                # Number of orders for current WCC
                ans = (ans * cnt) % MOD
                # Number of ways to insert <sz> number to array of <curLen> elements
                ans = (ans * c[curLen + sz][sz]) % MOD
                curLen += sz

    print(""ans: "", str(ans))

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
196,"<ans>
N=int(input())
print(""N: "", str(N))
S=input()
print(""S: "", str(S))
S=[1 if S[i]=='o' else -1 for i in range(N)]

#0番目は羊のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=1
print(""tmp: "", str(tmp))
if S[0]==1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  tmp[1]=-1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
#0番目は狼のパターン
tmp=[0]*N
print(""tmp: "", str(tmp))
tmp[0]=-1
print(""tmp: "", str(tmp))
if S[0]==-1: #0番目の両隣は同種
  #0番目の両隣は羊
  tmp[1]=1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  tmp[1]=-1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  tmp[1]=1
  tmp[N-1]=-1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  tmp[1]=-1
  tmp[N-1]=1
  print(""tmp: "", str(tmp))
  
  for i in range(2, N-1):
    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
    print(""tmp: "", str(tmp))
    
  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
    print(''.join(ans))
    return
  
print(-1)
</ans>",0,{}
197,"<ans>
n=int(input())
print(""n: "", str(n))
l=list(map(int,input().split()))
print(""l: "", str(l))
s=input()
print(""s: "", str(s))
water=0
print(""water: "", str(water))
grass=0
print(""grass: "", str(grass))
cgrass=0
print(""cgrass: "", str(cgrass))
time=0
print(""time: "", str(time))
seen=False
print(""seen: "", str(seen))
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        print(""dist: "", str(dist))
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)
</ans>",0,{}
198,"<ans>
from math import gcd

m,a,b = list(map(int,input().split()))
print(""m: "", str(m), ""a: "", str(a), ""b: "", str(b))

g = gcd(a,b)
print(""g: "", str(g)

vis = [0]*(a+b+1)
print(""vis: "", str(vis))
vis[0] = 1

nvis = 1
print(""nvis: "", str(nvis)

count = 0
print(""count: "", str(count))
last = 0
print(""last: "", str(last))
t = 0
print(""t: "", str(t))
while True:
    #print(t, vis)
    if t >= b:
        #print('back')
        t -= b
        if vis[t]:
            break
        vis[t] = 1
        nvis += 1
    else:
        t += a
        if t > m:
            break
        if t > last:
            #print('forward', t - last, 'with', nvis)
            count += (t - last)*nvis
            last = t
        if vis[t]:
            break
        vis[t] = 1
        nvis += 1
    #print(nvis,count)
    #print('---')

if t > m:
    # we're done
    count += (m - last + 1)*nvis
else:
    def sumto(n):
        whole = n//g + 1
        r = whole*(whole+1)//2 * g
        corr = whole * (g-1 - (n%g))
        r -= corr
        return r

    #S = 0
    #for i in range(last, m+1):
    #    S += i//g + 1
    #count += S
    #assert S == sumto(m) - sumto(last-1)

    count += sumto(m) - sumto(last-1)

#print(vis)
print(""count: "", str(count))
</ans>",0,{}
