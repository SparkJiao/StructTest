index,generated,result,format_properties
0," <ans>
'''input
9 4 8
6 8 5 1 8 1 1 2 1
9 2
8 4
5 3
9 7
'''
from sys import stdin
import math
from copy import deepcopy
from collections import defaultdict


def process_offer(offers):
	aux = []
	for i in offers:
		temp = offers[i]
		temp.sort()
		aux.append([i, temp[-1]])

	aux = sorted(aux, key = lambda x: x[0])
	return aux


def make(first, second):
	return str(first) + ' ' + str(second)


def brute(arr, dp, offers, index, remain):
	#print(index, remain)
	if remain == 0:
		return 0

	if make(index, remain) in dp:
		return dp[make(index, remain)]

	min_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)
	for i in range(len(offers)):
		cost = 0
		if offers[i][0] <= remain:
			free = offers[i][1]
			for j in range(index + free, index + offers[i][0]):
				cost += arr[j]
			cost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])
			min_cost = min(min_cost, cost)
		else:
			break
	dp[make(index, remain)] = min_cost
	print(""index: "", index, ""remain: "", remain, ""min_cost: "", min_cost)
	return min_cost



# main starts
n, m, k = list(map(int, stdin.readline().split()))
arr = list(map(int, stdin.readline().split()))
arr.sort()
offers = defaultdict(list)
for _ in range(m):
	x, y = list(map(int, stdin.readline().split()))
	offers[x].append(y)

offers = process_offer(offers)
dp = dict()
brute(arr, dp, offers, 0, k)
#print(dp)

</ans>",0,{}
1," <ans>
def PrimeDecomp(N, ConcFlag):
 print(""N: "", str(N), ""ConcFlag: "", str(ConcFlag))
 if ConcFlag:
 if N <= 1:
 return [1], 1
 else:
 I = 2
 PrimeDec = []
 DivCount = 1
 while I * I <= N:
 Cnt = 0
 while N % I == 0:
 N //= I
 PrimeDec.append(I)
 DivCount *= (Cnt + 1)
 I += 1
 if N >= 2:
 PrimeDec.append(N)
 DivCount *= 2
 return PrimeDec, DivCount
 else:
 if N <= 1:
 return [1], [1], 1
 else:
 I = 2
 PrimeDec = []
 PrimeCnt = []
 DivCount = 1
 while I * I <= N:
 Cnt = 0
 while N % I == 0:
 N //= I
 Cnt += 1
 if Cnt >= 1:
 PrimeDec.append(I)
 PrimeCnt.append(Cnt)
 DivCount *= (Cnt + 1)
 I += 1
 if N >= 2:
 PrimeDec.append(N)
 PrimeCnt.append(1)
 DivCount *= 2
 return PrimeDec, PrimeCnt, DivCount

def DivisorFactorial(N, FactDec, FactCnt, MemoFlag, Mod, ModFlag):
 print(""N: "", str(N), ""MemoFlag: "", str(MemoFlag), ""Mod: "", str(Mod), ""ModFlag: "", str(ModFlag))
 if MemoFlag:
 if N <= 1:
 FactCnt = [1]
 FDivCnt = 1
 return FactDec, FactCnt, FDivCnt
 else:
 for TN in range(2, N + 1):
 PrimeDec, PrimeCnt, _ = PrimeDecomp(TN, False)
 for TP in range(0, len(PrimeDec)):
 if PrimeDec[TP] in set(FactDec):
 FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
 else:
 FactDec.append(PrimeDec[TP])
 FactCnt.append(PrimeCnt[TP])
 FDivCnt = 1
 for TF in FactCnt:
 FDivCnt = [FDivCnt * (TF + 1), (FDivCnt * (TF + 1)) % Mod][ModFlag]
 return FactDec, FactCnt, FDivCnt

FactDec, FactCnt, FDivCnt = DivisorFactorial(int(input()), [], [], False, 10**9 + 7, True)
 print(""FactDec: "", str(FactDec), ""FactCnt: "", str(FactCnt), ""FDivCnt: "", str(FDivCnt))
</ans>",0,{}
2," <ans>
from math import sqrt,gcd

def gen_primes():
 """""" Generate an infinite sequence of prime numbers.
 """"""
 #
 D = {}

 # The running integer that's checked for primeness
 q = 2

 while True:
 if q not in D:
 # q is a new prime.
 # Yield it and mark its first multiple that isn't
 # already marked in previous iterations
 #
 yield q
 D[q * q] = [q]
 else:
 # q is composite. D[q] is the list of primes that
 # divide it. Since we've reached q, we no longer
 # need it in the map, but we'll mark the next
 # multiples of its witnesses to prepare for larger
 # numbers
 #
 for p in D[q]:
 D.setdefault(p + q, []).append(p)
 del D[q]

 q += 1

print(""q: "", q)

def is_prime(n):
 if n<=1:
 return False
 if n == 2:
 return True
 if n % 2 ==0:
 return False
 return all(n%i for i in range(3,int(sqrt(n))+1))

print(""n: "", n)

def calculate_colors(n):
 primes = gen_primes()
 sqr_n = int(sqrt(n)) + 1
 if n == 1:
 return 1
 for p in primes:
 if n % p == 0:
 while n % p == 0:
 g= gcd(p,n)
 n = int(n//g)
 if n > 1:
 return 1
 else:
 return p
 if p > sqr_n:
 return n
 print(""n: "", n)
 print(""p: "", p)
 return n

n = int(input())
 print(""n: "", n)
 print(""Result: "", calculate_colors(n))
</ans>",0,{}
3," <ans>
import numpy as np
mod = 998244353

def poly_mul(f, g):
 print(""f: "", str(f), ""g: "", str(g))
 Lf = len(f); Lg = len(g); L = Lf + Lg - 1
 if Lf <= 16 or Lg <= 16:
 if Lf == 0 or Lg == 0:
 return np.zeros((0,), dtype=np.int64)
 return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)
 fft = np.fft.rfft; ifft = np.fft.irfft
 fft_len = 1 << L.bit_length()
 fl = f & (1 << 15) - 1; fh = f >> 15
 gl = g & (1 << 15) - 1; gh = g >> 15
 x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod
 y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
 z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod
 print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
 return (x + ((y - x - z) << 15) + (z << 30)) % mod

def poly_inv(fps, n=None):
 print(""fps: "", str(fps))
 assert fps[0] != 0
 if n is None:
 n = len(fps)
 res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)
 res[0] = pow(int(fps[0]), mod-2, mod)
 i = 1
 while i < n:
 i <<= 1
 res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod
 print(""res: "", str(res[:i]))
 return res[:n]

def poly_div(fps1, fps2):
 print(""fps1: "", str(fps1), ""fps2: "", str(fps2))
 n1, n2 = len(fps1), len(fps2)
 if n1 < n2:
 return np.zeros((0,), dtype=np.int64)
 n = n1 - n2 + 1
 res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]
 print(""res: "", str(res))
 return res % mod

def poly_mod(fps1, fps2):
 print(""fps1: "", str(fps1), ""fps2: "", str(fps2))
 n1, n2 = len(fps1), len(fps2)
 if n1 < n2:
 return fps1
 res = fps1[:n2-1] - poly_div(fps1, fps2)[:n2-1]
 print(""res: "", str(res))
 return res % mod

def multipoint_evaluation(fps, xs):
 print(""fps: "", str(fps), ""xs: "", str(xs))
 threshold = 8
 n_xs = len(xs)
 bit = (n_xs-1).bit_length()
 if bit <= threshold:
 res = np.zeros_like(xs)
 xs_cumprod = np.ones_like(xs)
 for coef in fps:
 res += xs_cumprod * coef
 xs_cumprod *= xs
 xs_cumprod %= mod
 return res
 k = 1<<bit
 fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)
 fpss[0, :n_xs] = -xs % mod
 fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod
 fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod
 for i in range(1, bit):
 step = 2<<i
 half = step>>1
 for j in range(0, k, step):
 f1 = fpss[i, j:j+half+1].copy()
 f2 = fpss[i, j+half:j+step+1].copy()
 f1[-1] = f2[-1] = 1
 f = poly_mul(f1, f2)
 fpss[i+1, j:j+step] = f[:-1]
 print(""fpss[i+1]: "", str(fpss[i+1, j:j+step]))
 f = poly_mod(fps, f)
 fpss[-1, :len(f)] = f
 fpss[-1, len(f):] = 0
 for i in range(bit-1, threshold-1, -1):
 step = 2<<i
 half = step>>1
 for j in range(0, k, step):
 if j+half >= n:
 fpss[i, j:n] = fpss[i+1, j:n]
 continue
 f = fpss[i+1, j:min(j+step, n)]
 f1 = fpss[i, j:j+half+1].copy()
 f2 = fpss[i, j+half:min(j+step, n)+1].copy()
 f1[-1] = f2[-1] = 1
 fpss[i, j:min(j+step, n)] = (
 poly_mul(fpss[i, j:j+half], f2)
 + poly_mul(fpss[i, j+half:min(j+step, n)], f1)
 ) % mod
 print(""fpss[i]: "", str(fpss[i, j:min(j+step, n)]))
 xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)
 xs_cumprod = np.ones_like(xs)
 res = np.zeros_like(xs)
 for i in range(1<<threshold):
 res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
 xs_cumprod *= xs
 xs_cumprod %= mod
 return res.reshape(-1)[:n_xs] % mod

def poly_differential(fps):
 print(""fps: "", str(fps))
 return fps[1:] * np.arange(1, len(fps)) % mod

def lagrange_interpolation(X, Y, mod):
 print(""X: "", str(X), ""Y: "", str(Y))
 n = len(X)
 g = [0]*(n+1)
 g[0] = 1
 for i, x in enumerate(X):
 for j in range(i, -1, -1):
 g[j+1] += g[j] * (-x) % mod
 res = [0]*n
 for x, y in zip(X, Y):
 f = g[:]
 denom = 0
 v = 1
 pow_x = [1]
 for _ in range(n-1):
 v = v * x % mod
 pow_x.append(v)
 pow_x.reverse()
 for i, po in enumerate(pow_x):
 f_i = f[i]
 f[i+1] += f_i * x % mod
 denom = (denom + f_i * po) % mod
 denom_inv = pow(denom, mod-2, mod)
 for i, f_i in enumerate(f[:n]):
 res[i] += (f_i * y * denom_inv) % mod
 return [v % mod for v in res]

def polynomial_interpolation(xs, ys):
 print(""xs: "", str(xs), ""ys: "", str(ys))
 assert len(xs) == len(ys)
 threshold = 8
 n = len(xs)
 if n==1:
 return ys.copy()
 bit = (n-1).bit_length()
 if bit <= threshold:
 res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)
 return np.array(res[::-1], dtype=np.int64)
 k = 1<<bit
 fpss = np.zeros((bit+1, n+1), dtype=np.int64)
 fpss[0, :n] = -xs % mod
 for i in range(bit):
 step = 2 << i
 half = step >> 1
 for j in range(0, n, step):
 if j+half >= n:
 fpss[i+1, j:n] = fpss[i, j:n]
 continue
 f1 = fpss[i, j:j+half+1].copy()
 f2 = fpss[i, j+half:j+step+1].copy()
 f1[-1] = f2[-1] = 1
 f = poly_mul(f1, f2)
 fpss[i+1, j:j+len(f)-1] = f[:-1]
 fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)
 fpss2[bit, :n] = poly_differential(f)
 for i in range(bit-1, threshold-1, -1):
 step = 2<<i
 half = step>>1
 for j in range(0, n, step):
 if j+half >= n:
 fpss2[i, j:n] = fpss2[i+1, j:n]
 continue
 f = fpss2[i+1, j:min(j+step, n)]
 f1 = fpss[i, j:j+half+1].copy()
 f2 = fpss[i, j+half:min(j+step, n)+1].copy()
 f1[-1] = f2[-1] = 1
 fpss2[i, j:min(j+step, n)] = (
 poly_mul(fpss[i, j:j+half], f2)
 + poly_mul(fpss[i, j+half:min(j+step, n)], f1)
 ) % mod
 xs = np.lib.stride_tricks.as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))
 xs_cumprod = np.ones_like(xs)
 f = np.zeros_like(xs)
 for i in range(1<<threshold):
 f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod
 xs_cumprod *= xs
 xs_cumprod %= mod
 f = f.ravel()
 for j in range(n):
 fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod
 for i in range(bit):
 step = 2 << i
 half = step >> 1
 for j in range(0, k, step):
 if j+half >= n:
 fpss2[i+1, j:n] = fpss2[i, j:n]
 continue
 f1 = fpss[i, j:j+half+1].copy()
 f2 = fpss[i, j+half:min(j+step, n)+1].copy()
 f1[-1] = f2[-1] = 1
 fpss2[i+1, j:min(j+step, n)] = (
 poly_mul(fpss[i, j:j+half], f2)
 + poly_mul(fpss[i, j+half:min(j+step, n)], f1)
 ) % mod
 return fpss2[bit, :n]

mod = int(input())
 A = np.array(input().split(), dtype=np.int64)
 X = np.arange(mod, dtype=np.int64)
 Ans = polynomial_interpolation(X, A)
 print(""Ans: "", ("" "".join(map(str, Ans.tolist()))))
</ans>",0,{}
4," <ans>
import math
from collections import defaultdict
import sys

def main():
n, m = list(map(int, input().split()))
print(""n: "", n, ""m: "", m)
k = list(map(int, input().split()))
print(""k: "", str(k))
sales = [(0, 0)] * m
print(""sales: "", str(sales))
for i in range(m):
a, b = list(map(int, input().split()))
sales[i] = (b, a)
print(""sales after assignment: "", str(sales))

def check(days):
last_sale = {}
print(""Initializing last_sale:"")
for sale in sales:
if sale[1] <= days:
if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:
last_sale[sale[0]] = sale[1]
print(""last_sale after assignment: "", str(last_sale))

date_last_sales = {}
for t, d in list(last_sale.items()):
if d not in date_last_sales:
date_last_sales[d] = [t]
else:
date_last_sales[d].append(t)

balance = 0
required = [0] + k.copy()

end = 0
for d in range(1, days+1):
balance += 1
if d in date_last_sales:
for t in date_last_sales[d]:
if required[t] > 0:
if required[t] > balance:
end += required[t] - balance
balance -= min(required[t], balance)
required[t] = 0
if d == days: # last day
for r in required:
if r > 0:
end += r
print(""end: "", end)
print(""balance: "", balance)
if 2*end <= balance:
print(""days: "", days)
return
days -= 1

total = sum(k)
print(""total: "", total)
hi = 2*total
lo = 1

while lo + 1 < hi:
mid = (lo + hi) // 2
if check(mid):
hi = mid
else:
lo = mid

if check(lo):
print(""days: "", lo)
else:
print(""days: "", hi)

def __starting_point():
main()

__starting_point()
</ans>",0,{}
5," <ans>
import sys
from collections import deque
import heapq
input = sys.stdin.readline

N = int(input())
EDGE = [list(map(int, input().split())) for i in range(N - 1)]

EDGELIST = [[] for i in range(N + 1)]

print(""N: "", N)
for i, j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)
    print(""EDGE[{}], EDGE[{}]: {} and {}"".format(i, j, i, j))

REDG = [None for i in range(N + 1)]
QUE = deque([1])
check = [0] * (N + 1)
DEPTH = [None] * (N + 1)
i = 0
while QUE:
    NQUE = deque()
    i += 1

    while QUE:
        x = QUE.pop()
        DEPTH[x] = i
        check[x] = 1
        for to in EDGELIST[x]:
            if check[to] == 1:
                continue
            else:
                REDG[to] = x
                NQUE.append(to)
    QUE = NQUE

check = [0] * (N + 1)
check[1] = 1
# NEXT = []

# for i in EDGES[1]:
#     check[i] = 1
#     NEXT.append(i)

# for j in NEXT:
#     for k in EDGES[j]:
#         check[k] = 1

LEAF = []
for i in range(2, N + 1):
    if len(EDGELIST[i]) == 1:
        LEAF.append((-DEPTH[i], i))
        print(""LEAF: {} and {}"".format(-DEPTH[i], i))

QUE = LEAF
heapq.heapify(QUE)
ANS = 0

while QUE:
    dep, x = heapq.heappop(QUE)
    if check[x] != 0 or dep >=-3:
        continue

    if check[REDG[x]] == 2:
        continue

    if check[x] == 0:
        check[x] = 1
    if check[REDG[REDG[x]]] == 0:
        check[REDG[REDG[x]]] = 1
    check[REDG[x]] = 2
    heapq.heappush(QUE, (-DEPTH[REDG[REDG[REDG[x]]]], REDG[REDG[REDG[x]]]))
    ANS += 1
    print(""x: {}, QUE: {}, check: {}"".format(x, QUE, check))

print(ANS)
</ans>",0,{}
6," <ans>
class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        print(""N: "", N)

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        print(""x: "", x, ""root: "", self._parent[x])
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
            print(""gx: "", gx, ""gy: "", gy)
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]
            print(""gy: "", gy, ""gx: "", gx)

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

    def calc_group_num(self):
        N = len(self._parent)
        ans = 0
        for i in range(N):
            if self.find_root(i) == i:
                ans += 1
        print(""Number of groups: "", ans)
        return ans

import sys

input=sys.stdin.readline

n,m=list(map(int,input().split()))
print(""n: "", n)
print(""m: "", m)
t=list(map(int,input().split()))
t=[t[i]-1 for i in range(n)]
print(""t: "", t)
query=[]
for i in range(m-1):
    a,b=list(map(int,input().split()))
    query.append((a-1,b-1))
print(""query: "", query)

tower=[[] for i in range(m)]
for i in range(n):
    id=t[i]
    if not tower[id]:
        tower[id].append((i+1,i+1))
    else:
        start,end=tower[id].pop()
        if end+1==i+1:
            tower[id].append((start,i+1))
        else:
            tower[id].append((start,end))
            tower[id].append((i+1,i+1))

#print(tower)
test=[]
for i in range(len(test)):
    id1,id2=test[i]
    print(""test[i]: "", id1, id2)
    test[i]=(id1, id2)

#print(test)
start=[-1]*len(test)
end=[m-1]*len(test)
temp=[[] for i in range(m)]
for i in range(len(test)):
    T=(end[i]+start[i])//2
    temp[T].append(i)

def parabisect():
    uf=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=query[i]
        uf.unite(a,b)
        while temp[i]:
            j=temp[i].pop()
            id1,id2=test[j]
            if uf.is_same_group(id1,id2):
                end[j]=i
            else:
                start[j]=i
            if end[j]-start[j]>1:
                T=(end[j]+start[j])//2
                temp[T].append(j)

for i in range(20):
    parabisect()

res=[0]*m
for i in range(len(test)):
    res[end[i]+1]-=1

for i in range(1,m):
    res[i]+=res[i-1]

for i in range(m):
    print(len(test)+res[i])
</ans>",0,{}
7," <ans>
def input(): return sys.stdin.readline().rstrip(""\r\n"")

n, m = map(int, input().split())
inc = {}
print(""n, m: "", n, m)

l = [None for i in range(n*m)]
print(""l: "", l)

for i in range(n):
 t = int(input())
 print(""t: "", t)
 for j in range(m):
 ipt = input()
 l[t*m+j] = ipt
 print(""ipt: "", ipt)
 if len(inc)==26:continue
 for q in ipt:
 inc.setdefault(q, 0)
 print(""inc: "", inc)

d = {}
print(""d: "", d)

for p, i in enumerate(l[1:]):
 for j in range(min(len(l[p]), len(i))):
 if l[p][j] != i[j]:
 ae(i[j], l[p][j])
 print(""i[j], l[p][j]: "", i[j], l[p][j])
 break
 if len(i)-1==j and len(l[p])-1 > j:
 print(""IMPOSSIBLE"")
 return

ans = []
dq = []
print(""ans, dq: "", ans, dq)
ptr = 0

ninc = {}

for k, v in inc.items():
 if v == 0:
 dq.append(k)
 print(""dq: "", dq)
 inc[k] = v
 print(""inc: "", inc)

inc = ninc

while ptr != len(dq):
 fst = dq[ptr]
 ans.append(fst)
 print(""ans: "", ans)
 for i in d.get(fst, []):
 inc[i] -= 1
 print(""inc: "", inc)
 if inc[i] == 0:
 dq.append(i)
 inc.pop(i)
 print(""dq: "", dq)
 ptr += 1

if len(inc):
 print(""IMPOSSIBLE"")
 return

print(*reversed(ans), sep='')
</ans>",0,{}
8," <ans>
t = ii()
print(""t: "", str(t))
for _ in range(t):
 r, g, b = sorted(mi())
 print(""r: "", str(r), ""g: "", str(g), ""b: "", str(b))
 if b > r + g + 1:
 print(""No"")
 else:
 print(""Yes"")
</ans>",0,{}
9," <ans>
def get_inputs(test_inputs=None):
    print(""test_inputs: "", str(test_inputs))
    it = iter(test_inputs.split(""\n"")) if test_inputs else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if it:
            return next(it)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    imax = 3
    numa, numb = [], []
    for i in range(imax):
        numa.append(int(uinput()))
        numb.append(int(uinput()))

    print(""numa: "", str(numa))
    print(""numb: "", str(numb))
    return [numa, numb]

def calculate(test_inputs=None):
    """""" Base class calculate method wrapper """"""
    d = Art(get_inputs(test_inputs))
    print(""d: "", str(d))
    return d.calculate()

class unitTests(unittest.TestCase):

    def test_Art_class__basic_functions(self):
        """""" Art class basic functions testing """"""
        # Constructor test
        d = Art([[3, 1, 2], [2, 3, 1]])
        self.assertEqual(d.numa[0], 3)

        self.assertEqual(d.r, (3, 2))
        self.assertEqual(d.rmax, (3, 1))
        self.assertEqual(d.rmin, (2, 1))

        self.assertEqual(d.remain, [(3, 1)])

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        test = ""3 2\n1 3\n2 1""
        self.assertEqual(calculate(test), ""YES"")
        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])
        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])

        # Sample test 2
        test = ""5 5\n3 3\n3 3""
        self.assertEqual(calculate(test), ""NO"")

        # Sample test 3
        test = ""4 2\n2 3\n1 2""
        self.assertEqual(calculate(test), ""YES"")

        # My test 4
        test = ""5 5\n1 5\n1 5""
        self.assertEqual(calculate(test), ""YES"")

    def test_time_limit_test(self):
        """""" Quiz time limit test """"""

        import random

        # Time limit test
        test = ""1000 1000""
        test += ""\n900 900""
        test += ""\n50 50""

        import timeit

        start = timeit.default_timer()
        args = get_inputs(test)

        init = timeit.default_timer()
        d = Art(args)

        calc = timeit.default_timer()
        d.calculate()

        stop = timeit.default_timer()
        print((
            ""\nTime Test: "" +
            ""{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)"".
            format(stop-start, init-start, calc-init, stop-calc)))
</ans>",0,{}
10," <ans>
import sys
from collections import defaultdict

class BIT():
 def __init__(self, n):
 self.n = n
 self.tree = [0] * n

 def _get_sum(self, r):
 '''
 sum on interval [0, r)
 '''
 result = 0
 while r > 0:
 result += self.tree[r-1]
 r &= (r - 1)
 return result

 def get_sum(self, l, r):
 '''
 sum on interval [l, r)
 '''
 return self._get_sum(r) - self._get_sum(l)

 def add(self, i, value=1):
 while i < self.n:
 self.tree[i] += value
 i |= (i + 1)

reader = (line.rstrip() for line in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", n)
swaps = []
print(""swaps: "", swaps)
for _ in range(n):
 i, j = list(map(int, input().split()))
 swaps.append(i)
 swaps.append(j)
 print(""swaps after appending i and j: "", swaps)

pos = defaultdict(list)
print(""pos: "", pos)
for i, val in enumerate(swaps):
 pos[val].append(i)
 print(""pos after appending i and its value to pos: "", pos)

c = 0
prev = -1
compr = [0] * (2*n)
decompr = {}
for val in sorted(swaps):
 if prev == val: continue
 for j in pos[val]:
 compr[j] = c
 print(""compr after appending j's index to compr: "", compr)
 decompr[c] = val
 c += 1
 print(""decompr after appending val to decompr: "", decompr)
 prev = val

arr = list(range(c))
print(""arr before swapping elements: "", arr)
for t in range(n):
 i, j = compr[t<<1], compr[t<<1|1]
 arr[i], arr[j] = arr[j], arr[i]
 print(""arr after swapping elements i and j: "", arr)

bit = BIT(c)
print(""bit instance created: "", bit)
total_inv = 0
for i, val in enumerate(arr):
 total_inv += bit.get_sum(val+1, c)
 if i != val:
 total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)
 print(""total_inv after calculating get_sum and abs differences: "", total_inv)
 bit.add(val)
 print(""bit after adding value to bit: "", bit)
</ans>",0,{}
11," <ans>
from math import sqrt

eps = 1e-9

def mysqrt(x):
if x <= 0:
return 0
return sqrt(x)

def good(R):
nonlocal xs
nonlocal ys
nonlocal n

left = -10**20
right = 10**20

for i in range(n):
xi = xs[i]
yi = abs(ys[i])

print(""xi: "", str(xi), ""yi: "", str(yi))

D = 2 * R * yi - yi**2
sD = mysqrt(D)
new_left = xi - sD
new_right = xi + sD

left = max(left, new_left)
right = min(right, new_right)

print(""left: "", str(left), ""right: "", str(right))

if left + eps > right:
return False

return True

def solve(lower, high, md):
R = 0
for _ in range(150):
R = md(lower, high)

print(""R: "", str(R))

if good(R):
high = R
else:
lower = R

return R

n = int(input())

xs = [0.0 for _ in range(n)]
ys = [0.0 for _ in range(n)]

for i in range(n):
xs[i], ys[i] = list(map(float, input().split()))
if i > 0:
print(""xs[i]: "", str(xs[i]), ""ys[i]: "", str(ys[i]))
if ys[i] * ys[0] < 0:
print(-1)
return

R = None
if good(1):
R = solve(0, 1, lambda x, y: (x + y) / 2)
else:
R = solve(1, 1e16, lambda x, y: sqrt(x * y))

print('{:.16}'.format(R))
</ans>",0,{}
12," <ans>
def bin_pow(num, degree, module):
 print(""num: "", num, ""degree: "", degree, ""module: "", module)
 if degree == 0:
 return 1
 if degree == 1:
 return num % module

 if degree % 2 == 0:
 val = bin_pow(num, degree // 2, module)
 print(""val: "", val)
 return (val * val) % module

 if degree % 2 != 0:
 return (num * bin_pow(num, degree - 1, module)) % module

x, y = list(map(int, input().split()))
 print(""x: "", x, ""y: "", y)

 if y % x != 0:
 print(""y % x != 0"")
 print(0)
 return

 y //= x
 print(""y //= x"")

 divs = set()
 to_gen = []
 num = 2
 val = y
 print(""num: "", num, ""val: "", val)

 while num * num <= val:
 degree = 0
 while y % num == 0:
 degree += 1
 y //= num
 print(""num: "", num, ""degree: "", degree, ""y: "", y)
 if degree != 0:
 to_gen.append((num, degree))

 if num == 2:
 num += 1
 else:
 num += 2

 if y != 1:
 to_gen.append((y, 1))
 print(""to_gen: "", to_gen)

 to_gen_len = len(to_gen)
 print(""to_gen_len: "", to_gen_len)

 def generate(ind):
 if ind == to_gen_len:
 yield 1
 return
 gen_val = to_gen[ind][0]
 print(""gen_val: "", gen_val)
 for deg in range(1 + to_gen[ind][1]):
 for each in generate(ind + 1):
 yield gen_val ** deg * each

 for each in generate(0):
 divs.add(each)
 print(""each: "", each)
 divs = list(divs)
 divs.sort()
 divs_answers = {}
 mod = 10 ** 9 + 7
 ans = bin_pow(2, val - 1, mod)
 print(""ans: "", ans)

 for el in divs:
 if el == 1:
 divs_answers[el] = 1
 ans -= 1
 print(""el: "", el, ""divs_answers[el]: "", divs_answers[el])
 elif el in divs_answers:
 curr_val = bin_pow(2, el - 1, mod)
 curr_val -= divs_answers[el]
 divs_answers[el] = curr_val % mod
 ans -= curr_val
 print(""el: "", el, ""curr_val: "", curr_val, ""divs_answers[el]: "", divs_answers[el])
 else:
 curr_val = bin_pow(2, el - 1, mod)
 for other_el in divs:
 if other_el >= el:
 break
 if el % other_el != 0:
 continue
 curr_val -= divs_answers[other_el]
 divs_answers[el] = curr_val % mod
 ans -= curr_val
 print(""el: "", el, ""other_el: "", other_el, ""curr_val: "", curr_val, ""divs_answers[el]: "", divs_answers[el])

 print(divs_answers[val])
</ans>",0,{}
13," <ans>
import bisect

class BTreeNode:
 def __init__(self):
 self.key = []
 self.child = []

def __init__(self):
 self.root = BTreeNode()

def search_higher(self, key):
 ptr = self.root
 ret = None
 print(""ptr: "", str(ptr))
 while ptr.child:
 i = bisect.bisect_right(ptr.key, key)
 print(""i: "", i)
 if i != len(ptr.key):
 ret = ptr.key[i]
 print(""ret: "", str(ret))
 ptr = ptr.child[i]
 i = bisect.bisect_right(ptr.key, key)
 if i != len(ptr.key):
 ret = ptr.key[i]
 print(""ret: "", str(ret))
 return ret

def search_lower(self, key):
 ptr = self.root
 ret = None
 print(""ptr: "", str(ptr))
 while ptr.child:
 i = bisect.bisect_left(ptr.key, key)
 if i != 0:
 ret = ptr.key[i - 1]
 print(""ret: "", str(ret))
 ptr = ptr.child[i]
 i = bisect.bisect_left(ptr.key, key)
 if i != 0:
 ret = ptr.key[i - 1]
 print(""ret: "", str(ret))
 return ret

def insert(self, key):
 def insert_rec(ptr):
 b_size = 10
 if not ptr.child:
 bisect.insort(ptr.key, key)
 print(""ptr.key: "", str(ptr.key))
 if len(ptr.key) == b_size * 2 - 1:
 temp = BTreeNode()
 temp.key = ptr.key[:b_size]
 ptr.key = ptr.key[b_size:]
 print(""ptr.key: "", str(ptr.key))
 return temp
 else:
 i = bisect.bisect(ptr.key, key)
 temp = insert_rec(ptr.child[i])
 if temp is not None:
 ptr.key.insert(i, temp.key.pop(-1))
 print(""ptr.key: "", str(ptr.key))
 ptr.child.insert(i, temp)
 if len(ptr.child) == b_size * 2:
 temp = BTreeNode()
 temp.child = ptr.child[:b_size]
 ptr.child = ptr.child[b_size:]
 temp.key = ptr.key[:b_size]
 ptr.key = ptr.key[b_size:]
 print(""ptr.key: "", str(ptr.key))
 return temp
 return None

def dump(self):
 def dump_rec(ptr, dep):
 for _ in range(0, dep):
 print(""  "", end="""")
 print(ptr.key)
 for c in ptr.child:
 dump_rec(c, dep + 1)
 print("""")

def main():
 n = int(input())
 p = list(map(int, input().split()))
 idx = [0] * n
 for i in range(0, n):
 idx[i] = i
 print(""idx: "", str(idx))
 idx.sort(key=lambda i: - p[i])
 print(""idx: "", str(idx))
 t = BTree()
 print(""t: "", str(t))
 t.insert(-1)
 print(""t: "", str(t))
 t.insert(n)
 print(""t: "", str(t))
 ans = 0
 for i in idx:
 nex = t.search_higher(i)
 print(""nex: "", str(nex))
 nexnex = t.search_higher(nex)
 print(""nexnex: "", str(nexnex))
 pre = t.search_lower(i)
 print(""pre: "", str(pre))
 prepre = t.search_lower(pre)
 print(""prepre: "", str(prepre))
 if prepre != None:
 ans += p[i] * (pre - prepre) * (nex - i)
 print(""ans: "", ans)
 ans += p[i] * (i - pre) * (nexnex - nex)
 print(""ans: "", ans)
 t.insert(i)
 print(""t: "", str(t))
 print(ans)

main()
</ans>",0,{}
14," <ans>
k = 72
K = 1<<k
nu = lambda L: int("""".join([bin(K+a)[-k:] for a in L[::-1]]), 2)
st = lambda n: bin(n)[2:] + ""0""
li = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]

print(""k: "", str(k))
print(""K: "", str(K))

def grow(d, v, h):
    h += [0] * d
    print(""h before: "", str(h))
    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]
    
    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):
        t = [1] * (2*d+2)
        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P
        ti = [1] * (2*d+2)
        ti[-1] = pow(t[-1], P-2, P)
        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P
        
        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]
        fg = li(st(nu(f) * nu(g)), d * 2 + 2)
        print(""fg: "", str(fg))
        
        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P
    print(""h after: "", str(h))
    return h

# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]
def create_table(v):
    s = 1
    X = [1, v+1]
    while s < v:
        X = grow(s, v, X)
        s *= 2
    table = [1]
    for x in X:
        table.append(table[-1] * x % P)
    print(""table: "", str(table))
    return table

def fact(i, table):
    a = table[i//v]
    for j in range(i//v*v+1, i+1):
        a = a * j % P
    return a

P = 10**9+7
v = 1 << 11
fa = [1] * (2*v+2)
fainv = [1] * (2*v+2)
for i in range(2*v+1):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(2*v+1)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

T = create_table(v)

print(""T: "", str(T))

f = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P
r1, c1, r2, c2 = list(map(int, input().split()))
print(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))
</ans>",0,{}
15," <ans>
class UnionFind:
 def __init__(self, n):
 print(""n: "", str(n))
 self.parent = list(range(n))
 self.size = [1] * n
 self.num_sets = n

 def find(self, a):
 print(""a: "", str(a))
 to_update = []

 while a != self.parent[a]:
 print(""a: "", str(a), ""parent: "", str(self.parent[a]))
 to_update.append(a)
 a = self.parent[a]

 for b in to_update:
 self.parent[b] = a

 return self.parent[a]

 def merge(self, a, b):
 print(""a: "", str(a), ""b: "", str(b))
 a = self.find(a)
 b = self.find(b)

 if a == b:
 return

 if self.size[a] < self.size[b]:
 a, b = b, a

 self.num_sets -= 1
 self.parent[b] = a
 self.size[a] += self.size[b]

 def set_size(self, a):
 return self.size[self.find(a)]

def main():
 from sys import stdin, stdout

 print(""Start of main function"")

 def read():
 print(""read: "")
 return stdin.readline().rstrip('\n')

 def read_array(sep=None, maxsplit=-1):
 print(""read_array: "")
 return read().split(sep, maxsplit)

 def read_int():
 print(""read_int: "")
 return int(read())

 def read_int_array(sep=None, maxsplit=-1):
 print(""read_int_array: "")
 return [int(a) for a in read_array(sep, maxsplit)]

 def write(*args, **kwargs):
 print(""write: "", str(args), ""kwargs: "", str(kwargs))
 sep = kwargs.get('sep', ' ')
 end = kwargs.get('end', '\n')
 stdout.write(sep.join(str(a) for a in args) + end)

 def write_array(array, **kwargs):
 print(""write_array: "", str(array), ""kwargs: "", str(kwargs))
 sep = kwargs.get('sep', ' ')
 end = kwargs.get('end', '\n')
 stdout.write(sep.join(str(a) for a in array) + end)

 n, m = read_int_array()
 print(""n: "", str(n), ""m: "", str(m))
 uf = UnionFind(n)
 print(""uf: "", str(uf))
 for _ in range(m):
 nums = read_int_array()
 print(""nums: "", str(nums))
 sz = nums[0]
 leader = None
 for i in range(sz):
 p = nums[1 + i] - 1
 if leader is None:
 leader = p
 print(""leader: "", str(leader))
 else:
 uf.merge(p, leader)

 ans = [uf.set_size(i) for i in range(n)]
 print(""ans: "", str(ans))
 write(*ans)

 print(""End of main function"")

main()
</ans>",0,{}
16," <ans>
class Sponge:
"""""" Sponge representation """"""

def __init__(self, test_inputs=None):
"""""" Default constructor """"""

it = iter(test_inputs.split(""\n"")) if test_inputs else None

print(""test_inputs: "", str(test_inputs))

def uinput():
return next(it) if it else sys.stdin.readline().rstrip()

print(""n: "", str(n))
print(""m: "", str(m))

[self.n, self.m] = list(map(int, uinput().split()))

print(""numf: "", str(self.numf))
self.numf = list(map(int, uinput().split()))

print(""numb: "", str(self.numb))
self.numb = list(map(int, uinput().split()))

print(""fd: "", str(self.fd))
self.fd = {}

print(""fdn: "", str(self.fdn))
self.fdn = {}

for (i, n) in enumerate(self.numf):
self.fd[n] = self.fd.setdefault(n, 0) + 1
self.fdn[n] = i + 1
</ans>",0,{}
17," <ans>
n = input().split()
print(""n: "", str(n))
r = int(n[0])
print(""r: "", str(r))
k = int(n[1])
print(""k: "", str(k))
l = []
print(""l: "", str(l))
for i in range(r):
 li = input()
 print(""li: "", str(li))
 l.append(li)
rl = []
print(""rl: "", str(rl))
for i in range(r):
 x = []
 print(""x: "", str(x))
 for j in range(r):
 x.append(0)
 rl.append(x)
for i in range(r):
 for j in range(len(l[i])):
 flag = 0
 f = 0
 if j + k <= r:
 for q in range(k):
 if l[i][j + q:j + q + 1] == '.':
 continue
 else:
 flag = 1
 break
 if flag == 0:
 for q in range(k):
 rl[i][j + q] += 1
 if flag == 1:
 j = q + 1
for i in range(r):
 for j in range(r):
 flag = 0
 f = 0
 if j + k <= r:
 for q in range(k):
 if l[j + q][i:i + 1] == '.':
 continue
 else:
 flag = 1
 break
 if flag == 0:
 for q in range(k):
 rl[j + q][i] += 1
 if flag == 1:
 j = q + 1
maxi = 0
maxj = 0
m = 0
for i in range(r):
 for j in range(r):
 if rl[i][j] > m:
 m = rl[i][j]
 maxi = i
 maxj = j
print(""maxi+1: "", str(maxi + 1))
print(""maxj+1: "", str(maxj + 1))
</ans>",0,{}
18," <ans>
"""""" ATSTNG's ejudge Python3 solution template """"""
import sys, queue

try:
 import dev\_act\_ffc429465ab634
 DEV = True
except:
 DEV = False

def log(*s):
 if DEV: print('L',list(s),sep='')

class EJudge:
 def __init__(self, problem=""default"", reclim=1<<30):
 self.problem = problem
 sys.setrecursionlimit(reclim)

 print(""self: "", str(self))

 def use_files(self, infile='', outfile=''):
 if infile!='':
 self.infile = open(infile)
 sys.stdin = self.infile
 print(""infile: "", str(self.infile))
 if infile!='':
 self.outfile = open(outfile, 'w')
 sys.stdout = self.outfile
 print(""outfile: "", str(self.outfile))

 def use_bacs_files(self):
 self.use_files(self.problem+'.in', self.problem+'.out')

 def get_tl(self):
 while True: pass

 def get_ml(self):
 tmp = [[[5]*100000 for _ in range(1000)]]
 print(""tmp: "", str(tmp))
 while True: tmp.append([[5]*100000 for _ in range(1000)])

 def get_re(self):
 s = (0,)[8]
 print(""s: "", str(s))

 def get_wa(self, wstr='blablalblah'):
 for _ in range(3): print(wstr)
 print(""wstr: "", str(wstr))
 return

class IntReader:
 def __init__(self):
 self.ost = queue.Queue()

 def get(self):
 return int(self.sget())

 def sget(self):
 if self.ost.empty():
 for el in input().split():
 self.ost.put(el)
 return self.ost.get()

 def release(self):
 res = []
 while not self.ost.empty():
 res.append(self.ost.get())
 return res

 print(""IntReader: "", str(IntReader()))

###############################################################################
ej = EJudge( )
int\_reader = IntReader()
fmap = lambda f,l: list(map(f,l))
parse\_int = lambda: fmap(int, input().split())
sign = lambda x: (x>0)-(x<0)

# input
n,x = parse\_int()
st = [0]*100500
xored = [0]*100500
print(""n: "", str(n))
print(""x: "", str(x))
for _ in range(n): st[int\_reader.get()] += 1
print(""n times: "", str(n))
for idx in range(100500):
 pair = idx^x
 if pair < 100500:
 xored[pair] = st[idx]
 print(""pair: "", str(pair))
 print(""idx: "", str(idx))
 print(""st[idx]: "", str(st[idx]))

ans = 0
for idx in range(100500):
 ans += st[idx]*xored[idx]
 print(""ans: "", str(ans))

if x == 0: ans -= n
 print(""ans after if: "", str(ans))

print(ans//2)
</ans>",0,{}
19," <ans>
def __starting_point():
    n = I()
    print(""n: "", n)
    a = VI()
    print(""a: "", a)

    run(n, a)
</ans>",0,{}
20," <ans>
def e\_gcd(a, b):
 print(""a: "", a, ""b: "", b)
 if a==0 and b==0:
 return -1, 0, 0
 if b==0:
 return a, 1,0
 d, y,x = e\_gcd(b, a%b )
 print(""x: "", x, ""y: "", y, ""a: "", a, ""b: "", b)
 y-= a //b *x
 return d , x,y

def m\_reverse(a,n):
 print(""a: "", a, ""n: "", n)
 d,x,y = e\_gcd(a,n)
 print(""x: "", x, ""y: "", y, ""a: "", a, ""n: "", n)
 assert x*a + y*n == d
 if d==1:
 if x%n<=0:
 return x%n+n
 else:
 return x%n
 else:
 return -1

inId = 0
outId = 0
if inId>0:
 print(""inId: "", inId)
 sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
 print(""outId: "", outId)
 sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
 atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit

 base = 998244353
 print(""base: "", base)
 d = 1233
 print(""d: "", d)
 t = m\_reverse( d, base)
 print(""t: "", t)
 z = t * d % base
 print(""z: "", z)
 N, M, K= getIntList()
 print(""N: "", N, ""M: "", M, ""K: "", K)

 J = N-1 - K
 print(""J: "", J)
 Z = N - J
 print(""Z: "", Z)
 R = M
 print(""R: "", R)
 for i in range(Z-1):
 R *= M-1
 R%= base
 print(""R after for loop 1: "", R)

 n0 = J
 m0 = Z
 print(""n0: "", n0, ""m0: "", m0)
 for i in range(m0 -1):
 g = n0 + m0 -1 -i
 R*= g
 R%= base
 print(""R after for loop 2: "", R)

 for i in range(2, m0):
 t = m\_reverse(i,base)
 R*=t
 R%=base
 print(""R after for loop 3: "", R)

 print(R)
</ans>",0,{}
21," <ans>
for i in range(1):
    n, k = map(int, I().split())
    a = list(map(int, I().split()))
    s = I()
    c = 1; b = []
    print(""n: "", n, ""k: "", k)
    for i in range(1, n):
        if s[i-1] == s[i]:
            c += 1
            f = True
        else:
            b.append(c)
            c = 1
            f = False
    if f:
        b.append(c)
    print(""b: "", str(b))
    ans = 0
    su = 0
    for i in b:
        c = a[su:min(su+i, 10**9)]
        print(""c: "", str(c))
        c.sort(reverse=True)
        c = c[:min(i, k)]
        su += i
        ans += sum(c)
    print(""ans: "", ans)
</ans>",0,{}
22," <ans>
def solve(printing):

    n = int(input())
    print(""n: "", str(n))
    nums = [int(st)-1 for st in input().split("" "")]
    print(""nums before numdupe: "", str(nums))
    numdupe = [0] * n
    print(""numdupe: "", str(numdupe))

    for i in range(n):
        numdupe[nums[i]] += 1

    print(""numdupe after nums loop: "", str(numdupe))

    for i in range(n):
        if numdupe[i] == 0:
            missing.append(i)
            print(""missing.append(i): "", str(i))
            
        if numdupe[nums[i]] >= 2:
            dupeindex.append(i)
            print(""dupeindex.append(i): "", str(i))
            if nums[i] in dupeindexindv:
                dupeindexindv[nums[i]][1].append(i)
                print(""dupeindexindv[nums[i]][1].append(i): "", str(i))
            else:
                dupeindexindv[nums[i]] = [0, [i], False]
                print(""dupeindexindv[nums[i]]: "", str(dupeindexindv[nums[i]]))

    for num in dupeindexindv:
        dupeindexindv[num][0] = len(dupeindexindv[num][1])
        print(""dupeindexindv[num][0]: "", str(dupeindexindv[num][0]))

    print(""missing: "", str(missing))
    print(""dupeindexindv: "", str(dupeindexindv))

    misslen = len(missing)
    misindex = 0
    #answer = 0
    for index in dupeindex:

        if misslen <= misindex:
            break

        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:
            # one spot left but original not located yet.
            # locate original.
            dupeindexindv[nums[index]][0] -= 1
            dupeindexindv[nums[index]][2] = True
        
        elif dupeindexindv[nums[index]][0] > 0:
            
            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:
                # num is smaller or original is already located.
                # locate missing number.
                dupeindexindv[nums[index]][0] -= 1
                nums[index] = missing[misindex]
                misindex += 1
                #answer += 1

            else: # locate original
                dupeindexindv[nums[index]][0] -= 1
                dupeindexindv[nums[index]][2] = True

    print(""misslen: "", str(misslen))
    for num in nums:
        print(""num: "", str(num+1), end = "" "")
</ans>",0,{}
23," <ans>
from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi

def yes():print('YES')
def no():print('NO')

if (path.exists('input.txt')): 
 #------------------Sublime--------------------------------------#
 sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');

def I():return (int(input()))
def In():return(map(int,input().split()))
else:
 #------------------PYPY FAst I/o--------------------------------#
 def I():return (int(stdin.readline()))
 def In():return(map(int,stdin.readline().split()))

#sys.setrecursionlimit(1500)

def dict(a):
 d={} 
 for x in a:
 if d.get(x,-1)!=-1:
 d[x]+=1
 else:
 d[x]=1
 return d

def find_gt(a, x):
 'Find leftmost value greater than x'
 print(""find_gt: "", x)
 i = bi.bisect_right(a, x)
 if i != len(a):
 print(""find_gt: index: "", i)
 return i
 else:            
 print(""find_gt: index: -1"")
 return -1

def find_ge(a, x):
 'Find leftmost item greater than or equal to x'
 print(""find_ge: "", x)
 i = bi.bisect_left(a, x)
 if i != len(a):
 print(""find_ge: index: "", i)
 return i
 else:
 print(""find_ge: index: -1"")
 return -1

def main():
 try:
 n,Q=In()
 print(""n: "", n)
 print(""Q: "", Q)
 l=list(In())
 print(""l: "", str(l))
 l.sort()
 pre=[0]
 su=0
 for x in range(n):
 su+=l[x]
 pre.append(su)
 print(""pre: "", str(pre))
 for x in range(Q):
 q=I()
 print(""q: "", q)
 q*=2
 pos=find_ge(l,q)
 print(""pos: "", pos)
 if pos==-1:
 print(""ans: 0"")
 else:
 ans=pre[-1]-pre[pos]
 print(""ans: "", ans)
 except:
 pass

M = 998244353
P = 1000000007

def __starting_point():
 #for _ in range(I()):main()
 for _ in range(1):main()
__starting_point()
</ans>",0,{}
24," <ans>
import sys

def gcd(l):
 print(""l: "", str(l))
 if len(l)==0:
 return 0
 if len(l)==1:
 return l[0]
 if len(l)==2:
 if l[1]==0:
 return l[0]
 print(""l[1]: "", str(l[1]))
 print(""l[0]%l[1]: "", str(l[0]%l[1]))
 return gcd([l[1],l[0]%l[1]])
 return gcd([l[:-1],l[-1]])

def brute_force(l1,l2,l,sol):
 print(""l1: "", str(l1))
 print(""l2: "", str(l2))
 print(""l: "", str(l))
 print(""sol: "", str(sol))
 if len(l)==0:
 g1=gcd(l1)
 g2=gcd(l2)
 print(""g1: "", str(g1))
 print(""g2: "", str(g2))
 return g1==1 and g2==1,sol

 def factor(n):
 print(""n: "", str(n))
 res=[]
 i=2
 while i*i<=n:
 if n%i==0:
 res.append(i)
 while n%i==0:
 n=int(n/i)
 i+=1

 if n!=1:
 res.append(n)

 return res

 def dumpsol(sol):
 for v in sol:
 print(v,end=' ')

 n=int(sys.stdin.readline())
 l=sys.stdin.readline().strip().split("" "")[0:n]
 l=[int(x) for x in l]
 if n<12:
 print(""n: "", str(n))
 print(""l: "", str(l))
 ret,sol=brute_force([],[],l,[])
 if ret:
 print(""YES"")
 print(""sol: "", str(sol))
 else:
 print(""NO"")
 return

 factors={}
 for i in range(10):
 for key in factor(l[i]):
 factors[key]=0

 flists={}
 for f in factors:
 flists[f]=[]
 pos=0
 found=False
 for v in l:
 if v%f!=0:
 found=True
 factors[f]+=1
 flists[f].append(pos)
 pos+=1
 if not found:
 print(""NO"")
 return

 oftf={}
 isoftf={}
 for f in factors:
 if factors[f]==0:
 print(""factors["",str(f),""]: "", str(factors[f]))
 print(""NO"")
 return

 if factors[f]<10:
 oftf[f]=1
 isoftf[f]=1

 sol=[1 for i in range(len(l))]
 x=l[0]
 sol[0]=2
 oxf=factor(x)
 print(""oxf: "", str(oxf))
 xf=[]
 nxf=0
 isxoftf={}
 for f in oxf:
 if f in isoftf:
 nxf+=1
 isxoftf[f]=1
 xf.append(f)
 else:
 sol[flists[f][0]]=2

 nonxf=[]
 for f in oftf:
 if not f in isxoftf:
 nonxf.append(f)

 masks={}
 pos=0
 for f in xf+nonxf:
 for v in flists[f]:
 if not v in masks:
 masks[v]=0
 masks[v]|=1<<pos
 pos+=1

 vals=[{} for i in range(len(masks)+1)]
 vals[0][0]=0
 pos=0
 mlist=[]
 for mask in masks:
 mlist.append(mask)
 cmask=masks[mask]
 cmask1=cmask<<10
 for v in vals[pos]:
 vals[pos+1][v|cmask]=v
 if mask!=0:
 vals[pos+1][v|cmask1]=v
 pos+=1

 test_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
 for v in vals[pos]:
 if (v&test_val)==test_val:
 print(""YES"")
 while (pos!=0):
 nv=vals[pos][v]
 if (nv^v<1024 and nv^v!=0):
 sol[mlist[pos-1]]=2
 v=nv
 pos-=1
 dumpsol(sol)
 return

 print(""NO"")
</ans>",0,{}
25," <ans>
if a, b, f, k := [int(i) for i in input().split()]:
 print(""a: "", str(a), ""b: "", str(b), ""f: "", str(f), ""k: "", str(k))

if b < f:
 print(""b is less than f"")
 print(-1)
 return

journeys = 0
previous = 0
refuels1 = 0
tank = b-f
while(journeys != k):
 if previous == 0:
 print(""previous: 0, tank: "", str(tank))
 if tank >= a-f + a*(k-journeys-1):
 print(""refuels1: "", str(refuels1))
 return
 if b >= a-f + a*(k-journeys-1):
 print(""refuels1: "", str(refuels1+1))
 return
 if tank >= 2*(a-f):
 print(""tank: "", str(tank-2*(a-f)))
 elif b >= 2*(a-f):
 print(""refuels1: "", str(refuels1+1))
 tank = b - 2*(a-f)
 else:
 print(""cannot reach destination"")
 print(-1)
 return

 journeys += 1
 previous = a

 if previous == a:
 print(""previous: a, tank: "", str(tank))
 if tank >= f + a*(k-journeys-1):
 print(""refuels1: "", str(refuels1))
 return
 if tank >= 2*f:
 print(""tank: "", str(tank-2*f))
 elif b >= 2*f:
 print(""refuels1: "", str(refuels1+1))
 tank = b - 2*f
 else:
 print(""cannot reach destination"")
 print(-1)
 return

 journeys += 1
 previous = 0

if journeys == k:
 print(""refuels1: "", str(refuels1))
else:
 print(-1)
</ans>",0,{}
26," <ans>
import heapq
n, m, k = list(map(int, input().split()))
print(""n: "", n, ""m: "", m, ""k: "", k)
connectionList = []
for _ in range(n):
 print(""connectionList[{}]: "".format(_))
 connectionList.append([])
edgeList = []
for _ in range(m):
 print(""edgeList[{}]: "".format(_))
 x, y, w = list(map(int, input().split()))
 print(""x: {}, y: {}, w: {}"".format(x, y, w))
 edgeList.append((x, y, w))
print(""edgeList after sorting:"")
edgeList.sort(key=lambda x:x[2])
if k < m:
 maxDist = edgeList[min(m,k) - 1][2]
else:
 maxDist = sum([x[2] for x in edgeList])
print(""maxDist: "", maxDist)
colorList = {}
colorVertex = []
for i in range(n):
 print(""colorList and colorVertex initialization:"")
 colorList[i] = [i]
 colorVertex.append(i)
for i in range(min(m,k)):
 x,y,w = edgeList[i]
 print(""connectionList[{}] and connectionList[{}] update:"".format(x-1, y-1))
 connectionList[x-1].append((y-1,w))
 connectionList[y-1].append((x-1,w))
 print(""colorList update:"")
 prevColor = None
 if colorVertex[x-1] != colorVertex[y-1]:
 if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):
 prevColor = colorVertex[y-1]
 for elem in colorList[colorVertex[y-1]]:
 colorVertex[elem] = colorVertex[x-1]
 colorList[colorVertex[x-1]].append(elem)
 del colorList[prevColor]
 else:
 prevColor = colorVertex[x-1]
 for elem in colorList[colorVertex[x-1]]:
 colorVertex[elem] = colorVertex[y-1]
 colorList[colorVertex[y-1]].append(elem)
 del colorList[prevColor]
pathList = []
for key in colorList:
 print(""colorList[{}] initialization:"".format(key))
 vertexList = colorList[key]
 for mainVertex in vertexList:
 print(""mainVertex: {}"".format(mainVertex))
 vertexPQueue = []
 isCovered = {}
 distanceDic = {}
 for elem in vertexList:
 print(""vertexList[{}] initialization:"".format(elem))
 isCovered[elem] = False
 distanceDic[elem] = maxDist
 print(""isCovered and distanceDic initialization:"")
 for elem in vertexList:
 print(""elem: {} isCovered: {} distanceDic: {}"".format(elem, isCovered[elem], distanceDic[elem]))
 isCovered[mainVertex] = True
 for elem in connectionList[mainVertex]:
 print(""connectionList[{}][{}] initialization:"".format(mainVertex, elem[0]))
 heapq.heappush(vertexPQueue, (elem[1], elem[0]))
 distanceDic[elem[0]] = elem[1]
 print(""vertexPQueue and distanceDic after first iteration:"")
 while vertexPQueue:
 print(""vertexPQueue: {}"".format(vertexPQueue))
 print(""distanceDic: {}"".format(distanceDic))
 distance, curVertex = heapq.heappop(vertexPQueue)
 if isCovered[curVertex]:
 print(""isCovered[{}] is True, skipping: {}"".format(curVertex, curVertex))
 continue
 elif distance >= maxDist:
 print(""distance {} is greater than maxDist {}, breaking: {}"".format(distance, maxDist, distance))
 break
 for elem in connectionList[curVertex]:
 if distance + elem[1] < distanceDic[elem[0]]:
 print(""connectionList[{}][{}] update: {}"".format(curVertex, elem[0], distance + elem[1]))
 heapq.heappush(vertexPQueue, (distance + elem[1], elem[0]))
 distanceDic[elem[0]] = distance + elem[1]
 print(""vertexPQueue and distanceDic after current iteration:"")
for key in distanceDic:
 print(""key: {}, value: {}"".format(key, distanceDic[key]))
 if distanceDic[key] <= maxDist and key > mainVertex:
 pathList.append(distanceDic[key])
 print(""pathList after current iteration: {}"".format(pathList))
 if len(pathList) > k:
 pathList.sort()
 pathList = pathList[0:k]
 if pathList[-1] < maxDist:
 maxDist = pathList[-1]
 print(""maxDist updated to: {}"".format(maxDist))
pathList.sort()
print(""pathList after sorting:"")
print(""pathList[{}]"".format(k-1))
</ans>",0,{}
27," <ans>
class Ddict:
 def __init__(self):
 self.dicts={}
 print(""self.dicts: "", str(self.dicts))
 def add(self,key):
 d=self.dicts
 print(""d: "", str(d))
 for i in key:
 if i not in d:
 d[i]={}
 print(""d: "", str(d))
 d=d[i]
 print(""d: "", str(d))
 d[' ']=''
 print(""d: "", str(d))
 def find(self,key):
 if key=='':
 return '',''
 d=self.dicts
 q=[]
 h=[key[0]]
 for i in key:
 if i not in d:
 if ' ' in d and len(d)==1:
 return ''.join(q),''.join(h)
 print(""d: "", str(d))
 q.append(i)
 print(""q: "", str(q))
 h=q[:]
 d=d[i]
 print(""d: "", str(d))
 if ' ' in d and len(d)==1:
 return ''.join(q),''.join(h)
 print(""d: "", str(d))
 return '',''
words = Ddict()
print(""words: "", str(words))
ans=0
print(""ans: "", str(ans))
while True:
 try:
 x=input()
 print(""x: "", str(x))
 if not x:
 break
 print(""ans: "", str(ans))
 ans+=len(x)+1
 print(""ans: "", str(ans))
 ws=[[]]
 print(""ws: "", str(ws))
 for i in x:
 if i in '.,?!\'- ':
 if ws[-1]:
 ws.append([])
 print(""ws: "", str(ws))
 else:
 ws[-1].append(i)
 print(""ws[-1]: "", str(ws[-1]))
 ws=list([''.join(e) for e in ws])
 print(""ws: "", str(ws))
 for w in ws:
 next_word,helped_word = words.find(w)
 print(""next_word: "", str(next_word))
 print(""helped_word: "", str(helped_word))
 if next_word and next_word!=helped_word:
 ans-=len(next_word)-len(helped_word)-1
 print(""ans: "", str(ans))
 words.add(w)
 print(""words: "", str(words))
</ans>",0,{}
28," <ans>
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
INF = float('inf')
from sys import stdin
readline = stdin.readline

print(""n: "", n)
ans = 0

def dfs(v):
 if len(v) != 0:
 print(""v: "", str(v))
 if int(v) > n:
 return
 if v.count('3') and v.count('5') and v.count('7'):
 nonlocal ans
 ans += 1
 for s in ""357"":
 v += s
 dfs(v)
 v = v[:-1]

dfs("""")
print(""ans: "", ans)
</ans>",0,{}
29," <ans>
from sys import stdin, stdout
from itertools import accumulate

#T = int(input())
s = input()
#N,M,K,Q = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

def computeGCD(x, y):

   while(y):
       x, y = y, x % y

   return x

record = {}
print(""record: {}"".format(record))

for x in range(10):
    for y in range(10):
        for d in range(10):
            m = 9999
            if (x==0 or y==0) and d==0:
                record[(x,y,d)] = 0
            elif x==0 and y==0 and d!=0:
                record[(x,y,d)] = -1
            else:
                for k in range(10):
                    d_tmp = d + 10*k
                    if x==0:
                        if d_tmp%y==0:
                            record[(x,y,d)] = d_tmp//y - 1
                            print(""x, y, d: {}, {}, {}"".format(x, y, d))
                            break

                    elif y==0:
                        if d_tmp%x==0:
                            record[(x,y,d)] = d_tmp//x - 1
                            print(""x, y, d: {}, {}, {}"".format(x, y, d))
                            break

                    else:
                        for a in range((d_tmp//x)+1):
                            for b in range((d_tmp//y)+1):
                                if x*a+y*b==d_tmp and d_tmp!=0:
                                    m = min(m,a+b-1)

                if (x,y,d) not in record:
                    if m==9999:
                        m = -1
                    record[(x,y,d)] = m
            #print(x,y,d,record[(x,y,d)])

data = [[0]*10 for _ in range(10)]
print(""data: {}"".format(data))

len_s = len(s)
s = list(s)
freq = [0]*10
for i in range(len_s-1):
    A = s[i]
    B = s[i+1]

    d = ord(B)-ord(A)
    if d<0:
        d += 10

    freq[d] += 1

for x in range(10):
    for y in range(10):
        for d in range(10):
            if freq[d]==0:
                data[x][y] += 0
            elif record[(x,y,d)]==-1:
                data[x][y] = -10000000
            else:
                data[x][y] += freq[d]*record[(x,y,d)]
            print(""x, y, d, data: {}, {}, {}, {}"".format(x, y, d, data[x][y]))

for x in range(10):
    for y in range(10):
        if data[x][y]<0:
            print(-1,end=' ')
        else:
            print(data[x][y],end=' ')
    print('',end='\n')
</ans>",0,{}
30," <ans>
from sys import stdin, stdout
import math

N, r = [int(x) for x in stdin.readline().split()]
# N:  int: , r:  int:

visited = [0]*N
# visited: list: [0]*N

a = [0]*N
b = [0]*N

pos = 0

for i in range(N):
 arr = [int(x) for x in stdin.readline().split()]
 a[i] = arr[0]
 b[i] = arr[1]
 # a[i]: int, b[i]: int

 print(""arr: "", str(arr))
 if b[i]>=0:
 pos += 1

for i in range(pos):
 idx = -1
 start = 0
 gain = -50000
 for j in range(N):
 if visited[j]==1 or b[j]<0:
 continue
 if b[j]>gain and r>=a[j]:
 gain = b[j]
 idx = j
 start = a[j]
 elif b[j]==gain and r>=a[j]:
 if a[j]>start:
 idx = j
 start = a[j]

 if idx==-1:
 print('NO')
 quit()

 visited[idx] = 1
 r += b[idx]
 print(""idx: "", str(idx), ""r: "", str(r))

 tmp = []
 for i in range(N):
 if visited[i]==1 or b[i]>=0:
 continue
 tmp.append((a[i],b[i],i))
 # tmp: list: []

 tmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)

 for i in range(len(tmp)):
 require = tmp[i][0]
 bias = tmp[i][1]

 if r>=require:
 r += bias
 print(""require: "", str(require), ""r: "", str(r))
 else:
 print('NO')
 quit()

 if r<0:
 print('NO')
 quit()

 print('YES')
</ans>",0,{}
31," <ans>
from math import*
from random import*

n = int(input()) * 2
A = list(map(int, input().split()))
amount = [0] * 101

print(""n: "", str(n))
print(""A: "", str(A))

amount = [0] * 101
print(""amount before initialization: "", str(amount))

B = []
print(""B before initialization: "", str(B))

for i in range(n):
 print(""i: "", str(i))
 if amount[A[i]] < 2:
 print(""A[i]: "", str(A[i]))
 amount[A[i]] += 1
 B += [(A[i], i)]

print(""B after initialization: "", str(B))
B.sort()
x, y = [], []
print(""x, y before initialization: "", str(x), str(y))

for i in range(len(B)):
 if(i % 2 == 0):
 x.append(B[i][1])
 print(""x after appending x[{}]: {}"".format(i, x[i]))
 else:
 y.append(B[i][1])
 print(""y after appending y[{}]: {}"".format(i, y[i]))

lolka = 0
aaa = 0
print(""lolka, aaa before initialization: "", str(lolka), str(aaa))

for i in range(len(x)):
 if i in x:
 print(""i in x: "", str(i), ""lolka: "", str(lolka), ""aaa: "", str(aaa))
 lolka += 1
 aaa += 1
 print(""lolka, aaa after updating: "", str(lolka), str(aaa))

for i in range(n):
 if i in x:
 print(""i in x: "", str(i), ""lolka: "", str(lolka), ""aaa: "", str(aaa))
 print(1, end = ' ')
 elif i in y:
 print(2, end = ' ')
 else:
 if len(x) - lolka + aaa < n // 2:
 print(""len(x) - lolka + aaa: "", len(x) - lolka + aaa, ""n // 2: "", n // 2)
 print(1, end = ' ')
 aaa += 1
 else:
 print(2, end = ' ')
 print()

# B, C = [], []
# for i in range(n):

# S = list(set(A))
# where = [0] * 101
# am1, am2 = 0, 0
# print(""S before initialization: "", str(S))
# for i in range(len(S)):
# if(i % 2 == 0):
# where[S[i]] = 1
# print(""where[{}]: {}"".format(i, where[i]))
# am1 += 1
# else:
# where[S[i]] = 2
# print(""where[{}]: {}"".format(i, where[i]))
# am2 += 1

# used = [0] * 201
# print(""used before initialization: "", str(used))
# for i in range(n):
# if not used[A[i]]:
# print(""A[i]: "", str(A[i]))
# print(""used[A[i]] before printing: "", str(used[A[i]]))
# print(where[A[i]])
# used[A[i]] = True
# print(""used[A[i]] after updating: "", str(used[A[i]]))
# else:
# print(""A[i]: "", str(A[i]))
# print(""used[A[i]] before printing: "", str(used[A[i]]))
# print(3 - where[A[i]])
</ans>",0,{}
32," <ans>
def check(mid):
    ans = []
    print(""ans: []"")
    res = 0
    print(""res: 0"")
    for c, count in d:
        print(""c, count: "", str(c), str(count))
        tmp = count // mid
        print(""tmp: "", str(tmp))
        if (count % mid != 0):
            tmp += 1
        ans.append((c, tmp))
        print(""ans.append: "", str(c), str(tmp))
        res += tmp
        print(""res += tmp: "", str(res))
    print(""ans: "", str(ans))
    print(""res: "", str(res))
    return res <= n, ans

a = input()
print(""a: "", str(a))
n = int(input())
print(""n: "", str(n))
d = dict()
print(""d: {}"")
t = 0
for i in a:
    print(""i: "", str(i))
    if i not in d:
        d[i] = 1
        print(""d[i]: 1"")
        t += 1
    else: d[i] += 1
        print(""d[i] += 1"")
ans = []
print(""ans: []"")
res = """"
print(""res: ''"")
if n >= len(a):
    print(""n >= len(a): "", str(True))
    print(""a, end ='': "", str(a), end ='')
    n -= len(a)
    print(""n: "", str(n))
    for u in range(n):
        print(""u: "", str(res), end ='')
else:
    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))
    print(""d: "", str(d))
    l = 1
    print(""l: 1"")
    r = len(a)
    print(""r: len(a)"")
    res = []
    print(""res: []"")
    count_res = 0
    print(""count_res: 0"")
    while (l <= r):
        mid = (l + r) // 2
        print(""mid: "", str(mid))
        flag, tmp = check(mid)
        print(""flag, tmp: "", str(flag), str(tmp))
        if (flag):
            r = mid - 1
            print(""r = mid - 1"")
            count_res = mid
            print(""count_res: "", str(mid))
            res = tmp
            print(""res: "", str(tmp))
        else:
            l = mid + 1
            print(""l = mid + 1"")
        print(""l, r, tmp: "", str(l), str(r), str(tmp))
    if (len(res) == 0):
        print(""len(res) == 0: "", str(False))
    else:
        ttt = 0
        print(""ttt: 0"")
        print(""count_res: "", str(count_res))
        for c, sl in res:
            print(""c, sl: "", str(c), str(sl))
            for j in range(sl):
                print(""j: "", str(j))
                print(""c, end ='': "", str(c), end ='')
                ttt += 1
        print(""n: "", str(n))
        print(""n -= ttt: "", str(n - ttt))
        for i in range(n):
            print(""i: "", str(a[0]))
            print(""a[0], end ='': "", str(a[0]), end ='')
</ans>",0,{}
33," <ans>
""""""
Codeforces Contest Good Bye 2014 Contest Problem B

Author : chaotic_iak
Language: Python 3.4.2
""""""

################################################### SOLUTION

def main():
 print(""n: "", n)
 n, = read()
 print(""p: "", str(p))
 p = read(mode=1)
 print(""dsu: "")
 dsu = DSU()
 for i in range(n):
 print(""i: "", i)
 a = read(mode=0)
 dsu.make()
 for j in range(i):
 if a[j] == ""1"":
 print(""j: "", j)
 dsu.union(j, i)
 used = [0] * n
 res = [0] * n
 for i in range(n):
 if not used[i]:
 print(""i: "", i)
 pr = dsu.find(i)
 indices = []
 elements = []
 for j in range(n):
 if dsu.find(j) == pr:
 used[j] = 1
 indices.append(j)
 elements.append(p[j])
 print(""indices: "", indices)
 print(""elements: "", elements)
 elements.sort()
 for i, e in zip(indices, elements):
 res[i] = e
 print(""res[i]: "", res[i])
 write(res)

#################################################### HELPERS

class DSU(object):
 """"""
 Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.

 Methods:
 make(): add a new element and returns its index
 find(x): return representative of x
 union(x, y): merge the sets containing x and y

 Not to be used publicly:
 _parent: a list of ints for the parent of each vertex, used internally; call find instead
 _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case
 __init__(): called when initialization, initialize DSU to be empty
 __str__(): return a readable string description of the DSU; meant to be printed while debugging
 """"""

 def __init__(self):
 self._parent = []
 self._rank = []

 def make(self):
 i = len(self._parent)
 self._parent.append(i)
 self._rank.append(0)
 return i

 def find(self, x):
 if self._parent[x] != x:
 self._parent[x] = self.find(self._parent[x])
 return self._parent[x]

 def union(self, x, y):
 xr = self.find(x)
 yr = self.find(y)
 if xr == yr: return
 if self._rank[xr] < self._rank[yr]:
 self._parent[xr] = yr
 else:
 self._parent[yr] = xr
 self._rank[xr] += 1

 def __str__(self):
 s = ""DSU\n""
 for i in range(len(self._parent)):
 s += str(i) + "" in set "" + str(self.find(i)) + "" with rank "" + str(self._rank[self.find(i)]) + ""\n""
 return s

def read(mode=2):
 """"""
 0: String
 1: List of strings
 2: List of integers
 """"""
 inputs = input().strip()
 if mode == 0: return inputs
 if mode == 1: return inputs.split()
 if mode == 2: return list(map(int, inputs.split()))

def write(s=""\n""):
 if s is None: s = """"
 if isinstance(s, list): s = "" "".join(map(str, s))
 s = str(s)
 print(s, end="""")

write(main())
</ans>",0,{}
34," <ans>
from math import log2, floor

def is\_power2(num):
return num != 0 and ((num & (num - 1)) == 0)

print(""is\_power2: "", is\_power2)

def next\_two\_pow(val):
pw=0
while 2**pw <= val:
pw+=1
return pw

print(""next\_two\_pow: "", next\_two\_pow)

n = int(input())
arr=[int(x) for x in input().split()]

print(""n: "", n)
print(""arr: "", arr)

win\_idx =-1
selected=[]

for i in range(1,n+1):
val = arr[i-1]
if win\_idx ==-1:
if val == -1:
win\_idx =i
else:
if is\_power2(i):
selected.append(val)
print(""selected: "", selected)
selected.sort()
else:
if len(selected) > 0 and val < selected[-1]:
selected.pop()
selected.append(val)
selected.sort()
print(""selected: "", selected)

print(""win\_idx: "", win\_idx)

print(""sum(selected): "", sum(selected))
</ans>",0,{}
35," <ans>
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__

def go():
 print(""n: "", n)
 # n, h, l, r = map(int, input().split())
 a = list(map(int, input().split()))
 print(""a: "", a)
 e = {i: set() for i in range(n)}
 print(""e: "", e)
 for _ in range(n - 1):
 u, v = list(map(int, input().split()))
 u, v = u - 1, v - 1
 e[u].add(v)
 e[v].add(u)
 print(""u, v: "", u, v)
 ranks = [len(e[i]) for i in range(n)]
 print(""ranks: "", ranks)
 leafs = [i for i in range(n) if ranks[i] == 1]
 print(""leafs: "", leafs)
 index = 0
 vs = {i: {} for i in range(n)}
 done = set()
 while index < len(leafs):
 cur = leafs[index]
 mysum = sum(vs[cur].values())
 if a[cur] == 0:
 mysum -= 1
 else:
 mysum += 1
 print(""cur, mysum: "", cur, mysum)
 for i in e[cur] - done:
 vs[i][cur] = max(mysum, 0)
 ranks[i] -= 1
 if ranks[i] == 1:
 leafs.append(i)
 done.add(cur)
 index += 1
 sums = [0] * n
 que = [ranks.index(0)]
 done = set()
 index = 0
 while index < len(que):
 cur = que[index]
 mysum = sum(vs[cur].values())
 if a[cur] == 0:
 mysum -= 1
 else:
 mysum += 1
 sums[cur] = mysum
 for i in e[cur] - done:
 vs[i][cur] = max(mysum - vs[cur][i], 0)
 que.append(i)
 done.add(cur)
 index += 1
 return ' '.join(map(str,sums))

# t = int(input())
for _ in range(1):
 print(""Result: "", go())
</ans>",0,{}
36," <ans>
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
#mod = 998244353
INF = float('inf')
from sys import stdin
readline = stdin.readline

n = I()
A = []
B = []
ans = 0

# print(“n: ”, str(n))

A = readInts()
B = readInts()

# print(""A: "", str(A))
# print(""B: "", str(B))

for i in range(n):
 v = B[i]
 # kill = A[i] + A[i+1]
 nya = min(v, A[i])
 A.append(A[i] - nya)
 v -= nya
 ans += nya
 nya = min(A[i+1], v)
 ans += nya
 A.pop(i+1)
 A[i+1] = A[i+1] - nya
 # print(""i: "", str(i), ""A[i]: "", str(A[i]), ""v: "", str(v), ""nya: "", str(nya), ""ans: "", str(ans))

print(ans)
</ans>",0,{}
37," <ans>
def solve(s,t):
    hash_s = [False] * 256
    print(""hash_s: "", hash_s)
    hash_t = [False] * 256
    print(""hash_t: "", hash_t)
    arr = []
    n = len(s)
    print(""n: "", n)
    for c in s:
        hash_s[ord(c)] = True
    print(""hash_s after s: "", hash_s)
    for c in t:
        hash_t[ord(c)] = True
    print(""hash_t after t: "", hash_t)
    for i in range(256):
        if not hash_s[i] and hash_t[i]:
            print(-1)
            return
    rev = s[::-1]
    print(""rev: "", rev)
    i,j = 0,0
    while i < len(t):
        flag = True
        temp = t[i]
        j = i + 1
        while j < len(t):
            temp += t[j]
            if temp not in s and temp not in rev:
                flag = False
                break
            j += 1
        if flag:
            x = s.find(temp)
            if x != -1:
                arr.append((x + 1,x + len(temp)))
                print('1',x + 1,x + len(temp))
            else:
                y = rev.find(temp)
                arr.append((n - y,n - y - len(temp) + 1))
                print('2',n - y,n - y - len(temp) + 1)
        else:
            x = s.find(temp[:-1])
            if x != -1:
                arr.append((x + 1,x + len(temp) - 1))
                print('3',x + 1,x + len(temp) - 1)
            else:
                x = rev.find(temp[:-1])
                arr.append((n - x,n - x - len(temp) + 2))
                print('4',n - x,n - x - len(temp) + 2)
        i = j
    print(""len(arr): "", len(arr))
    for x,y in arr:
        print(""x,y: "", x,y)

s = input()
print(""s: "", s)
t = input()
print(""t: "", t)

solve(s,t)
</ans>",0,{}
38," <ans>
from itertools import chain
import sys

def main():
 print(""N: "", N)
 N = int(input())
 # TLEs were caused mostly by slow input (1s+)
 # S = list(input() for _ in range(N))
 S = sys.stdin.read().split('\n')
 print(""S: "", str(S))
 print(""counts: "", str(counts))
 counts = [[0,0] for _ in range(len(S))]
 counts = list(map(get_count, list(zip(S,counts))))
 print(""first\_group: "", str(first_group))
 print(""second\_group: "", str(second_group))
 first_group = []
 second_group = []
 min_first_group = float('inf')
 max_first_group = 0
 min_second_group = float('inf')
 max_second_group = 0

 for c in counts:
 print(""c: "", str(c))
 if c[0] - c[1] <= 0:
 first_group.append(c)
 max_first_group = max(max_first_group, c[0])
 min_first_group = min(min_first_group, c[0])
 else:
 second_group.append(c)
 max_second_group = max(max_second_group, c[1])
 min_second_group = min(min_first_group, c[1])

 first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])
 second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))

 order = chain(first_group, second_group)

 cum_sum = 0
 for c in order:
 cum_sum -= c[0]
 if cum_sum < 0:
 return 'No'
 cum_sum += c[1]
 if cum_sum == 0:
 return 'Yes'
 return 'No'

def __starting_point():
 main()

__starting_point()
</ans>",0,{}
39," <ans>
import math
from functools import reduce
class SegmentTree():
 # ... (the same as before)

n = int(input())
print(""n: "", n)
pies, index, first_equal = [0]*n, [0]*n, [0]*n
print(""pies: "", str(pies), ""index: "", str(index), ""first_equal: "", str(first_equal))
for i in range(n):
 # ... (the same as before)
 print(""pies[i]: "", str(pies[i]))
s_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))
print(""s_pies: "", str(s_pies))
for i in range(n):
 index[s_pies[i][0]] = i
 print(""index[i]: "", str(index[i]))
for i in range(1, n):
 first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]
 print(""first_equal[i]: "", str(first_equal[i]))
towers = SegmentTree([0]*(n+1), max)
print(""towers: "", str(towers))
for j, pie in enumerate(pies):
 # ... (the same as before)
 print(""j: "", j, ""pie: "", pie)
 i, k = index[j], first_equal[j]
 print(""i: "", i, ""k: "", k)
 q = towers.query(0, k+1)
 print(""q: "", q)
 towers.modify(i+1, q + pie)
 print(""towers.modify(i+1): "", str(towers.modify(i+1)))
print(math.pi * towers.query(0, n+1))
</ans>",0,{}
40," <ans>
# dat\_test = ""10101""
# rewards\_test = [3, 10, 15, 15, 15]

dat\_str = input().strip()
rewards\_input = input().strip().split()
rewards\_ints = [int(x) for x in rewards\_input]

print(""dat\_str: "", str(dat\_str))
print(""rewards\_ints: "", str(rewards\_ints))

print(""dat: "", str(dat))
print(""rewards: "", str(rewards))

# returns answer to the subproblem with interval range [start, end],
# but with a total of ""extra"" additional stuff on the end
# that must be deleted last.
memo = {}
def f(dat, rewards, start, end, extra):
 print(""curr: "", str(curr))
 if curr in memo:
 return memo[curr]
 if start > end:
 return 0
 if start == end:
 memo[curr] = rewards[dat[start] + extra]
 return memo[curr]

 cut = end
 while cut > start-1 and cut > start-2:
 cut -= 1

 if cut == end:
 out_curr = rewards[dat[cut] + extra]
 out_curr += f(dat, rewards, start, cut-1, 0)
 else:
 out_curr = f(dat, rewards, start, cut, extra + dat[end])
 out_curr += f(dat, rewards, cut+1, end-1, 0)

 out = max(out, out_curr)
 memo[curr] = out
 return memo[curr]

 def solve(dat\_str, rewards\_orig):
 # break into intervals.
 dat = []
 pos = 0
 while pos < len(dat\_str):
 end = pos
 while end < len(dat\_str) and dat\_str[pos] == dat\_str[end]:
 end += 1

 dat.append(end - pos)
 pos = end

 # compute the highest-value way to remove a run of size k.
 # (google translated from C++ thinking)
 rewards = [0, rewards\_orig[0]]
 for k in range(2, len(rewards\_orig) + 1):
 rewards.append(max(rewards[k-j] + rewards\_orig[j-1] for j in range(1, k+1)))

 print(""dat: "", str(dat))
 print(""rewards: "", str(rewards))

 return f(dat, rewards, 0, len(dat)-1, 0)

 int\_dummy = input()

 print((
 solve(
 dat\_str,
 rewards\_ints,
 )
 ))
</ans>",0,{}
41," <ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

class RAQ\_RMQ():
...

def __init__(self, n, inf=2**31-1):
print(""n: "", n)
print(""inf: "", inf)
self.n0 = 1<<(n-1).bit\_length()
self.INF = inf
self.data = [0]*(2\*self.n0)
self.lazy = [0]*(2\*self.n0)

...

n, m, k = map(int, input().split())
print(""n: "", n)
print(""m: "", m)
print(""k: "", k)
l = [0]*(n+1)
print(""l: "", l)
now = k
print(""now: "", now)

...

RMQ = RAQ\_RMQ(n+1)
print(""RMQ: "", RMQ)

for i in range(n+1):
print(""i: "", i)
l[i] = now
now += b+a
print(""now: "", now)
RMQ.update(i+1, i+1, l[i])

...

portal = list(range(n))
print(""portal: "", portal)

for i in range(m):
print(""i: "", i)
u, v = map(int, input().split())
print(""u: "", u)
print(""v: "", v)
u, v = u-1, v-1
if portal[v]<u:
portal[v] = u
print(""portal[v]: "", portal[v])

if RMQ.query(0, n+1) < 0:
print(""-1"")
return

heap = [(-point[i], -portal[i]) for i in range(n)]
print(""heap: "", heap)
from heapq import heapify, heappop
heapify(heap)

ans = 0
print(""ans: "", ans)
while heap:
p, i = heappop(heap)
p, i = -p, -i
print(""p: "", p)
print(""i: "", i)
if RMQ.query(i+1, n+1)>0:
ans += p
print(""ans: "", ans)
RMQ.update(i+1, n+1, -1)
</ans>",0,{}
42," <ans>
import sys
from collections import deque

t=1
for _ in range(int(input())):
 print(""t: "", t)
 n=int(input())
 print(""n: "", n)
 val=set([0,2*10**5+1])
 print(""val: "", str(val))
 seg=[(0,2*10**5+1)]
 print(""seg: "", str(seg))
 for i in range(n):
 print(""i: "", i)
 l,r=map(int,input().split())
 print(""l,r: "", l, r)
 val.add(l)
 print(""val after adding l: "", str(val))
 val.add(r)
 print(""val after adding r: "", str(val))
 seg.append((l,r))

 val=list(val)
 print(""val sorted: "", str(val))
 comp={i:e+1 for e,i in enumerate(val)}
 print(""comp: "", str(comp))
 for i in range(n+1):
 print(""i: "", i)
 for j in range(i+1,n+1):
 l,r=seg[i]
 L,R=seg[j]
 if L<=l and r<=R:
 out[j].append(i)
 print(""out[j] after appending i: "", str(out[j]))
 deg[i]+=1
 print(""deg[i] after increment: "", deg[i])

 ans=[0]
 print(""ans: "", str(ans))
 deq=deque(ans)

 while deq:
 print(""deq: "", str(deq))
 v=deq.popleft()
 print(""v: "", v)
 for nv in out[v]:
 deg[nv]-=1
 print(""deg[nv] before decrement: "", deg[nv])
 if deg[nv]==0:
 deq.append(nv)
 print(""nv added to deq: "", nv)
 ans.append(nv)
 print(""ans after appending nv: "", str(ans))

 dp=[0]*(n+1)
 print(""dp: "", str(dp))

 def solve(v):
 query=[[] for i in range(2*n+3)]
 print(""query: "", str(query))
 for nv in out[v]:
 l,r=seg[nv]
 query[r].append((l,dp[nv]))
 print(""query[r] after appending: "", str(query[r]))
 subdp=[0]*(2*n+3)
 print(""subdp: "", str(subdp))
 for i in range(1,2*n+3):
 res=subdp[i-1]
 print(""res: "", res)
 for l,val in query[i]:
 test=subdp[l-1]+val
 print(""test: "", test)
 res=max(test, res)
 print(""max(test, res): "", res)
 subdp[i]=res
 print(""subdp[i] after assignment: "", subdp[i])

 dp[v]=subdp[-1]+1
 print(""dp[v] after assignment: "", dp[v])

 for v in ans[::-1]:
 print(""v: "", v)
 solve(v)
 print(""dp[0] after solving: "", dp[0])
 print(dp[0]-1)
</ans>",0,{}
43," <ans>
n = int(input())
print(""n: "", str(n))
arr = list(map(int, input().split()))
print(""arr: "", str(arr))
dict1 = {}
print(""dict1: {}"")
for i in range(2 * n):
 try:
 dict1[arr[i]].append(i + 1)
 dict1[arr[i]].sort()
 except KeyError:
 dict1[arr[i]] = [i + 1]
ans = 0
curr1 = 1
curr2 = 1
print(""curr1: "", str(curr1), ""curr2: "", str(curr2))
for i in range(1, n + 1):
 if i == 1:
 ans += (dict1[i][0] - curr1)
 ans += (dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 elif dict1[i][0] > curr1 and dict1[i][0] > curr2:
 ans += (dict1[i][0] - curr1)
 ans += (dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 elif dict1[i][1] < curr1 < curr2:
 ans += abs(dict1[i][0] - curr1)
 ans += abs(dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 elif dict1[i][0] < curr1 and curr1 < dict1[i][1] < curr2:
 ans += abs(dict1[i][0] - curr1)
 ans += abs(dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 elif dict1[i][0] < curr1 and dict1[i][1] < curr2:
 ans += abs(dict1[i][0] - curr1)
 ans += abs(dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 elif curr1 < dict1[i][0] < dict1[i][1] < curr2:
 ans += abs(dict1[i][0] - curr1)
 ans += abs(dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
 else:
 ans += abs(dict1[i][0] - curr1)
 ans += abs(dict1[i][1] - curr2)
 curr1 = dict1[i][0]
 curr2 = dict1[i][1]
 print(""i: "", str(i), ""ans: "", str(ans), ""curr1: "", str(curr1), ""curr2: "", str(curr2))
</ans>",0,{}
44," <ans>
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

 print(""a: "", str(a), ""b: "", str(b))

 n = int(input())
 print(""n: "", str(n))
 P = [[int(x) for x in input().split()] for _ in range(n)]
 print(""P: "", str(P))

 L = []
 def addLine(x, y, dx, dy):
 if dx < 0:
 dx *= -1
 dy *= -1
 elif dx == 0:
 if dy < 0:
 dy *= -1
 g = gcd(dx, dy)
 dx //= g
 dy //= g

 x += dx * (10**9)
 y += dy * (10**9)
 if dx:
 k = x // dx
 else:
 k = y // dy
 x -= k * dx
 y -= k * dy
 L.append((x, y, dx, dy))

 for i in range(n):
 for j in range(i + 1, n):
 xi, yi = P[i]
 xj, yj = P[j]
 dx, dy = xi - xj, yi - yj
 addLine(xi, yi, dx, dy)

 from collections import defaultdict as dd, deque

 L = list(set(L))
 res = 0

 C = dd(int)
 for x, y, dx, dy in L:
 print(""x: "", str(x), ""y: "", str(y), ""dx: "", str(dx), ""dy: "", str(dy))
 C[dx, dy] += 1

 ss = sum(C.values())

 for x in C.values():
 res += (ss - x) * x

 # for i in range(len(L)):
 # for j in range(i + 1, len(L)):
 # x1, y1, dx1, dy1 = L[i]
 # x2, y2, dx2, dy2 = L[j]
 # if dx1 != dx2 or dy1 != dy2:
 # print(L[i])
 # print(L[j])
 # print('---')
 # res += 1

 print(""res: "", str(res))
 print(""res // 2: "", str(res // 2))
</ans>",0,{}
45," <ans>
import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
print(""n,m: "", str(n), "" "", str(m))
A=[list(map(int,input().split())) for i in range(n)]

for i in range(m):
 print(""i: "", str(i))
 ANSR=[0]*n
 ANSC=[0]*m

 for j in range(i):
 if A[0][j]==1:
 ANSC[j]=1
 print(""ANSC[j]: "", str(ANSC[j]))

 for j in range(i,m):
 if A[0][j]==0:
 ANSC[j]=1
 print(""ANSC[j]: "", str(ANSC[j]))

 for r in range(1,n):
 B=set()
 print(""r: "", str(r))
 for c in range(m):
 if ANSC[c]==0:
 B.add(A[r][c])
 print(""B: "", str(B))
 else:
 B.add(1-A[r][c])

 if len(B)>=2:
 break
 if max(B)==0:
 ANSR[r]=1
 print(""ANSR[r]: "", str(ANSR[r]))

 else:
 ANSR=[0]*n
 ANSC=[0]*m

 for j in range(m):
 if A[0][j]==1:
 ANSC[j]=1
 print(""ANSC[j]: "", str(ANSC[j]))

 flag=0
 for r in range(1,n):
 if flag==0:
 B=set()
 for c in range(m):
 if ANSC[c]==0:
 B.add(A[r][c])
 print(""B: "", str(B))
 else:
 B.add(1-A[r][c])

 if len(B)>=2:
 break
 if max(B)==0:
 ANSR[r]=1
 print(""ANSR[r]: "", str(ANSR[r]))
 continue

 elif min(B)==1:
 ANSR[r]=1
 continue

 else:
 OI=B.index(1)
 if min(B[OI:])==1:
 flag=1
 continue

 OO=B.index(0)
 if max(B[OO:])==0:
 flag=1
 ANSR[r]=1
 print(""ANSR[r]: "", str(ANSR[r]))
 continue

 else:
 print(""NO"")
 return

 ANSR=[0]*n
 ANSC=[0]*m

 for j in range(m):
 if A[0][j]==1:
 ANSC[j]=1
 print(""ANSC[j]: "", str(ANSC[j]))

 flag=0
 for r in range(1,n):
 if flag==0:
 B=set()
 for c in range(m):
 if ANSC[c]==0:
 B.add(A[r][c])
 print(""B: "", str(B))
 else:
 B.add(1-A[r][c])

 if len(B)>=2:
 break
 if max(B)==0:
 ANSR[r]=1
 print(""ANSR[r]: "", str(ANSR[r]))
 continue

 elif min(B)==1:
 ANSR[r]=1
 continue

 else:
 OI=B.index(1)
 if min(B[OI:])==1:
 flag=1
 continue

 OO=B.index(0)
 if max(B[OO:])==0:
 flag=1
 ANSR[r]=1
 print(""ANSR[r]: "", str(ANSR[r]))
 continue

 else:
 print(""NO"")
 return

 print(""NO"")
</ans>",0,{}
46," <ans>
""""""Cowboy Beblop at his computer, problem 717I from <https://codeforces.com/problemset/problem/717/I>""""""

# from fractions import Fraction

def convert_to_fractions(poly):
""""""convert polygon vertex to fractional type""""""
poly_frac = []
for x, y, z in poly:
vertex = (Fraction(x), Fraction(y), Fraction(z))
poly_frac.append(vertex)
return poly_frac

print(""poly: "", str(poly)) # Newly defined variable

def convert_to_float(poly):
""""""convert polygon vertex to float type""""""
poly_float = []
for x, y, z in poly:
vertex = (float(x), float(y), float(z))
poly_float.append(vertex)
return poly_float

print(""poly_float: "", str(poly_float)) # Newly defined variable

def cross_product(a, b):
""""""3-vector product""""""
return (a[1] * b[2] - a[2] * b[1],
a[2] * b[0] - a[0] * b[2],
a[0] * b[1] - a[1] * b[0])

print(""cross_product: "", str(cross_product)) # Newly defined variable

def dot_product(a, b):
""""""scalar product of 3-vectors""""""
return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]

print(""dot_product: "", str(dot_product)) # Newly defined function

def vect_diff(a, b):
""""""vector difference""""""
return a[0] - b[0], a[1] - b[1], a[2] - b[2]

print(""vect_diff: "", str(vect_diff)) # Newly defined function

def poly_normal(poly):
""""""return normal vector for first three vertex""""""
assert len(poly) >= 3
x, y, z = poly[:3]
u = vect_diff(y, x)
v = vect_diff(z, y)
normal = cross_product(u, v)
print(""normal: "", str(normal)) # Newly defined variable

def intersect_list(poly, plain_norm, plain_point, proj_dir):
""""""list of intersection points

find points where the edges enter or leave upper half-space over the plain
:return list of points projection on proj_dir
""""""
u = [dot_product(vert, proj_dir) for vert in poly]
plain_point_proj = dot_product(plain_point, plain_norm)
v = [dot_product(vert, plain_norm) for vert in poly]
print(""u: "", str(u)) # Newly defined variable
print(""v: "", str(v)) # Newly defined variable

def points_to_str(a_points, b_points):
""""""string representing the order of points 'a' and 'b'""""""
a_pairs = [('a', val) for val in a_points]
b_pairs = [('b', val) for val in b_points]
pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])
letters = [ch for ch, _ in pairs]
print(""letters: "", str(letters)) # Newly defined variable

def recognize_str(s):
""""""return True if string s belong to the grammar

The context-free grammar is given
S -> SS
S -> a S a
S -> b S b
S -> e
""""""
toggle = {'a':'b', 'b':'a'}
cross_num = 0
top = None
for ch in s:
if not cross_num:
cross_num = 1
top = ch
continue

if ch == top:
cross_num -= 1
else:
cross_num += 1

if cross_num:
top = toggle[top]
else:
top = None
return not cross_num

print(""recognize_str: "", str(recognize_str)) # Newly defined function

def is_well_connected(a, b):
""""""Two planar polygons are bind together in 3D

Arguments:
a_poly,
b_poly -- lists of vertex triples
""""""
a_poly_float = convert_to_float(a)
b_poly_float = convert_to_float(b)
a_norm = poly_normal(a_poly_float)
b_norm = poly_normal(b_poly_float)
common_dir = cross_product(a_norm, b_norm)
if not any(common_dir):
return False

a_list = intersect_list(a_poly_float, b_norm, b_poly_float[0], common_dir)
b_list = intersect_list(b_poly_float, a_norm, a_poly_float[0], common_dir)
char_str = points_to_str(a_list, b_list)
print(""char_str: "", str(char_str)) # Newly defined variable
return not recognize_str(char_str)

print(""is_well_connected: "", str(is_well_connected)) # Newly defined function

def run_from_console():
a_len, = [int(num) for num in input().split()]
a = []
for _ in range(a_len):
vertex = tuple(int(num) for num in input().split())
a.append(vertex)
print(""a: "", str(a)) # Newly defined variable

b_len, = [int(num) for num in input().split()]
b = []
for _ in range(b_len):
vertex = tuple(int(num) for num in input().split())
b.append(vertex)
print(""b: "", str(b)) # Newly defined variable

if is_well_connected(a, b):
print('YES')
else:
print('NO')
</ans>",0,{}
47," <ans>
for _ in range(ii()):
    n = ii()
    print(""n: "", n)
    a = li()
    print(""a: "", a)
    if n == 1 and a[0] & 1:
        print(""-1"")
    else:
        for i in range(n):
            if a[i] % 2 == 0:
                print(""i: "", i)
                print(""1"")
                break
        else:
            print(""2"")
            print(""1: "", 1)
            print(""2: "", 2)
</ans>",0,{}
48," <ans>
n, k = list(map(int, input().split()))
print(""n: "", str(n), ""k: "", str(k))
p = {}
np = {}
pair = []
used = {}
rev_d = {}

print(""p: {}, np: {}"".format(p, np))

def push(d, s, v):
if s not in d:
d[s] = []
d[s].append(v)

print(""After defining push function, p: {}, np: {}"".format(p, np))

for _ in range(n):
s, val = input().split()
val = int(val)

print(""s: "", str(s), ""val: "", str(val))

if is_pal(s):
push(p, s, val)
else:
push(np, s, val)

print(""After defining for loop, p: {}, np: {}"".format(p, np))

for s in np:
if s not in used and rev_d[s] in np:
pair.append([s, rev_d[s]])
used[s] = True
used[rev_d[s]] = True

print(""After defining for loop for pair, pair: "", str(pair))

max_remain = 0
minus = 0
max_S = 0

print(""Before for loop for v_arr in p, p: {}, np: {}"".format(p, np))

for v_arr in list(p.values()):
n = len(v_arr)
for i in range(0, n, 2):
if i+1==n:
if v_arr[i] > 0:
max_remain = max(max_remain, v_arr[i])

print(""After defining for loop for v_arr in p, p: {}, np: {}, max_remain: {}"".format(p, np, max_remain))

else:
if v_arr[i] + v_arr[i+1] >= 0:
max_S += v_arr[i] + v_arr[i+1]

if v_arr[i+1] < 0:
minus = min(minus, v_arr[i+1])

print(""After defining for loop for v_arr in p, p: {}, np: {}, max_S: {}, minus: {}"".format(p, np, max_S, minus))

for [u, v] in pair:
n = min(len(np[u]), len(np[v]))

for x, y in zip(np[u][:n], np[v][:n]):
if x+y > 0:
max_S += x+y

print(""After defining for loop for pair, pair: {}, max_S: {}"".format(pair, max_S))

print(max(max_S+max_remain, max_S-minus))
</ans>",0,{}
49," <ans>
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    print(""a, k: "", a, k)
    if a < k:
        return 0
    q = a//k
    r = (a-q*k)%(q+1)
    if r==0:
        return a//k
    v = (a-q*k)//(q+1) + 1
    print(""a, k, q, v: "", a, k, q, v)
    return grundy(a-(q+1)*v,k)
""""""
</ans>",0,{}
50," <ans>
a = input()
print(""a: "", str(a))
ans=[]
t=''
qoute =0
space =0
start =1 if a[0]=='""' else 0
print(""start: "", str(start))
for i in range(len(a)):
    v= a[i]
    print(""i: "", i, ""v: "", v)
    if start:
        if t=='':
            if v=='""':
                qoute+=1
                t = '<'
            elif v==' ':
                pass
            else:
                space+=1
                t='<'+v
        elif qoute>0:
            if v =='""':
                t+='>'
                qoute=0
                print(""ans: "", str(ans))
                ans.append(t)
                t=''
                start=0
            else:
                t+=v
        else:
            if v ==' ':
                if t!='<':
                    t+='>'
                    ans.append(t)
                    t=''
                    start=0
            else:
                t+=v
    else:
        if v==' ':
            start=1
        elif v=='""':
            start=1
            t='<'
            qoute=1
        else:
            t='<'+v
            start=1
print(""t: "", t)
if t!='':
    t+='>'
    ans.append(t)
print(""ans: "", str(ans))
for v in ans:
    print(v)
</ans>",0,{}
51," <ans>
def main1():
 bufs = [] # an empty list is created
 bufs.append(input()) # input is assigned to the first element of the list
 buflist = [] # an empty list is created
 buflist = bufs[0].split() # bufs[0] is assigned to buflist
 n = int(buflist[0]) # an integer is assigned to n
 M = int(buflist[1]) # an integer is assigned to M
 bufs.append(input()) # input is assigned to the second element of the list
 buflist = bufs[1].split() # bufs[1] is assigned to buflist
 t = list(map(int, buflist)) # a list of integers is assigned to t
 student = [] # an empty list is created
 minimum = [] # an empty list is created
 for i in range(n): # a for loop starts
 count = 0 # an integer is assigned to count
 pointer = 0 # an integer is assigned to pointer
 print(""i: "", i)
 while pointer < i:
 if count + student[pointer] <= M - t[i]:
 count += student[pointer]
 pointer += 1
 else:
 break
 print(""pointer: "", pointer)
 minimum.append(i - pointer) # an integer is assigned to the i-th element of minimum
 student.append(t[i]) # an integer is assigned to the i-th element of student
 student.sort() # the list student is sorted
 print(""student: "", student)
 print(""minimum: "", minimum)

def main2():
 bufs = [] # an empty list is created
 bufs.append(input()) # input is assigned to the first element of the list
 buflist = [] # an empty list is created
 buflist = bufs[0].split() # bufs[0] is assigned to buflist
 n = int(buflist[0]) # an integer is assigned to n
 M = int(buflist[1]) # an integer is assigned to M
 bufs.append(input()) # input is assigned to the second element of the list
 buflist = bufs[1].split() # bufs[1] is assigned to buflist
 t = list(map(int, buflist)) # a list of integers is assigned to t
 bucket = [] # an empty list is created
 for i in range(101): # a for loop starts
 bucket.append(0) # an integer is assigned to the i-th element of bucket
 minimum = [] # an empty list is created
 for i in range(n): # a for loop starts
 target = M - t[i] # an integer is assigned to target
 count = 0 # an integer is assigned to count
 subtotal = 0 # an integer is assigned to subtotal
 for j in range(1, 101): # an inner for loop starts
 if subtotal + bucket[j] * j > target:
 count += (target - subtotal) // j # an integer is assigned to count
 break
 else:
 count += bucket[j] # an integer is assigned to count
 subtotal += bucket[j] * j # an integer is assigned to subtotal
 minimum.append(i - count) # an integer is assigned to the i-th element of minimum
 bucket[t[i]] += 1 # an integer is assigned to the t[i]-th element of bucket
 print(""i: "", i)
 print(""target: "", target)
 print(""count: "", count)
 print(""bucket: "", bucket)
 print(""minimum: "", minimum)

def __starting_point():
 #main1() # for C1
 main2() # for C2

print(""Starting point reached"")
__starting_point()
</ans>",0,{}
52," <ans>
import itertools
from collections import deque,defaultdict,Counter
from itertools import accumulate
import bisect
from heapq import heappop,heappush,heapify
import math
from copy import deepcopy
import queue
#import numpy as np
# sympy as syp(素因数分解とか)
Mod = 1000000007
fact = [1, 1]
factinv = [1, 1]
inv = [0, 1] 
for i in range(2, 10**5 + 1):
    fact.append((fact[-1] * i) % Mod)
    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)
    factinv.append((factinv[-1] * inv[-1]) % Mod)

print(""Mod: "", Mod)
print(""fact: "", fact)
print(""factinv: "", factinv)
print(""inv: "", inv)

def cmb(n, r, p):
    if (r < 0) or (n < r):
        return 0
    r = min(r, n - r)
    return fact[n] * factinv[r] * factinv[n - r] % p

print(""n: "", n)
print(""a: "", a)

d = defaultdict(int)
ans = 0

print(""d: "", d)

for i in range(n):
    l = i - a[i]
    ans += d[l]
    d[a[i] + i] += 1
    
print(""ans: "", ans)
</ans>",0,{}
53," <ans>
#template
import sys
sys.setrecursionlimit(10**9)

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

read_int = lambda: int(readline())
read_ints = lambda: map(int,readline().split())
read_ints_list = lambda: list(map(int,readline().split()))
read_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))
read_strs_list = lambda: list(map(str,readline().rstrip().split()))
read_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))

def read_allints_grid(w):
grid = map(int,read().split())
grid = list(map(list,zip(*(grid for _ in range(w)))))
return grid

def read_allstrs_grid(w):
grid = map(str,read().split())
grid = list(map(list,zip(*(grid for _ in range(w)))))
return grid

#import
# from copy import deepcopy
# from decimal import Decimal
# from math import ceil,floor
# from collections import deque,Counter
# from heapq import heapify,heappop,heappush
# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement
# from bisect import bisect_left,bisect_right

#solution
def sol():
n = read_int()
A = read_ints_list()
gcd_A = GCD_multi(A)
print(""n: "", str(n))
print(""gcd_A: "", str(gcd_A))
def GCD(a:int,b:int)->int:
'''
ユークリッドの互除法による最大公約数/O(log min(a,b))
'''
if b==0:
return a
else:
return GCD(b,a%b)

def GCD_multi(vec:list)->int:
'''
数列の要素の最大公約数を求める/O(N log(a'))
'''
l = vec[0]
for i in range(len(vec)-1):
l = GCD(l,vec[i+1])
return l
return None

def main():
#input data
n = read_int()
A = read_ints_list()

#solve
gcd_A = GCD_multi(A)
print(""gcd_A: "", str(gcd_A))

def __starting_point():
main()
__starting_point()
</ans>",0,{}
54," <ans>
__author__ = ""Ryabchchun Vladimir""

class Stack:
# ... (previous code)
```python
def __init__(self, element=None):
    self.length = 0
    if element is None:
        self.__stack = []
    else:
        self.__stack = []
        for el in element:
            self.__stack.append(el)
            self.length += 1
            print(""After initializing self.__stack with:"", el)

n = int(input())
snekovik = Stack()
wrong_snaks = set()
the_biggest_snek = n
sneks = list(map(int, input().split()))
for i in sneks:
    printing = []
    if i == the_biggest_snek:
        snekovik.push(i)
        printing.append(i)
        the_biggest_snek -= 1
        while the_biggest_snek in wrong_snaks:
            snekovik.push(the_biggest_snek)
            wrong_snaks.remove(the_biggest_snek)
            printing.append(the_biggest_snek)
            the_biggest_snek -= 1
        print(""After pushing i:"", i)
        print(""After updating the_biggest_snek:"", the_biggest_snek)
    else:
        wrong_snaks.add(i)
        print(""After adding i to wrong_snaks:"", i)
    print(""After the for loop iteration:"", i)
    print(""printing:"", printing)
</ans>",0,{}
55," <ans>
H, W = map(int, input().split())
print(""H: "", str(H), ""W: "", str(W))
List = [list(input()) for i in range(H)]
print(""List: "", str(List))
res = ""Yes""
flag = True

def checkAround(ListX, i, j):
# (skipping the code for brevity)

for k in range(H):
 for l in range(W):
 if List[k][l] == ""."":
 pass
 else:
 flag = checkAround(List, k, l)
 if not flag:
 res = ""No""
 break
 if not flag:
 break
 print(""i: "", str(i), ""j: "", str(j), ""flag: "", str(flag), ""res: "", str(res))
</ans>",0,{}
56," <ans>
import sys
from collections import defaultdict

class MaxFlow(object):
# ... (the rest of the code remains the same)

def __init__(self):
print(""self: "", self)
self.edges = defaultdict(lambda: defaultdict(lambda: 0))

def add_edge(self, u, v, capacity=float('inf')):
print(""u: "", u, ""v: "", v, ""capacity: "", capacity)
self.edges[u][v] = capacity

def bfs(self, s, t):
# ... (the rest of the code remains the same)

def solve(self, s, t):
flow = 0
print(""s: "", s, ""t: "", t)
route = self.bfs(s, t)
# ... (the rest of the code remains the same)

def __str__(self):
# ... (the rest of the code remains the same)

def main():
# ... (the rest of the code remains the same)

print(""n: "", n)
print(""m: "", m)
print(""r: "", r)
xset = set()
yset = set()
print(""xs: "", xs)
print(""ys: "", ys)
# ... (the rest of the code remains the same)

print(""xx: "", xx)
print(""yy: "", yy)
print(""f: "", f)
print(""Result: "", f.solve(0, len(xx) + len(yy) + 1))
</ans>",0,{}
57," <ans>
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            print(""stack: "", str(stack))
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            print(""result: "", str(to))
            return to
    return wrappedfunc

N, K = getInts()
graph = defaultdict(set)
for i in range(N-1):
    A, B = getInts()
    graph[A].add(B)
    graph[B].add(A)
dp_count = [[0 for j in range(5)] for i in range(N+1)]
dp_total = [0 for j in range(N+1)]
ans = 0
@bootstrap
def dfs(node,parent,depth):
    dp_count[node][depth % K] = 1
    dp_total[node] = 1
    for neigh in graph[node]:
        if neigh != parent:
            yield from dfs(neigh,node,depth+1)
            for i in range(K):
                for j in range(K):
                    diff = (i+j-2*depth)%K
                    req = (-diff)%K
                    ans += req * dp_count[node][i] * dp_count[neigh][j]
            for i in range(K):
                dp_count[node][i] += dp_count[neigh][i]
            dp_total[node] += dp_total[neigh]
    ans += dp_total[node] * (N - dp_total[node])
    yield
dfs(1,-1,0)
print(""ans: "", str(ans))
print(""ans//K: "", str(ans//K))
</ans>",0,{}
58," <ans>
import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy

class UnionFind:

```python
def __init__(self, n: int):
    self._n = n
    self._parents = [i for i in range(n)]
    self._size = [1 for _ in range(n)]

def unite(self, x: int, y: int) -> None:
    px = self.find(x)
    py = self.find(y)

    # 一致していないときはリンクをつける
    if px != py:
        self._link(px, py)

def _link(self, x: int, y: int):
    if self._size[x] < self._size[y]:
        self._parents[x] = y
        self._size[y] += self._size[x]
    else:
        self._parents[y] = x
        self._size[x] += self._size[y]

def same(self, x: int, y: int) -> bool:
    px = self.find(x)
    py = self.find(y)
    return px == py

def find(self, x: int) -> int:
    if self._parents[x] == x:
        return x

    self._parents[x] = self.find(self._parents[x])
    return self._parents[x]

def size(self, x: int):
    return self._size[self.find(self._parents[x])]

N, K, L = map(int, input().split())

print(""N: "", N)
print(""K: "", K)
print(""L: "", L)

road = UnionFind(N + 1)
print(""road: "", road)
rail = UnionFind(N + 1)
print(""rail: "", rail)
share = UnionFind(N + 1)

roads = [list(map(int, input().split())) for _ in range(K)]
print(""roads: "", roads)
rails = [list(map(int, input().split())) for _ in range(L)]
print(""rails: "", rails)

for i in range(K):
    p, q = roads[i]
    road.unite(p, q)
    print(""p: "", p, ""q: "", q)

for i in range(L):
    r, s = rails[i]
    rail.unite(r, s)
    print(""r: "", r, ""s: "", s)

m = {}

for i in range(1, N + 1):
    print(""i: "", i)
    cnt = m.get((road.find(i), rail.find(i)), 0)
    m[(road.find(i), rail.find(i))] = cnt + 1

ans = [0] * N
for i in range(N):
    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]
    print(""ans[i]: "", ans[i])

print(*ans)
</ans>",0,{}
59," <ans>
import sys

MOD = (int)(1e9+7)

def add(a, b):
	a += b
	if a >= MOD: a -= MOD
	return a
	
def mul(a, b):
	return (a * b) % MOD

class fenwickTree:
	def __init__(self, max_val):
		self.max_val = max_val + 5
		self.tree = [0] * self.max_val
	
	def update(self, idx, value):
		idx += 1
		while idx < self.max_val:
			self.tree[idx] = add(self.tree[idx], value)
			idx += (idx & (-idx))
		
	def read(self, idx):
		idx += 1
		res = 0
		while idx > 0:
			res = add(res, self.tree[idx])
			idx -= (idx & (-idx))
		return res

inp = [int(x) for x in sys.stdin.read().split()]

n = inp[0]
print(""n: "", n)
a = []
print(""a: "", a)
for i in range(1, n + 1):
	a.append(inp[i])
	print(""a[{}]: "".format(i), a[i])
	
sorted_array = sorted(a)
print(""sorted_array: "", sorted_array)
dict = {}
for i in range(n):
	dict[sorted_array[i]] = i
	
factor = [0] * n
print(""factor: "", factor)
for i in range(0, n):
	factor[i] = mul(i + 1, n - i)
	print(""factor[{}]: "".format(i), factor[i])
	
left_tree = fenwickTree(n)
print(""left_tree: "", left_tree)
for i in range(0, n):
	element_idx = dict[a[i]]
	print(""element_idx: "", element_idx)
	factor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))
	left_tree.update(element_idx, i + 1)
	print(""left_tree.update: "", left_tree.tree)
	
right_tree = fenwickTree(n)
print(""right_tree: "", right_tree)
for i in range(n - 1, -1, -1):
	element_idx = dict[a[i]]
	print(""element_idx: "", element_idx)
	factor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))
	right_tree.update(element_idx, n - i)
	print(""right_tree.update: "", right_tree.tree)

ans = 0
print(""ans: "", ans)
for i in range(n):
	ans = add(ans, mul(a[i], factor[i]))
print(""ans: "", ans)
</ans>",0,{}
60," <ans>
import sys 
input = lambda: sys.stdin.readline().strip()

def f(A, r, c, l):
 # New variables definition
 q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
 x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]

 print(""q: "", str(q), ""w: "", str(w), ""e: "", str(e))
 print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
 print(""l: "", str(l))

 if x != y and y != z and e >= l and w == q == l:
 return (l, z, y, x)
 else:
 return 0

 # No new variables definition here

r, c = list(map(int, input().split()))
s = """"
for i in range(r):
 s += input()

arr = []
narr = [[0]*r for i in range(c)]
for i in range(c):
 arr.append(s[i:r*c:c])

r, c = c, r

length_str = [ [0] * c for i in range(r) ]
for i in range(r):
 for j in range(c):
 if j == 0:
 length_str[i][j] = (1, arr[i][j])
 elif arr[i][j-1] == arr[i][j]:
 length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])
 else:
 length_str[i][j] = (1, arr[i][j])

 for i in range(r):
 for j in range(c):
 l, _ = length_str[i][j]
 if j - l*3 + 1 < 0:
 continue
 else:
 narr[i][j] = f(length_str, i, j, l)

 dp =[ [0] * c for i in range(r) ]

 for j in range(c):
 cnt = 1
 for i in range(r):
 if narr[i][j] == 0:
 cnt = 1
 continue
 elif narr[i][j] == narr[i-1][j]:
 cnt += 1
 dp[i][j] = cnt
 dp[i-1][j] = 0
 else:
 cnt = 1
 dp[i][j] = 1

 ans = 0
 for i in dp:
 for j in i:
 ans += ((j)*(j+1))//2

 print(""ans: "", str(ans))
</ans>",0,{}
61," <ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)

class TreapNode:
 _value = None
 _priority = None
 _count = None
 _left = None
 _right = None

 def __init__(self, value):
 self._value = value
 self._priority = random()
 self._count = 1

def treap_rotate_right(n):
 l = n._left
 n._left = l._right
 l._right = n
 return l

def treap_rotate_left(n):
 r = n._right
 n._right = r._left
 r._left = n
 return r

def treap_insert(n, v):
 if n is None:
 return TreapNode(v)
 if n._value == v:
 n._count += 1
 return n
 if n._value > v:
 n._left = treap_insert(n._left, v)
 if n._priority > n._left._priority:
 n = treap_rotate_right(n)
 return n
 if n._value < v:
 n._right = treap_insert(n._right, v)
 if n._priority > n._right._priority:
 n = treap_rotate_left(n)
 return n
 return n

def treap_delete(n, v):
 if n is None:
 raise Exception('no nodes')
 if n._value > v:
 n._left = treap_delete(n._left, v)
 return n
 if n._value < v:
 n._right = treap_delete(n._right, v)
 return n

 # n._value == v
 if n._count > 1:
 n._count -= 1
 return n

 if n._left is None and n._right is None:
 return None

 if n._left is None:
 n = treap_rotate_left(n)
 return treap_delete(n, v)

 if n._right is None:
 n = treap_rotate_right(n)
 return treap_delete(n, v)

 # n._left is not None and n._right is not None
 if n._left._priority < n._right._priority:
 n = treap_rotate_right(n)
 return treap_delete(n, v)

 else:
 n = treap_rotate_left(n)
 return treap_delete(n, v)

def treap_size(n):
 if n is None:
 return 0
 return n._count + treap_size(n._left) + treap_size(n._right)

def treap_str(n):
 if n is None:
 return """"
 result = []
 if n._left is not None:
 result.append(treap_str(n._left))
 result.append(""%d:%d"" % (n._value, n._count))
 if n._right is not None:
 result.append(treap_str(n._right))
 return ' '.join(result)

def treap_search(n, v):
 # v 未満で最大のノードを検索する. v 未満のノードがなければ None を返す
 if n is None:
 return None
 if n._value >= v:
 if n._left is None:
 return None
 return treap_search(n._left, v)
 # n._value < v
 if n._right is None:
 return n
 r = treap_search(n._right, v)
 if r is None:
 return n
 return r

class Treap:
 _root = None
 _size = 0

 def insert(self, v):
 self._root = treap_insert(self._root, v)
 self._size += 1
 print(""self._root: "", str(self._root))

 def delete(self, v):
 self._root = treap_delete(self._root, v)
 self._size -= 1
 print(""self._root: "", str(self._root))

 def __len__(self):
 return self._size

 def __str__(self):
 return treap_str(self._root)

 def search(self, v):
 return treap_search(self._root, v)

N = int(input())
A = [int(input()) for _ in range(N)]

t = Treap()
for a in A:
 n = t.search(a)
 if n is not None:
 t.delete(n._value)
 print(""n: "", str(n))
 t.insert(a)
 print(""self._root: "", str(t._root))
 print(""len(t): "", len(t))
</ans>",0,{}
62," <ans>
def _3():
    from collections import defaultdict

    print(""defaultdict: "", str(defaultdict))

    def can_pair(s1, s2):
        print(""s1: "", str(s1), ""s2: "", str(s2))
        l = []
        for c1, c2 in zip(s1, s2):
            c = sorted([c1, c2])
            print(""c: "", str(c))
            if c in l:
                l.remove(c)
            else:
                l.append(c)

        print(""l: "", str(l))
        if len(s1) % 2 == 0:
            return len(l) == 0
        else:
            return len(l) == 1 and l[0][0] == l[0][1]

    print(""can_pair: "", str(can_pair))

    def pair_graph(s1, s2):
        print(""np: "", str(np))
        N = len(s1)
        G = np.zeros([N, N])
        print(""G: "", str(G.shape))
        for i in range(N):
            for j in range(i+1, N):
                if s1[i] == s2[j] and s1[j] == s2[i]:
                    G[i, j] = 1
                    G[j, i] = 1
        print(""G: "", str(G))
        return G

    import numpy as np
    H, W = list(map(int, input().split(' ')))
    print(""H, W: "", str(H), str(W))
    S = []
    print(""S: "", str(S))
    d = defaultdict(list)

    for h in range(H):
        s = input()
        print(""s: "", str(s))
        S.append(s)
        d[''.join(sorted(S))].append(h)

    print(""already_paired: "", str(np.zeros(H)))

    Gs = []

    for i in range(H):
        if already_paired[i]:
            continue

        for j in range(i+1, H):
            if already_paired[j]:
                continue

            if can_pair(S[i], S[j]):
                already_paired[i] = 1
                already_paired[j] = 1
                G = pair_graph(S[i], S[j])
                Gs.append(G)
                print(""Gs: "", str(Gs))
                break

    if already_paired.sum() < H - 1:
        print('NO')
        return

    elif already_paired.sum() == H - 1:
        for i in range(H):
            if already_paired[i] == 0:
                G = pair_graph(S[i], S[i])
                Gs.append(G)
                print(""Gs: "", str(Gs))
                break

    G = np.array(Gs).sum(axis=0) // len(Gs)

    print(""is_perfect_matching: "", str(is_perfect_matching))

    if is_perfect_matching(G):
        print('YES')
    else:
        print('NO')

def __starting_point():
    _3()
__starting_point()
</ans>",0,{}
63," <ans>
import sys
readline = sys.stdin.readline

def accumulate2d(X):
# ... (no new variables defined here)

N, M, Q = map(int, readline().split())
print(""N: "", N, ""M: "", M, ""Q: "", Q)
table = [None]*100
print(""table: "", str(table))
table[ord('R')] = 0
table[ord('G')] = 1
table[ord('B')] = 2
table[ord('Y')] = 3

INF = 10**3
print(""INF: "", INF)
D = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]
print(""D: "", str(D))
G = [[0]*M for _ in range(N)]
print(""G: "", str(G))

BS = 25
candi = []
geta = M
for i in range(N-1):
for j in range(M-1):
if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:
G[i][j] = 1
nh, nw = i, j
while True:
k = G[nh][nw]
fh, fw = i-k, j-k
k2 = 2*(k+1)
kh = k+1
if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:
break
if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\
any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\
any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)):
break
G[nh][nw] += 1
if G[nh][nw] > BS:
candi.append((nh, nw))
Gnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]
print(""Gnum: "", str(Gnum))
for h in range(N):
for w in range(M):
if G[h][w] > 0:
for k in range(1, min(BS, G[h][w])+1):
Gnum[k][h][w] = 1
Gnum = [None] + [accumulate2d(g) for g in Gnum[1:]]

Ans = [None]*Q
print(""Ans: "", str(Ans))
for qu in range(Q):
h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())
res = 0
for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):
hs, ws = h1+k-1, w1+k-1
he, we = h2-k, w2-k
if hs <= he and ws <= we:
cnt = Gnum[k][he][we]
if hs:
cnt -= Gnum[k][hs-1][we]
if ws:
cnt -= Gnum[k][he][ws-1]
if hs and ws:
cnt += Gnum[k][hs-1][ws-1]
if cnt:
res = k
break
for nh, nw in candi:
if h1 <= nh <= h2 and w1 <= nw <= w2:
res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))
Ans[qu] = 4*res**2
print(""Ans[qu]: "", Ans[qu])
print('\n'.join(map(str, Ans)))
</ans>",0,{}
64," <ans>
def __starting_point():
    n, m = list(map(int, input().split()))
    print(""n: "", n, ""m: "", m)
    w = {}
    g = [[] for _ in range(n)]
    w_tmp = {}
    c_m = 0
    kk = [0]
    lines = sys.stdin.readlines()
    print(""lines: "", str(lines))
    for i, line in enumerate(lines): #range(1, m + 1):
        u, v, c = list(map(int, line.split()))
        g[u - 1].append(v - 1)
        if (u - 1, v - 1) in list(w.keys()):
            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)
            print(""w[(u-1, v-1)]: "", w[(u - 1, v - 1)])
        else:
            w[(u - 1, v - 1)] = c
            print(""w[(u-1, v-1)]: "", w[(u - 1, v - 1)])
            w_tmp[(u - 1, v - 1)] = [str(i + 1)]
            print(""w_tmp[(u-1, v-1)]: "", w_tmp[(u - 1, v - 1)])
        kk.append(c)
        print(""kk.append(c): "", c)
        # c_m = max(c, c_m)

    kk.sort()
    print(""kk: "", kk)
    l, r = 0, len(kk)
    if not find_loop(g, w, kk[l], n):
        print(""find_loop(g, w, kk[l], n): False"")
        return
    if find_loop(g, w, kk[-1], n):
        kkk = kk[-1]
        print(""kkk: "", kkk)
    else:
        while l + 1 != r:
            m = int((l + r) / 2)
            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):
            if find_loop(g, w, kk[m], n):
                print(""find_loop(g, w, kk[m], n): True"")
                l = m
            else:
                print(""find_loop(g, w, kk[m], n): False"")
                r = m
        kkk = kk[l+1]
        print(""kkk: "", kkk)

    to_reverse = top_sort(g, w, kkk, n)
    num = 0
    s = []
    for t in to_reverse:
        num += len(w_tmp[t])
        s.extend(w_tmp[t])

    print(""to_reverse: "", to_reverse)
    print(""num: "", num)
    print(""s: "", s)
    print(kkk, num)
    print("" "".join(s))
</ans>",0,{}
65," <ans>
a = list(map(int,input().split()))
print(""a: "", str(a))
b = [0,0,0,0,0]
print(""b: "", str(b))
c = [0,0,0,0,0]
print(""c: "", str(c))
ipt = []
print(""ipt: "", str(ipt))
ans = []
print(""ans: "", str(ans))
d = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}
print(""d: "", str(d))

n = int(input())
print(""n: "", str(n))

for i in range(1,n+1) :
 ipt.append(j)
 print(""ipt[{}]: "".format(i), str(j))
 ans.append(j)
 if j.find(',') == -1 :
 a[d[j]] -= 1
 print(""a[{}]: "".format(d[j]), str(a[d[j]]))
 else :
 b[d[j[0:j.find(',')]]] += 1
 print(""b[{}]: "".format(d[j[0:j.find(',')]]), str(b[d[j[0:j.find(',')]]]))

ans = False;

for i in range(0,6) :
 if (a[i] < 0) and ans == False:
 ans = True
 print(""ans: "", str(ans))
 if i < 5:
 if i==0 :
 if b[i] > a[i] :
 c[i] = b[i] - a[i];
 print(""c[{}]: "".format(i), str(c[i]))
 b[i] -= a[i];
 print(""b[{}]: "".format(i), str(b[i]))
 a[i] = 0;
 else :
 if b[i-1] > 0 :
 if b[i-1] > a[i] :
 print(""ans: "", str(ans))
 ans = True
 else :
 a[i] -= b[i-1];
 print(""a[{}]: "".format(i), str(a[i]))
 if b[i] > a[i] :
 c[i] = b[i] - a[i];
 print(""c[{}]: "".format(i), str(c[i]))
 b[i] -= a[i];
 print(""b[{}]: "".format(i), str(b[i]))
 a[i] = 0;
 else :
 c[i] = 0;
 print(""c[{}]: "".format(i), str(c[i]))
 a[i] -= b[i];
 print(""a[{}]: "".format(i), str(a[i]))
 b[i] = 0;
 else :
 if a[i] < b[i-1]:
 ans = True
 print(""ans: "", str(ans))

if ans == True :
 print(""NO"")
 else :
 print(""YES"")
 for i in ipt :
 if i.find(',') == -1 :
 print(i)
 else :
 tmp = i[0:i.find(',')];
 if (c[d[tmp]] > 0) :
 print(i[i.find(',')+1:])
 print(""c[{}]: "".format(d[tmp]), str(c[d[tmp]]))
 c[d[tmp]] -= 1
 else :
 print(tmp)
</ans>",0,{}
66," <ans>
n, m = list(map(int, input().split()))
print(""n, m: "", str(n), "" "", str(m))
A = list(map(int, input().split()))
print(""A: "", str(A))
if n > 300:
lst = []
print(""lst: []"")
for i in range(m):
a, b = list(map(int, input().split()))
print(""a, b: "", str(a), "" "", str(b))
lst.append([a, b])
answer = 0
answer_1 = []
m300 = [[-1, -10**6]]
print(""m300: [[-1, -10**6]]"")
for i in range(max(0, m-1)):
m300.append([-1, -10**6])
print(""m300: "", str(m300))
for u in range(n):
if A[u] > min(m300)[1]:
m300[m300.index(min(m300))] = [u, A[u]]
print(""u, A[u]: "", str(u), "" "", str(A[u]))
for i, mi in m300:
B = A.copy()
print(""B: A.copy()"")
kek = []
print(""kek: []"")
for j in range(m):
a, b = lst[j][0], lst[j][1]
if a <= i + 1 <= b:
kek.append(j + 1)
print(""j, a, b: "", str(j), "" "", str(a), "" "", str(b))
for q in range(a - 1, b):
B[q] -= 1
print(""B[q]: "", str(B[q]))
elem = max(B)
print(""elem: "", str(elem))
if answer < elem - mi:
answer = elem - mi
answer_1 = kek.copy()
print(""answer: "", str(answer))
print(""answer_1: "", str(answer_1))
print(answer)
print(len(answer_1))
print(' '.join(map(str, answer_1)))
else:
lst = []
print(""lst: []"")
for i in range(m):
a, b = list(map(int, input().split()))
print(""a, b: "", str(a), "" "", str(b))
lst.append([a, b])
answer = 0
answer_1 = []
for i in range(n):
B = A.copy()
print(""B: A.copy()"")
kek = []
print(""kek: []"")
for j in range(m):
a, b = lst[j][0], lst[j][1]
if a <= i + 1 <= b:
kek.append(j + 1)
print(""j, a, b: "", str(j), "" "", str(a), "" "", str(b))
for q in range(a - 1, b):
B[q] -= 1
print(""B[q]: "", str(B[q]))
elem = max(B)
print(""elem: "", str(elem))
if answer < elem - B[i]:
answer = elem - B[i]
answer_1 = kek.copy()
print(""answer: "", str(answer))
print(""answer_1: "", str(answer_1))
print(answer)
print(len(answer_1))
print(' '.join(map(str, answer_1)))
</ans>",0,{}
67," <ans>
import math
import sys

class Graph:
 ...
 def __init__(self, Nodes, is_directed=False):
 print(""Nodes: "", str(Nodes))
 self.nodes = Nodes
 self.adj_list = {}
 self.is_directed = is_directed

 for node in self.nodes:
 self.adj_list[node] = []
 print(""self.adj\_list: "", str(self.adj_list))

 ...

 def add_edge(self, u, v):
 self.adj_list[u].append(v)
 print(""self.adj\_list[{}]: {}"".format(u, self.adj\_list[u]))
 if self.is_directed == False:
 self.adj_list[v].append(u)
 print(""self.adj\_list[{}]: {}"".format(v, self.adj\_list[v]))

 ...

 def print\_graph(self):
 for node in self.nodes:
 print(""({}, {})"".format(node, self.adj\_list[node]))

 ...

 def degree\_node(self, node):
 return len(self.adj\_list[node])

 ...

 def dfsUTIL(self, v, visited, parents=[]):
 print(""v: "", v)
 visited[v] = True
 for i in self.adj\_list[v]:
 if visited[i] == False:
 self.dfsUTIL(i, visited, parents)
 parents.append(i)

 ...

 def dfs(self, v):
 visited = [False] * (max(self.adj\_list) + 1)
 parents = [v]
 self.dfsUTIL(v, visited, parents)
 return len(parents)

 ...

def dict\_sort(ans):
 ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))

 ...

def is\_prime(n):
 if n == 1:
 return 0
 for i in range(2, int(math.sqrt(n)) + 1):
 if n % i == 0:
 return False
 return True

 ...

def swap(a, b):
 temp = a
 a = b
 b = temp
 return a, b

 ...

def seive\_primes(n):
 flag = [0] * (n + 10)
 flag[1] = flag[0] = 1
 i = 2
 while i * i <= n + 1:
 if flag[i] == 0:
 j = i * i
 while j <= n + 1:
 flag[j] = 1
 j += i
 i += 1
 return flag

 ...

def gcd(a, b):
 if b == 0:
 return a
 return gcd(b, a % b)

 ...

def lcm(a, b):
 return (a * b) // gcd(a, b)

 ...

def alphabates():
 return ""abcdefghijklmnopqrstuvwxyz""

 ...

def binary\_search(ls, n, flag):
 low = 0
 hi = n - 1
 while (low <= hi):
 mid = (low + hi) // 2
 if ls[mid] == flag:
 return mid
 elif ls[mid] > flag:
 hi = mid - 1
 else:
 low = mid + 1
 return -1

 ...

def qdrt(a, b, c):
 chk = b * b - 4 * a * c
 if chk >= 0:
 ans1 = (-b + chk ** 0.5) / (2 * a)
 ans2 = (-b - chk ** 0.5) / (2 * a)
 return [int(ans1), int(ans2)]
 return -1

 ...

def inp():
 ls = list(map(int, input().split()))
 return ls

 ...

def mult\_inp():
 return list(map(int, input().split()))

 ...

n = int(input())
 print(""n: "", n)
 d = {}
 while (n % 2 == 0):
 if 2 in d:
 d[2] += 1
 else:
 d[2] = 1
 n /= 2
 for i in range(3, int(n ** 0.5) + 1, 2):
 while (n % i == 0):
 if i in d:
 d[i] += 1
 else:
 d[i] = 1
 n = int(n)
 if n > 1:
 d[n] = 1
 n = 1
 print(""d: "", d)
 ans = 0
 for i in d:
 c = -2 * d[i]
 a = b = 1
 ls = qdrt(a, b, c)
 if ls[0] >= 0:
 ans += ls[0]
 elif ls[1] >= 0:
 ans += ls[1]
 print(""ans: "", ans)
</ans>",0,{}
68," <ans>
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
# mod = 9982443453
# mod = 998244353
INF = float('inf')
dx = [0,1,0,-1]
dy = [1,0,-1,0]
from sys import stdin

print(""N: "", N)
print(""S: "", S)
ans = 0
for i in range(N):
 print(""i: "", i)
 a = 0
 t = 0
 c = 0
 g = 0
 for j in range(i, N):
 print(""j: "", j)
 if S[j] == 'A':
 a += 1
 elif S[j] == 'T':
 t += 1
 elif S[j] == 'C':
 c += 1
 else:
 g += 1
 if a == t and c == g:
 ans += 1
 print(""ans: "", ans)
 print()
</ans>",0,{}
69," <ans>
from collections import deque
import math

def dfs(edges, s):
 print(""edges: "", str(edges))
 stack = deque([s])
 used = {s}
 while stack:
 x = stack.pop()
 print(""x: "", str(x))
 for y in edges[x]:
 if y not in used:
 print(""y: "", str(y))
 used.add(y)
 stack.append(y)
 return used

def bfs(edges, s):
 print(""edges: "", str(edges))
 queue = deque([s])
 used = {s}
 while queue:
 x = queue.popleft()
 print(""x: "", str(x))
 for y in edges[x]:
 if y in used:
 continue
 used.add(y)
 print(""y: "", str(y))
 queue.append(y)
 return used

def bellman(dist): #負辺があるケースでの、スタートからゴールへの最短路を求めるアルゴ。
 print(""dist: "", str(dist))
 cost = [float(""inf"")] * n
 cost[0] = 0
 for _ in range(n): #頂点の個数の分だけ回る
 print(""cost before update: "", str(cost))
 for u,v,c in dist: #辺の個数の分だけ回る
 if cost[u] + c < cost[v]:
 cost[v] = cost[u] + c
 print(""cost after update: "", str(cost))
 if cost[v] < 0:
 return -1
 return max(0, cost[n-1]*-1)

n,m,p = map(int, input().split())
 print(""n: "", str(n))
 print(""m: "", str(m))
 print(""p: "", str(p))
 dist = []
 edge1 = [[] for _ in range(n)]
 edge2 = [[] for _ in range(n)] # rev_edge
 print(""dist: "", str(dist))
 for _ in range(m):
 u,v,c = map(int, input().split())
 u -= 1
 v -= 1
 dist.append((u,v,(c-p)*-1))
 print(""dist after appending: "", str(dist))
 edge1[u].append(v)
 edge2[v].append(u)
 print(""edge1: "", str(edge1))
 print(""edge2: "", str(edge2))
 use = dfs(edge1, 0) & dfs(edge2, n-1)
 dist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]
 print(""dist2: "", str(dist2))
 print(bellman(dist2))
</ans>",0,{}
70," <ans>
import math
import sys
##### graph implementation with adjacency list#####
class Graph:
 def __init__(self, Nodes, is_directed=False):
 print(""Nodes: "", str(Nodes))
 self.nodes = Nodes
 self.adj_list = {}
 self.is_directed = is_directed

 for node in self.nodes:
 print(""node: "", str(node))
 self.adj_list[node] = []

 def add_edge(self, u, v):
 print(""u: "", str(u), ""v: "", str(v))
 self.adj_list[u].append(v)
 if self.is_directed == False:
 self.adj_list[v].append(u)

 def print_graph(self):
 for node in self.nodes:
 print((node, ""->"", self.adj_list[node]))

 def degree_node(self, node):
 return len(self.adj_list[node])

 def dfsUTIL(self, v, visited, parents=[]):
 #print(v, end="" "")
 visited[v] = True
 for i in self.adj_list[v]:
 if visited[i] == False:
 self.dfsUTIL(i, visited, parents)
 parents.append(i)

 def dfs(self, v):
 visited = [False] * (max(self.adj_list) + 1)
 parents = [v]
 self.dfsUTIL(v, visited, parents)
 return len(parents)

#####sorting a dictionary by the values#####
def dict_sort(ans):
 print(""ans: "", str(ans))
 ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))

#####naive method for testing prime or not O(n^.5);
def is_prime(n):
 if n == 1:
 return 0
 for i in range(2, int(math.sqrt(n)) + 1):
 if n % i == 0:
 return False
 return True

#####swap function#####
def swap(a, b):
 temp = a
 a = b
 b = temp
 return a, b

#####Primes till Nth O(n);
def seive_primes(n):
 flag = [0] * (n + 10)
 flag[1] = flag[0] = 1
 i = 2
 while i * i <= n + 1:
 if flag[i] == 0:
 for j in range(i * i, n + 1, i):
 flag[j] = 1
 i += 1
 return flag

#####all the prime factors of a number#####
def factors(n):
 d = {}
 while n % 2 == 0:
 if 2 in d:
 d[2] += 1
 else:
 d[2] = 1
 n //= 2
 for i in range(3, int(n ** 0.5) + 1, 2):
 while n % i == 0:
 if i in d:
 d[i] += 1
 else:
 d[i] = 1
 n //= i
 if n > 1:
 d[n] = 1
 return d

#####greatest common divisor of two numbers#####
def gcd(a, b):
 print(""a: "", str(a), ""b: "", str(b))
 if b == 0:
 return a
 return gcd(b, a % b)

#####least common multiplyer of two numbers#####
def lcm(a, b):
 return (a * b) // gcd(a, b)

#####function that return all the letters#####
def alphabates():
 return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN);
def binary_search(ls, n, flag):
 low = 0
 hi = n - 1
 while low <= hi:
 mid = (low + hi) // 2
 if ls[mid] == flag:
 return mid
 elif ls[mid] > flag:
 hi = mid - 1
 else:
 low = mid + 1
 return -1

#####quadratic roots#####
def qdrt(a, b, c):
 chk = b * b - 4 * a * c
 if chk >= 0:
 ans1 = (-b + chk ** 0.5) / (2 * a)
 ans2 = (-b - chk ** 0.5) / (2 * a)
 return [int(ans1), int(ans2)]
 return -1
#####permutations#####
def permutation(n, r):
 if n < r:
 return 0
 ans = 1
 for i in range(n - r + 1, n + 1):
 ans *= i
 return ans

#####combinations#####
def combination(n, r):
 if n < r:
 return 0
 ans = 1
 for i in range(r):
 ans *= (n - i)
 div = 1
 for i in range(2, r + 1):
 div *= i
 return ans // div

#####taking an array/list as input#####
def arinp():
 ls = list(map(int, input().split()))
 return ls

#####taking multiple inputs#####
def mult_inp():
 return list(map(int, input().split()))

#####Main function starts from here#####
def main():
 n, m = mult_inp()
 print(""n: "", str(n), ""m: "", str(m))
 print(""combination(n, 2) + combination(m, 2): "", combination(n, 2) + combination(m, 2))
def __starting_point():
 main()

__starting_point()
</ans>",0,{}
71," <ans>
import math
import bisect
import sys

def flrt(exp,x):
 print(""flrt: exp: "", str(exp), ""x: "", str(x))
 l=max(0,math.floor(x**(1/exp))-3)
 r = math.floor(x**(1/exp))+3
 while l<r:
 print(""l: "", str(l), ""r: "", str(r))
 mid=(l+r)//2
 if mid**exp<=x:
 l=mid+1
 else: 
 r=mid
 return l-1-str(l-1)

def c1(r):
 print(""r: "", str(r))
 ans=set()
 pr = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
 for i in pr:
 print(""i: "", str(i))
 x=2
 while x**i <= r:
 print(""x: "", str(x))
 val=x**i
 b2=flrt(2,val)
 b3=flrt(3,val)
 if b2**2 != val and b3**3 != val:
 ans.add(val)
 x+=1
 return ans

def solve(r, pc):
 print(""r: "", str(r), ""pc: "", str(pc))
 if r==0:
 return 0
 a=[2,3]
 ans=0
 for i in range(1,2**len(a)):
 tot=0
 mult=1
 for j,x in enumerate(a):
 if i&(1<<j):
 mult*=x
 tot+=1
 d= flrt(mult,r)
 ans+= d if tot%2 else -d
 return ans + bisect.bisect_right(pc,r)

q = int(input())

pc= c1(1e18+1)
 print(""pc: "", str(pc))
 pca=list(pc)
 pca.sort()

for i in range(q):
 l,r = [int(x) for x in sys.stdin.readline().split()]
 ans=solve(r,pca)-solve(l-1,pca)
 print(""ans: "", str(ans))
 sys.stdout.write(str(ans)+'\n')
</ans>",0,{}
72," <ans>
'''
# Auther: ghoshashis545 Ashis Ghosh
# College: jalpaiguri Govt Enggineering College

from os import path
import sys
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return list(map(int,input().split()))
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
 return ord(i)-ord('a')

n,m,w = mi() # new variables

def fessible(mid):
 b = [0]*n
 moves = 0
 if(a[0]<mid):
 b[0] += (mid-a[0])
 if(w<n):
 b[w] -= (mid-a[0])
 moves += (mid-a[0])
 if(moves > m):
 return 0
 for i in range(1,n):
 b[i] += b[i-1]
 x = a[i] + b[i]
 if(x<mid):
 b[i] += (mid-x)
 if(i+w<n):
 b[i+w] -= (mid-x)
 moves += (mid-x)
 if(moves > m):
 return 0
 return 1

l = 1
r = 1e10
ans = 0

while(l<=r):
 mid = l + (r-l)//2
 if(fessible(mid)):
 l = mid + 1
 ans = mid
 else:
 r = mid - 1

print(int(ans))

def __starting_point():
 solve()

__starting_point()
'''
</ans>",0,{}
73," <ans>
```python
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

S=lambda x:sum(map(int,str(x)))

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	z=S(x)%a
	if z:
		z=a-z
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(z,9-int(digit))
			z-=diff
			tail.append(str(int(digit)+diff))
			if z==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert S(x)%a==0
	x=int(x)
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	while a%5==0: a//=5
	return a==1

def solve(a):
	for first in range(1,60): # 120
		q=str((first*10**3000+a-1) // a) # 5000
		for s1 in range(1,200):
			i=1
			s2=int(q[0])
			while i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,a)
					if S(small*a)*a==S(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

if 0:
	for a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
		def work():
			nonlocal x
			x=solve(a)

		t=timeit(work,number=1)
		if t>0.5 or x==None:
			if x!=None:
				print(f""a: {a}, t: {t}, result: {powform(a*x)}"")
			else:
				print(f""a: {a}, t: {t}, result: ??????"")

#	print(solve(int(input())))

special='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5183051690006323 >> 3 * 10 ** 1813 + 1104
582 0.5202371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5263936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5272351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5333051690002504 >> 3 * 10 ** 2195 + 21003
636 0.5371086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5375810970001476 >> 2 * 10 ** 2140 + 439
64 0.5375810970000144 >> ?????
200 0.5379609099998779 >> ?????
100 0.538554023000611 >> ?????
125 0.5386040710005589 >> ?????
160 0.5388467480008985 >> ?????
800 0.5396178080002501 >> ?????
128 0.5396772269998764 >> ?????
80 0.5398211480000964 >> ?????
256 0.5398535130000467 >> ?????
250 0.5401464900000938 >> ?????
512 0.540266141999833 >> ?????
32 0.5402826909998985 >> ?????
50 0.5402834940000466 >> ?????
25 0.5406684799995637 >> ?????
400 0.5413751219998594 >> ?????
20 0.5416145570002263 >> ?????
500 0.5452691679997733 >> ?????
640 0.5459700739997934 >> ?????
40 0.5478258159996549 >> ?????
625 0.5485357299999087 >> ?????
16 0.5499494729997386 >> ?????
833 0.5555263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5696652009998797 >> 3 * 10 ** 1903 + 16008
320 0.5931684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.0451850",0,{}
74," <ans>
from collections import deque
from sys import stdin

def parser():
 return map(int, stdin.readline().split())

print(""n: "", str(n))
print(""m: "", str(m))

def DFS_Discriminiting():
 visited=[False for x in range(n)]
 visited[numbers_of_attacked_cities[0]]=True
 stack=[]
 intrudoction_order=[]
 stack.append(numbers_of_attacked_cities[0])
 while len(stack)>0:
 v=stack.pop()
 for u in adjacents_list[v]:
 if not visited[u]:
 pi[u]=v
 visited[u]=True
 intrudoction_order.append(u)
 for v in intrudoction_order[::-1]:
 count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]
 visited[pi[v]]=True
 if count_attacked_cities_subtree[v]==0:
 important_cities[v]=False
 print(""visited: "", str(visited))
 print(""count_attacked_cities_subtree: "", str(count_attacked_cities_subtree))

def DFS_Heigths():
 visited=[False for x in range(n)]
 visited[numbers_of_attacked_cities[0]]=True
 stack=[]
 intrudoction_order=[]
 stack.append(numbers_of_attacked_cities[0])
 while len(stack)>0:
 v=stack.pop()
 for u in adjacents_list[v]:
 if not visited[u]:
 pi[u]=v
 visited[u]=True
 stack.append(u)
 intrudoction_order.append(u)
 for v in intrudoction_order[::-1]:
 if heights1[pi[v]] < heights1[v]+1:
 heights2[pi[v]]=heights1[pi[v]]
 heights1[pi[v]]=heights1[v]+1
 print(""heights1: "", str(heights1))
 print(""heights2: "", str(heights2))

def Distance_Root(s):
 for v in adjacents_list[s]:
 if heights1[v]+1>distances1[s]:
 distances2[s]=distances1[s]
 distances1[s]=heights1[v]+1
 print(""distances1: "", str(distances1))
 print(""distances2: "", str(distances2))

def DFS_Distances():
 visited=[False for x in range(n)]
 visited[numbers_of_attacked_cities[0]]=True
 stack=[]
 stack.append(numbers_of_attacked_cities[0])
 while len(stack)>0:
 v=stack.pop()
 for u in adjacents_list[v]:
 if not visited[u]:
 pi[u]=v
 visited[u]=True
 stack.append(u)
 determinate=False
 for v in intrudoction_order[::-1]:
 if heights1[u]+1==distances1[v]:
 determinate=True
 if not determinate:
 distances1[u]=distances1[v]+1
 print(""distances1: "", str(distances1))
 print(""distances2: "", str(distances2))

def BFS(s):
 distance=[-1 for x in range(n)]
 distance[s]=0
 q=deque()
 q.append(s)
 while len(q)>0:
 v=q.popleft()
 for u in adjacents_list[v]:
 if distance[u] == -1:
 distance[u]=distance[v]+1
 q.append(u)
 return distance

n,m=parser()
 print(""n: "", str(n))
 print(""m: "", str(m))

#Creando los arrays necesarios para la ejecucion de DFS
#padres
pi=[0 for x in range(n)]
#ciudades atacadas en el subarbol
count_attacked_cities_subtree=[0 for x in range(n)]
#ciudad atacada o no atacada
attacked_city=[False for x in range(n)]
#ciudades_que_son atacadas o sirven para llegar a las mismas
important_cities=[True for x in range(n)]

adjacents_list=[[] for x in range(n)]
for i in range(n-1):
 print(""adjacents_list: "", str(adjacents_list))
 v1,v2=parser()
 adjacents_list[v1-1].append(v2-1)
 adjacents_list[v2-1].append(v1-1)

#numero de ciudades atacadas
numbers_of_attacked_cities=[x-1 for x in parser()]

if m==1:
 print(""numbers_of_attacked_cities: "", str(numbers_of_attacked_cities))
 print(""important_cities: "", str(important_cities))
 print(numbers_of_attacked_cities[0]+1)
 print(0)
 return

#marcando las ciudades atacadas
for i in numbers_of_attacked_cities:
 attacked_city[i]=True
 print(""attacked_city: "", str(attacked_city))

DFS_Discriminiting()

adjacents_list=[[] for x in range(n)]

count_edges=0
for v in range(n):
 if v==numbers_of_attacked_cities[0]:
 continue
 elif important_cities[v] and important_cities[pi[v]]:
 adjacents_list[v].append(pi[v])
 adjacents_list[pi[v]].append(v)
 count_edges+=1
 print(""adjacents_list: "", str(adjacents_list))

#padres
pi=[0 for x in range(n)]

#alturas
heights1=[0 for x in range(n)]
heights2=[0 for x in range(n)]

DFS_Heigths()

#distances
distances1=[0 for x in range(n)]
distances2=[0 for x in range(n)]

DFS_Distances()

lower=distances1[numbers_of_attacked_cities[0]]
for i in range(n):
 if important_cities[i] and lower>distances1[i]:
 lower=distances1[i]
 print(""lower: "", str(lower))

centers=[]
for i in range(n):
 if distances1[i]==lower:
 centers.append(i)
 print(""centers: "", str(centers))

posibles_begin_cities=[]

for i in centers:
 distances_center=BFS(i)
 max_distance=0
 for j in range(n):
 if distances_center[j]>max_distance:
 max_distance=distances_center[j]
 for j in range(n):
 if distances_center[j]==max_distance:
 posibles_begin_cities.append(j)
 print(""posibles_begin_cities: "", str(posibles_begin_cities))

print(min(posibles_begin_cities)+1)

print(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))
</ans>",0,{}
75," <ans>
from copy import deepcopy
n, k, m, a = [int(i) for i in input().split()]
print(""n: "", str(n), ""k: "", str(k), ""m: "", str(m), ""a: "", str(a))
cn = [0] * (n + 1)
last = [-1] * (n + 1)
print(""cn: "", str(cn), ""last: "", str(last))
v = [int(i) for i in input().split()]
print(""v: "", str(v))

for i in range(len(v)):
 last[v[i]] = i
 cn[v[i]] += 1
 print(""cn: "", str(cn), ""last: "", str(last))

cn1 = deepcopy(cn)
last1 = deepcopy(last)

for i in range(1, n + 1):
 cn = deepcopy(cn1)
 last = deepcopy(last1)
 res = [i1 for i1 in range(1, n + 1)]
 print(""res before sort: "", str(res))
 res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
 print(""res after sort: "", str(res))

 for j in range(len(res)):
 if res[j] != i:
 continue
 j1 = j + 1
 lft = m - a
 while j1 < n and lft:
 pls = min(lft, cn[i] - cn[res[j1]] + 1)
 cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)
 last[res[j1]] = m
 lft -= pls
 j1 += 1

 res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
 sans = 0
 for j in range(len(res)):
 if res[j] != i:
 continue
 if cn[i] == 0 or j >= k:
 sans = 0
 else:
 sans = 1
 break

 if sans == 1:
 print(""sans: 1"")
 continue

 cn = deepcopy(cn1)
 last = deepcopy(last1)

 if m - a:
 cn[i] += m - a
 last[i] = m - 1

 res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)
 for j in range(len(res)):
 if res[j] != i:
 continue
 sans = 0
 if cn[i] == 0 or j >= k:
 continue
 sans = 1
 break

 if sans:
 print(""sans: 1"")
 else:
 print(""sans: 0"")
</ans>",0,{}
76," <ans>
def indeksTurun(a):
	for x in range(len(a)-1):
		print(""x: "", x)
		if a[x] > a[x+1]:
			print(""reversed_indeks1: "", x+1)
			return x+1
			pass
		pass
	print(""reversed_indeks1: -1"")
	return -1
	pass

def menaik(a,i1):
	for x in range(i1,len(a)-1):
		print(""x: "", x)
		if a[x] > a[x+1]:
			print(""False"")
			return False
			pass
		pass
	print(""True"")
	return True
	pass

a=input()
a=list(map(int,input().split("" "")))

print(""a: "", str(a))

if len(a) == 1:
	print (""yes"")
	print (""1 1"")
else:
	reversed_indeks1=-1
	for x in range(len(a)-1):
		print(""x: "", x)
		if a[x] > a[x+1]:
			reversed_indeks1=x
			break
			pass
		pass
	print(""reversed_indeks1: "", str(reversed_indeks1))
	if reversed_indeks1 == -1:
		print (""yes"")
		print (""1 1"")
	else:
		reversed_indeks2=len(a)-1
		for x in range(reversed_indeks1,len(a)-1):
			print(""x: "", x)
			if a[x] < a[x+1]:
				reversed_indeks2=x
				break
		asc=True
		print(""asc: "", asc)
		if reversed_indeks2 != len(a)-1:
			asc=menaik(a,reversed_indeks2+1)
			print(""asc: "", asc)
		if asc:
			kiri=True
			kanan=True
			if reversed_indeks1 != 0:
				if a[reversed_indeks2] < a[reversed_indeks1-1]:
					kiri=False
					print(""kiri: False"")
					pass
			if reversed_indeks2 != len(a)-1:
				if a[reversed_indeks1] > a[reversed_indeks2+1]:
					kanan=False
					print(""kanan: False"")
					pass
				pass
			if kiri and kanan:
				print (""yes"")
				print (""%d %d""%(reversed_indeks1+1,reversed_indeks2+1))
				pass
			else:
				print (""no"")
		else:
			print (""no"")
			pass
	pass
</ans>",0,{}
77," <ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
 print(""i: "", i)
 if i == 2 * n + 1:
 nonlocal ans
 ans = ""Yes""
 return
 if ans == ""No"":
 if y[i] == 0:
 for k in range(1, n):
 if k + i >= 2 * n + 1:
 print(""k, i: "", k, i)
 continue
 if not ok(k, i):
 continue
 dfs(i + 2 * k)
 else:
 if ok(y[i], i):
 dfs(i + 2 * y[i])
 return
 print(""ans: "", ans)
 return

def ok(k, i):
 if k + i >= 2 * n + 1:
 return 0
 f = 1
 for l in range(k):
 if k + i + l >= 2 * n + 1:
 print(""k, i, l: "", k, i, l)
 continue
 if x[i + l] == 2 or x[k + i + l] == 1:
 print(""x[i+l], x[k+i+l]: "", x[i+l], x[k+i+l])
 f = 0
 break
 if not (y[i+l] == 0 or y[i+l] == k):
 print(""y[i+l], y[i+l]: "", y[i+l], y[i+l])
 f = 0
 break
 if not z[i+l] == z[k+i+l] and min(z[i+l], z[k+i+l]) >= 1:
 print(""z[i+l], z[k+i+l]: "", z[i+l], z[k+i+l])
 f = 0
 break
 return f

n = int(input())
 ans = ""Yes""
 x = [0] * (2 * n + 2)
 y = [0] * (2 * n + 2)
 z = [0] * (2 * n + 2)
 print(""n: "", n)
 for i in range(1, n + 1):
 a, b = map(int, input().split())
 print(""a, b: "", a, b)
 if a >= b and not (a == -1 or b == -1):
 ans = ""No""
 print(""ans: "", ans)
 if not (x[a] == 0 and x[b] == 0):
 ans = ""No""
 print(""ans: "", ans)
 if not a == -1:
 x[a] = 1
 z[a] = i
 print(""x[a]: "", x[a])
 if not b == -1:
 x[b] = 2
 z[b] = i
 print(""x[b]: "", x[b])
 if not (a == -1 or b == -1):
 y[a] = b - a
 print(""y[a]: "", y[a])
 if ans == ""No"":
 print(ans)
 return
 ans = ""No""
 dfs(1)
 print(ans)
</ans>",0,{}
78," <ans>
n, m = map(int, input().split())

print(""n: "", str(n), ""m: "", str(m))

t = [0] * (n + 1)
print(""t: "", str(t))
p = [0] * (n + 1)
print(""p: "", str(p))
q = [[] for i in range(n + 1)] 
print(""q: "", str(q))

def f(x):
for i in q[x]:
print(""i: "", str(i))
u, v = i[0], i[1]
if t[u] and t[v]: continue
if t[u] and not t[v]:
t[v] = 7 - t[x] - t[u]
print(""t[v]: "", str(t[v]))
for j in q[v]:
p[j[0]] |= t[v]
p[j[1]] |= t[v]
print(""p[j[0]]: "", str(p[j[0]]), ""p[j[1]]: "", str(p[j[1]]))
#f(u)
f(v)
elif not t[u] and t[v]:
t[u] = 7 - t[x] - t[v]
print(""t[u]: "", str(t[u]))
for j in q[u]:
p[j[0]] |= t[u]
p[j[1]] |= t[u]
print(""p[j[0]]: "", str(p[j[0]]), ""p[j[1]]: "", str(p[j[1]]))
f(u)
#f(v)
else:
for k in [1, 2, 4]:
t[u], t[v] = k, 7 - t[x] - k
print(""t[u]: "", str(t[u]), ""t[v]: "", str(t[v]))
if not (p[u] & t[u] or p[v] & t[v]): break
for j in q[v]:
p[j[0]] |= t[v]
p[j[1]] |= t[v]
print(""p[j[0]]: "", str(p[j[0]]), ""p[j[1]]: "", str(p[j[1]]))
for j in q[u]:
p[j[0]] |= t[u]
p[j[1]] |= t[u]
print(""p[j[0]]: "", str(p[j[0]]), ""p[j[1]]: "", str(p[j[1]]))
f(u)
f(v)

if m == 49999:
for j in range(m):
a, b, c = map(int, input().split())
print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
x = t[a] | t[b] | t[c]
print(""x: "", str(x))
for i in (a, b, c):
if not t[i]:
if not x & 1: t[i] = 1; x += 1;
print(""t[i]: "", str(t[i]))
elif not x & 2: t[i] = 2; x += 2;
else: t[i] = 4
print(""t[i]: "", str(t[i]))
else:
for i in range(m):
a, b, c = map(int, input().split())
print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))
q[a].append((b, c))
print(""q[a]: "", str(q[a]))
q[b].append((a, c))
print(""q[b]: "", str(q[b]))
q[c].append((a, b))
print(""q[c]: "", str(q[c]))

for x in range(1, n + 1):
if not t[x]:
t[x] = 1
print(""t[x]: "", str(t[x]))
for j in q[x]:
p[j[0]] |= 1
p[j[1]] |= 1
print(""p[j[0]]: "", str(p[j[0]]), ""p[j[1]]: "", str(p[j[1]]))
f(x)

p = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(""p: "", str(p))
print(''.join(p[x] for x in t[1:]))
</ans>",1,{}
79," <ans>
def good(nums):
    for num in nums:
        if num in nums:  # checking if num is already in nums
            print(""num: "", str(num), ""nums: "", str(nums))
            return True
    nums[num] = True
    print(""num: "", str(num), ""nums: "", str(nums))
    for num in nums:
        if nums[num] > 1:  # checking if any num has count > 1
            print(""num: "", str(num), ""nums: "", str(nums))
            return True
    return False

n = int(input())
print(""n: "", str(n))

a = [int(i) for i in input().split()]
print(""a: "", str(a))

s = []

l, r = 0, 0
nums = {}

for i in range(n):
    num = a[i]
    print(""num: "", str(num), ""i: "", str(i), ""nums: "", str(nums))
    if num in nums:
        break
    else:
        nums[num] = True
        print(""num: "", str(num), ""nums: "", str(nums))
else:
    print(-1)
    return

nums = {}

while r < n:
    while r < n:
        num = a[r]
        print(""num: "", str(num), ""r: "", str(r), ""nums: "", str(nums))
        if num in nums:
            r += 1
            break
        else:
            nums[num] = True
            print(""num: "", str(num), ""nums: "", str(nums))

        r += 1

    r -= 1

    s.append([l, r])
    print(""l: "", str(l), ""r: "", str(r), ""s: "", str(s))
    r += 1
    l = r

    nums = {}

length = len(s)
print(""length: "", str(length))

last = s[length-1]
print(""last: "", str(last))

for i in range(last[0], last[1]+1):
    num = a[i]
    print(""num: "", str(num), ""i: "", str(i), ""nums: "", str(nums))
    if num in nums:
        print(length)
        break
    else:
        nums[num] = True
else:
    s.pop()

    s[length-2][1] = n-1

    print(""s: "", str(s))

    print(length-1)

for st in s:
    for c in st:
        print(c+1, end="" "")
    print()
</ans>",0,{}
80," <ans>
import sys
input = sys.stdin.readline

G0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
G1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
G2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]

print(""G0: "", str(G0), ""G1: "", str(G1), ""G2: "", str(G2))

for x in range(1,6):
 for y in range(1,6):
 for z in range(1,6):

 for i in range(1,5500):
 s=G0[x][y][z][max(0,i-x)]
 t=G1[x][y][z][max(0,i-y)]
 u=G2[x][y][z][max(0,i-z)]

 for j in range(1,6):
 if j==s or j==t or j==u:
 continue
 else:
 G0[x][y][z][i]=j
 print(""G0[x][y][z][i]: "", str(j))
 break

 for j in range(1,6):
 if j==s or j==u:
 continue
 else:
 G1[x][y][z][i]=j
 print(""G1[x][y][z][i]: "", str(j))
 break

 for j in range(1,6):
 if j==s or j==t:
 continue
 else:
 G2[x][y][z][i]=j
 print(""G2[x][y][z][i]: "", str(j))
 break

def lcm(x, y):
 return (x * y) // math.gcd(x, y)

t=int(input())
print(""t: "", str(t))
for tests in range(t):
 n,x,y,z=list(map(int,input().split()))
 print(""n,x,y,z: "", str(n), str(x), str(y), str(z))
 B=list(map(int,input().split()))
 print(""B: "", str(B))
 A=[]
 for a in B:
 if a<=5400:
 A.append(a)
 else:
 A.append(a%2520+2520)
 print(""A: "", str(A))

 XOR=0
 print(""XOR: "", str(XOR))
 for a in A:
 XOR^=G0[x][y][z][a]
 print(""XOR: "", str(XOR))

 ANS=0
 print(""ANS: "", str(ANS))
 for a in A:
 k=XOR^G0[x][y][z][a]
 if G0[x][y][z][max(0,a-x)]==k:
 ANS+=1
 print(""ANS: "", str(ANS))
 if G1[x][y][z][max(0,a-y)]==k:
 ANS+=1
 print(""ANS: "", str(ANS))
 if G2[x][y][z][max(0,a-z)]==k:
 ANS+=1
 print(""ANS: "", str(ANS))
 print(ANS)
</ans>",0,{}
81," <ans>
def dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)
    
    x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
    print(""x0, y0, a1, a2, b1, b2: "", str([x0, y0, a1, a2, b1, b2]))
    xs, ys, t = list(map(int, input().split()))
    print(""xs, ys, t: "", str([xs, ys, t]))
    arr = []
    arr.append((x0, y0))
    now1 = x0
    now2 = y0
    print(""now1, now2: "", str([now1, now2]))
    while (1):
        now1 = a1 * now1 + b1
        now2 = a2 * now2 + b2
        print(""now1, now2: "", str([now1, now2]))
        if (now1 < xs or now2 < ys):
            arr.append((now1, now2))
            print(""arr: "", str(arr))
            continue
        arr.append((now1, now2))
        if (dist(now1, now2, xs, ys) > t):
            break
    print(""ans before loop: "", str(ans))
    ans = 0
    N = len(arr)
    print(""N: "", str(N))
    for i in range(N):
        print(""i: "", str(i))
        need = dist(arr[i][0], arr[i][1], xs, ys)
        print(""need: "", str(need))
        if (need > t):
            continue
        left = t - need
        print(""left: "", str(left))
        now = 1
        flag = 1
        now1 = arr[i][0]
        now2 = arr[i][1]
        print(""now1, now2: "", str([now1, now2]))
        for j in range(i - 1, -1, -1):
            d = dist(now1, now2, arr[j][0], arr[j][1])
            print(""d: "", str(d))
            if (d > left):
                flag = 0
                print(""flag: "", str(flag))
                break
            left -= d
            now1 = arr[j][0]
            now2 = arr[j][1]
            now += 1
            print(""now: "", str(now))
        if (not flag):
            ans = max(ans, now)
            print(""ans: "", str(ans))
            continue
        for j in range(i + 1, N):
            d = dist(now1, now2, arr[j][0], arr[j][1])
            print(""d: "", str(d))
            if (d > left):
                break
            left -= d
            now1 = arr[j][0]
            now2 = arr[j][1]
            now += 1
            print(""now: "", str(now))
        ans = max(ans, now)
        print(""ans: "", str(ans))
    print(""ans after loop: "", str(ans))
    print(ans)
</ans>",0,{}
82," <ans>
# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random

""""""
created by shhuan at 2017/10/6 22:19

""""""

t0 = time.time()
a, b, c = list(map(int, input().split()))

print(""a: "", str(a), ""b: "", str(b), ""c: "", str(c))

def ct(a, b):
 if a > b: a, b = b, a
 L=998244353
 s=1
 sx=1
 for k in range(1,a+1):
 s = s*(a+1-k)*(b+1-k)//k
 sx += s % L
 return sx

L=998244353

ans = ct(a,b) * ct(a,c) * ct(b,c)
print(""ans: "", str(ans))

# print(time.time()-t0)

# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]
# for i in range(1, MAXN):
# p[i][0] = 1
# for j in range(1, i+1):
# p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD
# print(""p: "", str(p))
# print(""time to compute p: "", time.time() - t0)

# pre = [0] * MAXN
# pre[0] = 1
# for i in range(1, MAXN):
# pre[i] = (i*pre[i-1]) % MOD
# print(""pre: "", str(pre))
# print(""time to compute pre: "", time.time() - t0)

# def solve(x, y):
# ans = 0
# for k in range(min(x, y)+1):
# d = pre[k]
# d = (d*p[x][k]) % MOD
# d = (d*p[y][k]) % MOD
# ans = (ans+d) % MOD
# return ans

# ans = 1
# ans = (ans * solve(a, b)) % MOD
# ans = (ans * solve(b, c)) % MOD
# ans = (ans * solve(a, c)) % MOD
# print(""ans after solving: "", str(ans))
# print(""time to solve: "", time.time() - t0)

# print(time.time() - t0)
</ans>",0,{}
83," <ans>
import sys
from functools import reduce

zz=1

sys.setrecursionlimit(10**5)
if zz:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
di=[[-1,0],[1,0],[0,1],[0,-1]]

print(""zz: "", str(zz))

def fori(n):
	return [fi() for i in range(n)]	

print(""n: "", str(n))

def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x

print(""d: "", str(d))

def ii():
	return input().rstrip()	

print(""ii: "", str(ii))

def li():
	return [int(xx) for xx in input().split()]

print(""li: "", str(li()))

def fli():
	return [float(x) for x in input().split()]	

print(""fli: "", str(fli()))

def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0		

print(""comp: "", str(comp))

def gi():	
	return [xx for xx in input().split()]

print(""gi: "", str(gi()))

def gtc(tc,ans):
	print((""Case #""+str(tc)+"":"",ans))	

print(""tc: "", str(tc), ""ans: "", str(ans))

def cil(n,m):
	return n//m+int(n%m>0)	

print(""cil: "", str(cil))

def fi():
	return int(input())

print(""fi: "", str(fi()))

def pro(a): 
	return reduce(lambda a,b:a*b,a)		

print(""pro: "", str(pro))

def swap(a,i,j): 
	a[i],a[j]=a[j],a[i]	

print(""a: "", str(a), ""i: "", str(i), ""j: "", str(j))

def si():
	return list(input().rstrip())	

print(""si: "", str(si()))

def mi():
	return 	list(map(int,input().split()))			

print(""mi: "", str(mi()))

def gh():
	sys.stdout.flush()

print(""sys.stdout: "", str(sys.stdout))

def isvalid(i,j,n,m):
	return 0<=i<n and 0<=j<m 

print(""i: "", str(i), ""j: "", str(j), ""n: "", str(n), ""m: "", str(m))

def bo(i):
	return ord(i)-ord('a')	

print(""i: "", str(i), ""ord(i): "", str(ord(i)), ""ord('a'): "", str(ord('a')))

def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)

print(""n: "", str(n), ""m: "", str(m), ""a: "", str(a))

t=1
uu=t

print(""t: "", str(t), ""uu: "", str(uu))

def can(val):
	p=val;c=0
	for i in range(n):
		c+=abs(a[i]-p)
		p+=1
	return c	

print(""val: "", str(val), ""p: "", str(p), ""c: "", str(c))

while t>0:
	t-=1
	n=fi()
	a=li()
	l=-2*max(a)
	r=2*max(a)
	mini=10**18
	while l<=r:
		lmid=l+(r-l)//3
		rmid=r-(r-l)//3
		p1=can(lmid)
		p2=can(rmid)
		mini=min([mini,p1,p2])
		if p1>=p2:
			l=lmid+1
		else:
			r=rmid-1
	print(""l: "", str(l), ""r: "", str(r), ""mini: "", str(mini))
	print(""can(lmid): "", str(p1), ""can(rmid): "", str(p2))
</ans>",0,{}
84," <ans>
def local_right_to_global(test, local_right):
 print(""local_right: "", str(local_right))
 return(len(test) + local_right)

def local_left_to_global(test, local_left):
 print(""local_left: "", str(local_left))
 return(local_left)

def check_left(test, template, good_symbols):
 left_idx = -1
 for symbol in template:
 left_idx += 1
 if symbol == '*':
 print(""left_idx: "", str(left_idx))
 return(local_left_to_global(test, left_idx))
 try:
 if test[left_idx] != template[left_idx]:
 if template[left_idx] != '?':
 print(""NO at left_idx: "", str(left_idx))
 return('NO')
 elif test[left_idx] not in good_symbols:
 print(""NO at left_idx: "", str(left_idx))
 return('NO')
 except:
 print(""NO at left_idx: "", str(left_idx))
 return('NO')

def check_right(test, template, good_symbols):
 right_idx = 0
 for symbol in reversed(template):
 right_idx -= 1
 if symbol == '*':
 print(""right_idx: "", str(right_idx))
 return(local_right_to_global(test, right_idx))
 try:
 if test[right_idx] != template[right_idx]:
 if template[right_idx] != '?':
 print(""NO at right_idx: "", str(right_idx))
 return('NO')
 elif test[right_idx] not in good_symbols:
 print(""NO at right_idx: "", str(right_idx))
 return('NO')
 except:
 print(""NO at right_idx: "", str(right_idx))
 return('NO')

good_symbols = set(list(input()))
 print(""good_symbols: "", str(good_symbols))
 template = input()
 print(""template: "", str(template))
 tests_nr = int(input())
 print(""tests_nr: "", str(tests_nr))
 tests = []
 print(""tests: "", str(tests))
 for _ in range(tests_nr):
 tests.append(input())
 print(""test: "", str(tests))
 abaca = '*' not in template
 print(""abaca: "", str(abaca))
 for test in tests:
 if abaca:
 pos = -1
 flag = True
 if len(test) != len(template):
 print(""NO"")
 continue
 for symbol in template:
 pos += 1
 try:
 if test[pos] != template[pos]:
 if template[pos] != '?':
 print(""NO"")
 flag = False
 break
 elif test[pos] not in good_symbols:
 print(""NO"")
 flag = False
 break
 except:
 print(""NO"")
 flag = False
 break
 if flag:
 print(""YES"")
 continue
 left_idx = check_left(test, template, good_symbols)
 right_idx = check_right(test, template, good_symbols)
 if left_idx == 'NO':
 print(""NO"")
 elif right_idx == 'NO':
 print(""NO"")
 else:
 if right_idx < left_idx - 1:
 print(""NO"")
 continue
 flag = True
 for pos in range(left_idx, right_idx + 1):
 if test[pos] in good_symbols:
 print(""NO"")
 flag = False
 break
 if flag:
 print(""YES"")
</ans>",0,{}
85," <ans>
n = int(input())
print(""n: "", str(n))
x0, y0 = map(int, input().split())
print(""x0: "", str(x0), ""y0: "", str(y0))
Nord = 10 ** 9 + 1
print(""Nord: "", str(Nord), ""fNord: '-'"")
East = 10 ** 9 + 1
print(""East: "", str(East), ""fEast: '-'"")
South = -10 ** 9 - 1
print(""South: "", str(South), ""fSouth: '-'"")
West = -10 ** 9 - 1
print(""West: "", str(West), ""fWest: '-'"")

NE = 10 ** 9 + 1
print(""NE: "", str(NE), ""fNE: '-'"")
NW = 10 ** 9 + 1
print(""NW: "", str(NW), ""fNW: '-'"")
SE = -10 ** 9 - 1
print(""SE: "", str(SE), ""fSE: '-'"")
SW = -10 ** 9 - 1
print(""SW: "", str(SW), ""fSW: '-'"")

for i in range(n):
 print(""i: "", str(i))
 f, x, y = input().split()
 print(""f: "", str(f), ""x: "", str(x), ""y: "", str(y))
 x = int(x)
 print(""x: "", str(x))
 y = int(y)
 print(""y: "", str(y))
 if x == x0:
 print(""x == x0"")
 if y0 < y < Nord:
 Nord = y
 print(""Nord: "", str(Nord))
 fNord = f
 print(""fNord: "", str(f))
 elif y0 > y > South:
 South = y
 print(""South: "", str(South))
 fSouth = f
 print(""fSouth: "", str(f))

 if y == y0:
 print(""y == y0"")
 if x0 < x < East:
 East = x
 print(""East: "", str(East))
 fEast = f
 print(""fEast: "", str(f))
 elif x0 > x > West:
 West = x
 print(""West: "", str(West))
 fWest = f
 print(""fWest: "", str(f))

 if x + y == x0 + y0:
 print(""x + y == x0 + y0"")
 if y0 < y < NW:
 NW = y
 print(""NW: "", str(NW))
 fNW = f
 print(""fNW: "", str(f))
 elif y0 > y > SE:
 SE = y
 print(""SE: "", str(SE))
 fSE = f
 print(""fSE: "", str(f))

 if x - y == x0 - y0:
 print(""x - y == x0 - y0"")
 if y0 < y < NE:
 NE = y
 print(""NE: "", str(NE))
 fNE = f
 print(""fNE: "", str(f))
 elif y0 > y > SW:
 SW = y
 print(""SW: "", str(SW))
 fSW = f
 print(""fSW: "", str(f))

ans = False
print(""ans: False"")
if fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':
 ans = True
 print(""ans: "", str(ans))
if fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':
 ans = True
 print(""ans: "", str(ans))
if fSW == 'B' or fSE == 'B' or fNW == 'B' or fNE == 'B':
 ans = True
 print(""ans: "", str(ans))
if fNord == 'R' or fsouth == 'R' or fWest == 'R' or fEast == 'R':
 ans = True
 print(""ans: "", str(ans))

print('YES' if ans else 'NO')
</ans>",0,{}
86," <ans>
#n = int(input())
print(""n: "", str(n))

s = input()

ans = int(n * (n - 1) / 2)
print(""ans: "", str(ans))
c = 0

for i in range(n):
 print(""i: "", str(i), ""s[i]: "", str(s[i]))
 if s[i] == 'A':
 c += 1
 print(""c: "", str(c))
 else:
 if c > 1:
 ans -= (c - 1)
 print(""ans: "", str(ans))
 c = 0

c = 0
for i in range(n):
 if s[i] == 'B':
 c += 1
 print(""c: "", str(c))
 else:
 if c > 1:
 ans -= (c - 1)
 print(""ans: "", str(ans))
 c = 0

s = s[::-1]

c = 0
for i in range(n):
 print(""i: "", str(i), ""s[i]: "", str(s[i]))
 if s[i] == 'A':
 c += 1
 print(""c: "", str(c))
 else:
 if c > 1:
 ans -= 1
 print(""ans: "", str(ans))
 c = 0

c = 0
for i in range(n):
 if s[i] == 'B':
 c += 1
 print(""c: "", str(c))
 else:
 if c > 1:
 ans -= 1
 print(""ans: "", str(ans))
 c = 0

c = 0
if s[0] == 'A':
 print(""s[0]: "", str(s[0]))
 c += 1
 for i in range(n):
 if s[i] == 'A':
 print(""i: "", str(i), ""s[i]: "", str(s[i]))
 c += 1
 print(""c: "", str(c))
 elif c >= 1:
 ans -= 1
 print(""ans: "", str(ans))
 c = 0

c = 0
if s[0] == 'B':
 print(""s[0]: "", str(s[0]))
 c += 1
 for i in range(n):
 if s[i] == 'B':
 print(""i: "", str(i), ""s[i]: "", str(s[i]))
 c += 1
 print(""c: "", str(c))
 elif c >= 1:
 ans -= 1
 print(""ans: "", str(ans))
 c = 0

print(""ans: "", str(ans))
</ans>",0,{}
87," <ans>
#!/usr/bin/env python3

class CantException(Exception): pass

def odd_v(value): return 1 if value % 2 == 1 else -1

change_idx = 1

acceptable = {-1: set(), 1: set()}

def change(card_values, oddv, m): nonlocal change_idx print(""change_idx: "", change_idx) if acceptable[oddv]: res = acceptable[oddv].pop() card_values.add(res) return res print(""Accepted: "", res) change_idx_start = change_idx while change_idx in card_values or odd_v(change_idx) != oddv: if change_idx not in card_values: acceptable[odd_v(change_idx)].add(change_idx) print(""Added to acceptable: "", change_idx, "" with oddv: "", odd_v(change_idx)) change_idx += 1 if change_idx > m: change_idx = 1 if change_idx == change_idx_start: raise CantException() print(""change_idx: "", change_idx) res = change_idx card_values.add(res) change_idx += 1 if change_idx > m: change_idx = 1 return res print(""Changed: "", res)

def solve(): n, m = list(map(int, input().split())) cards = list(map(int, input().split()))

odd_balance = 0
card_values = set()
indices_to_be_changed = set()

for i, c in enumerate(cards): odd_balance += odd_v(c) if c in card_values: indices_to_be_changed.add(i) card_values.add(c)

change_count = len(indices_to_be_changed)

for i in indices_to_be_changed: if odd_v(cards[i]) * odd_balance <= 0: cards[i] = change(card_values, odd_v(cards[i]), m) else: odd_balance -= 2 * odd_v(cards[i]) cards[i] = change(card_values, -odd_v(cards[i]), m)

odd_balance = 0
for i, c in enumerate(cards): odd_balance += odd_v(c) if odd_balance != 0: print(""odd_balance: "", odd_balance) print(""WTFFFFF"")

return change_count, cards

def __starting_point(): try: change_cnt, cards = solve() print(""change_count: "", change_cnt) print(""cards: "", cards) except CantException: print(""-1"")

__starting_point()
</ans>",0,{}
88," <ans>
def dp(ind, max_covered):
	max_covered = min(m, max_covered)
	print(""max_covered: "", str(max_covered))

	if ind not in cache:
		cache[ind] = {}

	d = cache[ind]
	if max_covered in d:
		return d[max_covered]

	ans = blah(ind, max_covered)

	d[max_covered] = ans
	print(""ans: "", str(ans))
	return ans

	# path = {}

class Node:
	def __init__(self, key, val, next=None):
		self.key = key
		self.val = val
		self.next = next

def blah(ind, max_covered):
	x, s = antenna[ind]
	# key = (ind, max_covered)
	print(""x: "", str(x), ""s: "", str(s))

	if max_covered >= m:
		# path[key] = Node(key, 0)
		return 0

	if ind == len(antenna) - 1:
		if max_covered < x - s - 1:
			left_needed = x - s - (max_covered + 1)
			right_needed = max(m - (x + s), 0)
			ans = max(left_needed, right_needed)
			# path[key] = Node(key, ans)
			return ans
		else:
			right_boundary = max(max_covered, x + s)
			ans = max(0, m - right_boundary)
			# path[key] = Node(key, ans)
			return ans

	if max_covered < x - s - 1:
		num_needed = x - s - (max_covered + 1)
		new_boundary = min(x + s + num_needed, m)
		use_i = num_needed + dp(ind + 1, new_boundary)
		dont_use_i = dp(ind + 1, max_covered)

		# if use_i < dont_use_i:
		#	 path[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])
		# else:
		#	 path[key] = Node(key, 0, path[(ind + 1, max_covered)])

		return min(use_i, dont_use_i)
	else:
		new_boundary = min(max(max_covered, x + s), m)
		ans = dp(ind + 1, new_boundary)
		# path[key] = Node(key, 0, path[(ind + 1, new_boundary)])
		return ans

import sys

cache = {}


n, m = [int(x) for x in sys.stdin.readline().split("" "")]
print(""n: "", str(n), ""m: "", str(m))

antenna = []

for i in range(n):
	x, s = [int(x) for x in sys.stdin.readline().split("" "")]
	print(""antenna[i]: "", str(x), str(s))
	antenna.append((x, s))

antenna.sort(key=lambda a: a[0])
print(""antenna: "", str(antenna))

print(dp(0, 0))
</ans>",0,{}
89," <ans>
import math;

def getCoordinate(gx, gy, alpha, x, y):
 print(""x1, y1: "", x1, y1)
 x1=gx+x*math.cos(alpha)-y*math.sin(alpha);
 y1=gy+x*math.sin(alpha)+y*math.cos(alpha);
 return x1, y1

def getAngle(gx, gy, x, y):
 print(""x, y: "", x, y)
 x=x-gx;
 y=y-gy;
 cos=x/math.sqrt(x**2+y**2);
 alpha=math.acos(cos);
 if y<0:
 alpha=-alpha;
 return math.pi/2-alpha;

n, q = list(map(int, input().split(' ')));
 print(""n, q: "", n, q)
 x=[0]*n;
 y=[0]*n;
 for i in range(n):
 print(""x[i], y[i]: "", x[i], y[i])
 x[i], y[i]=list(map(int, input().split(' ')));
 r=[0]*q;
 f=[0]*q;
 t=[0]*q;
 v=[0]*q;
 for i in range(q):
 print(""r[i], f[i], t[i]: "", r[i], f[i], t[i])
 l=list(map(int, input().split(' ')));
 r[i]=l[0];
 if r[i]==1:
 f[i]=l[1]-1;
 t[i]=l[2]-1;
 else:
 v[i]=l[1]-1;
 gx=0;
 gy=0;
 s=0;
 for i in range(n):
 ip=i+1;
 if ip==n:
 ip=0;
 ds=x[i]*y[ip]-x[ip]*y[i];
 s+=ds;
 gx+=(x[i]+x[ip])*ds;
 gy+=(y[i]+y[ip])*ds;
 print(""gx, gy, s: "", gx, gy, s)
 s/=2;
 gx/=6*s;
 gy/=6*s;
 angles=[0]*n;
 for i in range(n):
 angles[i]=getAngle(gx, gy, x[i], y[i]);
 for i in range(n):
 print(""angles[i]: "", angles[i])
 x[i]-=gx;
 y[i]-=gy;
 alpha=0;
 fix={0, 1}
 for i in range(q):
 if r[i]==2:
 print(""i: "", i)
 currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);
 print(""currX, currY: "", currX, currY)
 elif len(fix)==2:
 print(""fix: "", fix)
 j = fix.pop();
 print(""j: "", j)
 currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);
 print(""currX, currY: "", currX, currY)
 alpha=angles[j];
 gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);
 print(""gx, gy: "", gx, gy)
 fix.add(t[i]);
</ans>",0,{}
90," <ans>
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
 return list(map(int, input().split())) 

try :
 import numpy
 def dprint(*args, **kwargs):
 #print(*args, **kwargs, file=sys.stderr)
 # in python 3.4 **kwargs is invalid???
 print(*args, file=sys.stderr)
 except Exception:
 def dprint(*args, **kwargs):
 pass

inId = 0
outId = 0
if inId>0:
 dprint('use input', inId)
 sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
 dprint('use output', outId)
 sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
 atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
 
N = getIntList()[0]
# print(N)
re = 1
mc = 1
zc = []
print(""N: "", N)
for i in range(2, 10000):
 if N%i != 0 : continue
 re *= i
 c = 0
 while N%i==0:
 N //= i
 c+=1
 zc.append(c)
 if N>1:
 re *= N
 zc.append(1)
 if zc:
 mc = max(zc)
 t =1
 print(""t: "", t)
 for i in range(100):
 if mc<=t:
 break
 t*=2
 print(""t: "", t)
 g = i
 for x in zc:
 if x<t:
 g+=1
 break
 print(""g: "", g)

print(re,g)
</ans>",0,{}
91," <ans>
#-------------------------code---------------------------#
# vsInput()

n, m, o = value()
print(""n: "", n, ""m: "", m, ""o: "", o)

for i in range(n):
 print(""i: "", i)
 input()

print(""m*(m-1)//2: "", m*(m-1)//2)
for i in range(1, m+1):
 for j in range(i+1, m+1):
 if o == 0:
 print(""i: "", i, ""j: "", j)
 print(""m-i+1: "", m-i+1, ""m-j+1: "", m-j+1)
 else:
 print(""m-i+1: "", m-i+1, ""m-j+1: "", m-j+1)
</ans>",0,{}
92," <ans>
def solve1(a, n):  
    left=[]
    print(""left: []"")
    st=[]
    print(""st: []"")
    i=0
    while i<(n):
        if not st:
            left.append(-1)
            print(""left.append(-1)"")
            st.append(i)
            print(""st.append(i)"")
            
        elif st and a[i]<a[st[-1]]:
            left.append(st[-1])
            print(""left.append(st[-1])"")
            st.append(i)
            print(""st.append(i)"")
        else:
            while st and a[i]>a[st[-1]]:
                st.pop()
                print(""st.pop()"")
                
            if not st:
                st.append(i)
                print(""st.append(i)"")
                left.append(-1)
                print(""left.append(-1)"")
                
            else:
                left.append(st[-1])
                print(""left.append(st[-1])"")
                st.append(i)
                print(""st.append(i)"")
                
                
        i+=1
    print(""left: "", str(left))
    right=[]
    print(""right: []"")
    st=[]
    print(""st: []"")
    i=n-1
    while i>(-1):
        if not st:
            right.append(n)
            print(""right.append(n)"")
            st.append(i)
            print(""st.append(i)"")
            
        elif st and a[i]>a[st[-1]]:
            right.append(st[-1])
            print(""right.append(st[-1])"")
            st.append(i)
            print(""st.append(i)"")
        else:
            while st and a[i]<a[st[-1]]:
                st.pop()
                print(""st.pop()"")
                
            if not st:
                st.append(i)
                print(""st.append(i)"")
                right.append(n)
                print(""right.append(n)"")
                
            else:
                right.append(st[-1])
                print(""right.append(st[-1])"")
                st.append(i)
                print(""st.append(i)"")
                
                
        i-=1
    print(""right: "", str(right[::-1]))
    c=0
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        print(""x: "", str(x))
        if x==0:
            c+=a[i]
            print(""c+=a[i]"")
        else:
            c+=x
            print(""c+=x"")
    print(""c: "", str(c))
    print(""a: "", str(a))
    print(""left: "", str(left))
    print(""right: "", str(right))
            
    return c


def solve2(a, n): 
    left=[]
    print(""left: []"")
    st=[]
    print(""st: []"")
    i=0
    while i<(n):
        if not st:
            left.append(-1)
            print(""left.append(-1)"")
            st.append(i)
            print(""st.append(i)"")
            
        elif st and a[i]>a[st[-1]]:
            left.append(st[-1])
            print(""left.append(st[-1])"")
            st.append(i)
            print(""st.append(i)"")
        else:
            while st and a[i]<a[st[-1]]:
                st.pop()
                print(""st.pop()"")
                
            if not st:
                st.append(i)
                print(""st.append(i)"")
                left.append(-1)
                print(""left.append(-1)"")
                
            else:
                left.append(st[-1])
                print(""left.append(st[-1])"")
                st.append(i)
                print(""st.append(i)"")
                
                
        i+=1
    print(""left: "", str(left))
    right=[]
    print(""right: []"")
    st=[]
    print(""st: []"")
    i=n-1
    while i>(-1):
        if not st:
            right.append(n)
            print(""right.append(n)"")
            st.append(i)
            print(""st.append(i)"")
            
        elif st and a[i]>a[st[-1]]:
            right.append(st[-1])
            print(""right.append(st[-1])"")
            st.append(i)
            print(""st.append(i)"")
        else:
            while st and a[i]<=a[st[-1]]:
                st.pop()
                print(""st.pop()"")
                
            if not st:
                st.append(i)
                print(""st.append(i)"")
                right.append(n)
                print(""right.append(n)"")
                
            else:
                right.append(st[-1])
                print(""right.append(st[-1])"")
                st.append(i)
                print(""st.append(i)"")
                
                
        i-=1
    print(""right: "", str(right[::-1]))
    c=0
    for i in range(len(left)):
        x=(right[i]-i)*(i-left[i])*a[i]
        print(""x: "", str(x))
        if x==0:
            c+=a[i]
            print(""c+=a[i]"")
        else:
            c+=x
            print(""c+=x"")
    print(""c: "", str(c))
    print(""a: "", str(a))
    print(""left: "", str(left))
    print(""right: "", str(right))
            
    return c


n=int(input())
arr=[int(x) for x in input().split()]
print(""n: "", str(n))
print(""arr: "", str(arr))
# print(solve2(arr,n))
# print(solve1(arr,n))
# print()
# (solve2(arr,n))

print(""Result: "", str(solve1(arr,n)-solve2(arr,n)))
</ans>",0,{}
93," <ans>
import math
N=int(input())

def get_circle_2p(p1,p2):
 print(""p1: "", str(p1), ""p2: "", str(p2))
 x1,y1=p1
 x2,y2=p2
 x=(x1+x2)/2
 y=(y1+y2)/2
 r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
 return x,y,r

def get_circle_3p(p1,p2,p3):
 print(""p1: "", str(p1), ""p2: "", str(p2), ""p3: "", str(p3))
 x1,y1=p1
 x2,y2=p2
 x3,y3=p3
 d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))

 if d==0:
 rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
 rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2
 rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2

 if rad1>=rad2 and rad1>=rad3:
 x=(x1+x2)/2
 y=(y1+y2)/2
 return x,y,rad1
 elif rad2>=rad1 and rad2>=rad3:
 x=(x1+x3)/2
 y=(y1+y3)/2
 return x,y,rad2
 elif rad3>=rad1 and rad3>=rad2:
 x=(x2+x3)/2
 y=(y2+y3)/2
 return x,y,rad3

 xylist=[]
 for i in range(N):
 print(""xylist[{}]: "".format(i), str(xylist[i])) if i < N else None,
 xi,yi=map(int,input().split())
 xylist.append((xi,yi))

 if N==2:
 x,y,r=get_circle_2p(xylist[0],xylist[1])
 print(""r: "", r)
 else:
 min_radius=float(""inf"")
 for i in range(N):
 for j in range(i+1,N):
 x,y,r=get_circle_2p(xylist[i],xylist[j])
 if r>min_radius:
 continue
 for l in range(N):
 if l==i or l==j:
 continue
 xl,yl=xylist[l]
 diff_xl=xl-x
 diff_yl=yl-y
 if math.sqrt(diff_xl**2+diff_yl**2)>r:
 break
 else:
 min_radius=r

 for i in range(N):
 for j in range(i+1,N):
 for k in range(j+1,N):
 x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])
 if r>min_radius:
 continue
 for l in range(N):
 if l==i or l==j or l==k:
 continue
 xl,yl=xylist[l]
 diff_xl=xl-x
 diff_yl=yl-y
 if math.sqrt(diff_xl**2+diff_yl**2)>r:
 break
 else:
 min_radius=r
 print(""min_radius: "", min_radius)
</ans>",0,{}
94," <ans>
import math
from decimal import Decimal
import heapq
from collections import deque

def na():
 print(""n: "", n, ""b: "", b)
 n = int(input())
 b = [int(x) for x in input().split()]
 return n,b

 def nab():
 print(""n: "", n, ""b: "", b, ""c: "", c)
 n = int(input())
 b = [int(x) for x in input().split()]
 c = [int(x) for x in input().split()]
 return n,b,c

 def dv():
 print(""n: "", n, ""m: "", m)
 n, m = list(map(int, input().split()))
 return n,m

 def dva():
 print(""n: "", n, ""m: "", m, ""a: "", a, ""b: "", b)
 n, m = list(map(int, input().split()))
 a = [int(x) for x in input().split()]
 b = [int(x) for x in input().split()]
 return n,m,a,b

 def eratosthenes(n):
 print(""sieve: "", sieve)
 sieve = list(range(n + 1))
 for i in sieve:
 if i > 1:
 for j in range(i + i, len(sieve), i):
 sieve[j] = 0
 return sorted(set(sieve))

 def lol(lst,k):
 print(""lst: "", lst, ""k: "", k, ""ret: "", ret)
 k=k%len(lst)
 ret=[0]*len(lst)
 for i in range(len(lst)):
 if i+k<len(lst) and i+k>=0:
 ret[i]=lst[i+k]
 if i+k>=len(lst):
 ret[i]=lst[i+k-len(lst)]
 if i+k<0:
 ret[i]=lst[i+k+len(lst)]
 return(ret)

 def nm():
 print(""n: "", n, ""b: "", b, ""m: "", m, ""c: "", c)
 n = int(input())
 b = [int(x) for x in input().split()]
 m = int(input())
 c = [int(x) for x in input().split()]
 return n,b,m,c

 def dvs():
 print(""n: "", n, ""m: "", m)
 n = int(input())
 m = int(input())
 return n, m

 def fact(a, b):
 print(""a: "", a, ""b: "", b, ""c: "", c, ""l: "", l, ""ans: "", ans)
 c = []
 ans = 0
 f = int(math.sqrt(a))
 for i in range(1, f + 1):
 if a % i == 0:
 c.append(i)
 l = len(c)
 for i in range(l):
 if c[i] <= b:
 ans += 1
 if a / f == f and b >= f:
 return ans - 1
 return ans

 t = int(input())
 for i in range(t):
 x, y = list(map(int, input().split()))
 print(""x: "", x, ""y: "", y)
 if x >= y:
 print('YES')
 continue
 if x == 2 and y == 3:
 print('YES')
 continue
 if x <= 3 and y > 3:
 print('NO')
 continue
 if x == 1:
 print('NO')
 else:
 print('YES')
</ans>",0,{}
95," <ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(x) for x in input().split(' ')]

print(""n: "", n, ""m: "", m, ""k: "", k)

s = [None]*n
for i in range(n):
 s[i] = [None]*m
 print(""s[{}]: "".format(i))
 for j in range(m):
 s[i][j] = input()[j]
 if s[i][j] == 'X': x, y = j, i

def bfs(x, y):
 res = [[10000000]*m for i in range(n)]
 print(""res: "", res)
 if s[y][x] == '*': return res
 q = Queue()
 q.put((x, y))
 step = 0

 def add(x, y):
 if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return
 q.put((x, y))
 res[y][x] = step+1

 res[y][x] = step

 while not q.empty():
 x, y = q.get()
 step = res[y][x]
 #print('-')
 if y < n-1: add(x, y+1) #D
 if x > 0: add(x-1, y)   #L
 if x < m-1: add(x+1, y) #R
 if y > 0: add(x, y-1)   #U
 print(""step: "", step, ""x: "", x, ""y: "", y)

 return res

res = bfs(x, y)

path = []
add = lambda s: path.append(s)
for i in range(k):
 step = k-i
 print(""step: "", step)
 if y < n-1 and res[y+1][x] <= step: #D
 print(""y+1: "", y+1)
 add('D')
 y = y+1
 elif x > 0 and res[y][x-1] <= step: #L
 print(""x-1: "", x-1)
 add('L')
 x = x-1
 elif x < m-1 and res[y][x+1] <= step: #R
 print(""x+1: "", x+1)
 add('R')
 x = x+1
 elif y > 0 and res[y-1][x] <= step: #U
 print(""y-1: "", y-1)
 add('U')
 y = y-1
 else:
 print('IMPOSSIBLE')
 return

print(""path: "", path)

</ans>",0,{}
96," <ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

inf = float('inf')
Edge = namedtuple('Edge', 'start, end, cost')

def make_edge(start, end, cost=1):
 return Edge(start, end, cost)

class Graph:
 def __init__(self, edges, bi=True):
 wrong_edges = [i for i in edges if len(i) not in [2, 3]]
 if wrong_edges:
 raise ValueError('Wrong edges data: {}'.format(wrong_edges))
 self.edges = [make_edge(*edge) for edge in edges]
 self.vertices = set(
 sum(
 [edge.start, edge.end] for edge in self.edges
 ), {}
 )
 self.neighbors = {vertex: set() for vertex in self.vertices}
 for edge in self.edges:
 self.neighbors[edge.start].add(edge.end)
 self.neighbors[edge.end].add(edge.start)

 def get_node_pairs(self, n1, n2, both_ends=True):
 if both_ends:
 node_pairs = [[n1, n2], [n2, n1]]
 else:
 node_pairs = [[n1, n2]]
 return node_pairs

 def remove_edge(self, n1, n2, both_ends=True):
 node_pairs = self.get_node_pairs(n1, n2, both_ends)
 edges = self.edges[:]
 for edge in edges:
 if [edge.start, edge.end] in node_pairs:
 self.edges.remove(edge)
 self.neighbors[edge.start] = self.neighbors[edge.start] - {edge.end}
 self.neighbors[edge.end] = self.neighbors[edge.end] - {edge.start}

 def add_edge(self, n1, n2, cost=1, both_ends=True):
 node_pairs = self.get_node_pairs(n1, n2, both_ends)
 for edge in self.edges:
 if [edge.start, edge.end] in node_pairs:
 return ValueError('Edge {} {} already exists'.format(n1, n2))
 self.edges.append(Edge(start=n1, end=n2, cost=cost))
 self.edges.append(Edge(start=n2, end=n1, cost=cost))
 self.neighbors[n1] = self.neighbors[n1] | {n2}
 self.neighbors[n2] = self.neighbors[n2] | {n1}

 def dijkstra(self, source, dest):
 assert source in self.vertices, 'Such source node doesn\'t exist'
 distances = {vertex: inf for vertex in self.vertices}
 distances[source] = 0

 q, seen = [(0, source)], set()
 while q:
 curr_cost, current_vertex = heappop(q)
 if current_vertex in seen:
 continue
 seen.add(current_vertex)
 for neighbor in self.neighbors[current_vertex]:
 cost = 1
 if neighbor in seen:
 continue
 alternative_route = distances[current_vertex] + cost
 if alternative_route < distances[neighbor]:
 distances[neighbor] = alternative_route
 heappush(q, (alternative_route, neighbor))

 return distances

n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]

verts = []
for i in range(m):
 print(""verts: "", verts)
 verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
rev_verts = []
for i in verts:
 print(""rev_verts: "", rev_verts)
 rev_verts.append((i[1], i[0]))
for i in rev_verts:
 print(""verts: "", verts)
 verts.append(i)
graph = Graph(verts)
print(""graph: "", graph)
s_dist = graph.dijkstra(s, t)
print(""s_dist: "", s_dist)
t_dist = graph.dijkstra(t, s)
print(""t_dist: "", t_dist)
SHORTEST_DIST = s_dist[t]
count = 0

for i in range(1, n + 1):
 for j in range(i + 1, n + 1):
 if j not in graph.neighbors[i] and \
 i not in graph.neighbors[j] and \
 s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \
 s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:
 count = count + 1
print(""count: "", count)
</ans>",0,{}
97," <ans>
N, K = readInts()
print(""N: "", N, ""K: "", K)

ans = 0
for AB in range(2*N+1):
 print(""AB: "", AB)
 calc_AB = calc(AB)
 print(""calc_AB: "", calc_AB)
 calc_AB_minus_K = calc(AB-K)
 print(""calc_AB_minus_K: "", calc_AB_minus_K)
 ans += calc_AB * calc_AB_minus_K
</ans>",0,{}
98," <ans>
import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline ####

def int1(x): return int(x) - 1
def II(): return int(input())
def MI(): return list(map(int, input().split()))
def MI1(): return list(map(int1, input().split()))
def LI(): return list(map(int, input().split()))
def LI1(): return list(map(int1, input().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def MS(): return input().split()
def LS(): return list(input())
def LLS(rows_number): return [LS() for _ in range(rows_number)]
def printlist(lst, k=' '): print((k.join(list(map(str, lst)))))
INF = float('inf')
# from math import ceil, floor, log2
# from collections import deque
from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum # accumulate

print(""N: "", II())
print(""K: "", II())
A = LI()
print(""A: "", A)
M = sum(A)
print(""M: "", M)
divs = []
print(""divs: []"")
for i in range(1, int(pow(M, 0.5))+1):
 if M % i: continue
 divs.append(i)
 print(""divs: "", divs)
 if i != M//i: divs.append(M//i)
 divs.sort(reverse=True)
 print(""divs: "", divs)

for d in divs:
 B = list([x%d for x in A])
 print(""B: "", B)
 B.sort()
 C = list([d-x for x in B])
 print(""C: "", C)
 Ba = list(accumulate(B))
 print(""Ba: "", Ba)
 Ca = list(accumulate(C))
 print(""Ca: "", Ca)
 for i in range(0, N-1):
 b = Ba[i]
 c = Ca[-1] - Ca[i]
 print(""b: "", b)
 print(""c: "", c)
 if b == c and b <= K:
 print(""d: "", d)
 return
 print(""1"")
</ans>",0,{}
99," <ans>
import sys

def matching(node, visited, adj, assigned):
# ... (no new variables are defined here)

INF = 1000 * 1000

inp = [int(x) for x in sys.stdin.read().split()]
print(""inp: "", str(inp))

n, m = inp[0], inp[1]
inp_idx = 2

G = [[INF] * n for _ in range(n)]
print(""G: "", str(G))

for _ in range(m):
// ... (no new variables are defined here)

for v in range(n):
// ... (no new variables are defined here)

for k in range(n): :
// ... (no new variables are defined here)

s, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]
inp_idx += 4

spaceships = []
for _ in range(s):
x, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]
inp_idx += 3
spaceships.append((x, a, f))
print(""spaceships: "", str(spaceships))

bases = []
for _ in range(b):
x, d = inp[inp_idx] - 1, inp[inp_idx + 1]
inp_idx += 2
bases.append((x, d))
print(""bases: "", str(bases))

adj = [[] for _ in range(s)]
assigned = [[] for _ in range(b)]
for i in range(s):
space = spaceships[i]
print(""space: "", str(space))
for j in range(b):
base = bases[j]
u, v = space[0], base[0]
fuel = space[2]
if G[u][v] <= fuel and space[1] >= base[1]:
adj[i].append(j)

visited = [False] * s
assigned = [-1] * b

matched = 0
for i in range(s):
visited = [False] * s
if matching(i, visited, adj, assigned):
matched += 1
print(""matched: "", str(matched))

print(min(matched * k, h * s))
</ans>",0,{}
100," <ans>
import sys

inp = sys.stdin.readline
input = lambda: inp().strip()

def iin(): return int(input())

def lin(): return list(map(int, input().split()))

def main():
 import heapq as hq
 n = iin()
 a = lin()
 t = lin()
 dc = {}
 print(""dc: "", str(dc))
 for i in range(n):
 try:
 dc[a[i]].append(t[i])
 except:
 dc[a[i]] = [t[i], ]
 print(""dc after defining a[i]: "", str(dc))
 # print(dc)
 sa = list(dc.keys())
 sa.sort()
 n = len(sa)
 ch = 0
 pt = sa[ch]
 temp = []
 sm = 0
 ans = 0
 hq.heapify(temp)
 done = 0
 while ch < n:
 # print(""temp: "", str(temp), ""sa[ch]: "", str(sa[ch]))
 pt = sa[ch]
 if len(dc[pt]) > 1 or done:
 a1 = sorted(dc[pt])
 for item in a1:
 hq.heappush(temp, -item)
 sm += item
 print(""sm: "", sm, ""temp: "", temp)
 x = hq.heappop(temp) * (-1)
 dc[pt] = [x]
 sm -= x
 while len(temp):
 ans += sm
 pt += 1
 if pt in dc:
 ch += 1
 done = 1
 break
 else:
 x = hq.heappop(temp) * (-1)
 sm -= x
 print(""sm: "", sm)
 print(""ans: "", ans)
 else:
 ch += 1
 done = 0
 print(""ans: "", ans)

main()
</ans>",0,{}
101," <ans>
for _ in range(ii()):
 print(""_: "", _)
 a, b = mi()
 print(""a: "", a, ""b: "", b)
 print(b - a % b) if a % b else print(0)
</ans>

This will print out the value of `_`, `a` and `b` at the beginning of each iteration of the for loop.",0,{}
102," <ans>
def add(a,b):
	a = a%(1000000000+7)
	print(""a: "", str(a))
	b=b%(1000000000+7)
	print(""b: "", str(b))
	return (a+b)%(1000000000+7)

n =int(input())
print(""n: "", str(n))
i=1
print(""i: "", str(i))
statements = []
print(""statements: "", str(statements))

dp = [[0 for i in range(n)] for i in range(n)]
print(""dp: "", str(dp))
prefix = [[0 for i in range(n)] for i in range(n)]
print(""prefix: "", str(prefix))

i=1
print(""i: "", str(i))
while(i<=n):
	s = input()
	print(""s: "", str(s))
	statements.append(s)
	print(""statements: "", str(statements))
	i+=1

dp[0][0]=1
print(""dp[0][0]: "", str(dp[0][0]))
prefix[0][0]=1
print(""prefix[0][0]: "", str(prefix[0][0]))
j=1
print(""j: "", str(j))
while(j<n):
	dp[0][j]=0
	print(""dp[0][j]: "", str(dp[0][j]))
	prefix[0][j] = dp[0][j] + prefix[0][j-1]
	print(""prefix[0][j]: "", str(prefix[0][j]))
	j+=1

i=1
print(""i: "", str(i))
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		print(""j: "", str(j))
		while(j<n):
			dp[i][0]=0
			print(""dp[i][0]: "", str(dp[i][0]))
			prefix[i][0]=0
			print(""prefix[i][0]: "", str(prefix[i][0]))
			dp[i][j] = dp[i-1][j-1]
			print(""dp[i][j]: "", str(dp[i][j]))
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			print(""prefix[i][j]: "", str(prefix[i][j]))
			j+=1
	else:
		j=0
		print(""j: "", str(j))
		while(j<n):
			if(j==0):
				dp[i][j] = prefix[i-1][n-1]
				print(""dp[i][j]: "", str(dp[i][j]))
			else:
				dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
				print(""dp[i][j]: "", str(dp[i][j]))
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			print(""prefix[i][j]: "", str(prefix[i][j]))
			j+=1
	# print(prefix)
	i+=1

ans = 0
print(""ans: "", str(ans))
j=0
print(""j: "", str(j))
while(j<n):
	ans=add(ans,dp[n-1][j])
	print(""ans: "", str(ans))
	j+=1

print(""ans%(1000000000+7): "", str(ans%(1000000000+7)))
</ans>",0,{}
103," <ans>
def compute():
    n, m = [int(s) for s in input().split()]
    print(""n, m: "", str(n), str(m))
    p = {}
    print(""p: "", str(p))
    for i in range(m):
        u, v = [int(s) for s in input().split()]
        print(""u, v: "", str(u), str(v))
        if u > v:
            if p.get(u) == 2:
                return 0
            if p.get(v) == 1:
                return 0
            p[u] = 1
            p[v] = 2
        else:
            if p.get(v) == 2:
                return 0
            if p.get(u) == 1:
                return 0
            p[v] = 1
            p[u] = 2
    div1, div2 = [], []
    print(""div1, div2: "", str(div1), str(div2))
    for k, v in list(p.items()):
        print(""k, v: "", str(k), str(v))
        if v == 1:
            div1.append(k)
        else:
            div2.append(k)
    p_left = [i for i in range(1, n + 1) if i not in p]
    print(""p_left: "", str(p_left))
    if not div1:
        if p_left:
            div1.append(p_left[-1])
            p_left.remove(p_left[-1])
        else:
            return 0
    if not div2:
        if p_left:
            div2.append(p_left[0])
            p_left.remove(p_left[0])
        else:
            return 0
    div1_easiest = min(div1)
    div2_hardest = max(div2)
    print(""div1_easiest, div2_hardest: "", str(div1_easiest), str(div2_hardest))
    if div2_hardest > div1_easiest:
        return 0

    res = 1
    for i in range(len(p_left)):
        print(""i: "", str(i), ""p_left[i]: "", str(p_left[i]))
        if p_left[i] > div1_easiest:
            pass
        elif p_left[i] < div2_hardest:
            pass
        else:
            res += 1

    return res
res = compute()
print(""res: "", str(res))
</ans>",0,{}
104," <ans>
import itertools

SolutionImpossible = Exception()

blocks\_cnt, finish, min\_sprint, max\_jump = [int(x) for x in input().split()]

print(""blocks\_cnt: "", str(blocks\_cnt))
print(""finish: "", str(finish))
print(""min\_sprint: "", str(min\_sprint))
print(""max\_jump: "", str(max\_jump))

def read\_blocks\_coords():
it = (int(x) for x in input().split())
return (x for x in it if x < finish)

print(""read\_blocks\_coords: "", str(list(read\_blocks\_coords())[:10]))

def _grouper(value):
if _grouper._prev\_value is not None:
if value - _grouper._prev\_value - 1 <= min\_sprint:
_current\_key = _grouper._current\_key
else:
_current\_key = id(value)

_grouper._prev\_value = value
_grouper._current\_key = _current\_key

return _current\_key

_grouper._prev\_value = None
_grouper._current\_key = None

print(""_grouper: "", str(_grouper))

def check\_chunk(run\_from, block=None):
if block is None:
return

next\_run\_from = block[-1] + 1
if next\_run\_from - block[0] >= max\_jump:
raise SolutionImpossible

if abs(run\_from - block[0]) <= min\_sprint:
raise SolutionImpossible

print(""check\_chunk: run\_from: "", str(run\_from), ""block: "", str(block))

def solve\_chunk(run\_from, block=None):
if block is not None:
run\_len = block[0] - run\_from - 1
jump\_len = block[-1] - block[0] + 2
print((
""RUN {run\_len}\n""
""JUMP {jump\_len}"".format(
run\_len=run\_len,
jump\_len=jump\_len,
)
))

else:
run\_len = finish - run\_from
if run\_len > 0:
print(""RUN {run\_len}"".format(run\_len=run\_len))

def main():
blocks = (list(g) for k, g in itertools.groupby(sorted(read\_blocks\_coords(), key=_grouper)))

run\_from = 0
chunks = []

while True:
block = next(blocks, None)

chunk = (run\_from, block)
check\_chunk(*chunk)

chunks.append(chunk)

if block is None:
break

run\_from = block[-1] + 1

for chunk in chunks:
solve\_chunk(*chunk)

print(""chunks: "", str(chunks))

__starting\_point()
</ans>",0,{}
105," <ans>
#import sys
#sys.stdin = open('in.txt', 'r')
#sys.setrecursionlimit(10000)

def isPrefix(sa, sb):
print(""sa: "", str(sa), ""sb: "", str(sb))
if len(sa) <= len(sb):
return False
return sa[0:len(sb)] == sb

def getOrder(sa, sb):
print(""sa: "", str(sa), ""sb: "", str(sb))
for i in range(0, min(len(sa), len(sb))):
if sa[i] != sb[i]:
return sa[i], sb[i]

test = False
if test:
print(""test: "", str(test))
fp = open(""in.txt"", 'r')
n = int(fp.readline().strip())
print(""n: "", str(n))
names = [fp.readline().strip() for i in range(0, n)]
print(""names: "", str(names))
fp.close()
else:
n = int(input().strip())
print(""n: "", str(n))
names = [input().strip() for i in range(0, n)]
print(""names: "", str(names))

g = [[False] * 26 for i in range(0, 26)]
print(""g: "", str(g))

res = True
for i in range(1, n):
if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):
continue
elif isPrefix(names[i - 1], names[i]):
res = False
break
else:
ca, cb = getOrder(names[i - 1], names[i])
print(""ca: "", str(ca), ""cb: "", str(cb))
if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:
res = False
break
else:
g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True

def printG():
print(""   abcdefghijklmnopqrstuvwxyz"")
for i in range(0, 26):
print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in g[i]]), sep = """")
printG()

if not res:
print(""Impossible"")
else:
def getZeroIndegreeNode():
print(""getZeroIndegreeNode:"")
for i in range(0, 26):
if not used[i] and indegree[i] == 0:
return i
return -1

theOrder = []
indegree = [0] * 26
used = [False] * 26

#calc indegree
for i in range(0, 26):
ithIndegree = 0
for j in range(0, 26):
if g[j][i]: ithIndegree += 1
indegree[i] = ithIndegree
print(""indegree: "", str(indegree))

#topo sort
for i in range(0, 26):
zeroIndegreeNode = getZeroIndegreeNode()
if zeroIndegreeNode == -1:
res = False
break
else:
used[zeroIndegreeNode] = True
theOrder.append(chr(ord('a') + zeroIndegreeNode))
for j in range(0, 26):
if g[zeroIndegreeNode][j]:
indegree[j] -= 1
print(""theOrder: "", str(theOrder))
if not res:
print(""Impossible"")
else:
print("""".join(theOrder))
</ans>",0,{}
106," <ans>
#!/usr/bin/env python3

class UnionFind:
 # 作りたい要素数nで初期化
 # 使用するインスタンス変数の初期化
 def __init__(self, n):
 print(""n: "", str(n))
 self.n = n
 self.root = [-1] * (n + 1)
 self.rnk = [0] * (n + 1)

 # ノードxのrootノードを見つける
 def Find_Root(self, x):
 if self.root[x] < 0:
 return x
 else:
 # ここで代入しておくことで、後の繰り返しを避ける
 self.root[x] = self.Find_Root(self.root[x])
 return self.root[x]

 # 木の併合、入力は併合したい各ノード
 def Unite(self, x, y):
 print(""x: "", str(x), ""y: "", str(y))
 x = self.Find_Root(x)
 y = self.Find_Root(y)
 if x == y:
 return
 elif self.rnk[x] > self.rnk[y]:
 self.root[x] += self.root[y]
 self.root[y] = x

 else:
 self.root[y] += self.root[x]
 self.root[x] = y
 if self.rnk[x] == self.rnk[y]:
 self.rnk[y] += 1

 # xとyが同じグループに属するか判断
 def isSameGroup(self, x, y):
 return self.Find_Root(x) == self.Find_Root(y)

 # ノードxが属する木のサイズを返す
 def Count(self, x):
 return -self.root[self.Find_Root(x)]

def main():
 n, m = list(map(int, input().split()))
 print(""n: "", str(n), ""m: "", str(m))
 uf = UnionFind(n)

 for i in range(m):
 a, b = list(map(int, input().split()))
 uf.Unite(a, b)
 print(""After Unite(a, b):"")
 print(uf.root)

 for i in range(n):
 i += 1
 uf.isSameGroup(i, i)
 print(""After isSameGroup(i, i):"")
 print(uf.root)

 ans = 0
 for i in range(n):
 i += 1
 ans = max(ans, -uf.root[i + 1])
 print(""Answer:"")
 print(ans)

main()
</ans>",0,{}
107," <ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7

def isprime(n):
 n = abs(int(n))
 print(""n: "", n)
 if n < 2:
 return False
 if n == 2:
 return True
 if not n & 1:
 return False
 for x in range(3, int(n**0.5) + 1, 2):
 if n % x == 0:
 return False
 print(""n is prime: "", True)
 return True

def mhd(a,b):
 print(""mhd: "", abs(a[0]-b[0])+abs(b[1]-a[1]))
 return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
 print(""charIN: "", sys.stdin.readline().strip().split(x))
 return sys.stdin.readline().strip().split(x)

def arrIN(x = ' '):
 print(""arrIN: "", list(map(int,sys.stdin.readline().strip().split(x))))
 return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
 a = y[0]-x[0]
 b = x[1]-y[1]
 print(""eld: "", (a*a+b*b)**0.5)
 return (a*a+b*b)**0.5

def lgcd(a):
 g = a[0]
 for i in range(1,len(a)):
 g = math.gcd(g,a[i])
 print(""g: "", g)
 return g

def ms(a):
 msf, st, en = 0, 0, 0
 meh = 0
 for i in range(len(a)):
 meh+=a[i]
 print(""meh: "", meh)
 if msf<meh:
 msf = meh
 st = be = i
 print(""msf, st, be: "", msf, st, be)
 return msf,st,en

def ncr(n,r):
 num=den=1
 for i in range(r):
 num = (num*(n-i))%MOD
 den = (den*(i+1))%MOD
 print(""num, den: "", num, den)
 return (num*(pow(den,MOD-2,MOD)))%MOD

def flush():
 return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
 a,b,c = arrIN()
 print(""a,b,c: "", a,b,c)
 print(""(a+b+c)//2: "", (a+b+c)//2)
</ans>",0,{}
108," <ans>
n = int(input())
print(""n: "", str(n))
s = input()
print(""s: "", str(s))

flag = True
if n == 1:
print(""flag: "", str(flag))
if n == 1:
if s == '0':
print(""pow(10, 10): "", str(pow(10, 10)))
elif s == '1':
print(""pow(10, 10) * 2: "", str(pow(10, 10) * 2))
elif n == 2:
print(""flag: "", str(flag))
if n == 2:
if s in ['11', '10']:
print(""pow(10, 10): "", str(pow(10, 10)))
elif s == '01':
print(""pow(10, 10) - 1: "", str(pow(10, 10) - 1))
else:
print(""0: "", str(0))
else:
print(""flag: "", str(flag))
flag = True
f = n // 3
r = n % 3
print(""f: "", str(f))
print(""r: "", str(r))
for i in range(0, n, 3):
if i == 0:
ans = s[0:3]
print(""ans: "", str(ans))
if i < 3 * f:
tmp = s[i:i + 3]
print(""tmp: "", str(tmp))
if i >= 3 * f:
tmp = s[i:n]
print(""tmp: "", str(tmp))
if ans not in ['110', '101', '011']:
print(""flag: False"")
flag = False
break
if tmp != ans[0:n - i]:
print(""flag: False"")
flag = False
break
if not flag:
print(""0: "", str(0))
else:
if ans == '110':
print(""r: "", str(r))
if r == 0:
print(""pow(10, 10) - f + 1: "", str(pow(10, 10) - f + 1))
else:
print(""pow(10, 10) - f: "", str(pow(10, 10) - f))
elif ans == '101':
print(""pow(10, 10) - f: "", str(pow(10, 10) - f))
elif ans == '011':
print(""r: "", str(r))
if r < 2:
print(""pow(10, 10) - f: "", str(pow(10, 10) - f))
else:
print(""pow(10, 10) - f - 1: "", str(pow(10, 10) - f - 1))
</ans>",0,{}
109," <ans>
import sys
from math import *

def minp():
 print(""minp: "",) # no return value, so no variable is defined
 return sys.stdin.readline().strip()

def mint():
 print(""mint: "",)
 return int(minp())

def mints():
 print(""mints: "",)
 return list(map(int, minp().split()))

def gcd(a,b):
 print(""gcd: a: "", a, "" b: "", b)
 while b != 0:
 a,b = b,a%b
 print(""gcd: a: "", a)
 return a

def stupid(x):
 print(""stupid: x: "", x)
 r = 1
 for i in range(1, x):
 print(""stupid: i: "", i, "" r: "", r)
 r = max(r, gcd(i&x, i^x))
 print(""stupid: r: "", r)
 return r

d = {} # Python dictionary, no need to print since it's not a variable
d[511] = 73
d[2047] = 89
d[32767] = 4681
d[2097151] = 299593
d[8388607] = 178481
d[33554431] = 1082401

def smart(x):
 print(""smart: x: "", x)
 if x in d:
 print(""smart: x is in d: "", d[x])
 return d[x]
 if (x & (x+1)) == 0:
 i = 0
 while ((1<<i)-1) != x:
 i += 1
 if i % 2 == 0:
 z = 0
 for i in range(0,i,2):
 z += (1<<i)
 print(""smart: z: "", z)
 return z
 else:
 i = 1
 z = 0
 while i < x:
 if (i & x) == 0:
 z += i
 i *= 2
 print(""smart: z: "", z)
 return x+z

q = mint()
print(""q: "", q)
for i in range(q):
 x = mint()
 print(""x: "", x)
 print(""smart: x: "", smart(x))
 #if (x & (x+1)) == 0:
 # a = stupid(x)
 # b = smart(x)
 # if a != b:
 # print(""x, a, b: "", x, a, b)
</ans>",0,{}
110," <ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 1000010
MOD = 10**9+7
spf = [i for i in range(MAXN)]
spf[0]=spf[1] = -1
def sieve():
    print(""spf: "", spf)
    for i in range(2,MAXN,2):
        print(""i: "", i)
        spf[i] = 2
    for i in range(3,int(MAXN**0.5)+1):
        if spf[i]==i:
            for j in range(i*i,MAXN,i):
                print(""j: "", j)
                if spf[j]==j:
                    spf[j]=i
def fib(n,m):
    print(""n, m: "", n, m)
    if n == 0:
        return [0, 1]
    else:
        a, b = fib(n // 2)
        print(""a, b: "", a, b)
        c = ((a%MOD) * ((b%MOD) * 2 - (a%MOD)))%MOD
        d = ((a%MOD) * (a%MOD))%MOD + ((b)%MOD * (b)%MOD)%MOD
        print(""c, d: "", c, d)
        if n % 2 == 0:
            return [c, d]
        else:
            return [d, c + d]
 
def charIN(x= ' '):
    print(""x: "", x)
    return(sys.stdin.readline().strip().split(x))
 
def arrIN(x = ' '):
    print(""x: "", x)
    return list(map(int,sys.stdin.readline().strip().split(x)))
 
def ncr(n,r):
    num=den=1
    print(""n, r: "", n, r)
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD
 
    print(""num, den: "", num, den)
 
    return (num*(pow(den,MOD-2,MOD)))%MOD
 
def flush():
    return sys.stdout.flush()
 
'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    n = int(input())
    print(""n: "", n)
    if n%2:
        print(""n//2: "", n//2)
    else:
        print(""n//2-1: "", n//2-1)
</ans>",0,{}
111," <ans>
from math import log
from decimal import Decimal

def a1(x, y, z):
 print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
 return (y ** z) * Decimal(log(x))

def s1(x, y, z):
 print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
 return ""x^y^z""

# ... (same for other functions a2 to s12)

x, y, z = list(map(Decimal, input().split()))
print(""x: "", str(x), ""y: "", str(y), ""z: "", str(z))
ans = s1(x, y, z)
a = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]
s = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]
max = a1(x, y, z)
for i in range (12):
 print(""Function i: "", str(i))
 x_new, y_new, z_new = x, y, z # new variables for function call
 print(""x: "", str(x_new), ""y: "", str(y_new), ""z: "", str(z_new))
 result = a[i](x_new, y_new, z_new)
 print(""Result: "", str(result))
 if max < result:
 ans = s[i](x_new, y_new, z_new)
 max = result
print(""Answer: "", ans)
</ans>",0,{}
112," <ans>
s = input()

cur_len = 1
a = []
char = []
print(""s: "", str(s))
for i in range(1, len(s)):
 if s[i] == s[i-1]: cur_len += 1
 else:
 a.append(cur_len)
 print(""cur_len: "", cur_len)
 char.append(s[i-1])
 cur_len = 1
 a.append(cur_len)
 char.append(s[len(s)-1])

ans = 0
while len(a) > 1:
 n = len(a)
 inner_min = 100000000
 for i in range(1,n-1):
 if a[i] < inner_min: inner_min = a[i]
 print(""a: "", a, ""; inner_min: "", inner_min)
 k = min(a[0], a[n-1],(inner_min + 1)//2)
 b = []
 new_char = []
 print(""k: "", k)
 for i in range(n):
 if i == 0 or i == n-1:
 if a[i] > k:
 b.append(a[i]-k)
 new_char.append(char[i])
 else:
 if a[i] > 2*k:
 b.append(a[i] - 2*k)
 new_char.append(char[i])
 print(""b: "", b)
 ans += k
 if len(b) > 1:
 c = [0]*n
 newnew_char = [new_char[0]]
 count = 0
 for i in range(0,len(b)-1):
 c[count] += b[i]
 if new_char[i] == new_char[i+1]: continue
 else:
 count += 1
 newnew_char.append(new_char[i+1])
 if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]
 else:
 newnew_char.append(new_char[i+1])
 c[count] = b[len(b)-1]
 a = c[:count+1]
 char = newnew_char[:]
 else:
 a = b[:]
 print(""ans: "", ans)
</ans>",0,{}
113," <ans>
a, r, l, m = list(map(int, input().split()))
print(""a: "", str(a), ""r: "", str(r), ""l: "", str(l), ""m: "", str(m))
_l = list(map(int, input().split()))
s = set(_l)
print(""_l: "", str(_l), ""s: "", str(s))
if abs(a) > l:
 print(0)
 return
if a == 0:
 if 0 in s:
 print(0)
 return
 else:
 print(""inf"")
 return
if r == 0:
 if a == 0:
 if 0 in s:
 print(0)
 return
 else:
 if a not in s:
 if abs(a) <= l:
 if 0 in s:
 print(1)
 return
 else:
 print(""inf"")
 return
if r == 1:
 if a in s or abs(a) > l:
 print(0)
 return
 else:
 print(""inf"")
 return
if r == -1:
 if a in s:
 if 0 - a in s:
 print(0)
 return
 else:
 if abs(a) <= l:
 print(""inf"")
 return
 else:
 print(0)
 return
tot = 0
print(""tot: "", str(tot))
while abs(a) <= l:
 if a not in s:
 tot += 1
 a *= r
 print(""a: "", str(a))
print(tot)
</ans>",0,{}
114," <ans>
import datetime
import sys
import copy
import functools
import collections
import itertools

class Solution:
 def __init__(self):
 self.N = 0
 self.boards = None

 def test(self):
 pass

 def readInput(self):
 print(""N: "", self.N)
 self.N = int(input())
 self.boards = []
 print(""Initial boards:"")
 for i in range(self.N):
 self.boards.append(list(input()))
 print(""Boards after reading input:"")
 print(self.boards)

 def readMockInput(self):
 pass

 def solve(self):
 N = self.N
 impossibleMoves = set()
 chesses = list()
 notAttacked = list()
 print(""chesses and notAttacked before recording impossible moves:"")
 print(""chesses: "", chesses)
 print(""notAttacked: "", notAttacked)
 # record all impossible moves
 for r in range(N):
 for c in range(N):
 if self.boards[r][c] == 'o':
 chesses.append((r, c))
 elif self.boards[r][c] == '.':
 notAttacked.append((r, c))
 print(""chesses and notAttacked after recording impossible moves:"")
 print(""chesses: "", chesses)
 print(""notAttacked: "", notAttacked)
 for r, c in chesses:
 for i, j in notAttacked:
 impossibleMoves.add((i-r, j-c))
 print(""impossibleMoves: "", impossibleMoves)

 # check whether there are any conflicts
 # reboard = [['.' for c in range(N)] for r in range(N)]
 # for r, c in chesses:
 #     reboard[r][c] = 'o'

 startTime = datetime.datetime.now()

 for i in range(N):
 for j in range(N):
 if self.boards[i][j] == 'o':
 continue
 for r, c in chesses:
 if (i-r, j-c) not in impossibleMoves:
 if self.boards[i][j] == '.':
 print('NO')
 return
 self.boards[i][j] = 'v'

 # for r, c in chesses:
 #     for i in range(-N+1, N):
 #         for j in range(-N+1, N):
 #             # much faster than 2 for
 #             if (i, j) not in impossibleMoves:
 #                 nr = r + i
 #                 nc = c + j
 #                 if 0 <= nr < N and 0 <= nc < N and self.boards[nr][nc] != 'o':
 #                     # reboard[nr][nc] = 'x'
 #
 #                     if self.boards[nr][nc] == '.':
 #                         print('NO')
 #                         return
 #                     self.boards[nr][nc] = 'v'
 if sum([row.count('x') for row in self.boards]) > 0:
 print('NO')
 return
 # for r in range(N):
 #     for c in range(N):
 #         if self.boards[r][c] != reboard[r][c]:
 #             print('NO')
 #             return
 print('YES')
 res = [['.' for c in range(2*N-1)] for r in range(2*N-1)]
 res[N-1][N-1] = 'o'
 for i in range(-N+1, N):
 for j in range(-N+1, N):
 if not (i == 0 and j == 0) and (i, j) not in impossibleMoves:
 res[i+N-1][j+N-1] = 'x'
 print('Final board:')
 for row in res:
 print(''.join(row))

 sys.stderr.write('Check Cost: {}\n'.format(datetime.datetime.now()-startTime))
</ans>",0,{}
115," <ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import copy
import decimal

class Scanner():
# ... (same as before)

def pop_count(x):
# ... (same as before)

def solve():
S = Scanner.string()
N = len(S)
K = Scanner.int()
dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]
print(""dp: "", dp)
dp[0][0][0] = 1
for i in range(N):
for j in range(4):
for k in range(2):
print(""i: "", i, ""j: "", j, ""k: "", k)
nd = int(S[i])
for d in range(10):
ni, nj, nk = i + 1, j, k
if d != 0:
nj += 1
if nj > K:
continue
if k == 0:
if d > nd:
continue
if d < nd:
nk += 1
dp[ni][nj][nk] += dp[i][j][k]
print(""dp[{}][{}][{}]: {}"".format(ni, nj, nk, dp[ni][nj][nk]))
print((dp[N][K][0] + dp[N][K][1]))

def main():
# ... (same as before)

def __starting_point():
main()

__starting_point()
</ans>",0,{}
116," <ans>
import heapq

INF = float('inf')
N, M = map(int, input().split())
to = [[] for _ in range(N)]
sides = [[0] * N for _ in range(N)]

print(""N: "", N, ""M: "", M)

for _ in range(M):
 print(""a, b, c: "", a, b, c)
 a, b = a - 1, b - 1
 to[a].append((c, b))
 to[b].append((c, a))
 sides[a][b] = 1
 sides[b][a] = 1

print(""to: "", str(to))

def dijkstra(s):
 hq = [(0, s)]
 heapq.heapify(hq)
 cost = [[INF, []] for i in range(N)]
 cost[s][0] = 0
 while hq:
 c, v = heapq.heappop(hq)
 if c > cost[v][0]:
 continue
 for d, u in to[v]:
 tmp = d + cost[v][0]
 if tmp < cost[u][0]:
 cost[u][0] = tmp
 cost[u][1] = [v]
 heapq.heappush(hq, (tmp, u))
 return cost

print(""tree: "", str(dijkstra(0)))

def dfs(v, tree, p=-1):
 if p >= 0:
 sides[v][p] = 0
 sides[p][v] = 0
 for nv in tree[v][1]:
 dfs(nv, tree, v)

main = lambda : print(sum(sum(column) for column in sides) // 2)
main()
</ans>",0,{}
117," <ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

n, k = mints()
print(""n: "", str(n), ""k: "", str(k))
q = list(mints())
print(""q: "", str(q))
for i in range(n):
	q[i] -= 1
	print(""q[i]: "", str(q[i]))
s = list(mints())
print(""s: "", str(s))
a = [i for i in range(1,n+1)]
print(""a before first loop: "", str(a))
d = [0]*n
print(""d before first loop: "", str(d))
b = [False]*(k+1)
print(""b: "", str(b))
c = [False]*(k+1)
print(""c: "", str(c))
e = [10000]*2
print(""e: "", str(e))
f = [10000]*2
print(""f: "", str(f))
for i in range(k+1):
	print(""a before inner loop: "", str(a))
	b[i] = (a == s)
	print(""b[i]: "", str(b[i]))
	if b[i]:
		e[i%2] = min(e[i%2], i)
		print(""e[i%2]: "", str(e[i%2]))
	for j in range(n):
		d[j] = a[q[j]]
		print(""d[j]: "", str(d[j]))
	a,d = d,a
	print(""a after inner loop: "", str(a))
a = [i for i in range(1,n+1)]
print(""a before second loop: "", str(a))
for i in range(k+1):
	print(""a before inner loop: "", str(a))
	c[i] = (a == s)
	print(""c[i]: "", str(c[i]))
	if c[i]:
		f[i%2] = min(f[i%2], i)
		print(""f[i%2]: "", str(f[i%2]))
	for j in range(n):
		d[q[j]] = a[j]
		print(""d[q[j]]: "", str(d[q[j]]))
		a[j], d[j] = d[j], a[j]
		print(""a[j] and d[j] swapped: "", str(a[j]), str(d[j]))
		print(""a after inner loop: "", str(a))
#print('====')
print(""e: "", str(e))
print(""f: "", str(f))
if e[0] == 0:
	print(""e[0] is 0"")
elif e[1] == 1:
	if f[1] == 1 and k > 1:
		print(""f[1] is 1 and k > 1"")
		print(""k: "", str(k))
		print(""f: "", str(f))
		print(""e: "", str(e))
		print(""k%2: "", str(k%2))
		print(""f[k%2]: "", str(f[k%2]))
		print(""e[k%2]: "", str(e[k%2]))
		print(""k <= e[k%2] or k <= f[k%2]: "", str(k <= e[k%2] or k <= f[k%2]))
		if k <= e[k%2] or k <= f[k%2]:
			print('YES')
		else:
			print('NO')
	elif k%2 == 1 or f[k%2] <= k:
		print(""k%2 is 1 or f[k%2] <= k"")
		print(""k: "", str(k))
		print(""f: "", str(f))
		print(""k%2: "", str(k%2))
		print(""f[k%2]: "", str(f[k%2]))
		print(""k <= f[k%2]: "", str(k <= f[k%2]))
		if k <= f[k%2]:
			print('YES')
		else:
			print('NO')
	else:
		print(""else statement"")
		print(""e[k%2]: "", str(e[k%2]))
		print(""f[k%2]: "", str(f[k%2]))
		print(""k <= e[k%2] or k <= f[k%2]: "", str(k <= e[k%2] or k <= f[k%2]))
		if k <= e[k%2] or k <= f[k%2]:
			print('YES')
		else:
			print('NO')
elif f[1] == 1:
	if k%2 == 1 or e[k%2] <= k:
		print(""k%2 is 1 or e[k%2] <= k"")
		print(""k: "", str(k))
		print(""e: "", str(e))
		print(""k%2: "", str(k%2))
		print(""e[k%2]: "", str(e[k%2]))
		print(""k <= e[k%2]: "", str(k <= e[k%2]))
		if k <= e[k%2]:
			print('YES')
		else:
			print('NO')
	else:
		print(""else statement"")
		print(""e: "", str(e))
		print(""f: "", str(f))
		print(""k <= e[k%2] or k <= f[k%2]: "", str(k <= e[k%2] or k <= f[k%2]))
		if k <= e[k%2] or k <= f[k%2]:
			print('YES')
		else:
			print('NO')
else:
	if e[k%2] <= k or f[k%2] <= k:
		print(""e[k%2] <= k or f[k%2] <= k"")
		print(""k: "", str(k))
		print(""e: "", str(e))
		print(""f: "", str(f))
		print(""k%2: "", str(k%2))
		print(""e[k%2]: "", str(e[k%2]))
		print(""f[k%2]: "", str(f[k%2]))
		print(""k <= e[k%2] or k <= f[k%2]: "", str(k <= e[k%2] or k <= f[k%2]))
		if k <= e[k%2] or k <= f[k%2]:
			print('YES')
		else:
			print('NO')
	else:
		print(""else statement"")
		print(""e: "", str(e))
		print(""f: "", str(f))
		print(""k <= e[k%2] or k <= f[k%2]: "", str(k <= e[k%2] or k <= f[k%2]))
		if k <= e[k%2] or k <= f[k%2]:
			print('YES')
		else:
			print('NO')
</ans>",0,{}
118," <ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

def sieve(n):
 print(""n: "", str(n))
 if n < 2: return list()
 prime = [True for _ in range(n + 1)]
 p = 3
 while p * p <= n:
 print(""p: "", str(p))
 if prime[p]:
 for i in range(p * 2, n + 1, p):
 print(""i: "", str(i))
 prime[i] = False
 p += 2
 return r = [2]
 for p in range(3, n + 1, 2):
 print(""p: "", str(p))
 if prime[p]:
 r.append(p)
 return r

def divs(n, start=1):
 print(""n: "", str(n))
 divisors = []
 for i in range(start, int(math.sqrt(n) + 1)):
 print(""i: "", str(i))
 if n % i == 0:
 if n / i == i:
 divisors.append(i)
 else:
 divisors.extend([i, n // i])
 return divisors

def divn(n, primes):
 print(""n: "", str(n))
 print(""primes: "", str(primes))
 divs_number = 1
 for i in primes:
 print(""i: "", str(i))
 t = 1
 while n % i == 0:
 print(""n % i: "", str(n % i))
 print(""i: "", str(i))
 t += 1
 n //= i
 divs_number *= t

def flin(d, x, default=-1):
 print(""d: "", str(d))
 print(""x: "", str(x))
 print(""default: "", str(default))
 left = right = -1
 for i in range(len(d)):
 print(""d[i]: "", str(d[i]))
 if d[i] == x:
 if left == -1: left = i
 right = i
 return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' ', end='\n'): print(sep.join(map(str, a)), end=end)
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
 print(""_: "", str(_))
 n, m = mi()
 print(""n: "", str(n))
 print(""m: "", str(m))
 if n == 1:
 print(""0"")
 elif n == 2:
 print(m)
 else:
 print(""2*m"")
</ans>",0,{}
119," <ans>
from random import randint

def factMod(n, mod):
 print(""mod: "", str(mod))
 res = 1
 for i in range(2, n+1):
 print(""i: "", i, ""res: "", str(res))
 res = (res * i) % mod
 return res

def powMod(n, p, mod):
 print(""n: "", n, ""p: "", p, ""mod: "", mod)
 res = 1

 while p > 0:
 print(""p: "", p)
 if p % 2 == 1:
 print(""n: "", n)
 res = (res * n) % mod
 p //= 2
 n = (n * n) % mod

 return res

def invMod(n, mod):
 print(""n: "", n, ""mod: "", mod)
 return powMod(n, mod - 2, mod)

#t = 6
#print(""t: "", t)
#print(""invMod(t, 97): "", invMod(t, 97))
#print(""(invMod(t, 97) * t) % 97: "", (invMod(t, 97) * t) % 97)
#return

def CnkMod(n, k, mod):
 print(""n: "", n, ""k: "", k, ""mod: "", mod)
 return (
 factMod(n, mod) *
 invMod(factMod(k, mod) * factMod(n-k, mod), mod)
 ) % mod

def computeCnksMod(N, mod):
 print(""N: "", N, ""mod: "", mod)
 res = [[0] * (N+1) for i in range(N+1)]
 res[0][0] = 1
 for n in range(1, N+1):
 print(""n: "", n)
 res[n][0] = res[n-1][0]
 for k in range(1, n+1):
 print(""k: "", k)
 res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod

 return res

magic = 998244353

n = int(input()) + 1
aa = [1] + [int(s)+1 for s in input().split(' ')]

#aa = [1] + [randint(0, 999) for i in range(1000)]
#n = len(aa)

cnks = computeCnksMod(n, magic)

#print(""aa: "", aa)
print(""n: "", n, ""aa: "", str(aa))

d = [0] * (n + 1)
d[n] = 1

for i in reversed(list(range(n))):
 if i != 0 and aa[i] < 2:
 continue

 cur = 0

 tosel = aa[i] - 1
 for j in range(i + tosel + 1, n + 1):
 avail = j - i - 1
 #cur = (cur + CnkMod(avail, tosel, magic) * d[j]) % magic
 print(""i: "", i, ""j: "", j, ""avail: "", avail, ""tosel: "", tosel, ""cur: "", cur)
 cur = (cur + cnks[avail][tosel] * d[j]) % magic

 d[i] = cur

print(""d: "", d)
print(""d[0] - 1: "", d[0] - 1)
</ans>",0,{}
120," <ans>
from math import sin
def mp():  return list(map(int,input().split()))
def lt():  return list(map(int,input().split()))
def pt(x):  print(x)
def ip():  return input()
def it():  return int(input())
def sl(x):  return [t for t in x]
def spl(x): return x.split()
def aj(liste, item): liste.append(item)
def bin(x):  return ""{0:b}"".format(x)
def listring(l): return ' '.join([str(x) for x in l])
def ptlist(l): print(' '.join([str(x) for x in l]))

n = it()
print(""n: "", n)
step = lt()
print(""step: "", step)
dict = {}
print(""dict: {}"")

def explosion(start,s,d):
    (i,j) = start
    t = s+1
    if d == 0:
        for k in range(j+1,j+t):
            dict[(i,k)] = True
        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)
    if d == 1:
        for k in range(1,t):
            dict[(i+k,j+k)] = True
        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)
    if d == 2:
        for k in range(1,t):
            dict[(i+k,j)] = True
        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)
    if d == 3:
        for k in range(1,t):
            dict[(i+k,j-k)] = True
        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)
    if d == 4:
        for k in range(1,t):
            dict[(i,j-k)] = True
        return ((i,j-t+1),(d+7)%8),((i,j-t+1),(d+1)%8)
    if d == 5:
        for k in range(1,t):
            dict[(i-k,j-k)] = True
        return ((i-t+1,j-t+1),(d+7)%8),((i-t+1,j-t+1),(d+1)%8)
    if d == 6:
        for k in range(1,t):
            dict[(i-k,j)] = True
        return ((i-t+1,j),(d+7)%8),((i-t+1,j),(d+1)%8)
    if d == 7:
        for k in range(1,t):
            dict[(i-k,j+k)] = True
        return ((i-t+1,j+t-1),(d+7)%8),((i-t+1,j+t-1),(d+1)%8)

start = [((0,0),0)]
print(""start: "", start)
for i in range(n):
    l = []
    for p,q in start:
        a,b = explosion(p,step[i],q)
        l.append(a)
        l.append(b)
    start = set(l)
print(""new start: "", list(start))
pt(len(dict))
</ans>",0,{}
121," <ans>
n = I()
print(""n: "", str(n))
m = LI()
print(""m: "", str(m))
tot = 0
for i in range(n):
 print(""i: "", str(i))
 l, r = [], []
 tmp = m[i]
 p = m[i]

 # right
 for j in range(i+1, n):
 print(""j: "", str(j))
 if m[j]<p:
 p = m[j]
 tmp += p
 r.append(p)

 # left
 for j in range(i-1, -1, -1):
 print(""j: "", str(j))
 if m[j]<p:
 p = m[j]
 tmp += p
 l.append(p)

 if tmp > tot:
 tot = tmp
 ans = l[::-1] + [m[i]] + r
 print(""tot: "", str(tot))
 print(""ans: "", str(ans))
</ans>",0,{}
122," <ans>
import sys
sys.setrecursionlimit(10000)

n, m = list(map(int, f().split()))

matrix = []

disco = [[0 for _ in range(m)] for _ in range(n)]

for i in range(n):
 print(""matrix["", i, ""]: "", str(matrix[i]))
 matrix.append(f())

def valid_node(i, j):
 return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, k, cc = 0):
 if disco[i][j] == k:
 return True
 print(""disco["", i, "", "", j, ""]: "", str(disco[i][j]))
 disco[i][j] = k

 res = False
 dd = [[0,1], [1,0], [-1,0], [0,-1]]
 for d in dd:
 if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
 if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:
 res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)

 return res

ok = False
k = 1
for i in range(n):
 for j in range(m):
 if disco[i][j] == 0:
 ok = ok or dfs(i, j, [i, j], k)
 k += 1

if ok:
 print(""Yes"")
 else:
 print(""No"")
</ans>",0,{}
123," <ans>
D = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100,
print(""D: "", str(D))
k = int(input())
start = k - k%100
i = D[start]
j = start

while j < k:
    i += 1
    if sum(int(d) for d in str(i))==10:
        j += 1
        print(""i: "", i)
</ans>",0,{}
124," <ans>
MOD = 998244353

pop\_count = function with no new variables defined
check = function with no new variables defined
pop = list with no new variables defined (initialized in prepare function)
p10 = list with no new variables defined (initialized in prepare function)
f = list of lists with no new variables defined (initialized in prepare function)
w = list of lists with no new variables defined (initialized in prepare function)

prepare = function with no new variables defined
sx = list with no new variables defined (assigned within solve function, but not newly defined)
n = variable with no new definition (assigned within solve function)
ans = variable with no new definition (assigned within main code)

Therefore, no print statements are needed.
</ans>",0,{}
125," <ans>
def main():
 # ... (previous lines)

 print(""N: "", N)
 print(""M: "", M)

 par = [i for i in range(N)]
 print(""par: "", str(par))
 size = [1 for i in range(N)]
 print(""size: "", str(size))

 # ... (find function)

 G = [[] for _ in range(N)]
 print(""G: "", str(G))

 # ... (union function)

 S = [False]*4
 print(""S: "", str(S))

 # ... (dfs function)

 is_bipartite, _ = dfs(0)
 print(""is_bipartite: "", is_bipartite)

 if is_bipartite:
 w = 0
 if t == 3:
 w = N*(N-1)*(N-2)//3//2
 print(""t: "", t)
 if t == 2:
 used = [False]*N
 print(""used: "", str(used))
 for i in range(N):
 if not used[find(i)] and get_size(i) == 2:
 w += (N-2)
 used[find(i)] = True
 print(""w: "", w)
 elif t == 1:
 used = [False]*N
 color = [-1]*N
 print(""used: "", str(used))
 print(""color: "", str(color))
 for i in range(N):
 if not used[find(i)] and get_size(i) >= 3:
 _, ways = dfs(i)
 w += ways
 used[find(i)] = True
 print(""w: "", w)
 print(t, w)
 else:
 print(0, 1)
</ans>",0,{}
126," <ans>
__author__ = 'Michael Ilyin'

import math

# debug = True
debug = False

def dist(x1, y1, x2, y2):
 return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))

def get_y(x1, y1, x2, y2, x):
 return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1

if debug:
 with open(""input.txt"", ""r"") as inp:
 firstLine = inp.readline()
 secondLine = inp.readline()
 thirdLine = inp.readline()
 fourthLine = inp.readline()
else:
 firstLine = input()
 secondLine = input()
 thirdLine = input()
 fourthLine = input()

print(""first: "", str(first))
n = float(first[0])
m = float(first[1])
a = float(first[2])
b = float(first[3])

print(""n: "", n, ""m: "", m, ""a: "", a, ""b: "", b)
A = [float(x) for x in secondLine.split()]
B = [float(x) for x in thirdLine.split()]
L = [float(x) for x in fourthLine.split()]

if debug:
 print(""A: "", A)
 print(""B: "", B)
 print(""L: "", L)

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
 d = dist(0, 0, b, bi) + L[i]
 if d <= optimalLen:
 optimalLen = d
 optimalBIdx = i

print(""optimalBIdx: "", optimalBIdx)

intersectY = get_y(0, 0, b, B[optimalBIdx], a)

print(""intersectY: "", intersectY)

pointDist = float(""inf"")
optimalAIdx = -1
for i, ai in enumerate(A):
 d = dist(a, ai, a, intersectY)
 if d < pointDist:
 pointDist = d
 optimalAIdx = i

print(""optimalAIdx: "", optimalAIdx)

optimalLen = float(""inf"")
optimalBIdx = -1
for i, bi in enumerate(B):
 d = dist(a, A[optimalAIdx], b, bi) + L[i]
 if d <= optimalLen:
 optimalLen = d
 optimalBIdx = i

print(""optimalBIdx: "", optimalBIdx)
</ans>",0,{}
127," <ans>
from bisect import bisect_left as bl, bisect_right as br
import heapq
import math
from collections import Counter, deque
from functools import reduce, cmp_to_key
import sys
input = sys.stdin.readline

n = val()
l = li()
l1 = l[:]
l2 = l[:]

i = 0
l1 = sorted(list(set(l1)))
doit, tot1 = 0, 0
cn = Counter(l1)
l = l1[:]

print(""l1: "", str(l1))

while i < len(l1):
 if cn[l[i] - 1] > 0:
 cn[l[i]] -= 1
 cn[l[i] - 1] += 1
 l[i] -= 1
 i += 1
 else:
 cn[l[i]] -= 1
 cn[l[i] + 1] += 1
 l[i] += 1
 if i < len(l1) - 1 and l[i + 1] == l[i]:
 i += 1
 else:
 i += 1
 tot1 = sum(1 for i in cn if cn[i])

print(""cn: "", str(cn))

i = 0
cnt = Counter(l2)
l2 = sorted(l2)
l = l2[:]

print(""l2: "", str(l2))

for i in range(n):
 if cnt[l[i] - 1] == 0:
 cnt[l[i] - 1] += 1
 cnt[l[i]] -= 1
 l[i] -= 1
 elif cnt[l[i]] > 1:
 cnt[l[i] + 1] += 1
 cnt[l[i]] -= 1
 l[i] += 1

print(""cnt: "", str(cnt))

tot2 = sum(1 for i in cnt if cnt[i])

print(""i: "", i)
print(""tot1: "", tot1)
print(""tot2: "", tot2)
</ans>",0,{}
128," <ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush

def main():
 N = I()
 print(""N: "", N)
 if N == 0:
 print(""0"")
 return
 if N < 0:
 D = defaultdict(int)
 index = 0
 while N >= 1:
 if N & 1 == 1:
 if index % 2 == 0:
 D[index] += 1
 D[index+1] += 1
 print(""index: "", index, ""bit: 1, D[index]: "", D[index], ""D[index+1]: "", D[index+1])
 else:
 D[index] = D[index]
 N = N>>1
 index += 1
 else:
 D = defaultdict(int)
 if N & 1 == 1:
 D[0] = 1
 print(""index: "", index, ""bit: 1, D[index]: "", D[index])
 else:
 D[0] = 0
 print(""index: "", index, ""bit: 0, D[index]: "", D[index])
 index += 1

 index = 0
 while True:
 if not index in D.keys():
 break
 if D[index] <= 1:
 pass
 else:
 temp = D[index]
 D[index] = temp % 2
 D[index+1] += (temp // 2)
 D[index+2] += (temp // 2)
 print(""index: "", index, ""D[index]: "", D[index], ""temp: "", temp, ""D[index+1]: "", D[index+1], ""D[index+2]: "", D[index+2])
 if D[index+1] >= D[index+2] * 2:
 temp = D[index+2]
 D[index+2] -= temp
 D[index+1] -= temp * 2
 index += 1
 res = True

 for i in reversed(D.values()):
 if res and i == 1:
 res = False
 print(""i: "", i, end="""")
 print()

def __starting_point():
 main()
__starting_point()
</ans>",0,{}
129," <ans>
n, k = map(int, input().split())
print(""n: "", n, ""k: "", k)
XY = [list(map(int, input().split())) for _ in range(n)]
print(""XY: "", str(XY))
XY.sort(key=lambda x: x[0])
print(""XY sorted by x: "", str(XY))
XY = [xy + [x] for x, xy in enumerate(XY)]
print(""XY with indices: "", str(XY))
XY.sort(key=lambda x: x[1])
print(""XY sorted by y: "", str(XY))
XY = [xy + [y] for y, xy in enumerate(XY)]
print(""XY with y indices: "", str(XY))

gr = [[0] * n for _ in range(n)]
print(""gr: "", str(gr))
for _, _, i, j in XY:
 gr[i][j] = 1
 print(""gr[{}][{}]: {}"".format(i, j, gr[i][j]))

rui = [[0] * (n + 1) for _ in range(n + 1)]
print(""rui: "", str(rui))
for i in range(n):
 for j in range(n):
 rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]
 print(""rui[{}][{}]: {}"".format(i + 1, j + 1, rui[i + 1][j + 1]))

ans = 10 ** 21
print(""ans: "", ans)
for i in range(n - 1):
 for j in range(i + 1, n):
 x = [XY[m][0] for m in [i, j]]
 y = [XY[m][1] for m in [i, j]]
 ii = [XY[m][2] for m in [i, j]]
 jj = [XY[m][3] for m in [i, j]]
 innerPoints = rui[max(ii) + 1][max(jj) + 1] \
 + rui[min(ii)][min(jj)] \
 - rui[min(ii)][max(jj) + 1] \
 - rui[max(ii) + 1][min(jj)]
 print(""innerPoints: "", innerPoints)
 if innerPoints >= k:
 area = (max(x) - min(x)) * (max(y) - min(y))
 print(""area: "", area)
 if area < ans:
 ans = area
 print(""new ans: "", ans)

if n > 2:
 for i in range(n - 2):
 for j in range(i + 1, n - 1):
 for l in range(j + 1, n):
 x = [XY[m][0] for m in [i, j, l]]
 y = [XY[m][1] for m in [i, j, l]]
 ii = [XY[m][2] for m in [i, j, l]]
 jj = [XY[m][3] for m in [i, j, l]]
 innerPoints = rui[max(ii) + 1][max(jj) + 1] \
 + rui[min(ii)][min(jj)] \
 - rui[min(ii)][max(jj) + 1] \
 - rui[max(ii) + 1][min(jj)]
 print(""innerPoints: "", innerPoints)
 if innerPoints >= k:
 area = (max(x) - min(x)) * (max(y) - min(y))
 print(""area: "", area)
 if area < ans:
 ans = area
 print(""new ans: "", ans)

if n > 3:
 for i in range(n - 3):
 for j in range(i + 1, n - 2):
 for l in range(j + 1, n - 1):
 for o in range(l + 1, n):
 x = [XY[m][0] for m in [i, j, o, l]]
 y = [XY[m][1] for m in [i, j, o, l]]
 ii = [XY[m][2] for m in [i, j, o, l]]
 jj = [XY[m][3] for m in [i, j, o, l]]
 innerPoints = rui[max(ii) + 1][max(jj) + 1] \
 + rui[min(ii)][min(jj)] \
 - rui[min(ii)][max(jj) + 1] \
 - rui[max(ii) + 1][min(jj)]
 print(""innerPoints: "", innerPoints)
 if innerPoints >= k:
 area = (max(x) - min(x)) * (max(y) - min(y))
 print(""area: "", area)
 if area < ans:
 ans = area
 print(""new ans: "", ans)

print(""final ans: "", ans)
</ans>",0,{}
130," <ans>
import math
from fractions import gcd

def primes(limit):
 print(""limit: "", str(limit))
 Ans=[]
 C=[True]*(limit+1)
 L=list(range(2,limit+1))
 for i in range(len(p)):
 print(""p[i]: "", str(p[i]))
 if(C[p[i]]):
 for j in range(p[i], limit+1, p[i]):
 C[j]=False
 print(""C after p[i]: "", str(C[p[i]:]))
 for item in L:
 if(C[item]):
 Ans+=[item]
 print(""Ans: "", str(Ans))
 return Ans

a,b=list(map(int,input().split()))
 print(""a: "", str(a))
 print(""b: "", str(b))
 aa=a
 bb=b
 A=[]
 B=[]

p=primes(int(math.sqrt(10**9)))
 print(""p: "", str(p))

for i in range(len(p)):
 print(""i: "", str(i))
 if(p[i]>a):
 break
 while(a%p[i]==0):
 A.append(p[i])
 a//=p[i]
 if(a!=1):
 A.append(a)
 print(""A: "", str(A))

for i in range(len(p)):
 print(""i: "", str(i))
 if(p[i]>b):
 break
 while(b%p[i]==0):
 B.append(p[i])
 b//=p[i]
 if(b!=1):
 B.append(b)
 print(""B: "", str(B))

if(aa==1 and bb==1):
 print(""aa: "", str(aa), ""bb: "", str(bb), ""ans: 0"")

elif(aa==1):
 Done=True
 for item in B:
 print(""item: "", str(item))
 if(item>5):
 Done=False
 break
 if(Done):
 print(""len(B): "", len(B))
 else:
 print(""ans: -1"")

elif(bb==1):
 Done=True
 for item in A:
 print(""item: "", str(item))
 if(item>5):
 Done=False
 break
 if(Done):
 print(""len(A): "", len(A))
 else:
 print(""ans: -1"")

else:
 B.sort()
 print(""B sorted: "", str(B))
 A.sort()
 print(""A sorted: "", str(A))
 Done=True
 ind=0
 ans=0
 while(A!=B):
 print(""A: "", str(A), ""B: "", str(B), ""ind: "", str(ind), ""len(A): "", len(A), ""len(B): "", len(B))
 if(ind>=len(A) and ind>=len(B)):
 Done=False
 break
 elif(ind>=len(A)):
 if(B[-1]>5):
 Done=False
 break
 else:
 ans+=len(B)-ind
 print(""ans: "", ans)
 break
 elif(ind>=len(B)):
 if(A[-1]>5):
 Done=False
 break
 else:
 ans+=len(A)-ind
 print(""ans: "", ans)
 break
 if(Done):
 print(""ans: "", ans)
 else:
 print(""ans: -1"")
</ans>",0,{}
131," <ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import decimal

class Scanner():
 # ... (same as before)

MOD = int(1e09) + 7
INF = int(1e15)

def solve():
 N = Scanner.int()
 print(""N: "", N)
 A = [0 for _ in range(N)]
 print(""A: "", A)
 B = [0 for _ in range(N)]
 print(""B: "", B)
 for i in range(N):
 A[i], B[i] = Scanner.map_int()
 print(""A[{}]: {} {}"".format(i, A[i], B[i]))
 A.sort()
 B.sort()
 if N % 2 == 0:
 mA = A[N // 2] + A[N // 2 - 1]
 mB = B[N // 2] + B[N // 2 - 1]
 print(""mA: {}, mB: {}"".format(mA, mB))
 print((mB - mA + 1))
 else:
 mA = A[N // 2]
 mB = B[N // 2]
 print(""mA: {}, mB: {}"".format(mA, mB))
 print((mB - mA + 1))

def main():
 # ... (same as before)
 __starting_point()
</ans>",0,{}
132," <ans>
n=int(input())
print(""n: "", str(n))
a=list(map(int,input().split()))
print(""a: "", str(a))

c=[0]*1001
print(""c: "", str(c))

for i in range (len(a)):
	c[a[i]]+=1
print(""c after first for loop: "", str(c))

sym=0
sin=0
print(""sym: "", str(sym), ""sin: "", str(sin))

for i in range (1001):
	sym+=(c[i]//4)
	print(""sym after first for loop: "", str(sym))
	if(c[i]%2==1):
		sin+=1
	print(""sin after first for loop: "", str(sin))

if(n%2==0 and sym==((n*n)//4)):
	mat= [([0]*(n//2)) for i in range (n//2)]
	ar=[]
	print(""ar: [], before for loop"")
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	print(""ar: "", str(ar))
	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			k+=1
	newm=[([0]*n) for i in range (n)]
	print(""newm: [], before for loop"")
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]
	print(""newm: "", str(newm))
	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

elif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):
	mat= [([0]*(n//2)) for i in range (n//2)]
	ar=[]
	print(""ar: [], before for loop"")
	for i in range (1001):
		while(c[i]>=4):
			ar.append(i)
			c[i]-=4
	print(""ar: "", str(ar))
	k=0
	for i in range (n//2):
		for j in range (n//2):
			mat[i][j]=ar[k]
			ar.pop(k)
	newm=[([0]*n) for i in range (n)]
	print(""newm: [], before for loop"")
	for i in range (n//2):
		for j in range (n//2):
			newm[i][j]=mat[i][j]
			newm[n-i-1][j]=mat[i][j]
			newm[n-i-1][n-j-1]=mat[i][j]
			newm[i][n-j-1]=mat[i][j]
	na=len(ar)
	ar2=[]
	print(""ar2: [], before for loop"")
	for i in range (na):
		ar2.append(ar[i])
		ar2.append(ar[i])
	print(""ar2: "", str(ar2))
	for i in range (1001):
		while(c[i]>=2):
			ar2.append(i)
			c[i]-=2
	print(""ar2: "", str(ar2))
	for i in range (n//2):
		newm[n//2 ][i]=ar2[0]
		newm[n//2 ][n-i-1]=ar2[0]
		ar2.pop(0)
		newm[i][n//2 ]=ar2[0]
		newm[n-i-1][n//2 ]=ar2[0]
		ar2.pop(0)
	for i in range (1001):
		if(c[i]==1):
			newm[n//2][n//2]=i
	print(""YES"")
	for i in range (n):
		for j in range (n):
			print(newm[i][j],end="" "")
		print()

else:
	print(""NO"")
</ans>",0,{}
133," <ans>
import sys
n = int(input())
print(""n: "", n)
a = list(map(int, input().split()))
print(""a: "", a)
height = n
ans = []
last3 = -1
fail = 0
used = -1
for i in range(n):
 if a[i] == 3:
 print(""i: "", i)
 if height == n:
 print(""height: "", height)
 ans.append((n - height + 1, i + 1))
 height -= 1
 else:
 print(""height: "", height)
 ans.append((n + 1 - (height + 1), i + 1))
 ans.append((n + 1 - height, i + 1))
 height -= 1
 last3 = i
if last3 == n - 1:
 print(""-1"")
 return
if last3 > -1:
 flag = 0
 for i in range(last3, n):
 if a[i] == 2:
 flag = 1
 print(""i: "", i)
 ans.append((n + 1 - (height + 1), i + 1))
 height -= 1
 break
 if flag == 0:
 flag2 = 0
 for i in range(last3, n):
 if a[i] == 1:
 ans.append((n + 1 - (height + 1), i + 1))
 height -= 1
 flag2 = 1
 used = i
 break
 if flag2 == 0:
 print(""-1"")
 return
ones = []
if used == -1:
 height -= 1
for i in range(n - 1, -1, -1):
 if a[i] == 1 and i != used:
 ones.append(i)
 if a[i] == 2:
 if len(ones) == 0:
 print(""-1"")
 return
 k = ones.pop()
 print(""i: "", i)
 ans.append((n + 1 - (height + 1), i + 1))
 ans.append((n + 1 - (height + 1), k + 1))
 height -= 1
if used > -1:
 ones.append(used)
for i in ones:
 print(""i: "", i)
 ans.append((n + 1 - (height + 1), i + 1))
 height -= 1
print(len(ans))
for x, y in ans:
 print(x, y)
</ans>",0,{}
134," <ans>
__author__ = 'zhan'

import time
[a1, b1] = [int(i) for i in input().split()]
[a2, b2] = [int(i) for i in input().split()]

t0 = time.time()
q1 = [[a1, b1, 0]]
q2 = [[a2, b2, 0]]
tested1 = []
tested2 = []
tested_total1 = []
tested_total2 = []

print(""a1: "", a1, ""b1: "", b1)
print(""a2: "", a2, ""b2: "", b2)

def equal(t, q):
lo = 0
hi = len(q)
while True:
if lo >= hi:
return False
m = (lo + hi) // 2
p = q[m]
temp = p[0] * p[1]
if t == temp:
return [p[0], p[1], p[2]]
if t < temp:
lo = m + 1
elif t > temp:
hi = m

def found(key, a):
lo = 0
hi = len(a)
while True:
if lo >= hi:
return False
m = (lo + hi) // 2
p = a[m]
if key[0] == p[0] and key[1] == p[1]:
return True
if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:
lo = m + 1
if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:
hi = m

while True:
if len(q1) > 0 and len(q2) > 0:
total1 = q1[0][0] * q1[0][1]
total2 = q2[0][0] * q2[0][1]
if total1 > total2:
ans = equal(total1, q2)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
ans = equal(total2, q1)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
if not(q1[0][0] & 1):
tt = [q1[0][0] // 2, q1[0][1], q1[0][2] + 1]
if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
tested1.append([tt[0], tt[1]])
q1.append(tt)
tested_total1.append(tt[0]*tt[1])
ans = equal(tt[0]*tt[1], q2)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
if q1[0][0] % 3 == 0:
tt = [q1[0][0] // 3 * 2, q1[0][1], q1[0][2] + 1]
if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
tested1.append([tt[0], tt[1]])
q1.append(tt)
tested_total1.append(tt[0]*tt[1])
ans = equal(tt[0]*tt[1], q2)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
if not(q1[0][1] & 1):
tt = [q1[0][0], q1[0][1] // 2, q1[0][2] + 1]
if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
tested1.append([tt[0], tt[1]])
q1.append(tt)
tested_total1.append(tt[0]*tt[1])
ans = equal(tt[0]*tt[1], q2)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
if q1[0][1] % 3 == 0:
tt = [q1[0][0], q1[0][1] // 3 * 2, q1[0][2] + 1]
if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):
tested1.append([tt[0], tt[1]])
q1.append(tt)
tested_total1.append(tt[0]*tt[1])
ans = equal(tt[0]*tt[1], q2)
if ans:
print(""ans: "", ans)
print(""ans[0]: "", ans[0])
print(""ans[1]: "", ans[1])
print(""ans[2]: "", ans[2])
print(""q1[0][0]: "", q1[0][0])
print(""q1[0][1]: "", q1[0][1])
print(""q1[0][2]: "", q1[0][2])
print(""q2[0][0]: "", q2[0][0])
print(""q2[0][1]: "", q2[0][1])
print(""q2[0][2]: "", q2[0][2])
return
if len(q1) > 0:
q1.pop(0)
q1.sort(key=lambda x: x[0]*x[1], reverse=True)
#tested1.sort(key=lambda x: (x[0], x[1]), reverse=True)
if len(q2) > 0:
q2.pop(0)
q2.sort(key=lambda x: x[0]*x[1], reverse=True)
#tested2.sort(key=lambda x: (x[0], x[1]), reverse=True)

else:
print(-1)
break

t1 = time.time()
#print(t1-t0)
</ans>",0,{}
135," <ans>
import sys
sys.setrecursionlimit(10000000)
mod = 10**9 + 7
#mod = 9982443453
#mod = 998244353
from sys import stdin
readline = stdin.readline

n = I()
s = input()
ans = """"
prv = None

print(""n: "", n)

for i in range(n):
 if i == 0:
 print(""i: "", i, ""s[i]: "", s[i])
 prv = s[i]
 ans += s[i]
 continue
 if s[i] == prv:
 continue
 else:
 print(""i: "", i, ""s[i]: "", s[i])
 prv = s[i]
 ans += s[i]

print(""ans: "", len(ans))
</ans>",0,{}
136," <ans>
import sys

n = int(sys.stdin.readline().split()[0])

class Polynomial:
 # ... (the rest of the code remains the same)

f = []

f.append(Polynomial([1]))
print(""f[0]: degree: "", str(0), "", coef: "", str([1]))
f.append(Polynomial([0, 1]))
print(""f[1]: degree: "", str(1), "", coef: "", str([0, 1]))

for j in range(2, 151):
 xf = f[j-1].multiply_by_x()
 print(""xf: degree: "", str(xf.degree + 1), "", coef: "", str(xf.coef))
 t_1 = xf.add(f[j - 2])
 print(""t_1: degree: "", str(t_1.degree), "", coef: "", str(t_1.coef))
 t_2 = xf.add(f[j - 2].minus())
 print(""t_2: degree: "", str(t_2.degree), "", coef: "", str(t_2.coef))
 if t_1.is_legal():
 f.append(t_1)
 print(""Appended t_1"")
 elif t_2.is_legal():
 f.append(t_2)
 print(""Appended t_2"")
 else:
 print(""Skipped this iteration"")

print(""f[{}]: degree: "".format(n), str(f[n].degree))
f[n].print()
print(""f[{}]: degree: "".format(n-1), str(f[n-1].degree))
f[n-1].print()
</ans>",0,{}
137," <ans>
class Combination:
......
 def __init__(self, n_max, mod=10**9+7):
 print(""mod: "", str(mod))
 self.mod = mod
......
 def make_factorial_list(self, n):
 print(""n: "", str(n))
 fac = [1]
 facinv = [1]
......
 def make_modinv_list(self, n):
 print(""n: "", str(n))
 modinv = [0] * (n+1)
......
 def __call__(self, n, r):
 print(""n: "", str(n), ""r: "", str(r))
......
L = []
print(""K: "", str(K), ""N: "", str(N))
comb = Combination(10000, mod=mod)
print(""comb: "", str(comb))
......
for i in range(2, 2*K+1, 2):
 print(""i: "", str(i))
 ans = 0
 M = i//2
 b = 1
 for j, a in enumerate(range(M, K)):
 print(""j: "", str(j), ""a: "", str(a))
 ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b
 print(""pow(2, M-j, mod): "", str(pow(2, M-j, mod)), ""C(M, j): "", str(C(M, j)), ""H(K-a, N): "", str(H(K-a, N)), ""b: "", str(b))
 ans %= mod
 b = -b
 print(""ans: "", str(ans))
 L.append(ans)
 print(""ans: "", str(ans))
......
print(*L[::-1], sep=""\n"")
</ans>",0,{}
138," <ans>
import sys
import math
import random

n, k, x = map(int, input().split())
print(""n: "", n, ""k: "", k, ""x: "", x)
a = list(map(int, input().split()))
ans = 0
if n == 1:
 print(""n: 1"")
 print(""ans: 0"")
 return

for i in range(0, n - 1):   
 l = i
 print(""i: "", i)
 while l >= 0 and a[i] == a[l]:
 l -= 1
 r = i + 1
 while r < n and a[r] == x:
 r += 1
 print(""l: "", l, ""r: "", r)
 while (1):
 if l == -1 or r == n:
 break
 if a[l] != a[r]:
 break
 if l == 0 and r == n - 1:
 break
 if l == 0:
 if a[0] == a[r + 1]:
 while r < n and a[r] == a[0]:
 r += 1
 l -= 1
 continue
 else:
 break
 if r == n - 1:
 if a[n - 1] == a[l - 1]:
 while l >= 0 and a[l] == a[n - 1]:
 l -= 1
 r += 1
 continue
 else:
 break
 if a[l] == a[r + 1] or a[l - 1] == a[r]:
 t = a[l]
 while l >= 0 and a[l] == t:
 l -= 1
 while r < n and a[r] == t:
 r += 1
 print(""ans: "", ans)
 ans = max(ans, r - l - 1)

print(""ans: "", ans)
</ans>",0,{}
139," <ans>
ka, kb = 0, 0

print(""ka: "", str(ka), ""kb: "", str(kb))

def g(a, b):
 nonlocal ka, kb
 if a == b:
 return
 if abs(a - b) == 2:
 if a == 1:
 ka += 1
 else:
 kb += 1
 else:
 if a > b:
 ka += 1
 else:
 kb += 1

print(""a: "", str(a), ""b: "", str(b))
print(""ka: "", str(ka), ""kb: "", str(kb))

def main():
 nonlocal ka, kb
 k, a, b = list(map(int, input().split()))
 aa = [[] for i in [1, 1, 1]]
 bb = [[] for i in [1, 1, 1]]
 aa[0] = list(map(int, input().split()))
 aa[1] = list(map(int, input().split()))
 aa[2] = list(map(int, input().split()))
 bb[0] = list(map(int, input().split()))
 bb[1] = list(map(int, input().split()))
 bb[2] = list(map(int, input().split()))
 x = a
 y = b
 o = 1
 c = [[x, y]]
 d = [[0, 0]]
 g(x, y)
 if k == 1:
 return
 x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
 print(""x: "", str(x), ""y: "", str(y))
 print(""ka: "", str(ka), ""kb: "", str(kb))
 while [x, y] not in c:
 o += 1
 c += [[x, y]]
 d += [[ka, kb]]
 g(x, y)
 x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
 print(""x: "", str(x), ""y: "", str(y))
 print(""ka: "", str(ka), ""kb: "", str(kb))
 if o == k:
 return
 ind = c.index([x, y])
 dka = ka - d[ind][0]
 dkb = kb - d[ind][1]
 delta = o - ind
 kk = (k - ind) // delta - 1
 print(""dka: "", str(dka), ""dkb: "", str(dkb), ""delta: "", str(delta))
 ka += kk * dka
 kb += kk * dkb
 o += kk * delta
 while o != k:
 o += 1
 g(x, y)
 x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
 print(""x: "", str(x), ""y: "", str(y))
 print(""ka: "", str(ka), ""kb: "", str(kb))

main()
print(""ka: "", str(ka), ""kb: "", str(kb))
</ans>",0,{}
140," <ans>
import sys
sys.setrecursionlimit(4100000)
import math
import fractions

S = input()
check = len(S)-1

print(""S: "", str(S))

while(check >= 0):

if S[check] == ""r"":
if S[check-2:check] == ""dreamer"":
remove = ""dreamer""
else:
remove = S[check-6: check+1]
if remove == ""dreamer"":
check -= 7
else:
print(""NO"")
return

elif S[check] == ""s"":
remove = S[check-5: check+1]
if remove == ""eraser"":
check -= 6
else:
print(""NO"")
return

else:
print(""NO"")
return

if S[check] == ""e"":
remove = S[check-4: check+1]
if remove == ""erase"":
check -= 5
else:
print(""NO"")
return

elif S[check] == ""m"":
remove = S[check-4: check+1]
if remove == ""dream"":
check -= 5
else:
print(""NO"")
return

else:
print(""NO"")
return

print(""YES"")
</ans>",0,{}
141," <ans>
class UnionFind():
 def __init__(self, n):
 print(""n: "", str(n))
 self.n = n + 1
 self.parents = [-1] * self.n

 def find(self, x):
 if self.parents[x] < 0:
 return x
 else:
 self.parents[x] = self.find(self.parents[x])
 print(""x: "", str(x), ""parents: "", str(self.parents[x]))
 return self.parents[x]

 def union(self, x, y):
 x = self.find(x)
 y = self.find(y)
 print(""x: "", str(x), ""y: "", str(y))
 if x == y:
 return

 self.parents[x] += self.parents[y]
 self.parents[y] = x

 def size(self, x):
 return -self.parents[self.find(x)]

 def same(self, x, y):
 return self.find(x) == self.find(y)

 def members(self, x):
 root = self.find(x)
 return [i for i in range(self.n) if self.find(i) == root]

 def roots(self):
 return [i for i, x in enumerate(self.parents) if x < 0]

 def group_count(self):
 return len(self.roots())

 def all_group_members(self):
 return {r: self.members(r) for r in self.roots()}

 def __str__(self):
 return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
 N, M = list(map(int, input().split()))
 print(""N: "", str(N), ""M: "", str(M))
 A = list(map(int, input().split()))
 print(""A: "", str(A))
 B = list(map(int, input().split()))
 print(""B: "", str(B))
 A.append(0)
 B.append(0)
 uf = UnionFind(N+1)
 print(""uf: "", str(uf))
 for _ in range(M):
 c, d = list(map(int,input().split()))
 print(""c: "", str(c), ""d: "", str(d))
 uf.union(c, d)
 A_sums = defaultdict(int)
 B_sums = defaultdict(int)
 for i in range(1, N+1):
 x = uf.find(i)
 print(""i: "", str(i), ""x: "", str(x))
 A_sums[x] += A[i-1]
 B_sums[x] += B[i-1]
 for a, b in zip(list(A_sums.values()), list(B_sums.values())):
 if a != b:
 print(""a: "", str(a), ""b: "", str(b))
 print(""No"")
 return
 print(""Yes"")

main()
</ans>",0,{}
142," <ans>
from sys import stdin, stdout

k = int(stdin.readline())

print(""k: "", str(k))

n, m = list(map(int, stdin.readline().split()))

print(""n: "", str(n), ""m: "", str(m))

left, right, down, up = [], [], [], []

print(""left, right, down, up: "", str(left), str(right), str(down), str(up))

coordinates = []

for i in range(k):

x1, y1, x2, y2 = list(map(int, stdin.readline().split()))

if x1 == x2:

if y1 < y2:

coordinates.append((x1, y1, x2, y2, i))

else:

coordinates.append((x2, y2, x1, y1, i))

else:

if x1 < x2:

coordinates.append((x1, y1, x2, y2, i))

else:

coordinates.append((x2, y2, x1, y1, i))

left.append(coordinates[-1])

right.append(coordinates[-1])

up.append(coordinates[-1])

down.append(coordinates[-1])

print(""left after appending: "", str(left))
print(""right after appending: "", str(right))
print(""up after appending: "", str(up))
print(""down after appending: "", str(down))

left.sort(key = lambda x: (x[0], x[2]))

down.sort(key = lambda x: (x[1], x[3]))

print(""left after sorting: "", str(left))
print(""down after sorting: "", str(down))

challengers = [[], [], [], []]

cntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))

label = 1

if cntl or not cntl:

for i in range(cntl, -1, -1):

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

challengers[0].append(left[i][-1])

else:

break

print(""challengers[0] after first for loop: "", str(challengers[0]))

for i in range(cntl + 1, k):

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:

label = 0

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

challengers[0].append(left[i][-1])

else:

break

print(""challengers[0] after second for loop: "", str(challengers[0]))

if cntr or not cntr:

for i in range(k - 1 - cntr, k):

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

challengers[1].append(left[i][-1])

else:

break

print(""challengers[1] after first for loop: "", str(challengers[1]))

for i in range(k - 2 - cntr, -1, -1):

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:

label = 0

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

challengers[1].append(left[i][-1])

else:

break

print(""challengers[1] after second for loop: "", str(challengers[1]))

if cntd or not cntd:

for i in range(cntd, -1, -1):

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

challengers[2].append(down[i][-1])

else:

break

print(""challengers[2] after first for loop: "", str(challengers[2]))

for i in range(cntd + 1, k):

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:

label = 0

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

challengers[2].append(down[i][-1])

else:

break

print(""challengers[2] after second for loop: "", str(challengers[2]))

if cntu or not cntu:

for i in range(k - 1 - cntu, k):

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

challengers[3].append(down[i][-1])

else:

break

print(""challengers[3] after first for loop: "", str(challengers[3]))

for i in range(k - 2 - cntu, -1, -1):

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:

label = 0

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

challengers[3].append(down[i][-1])

else:

break

print(""challengers[3] after second for loop: "", str(challengers[3]))

ans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])

print(""ans: "", str(ans))

if not len(ans) or not label:

stdout.write('-1')

else:

stdout.write(str(list(ans)[0] + 1))
</ans>",0,{}
143," <ans>
import math
import sys

class Graph:
......
def __init__(self, Nodes, is_directed=False):
print(""Nodes: "", str(Nodes))
self.adj_list = {}
......
for node in self.nodes:
print(""node: "", str(node))
self.adj_list[node] = []
......
def add_edge(self, u, v):
print(""u: "", str(u), ""v: "", str(v))
self.adj_list[u].append(v)
if self.is_directed == False:
self.adj_list[v].append(u)
......
def print_graph(self):
for node in self.nodes:
print((node, ""->"", self.adj_list[node]))
......
def degree_node(self, node):
return len(self.adj_list[node])
......
def dfsUTIL(self, v, visited, parents=[]):
#print(v, end="" "")
......
def dfs(self, v):
visited = [False] * (max(self.adj_list) + 1)
parents = [v]
self.dfsUTIL(v, visited, parents)
return len(parents)
......
def dict_sort(ans):
ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))
......
def is_prime(n):
if n == 1:
return 0
for i in range(2, int(math.sqrt(n)) + 1):
if n % i == 0:
return False
return True
......
def swap(a, b):
temp = a
a = b
b = temp
return a, b
......
def seive_primes(n):
flag = [0] * (n + 10)
flag[1] = flag[0] = 1
i = 2
while i * i <= n + 1:
if flag[i] == 0:
j = i * i
while j <= n + 1:
flag[j] = 1
j += i
i += 1
return flag
......
def factors(n):
d = {}
while n % 2 == 0:
if 2 in d:
d[2] += 1
else:
d[2] = 1
n /= 2
for i in range(3, int(n ** 0.5) + 1, 2):
while n % i == 0:
if i in d:
d[i] += 1
else:
d[i] = 1
n = int(n)
if n > 1:
d[n] = 1
return d
......
def gcd(a, b):
if b == 0:
return a
return gcd(b, a % b)
......
def lcm(a, b):
return (a * b) // gcd(a, b)
......
def alphabates():
return ""abcdefghijklmnopqrstuvwxyz""
......
def binary_search(ls, n, flag):
low = 0
hi = n - 1
while low <= hi:
mid = (low + hi) // 2
if ls[mid] == flag:
return mid
elif ls[mid] > flag:
hi = mid - 1
else:
low = mid + 1
return -1
......
def qdrt(a, b, c):
chk = b * b - 4 * a * c
if chk >= 0:
ans1 = (-b + chk ** 0.5) / (2 * a)
ans2 = (-b - chk ** 0.5) / (2 * a)
return [int(ans1), int(ans2)]
......
def permutation(n, r):
if n < r:
return 0
ans = 1
for i in range(n - r + 1, n + 1):
ans *= i
return ans
......
def combination(n, r):
if n < r:
return 0
ans = 1
for i in range(r):
ans *= (n - i)
div = 1
for i in range(2, r + 1):
div *= i
return ans // div
......
def arinp():
ls = list(map(int, input().split()))
return ls
......
def mult_inp():
return list(map(int, input().split()))
......
def main():
s = input()
n = len(s)
print(""s: "", str(s))
print(""n: "", str(n))
if s == s[::-1] and s[:n // 2] == s[n // 2 + 1:]:
print('Yes')
else:
print('No')
......
def __starting_point():
main()
</ans>",0,{}
144," <ans>
from array import array
inf = (1 << 30)

def main():
 print(""n: "", n, ""k: "", k)
 (n,k) = [int(x) for x in input().split(' ')]
 Matrix = []
 print(""Matrix: "", Matrix)
 for i in range(n):
 Matrix.append(array('b',[ord(x) for x in input()]))
 print(""Matrix after initialization: "", Matrix)
 dp = [array('l', [inf for j in range(n)]) for i in range(n)]
 print(""dp: "", dp)
 direct = [[ord('d') for j in range(n)] for i in range(n)]
 print(""direct: "", direct)
 for s in range (2 * n - 1):
 opt = """"
 for i in range(0, s+1):
 j = s - i;
 if j < n and i < n:
 if(i > 0 and j > 0):
 if(dp[i-1][j] < dp[i][j-1]):
 dp[i][j] = dp[i-1][j]
 direct[i][j] = 'l'
 else:
 dp[i][j] = dp[i][j-1]
 direct[i][j] = 'd'
 if dp[i][j] < k and Matrix[i][j] is not ord('a'):
 dp[i][j]+=1
 Matrix[i][j] = ord('a')
 if Matrix[i][j] < ord(opchar) and dp[i][j] <= k:
 opchar = chr(Matrix[i][j])
 if i in positions:
 continue
 positions.append(i)
 print(""positions: "", positions)
 for i in range(0, s+1):
 j = s - i;
 if j < n and i < n:
 if(Matrix[i][j] is not ord(opchar)):
 dp[i][j] = inf
 print(""dp[i][j]: "", dp[i][j])
 a,b = (n-1,n-1)
 while(direct[a][b] is not 'e'):
 ans += chr(Matrix[a][b])
 if(direct[a][b] is 'l'):
 a-=1
 else:
 b-=1
 ans += chr(Matrix[0][0])
 print(""ans: "", ans[::-1])
 print(""final answer: "", ans[::-1])

main()
</ans>",0,{}
145," <ans>
import sys

cases = False

def fast_pow(a:int, b:int):
 print(""a: "", a, ""b: "", b)
 res = 1
 while b > 0:
 if b & 1:
 res *= a
 print(""res: "", res)
 a *= a
 b >>= 1
 return res

def c2(n):
 print(""n: "", n)
 return n * (n-1) // 2

def get():
 print(""input(): "", input().split())
 return list(map(int, input().split()))

def bits(n: int):
 print(""n: "", n)
 return list(bin(n)).count('1')

def main(test_case = False):
 print(""n: "", n)
 if test_case:
 n = int(input())
 print(""input(): "", input().split())
 for _ in range(n):
 test()
 else:
 for _ in range(1):
 test()

def flush():
 sys.stdout.flush()

def parr(arr):
 print(*arr, sep=' ')

def gcd(a, b):
 print(""gcd(a, b): "", a, ""b: "", b)
 while b:
 if b % a == 0:
 break
 tmp = a
 a = b % a
 b = tmp
 return a

def ext_gcd(a: int, b: int):
 print(""ext_gcd(a, b): a: "", a, ""b: "", b)
 if (b == 0):
 return [a, [1, 0]]
 res = ext_gcd(b, a % b)
 g = res[0]
 x1 = res[1][0]
 y1 = res[1][1]
 x = y1
 y = x1 - y1 * (a // b)
 print(""x: "", x, ""y: "", y)
 return [g, [x, y]]

b = []
p = []
n = m = a = 0

def check(cnt):
 print(""cnt: "", cnt)
 if cnt == 0:
 return True
 x = b[-cnt:]
 y = p[:cnt]
 s = a
 i = 0
 while i < cnt and s >= 0:
 s -= max(0, y[i]-x[i])
 i += 1
 print(""s: "", s)
 return s >= 0

def test():
 global n, m, a, b, p
 n, m, a = get()
 b = sorted(get())
 p = sorted(get())
 left = 0
 right = min(n, m)
 ans = -1
 while left <= right:
 mid = (left + right) // 2
 if check(mid):
 ans = max(ans, mid)
 left = mid + 1
 else:
 right = mid - 1
 print(""ans: "", ans)
 if ans == -1:
 print(0, 0)
 return
 t = 0
 x = b[-ans:]
 y = p[:ans]
 i = 0
 while i < ans:
 t += min(x[i], y[i])
 a -= max(0, y[i]-x[i])
 i += 1
 print(""t: "", t, ""a: "", a)
 print(ans, max(0, t-a))

main(cases)
</ans>",0,{}
146," <ans>
n = int(input())
print(""n: "", str(n))
la = []
print(""la: "", str(la))
le = []
print(""le: "", str(le))
li = []
print(""li: "", str(li))
lo = []
print(""lo: "", str(lo))
lu = []
print(""lu: "", str(lu))
ans = []
print(""ans: "", str(ans))
d1 = {}
print(""d1: "", str(d1))
for i in range(n):
 print(""i: "", str(i))
 s = input()
 print(""s: "", str(s))
 x = s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')
 print(""x: "", str(x))
 if x > 0:
 for c in s[::-1]:
 if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u':
 break
 if (x, c) in d1:
 d1[(x, c)].append(s)
 else:
 d1[(x, c)] = [s]
 d2 = {}
 print(""d2: "", str(d2))
 pairs1 = []
 print(""pairs1: "", str(pairs1))
 pairs2 = []
 print(""pairs2: "", str(pairs2))
 for k in d1:
 if len(d1[k]) % 2 == 1:
 if k[0] in d2:
 d2[k[0]].append(d1[k][0])
 else:
 d2[k[0]] = [d1[k][0]]
 for i in range(1, len(d1[k]), 2):
 pairs1.append((d1[k][i], d1[k][i + 1]))
 else:
 for i in range(0, len(d1[k]), 2):
 pairs1.append((d1[k][i], d1[k][i + 1]))
 for k in d2:
 if len(d2[k]) > 1:
 if len(d2[k]) % 2 == 1:
 d2[k].pop()
 for i in range(0, len(d2[k]), 2):
 pairs2.append((d2[k][i], d2[k][i + 1]))
 if len(pairs1) < len(pairs2):
 print(len(pairs1))
 for i in range(len(pairs1)):
 print(""pairs2[i][0]: "", str(pairs2[i][0]))
 print(""pairs1[i][0]: "", str(pairs1[i][0]))
 print(""pairs2[i][1]: "", str(pairs2[i][1]))
 print(""pairs1[i][1]: "", str(pairs1[i][1]))
 else:
 print(len(pairs2) + (len(pairs1) - len(pairs2)) // 2)
 for i in range(len(pairs2)):
 print(""pairs2[i][0]: "", str(pairs2[i][0]))
 print(""pairs1[i][0]: "", str(pairs1[i][0]))
 print(""pairs2[i][1]: "", str(pairs2[i][1]))
 print(""pairs1[i][1]: "", str(pairs1[i][1]))
 for j in range(len(pairs2), len(pairs1), 2):
 if j == len(pairs1) - 1:
 break
 else:
 print(""pairs1[j][0]: "", str(pairs1[j][0]))
 print(""pairs1[j+1][0]: "", str(pairs1[j+1][0]))
 print(""pairs1[j][1]: "", str(pairs1[j][1]))
 print(""pairs1[j+1][1]: "", str(pairs1[j+1][1]))
</ans>",0,{}
147," <ans>
import sys
from functools import lru_cache

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
INF = 1 << 60
MOD = 1000000007

def main():
 N, K = int(read()), list(map(int, read().split()[1:]))
 print(""N: "", N)
 print(""K: "", str(K))
 K = [list(map(int, f'{bin(k)[2:]:>040b}')) for k in K]
 A = []
 for _ in range(N):
 A.append(list(map(int, readline().split())))
 print(""A: "", str(A))
 A2 = [[list(map(int, f'{a[i]:>040b}')) for a in A] for i in range(len(A[0]))]
 print(""A2: "", str(A2))
 B = [0] * 40
 for i, a in enumerate(A2):
 for j in range(len(a)):
 B[j] += a[j]
 print(""B: "", str(B))

 @lru_cache(maxsize=None)
 def rec(i, x, smaller):
 if i == 40:
 ans = 0
 for a in A:
 ans += x ^ a[i]
 return ans
 if i > 40:
 return ans
 elif smaller:
 if B[i] == 2:
 return rec(i + 1, (x << 1), True)
 else:
 return rec(i + 1, (x << 1) + B[i], True)
 else:
 if B[i] == 2:
 if K[0][i] == 0:
 return rec(i + 1, (x << 1), False)
 else:
 return rec(i + 1, (x << 1) + B[i], True)
 elif K[0][i] == B[i]:
 return rec(i + 1, (x << 1) + K[0][i], False)
 elif K[0][i] < B[i]:
 return rec(i + 1, (x << 1) + K[0][i], False)
 else:
 return rec(i + 1, (x << 1) + B[i], True)

 print(""Result: "", rec(0, 0, False))
 return

def __starting_point():
 main()

__starting_point()
</ans>",0,{}
148," <ans>
def resolve():
    N = int(input())
    print(""N: "", N)
    A = list(map(int, input().split()))
    print(""A: "", str(A))

    Q = 0
    E = 0
    O = 0
    for a in A:
        print(""a: "", a)
        if a % 4 == 0:
            Q += 1
        elif a % 2 == 0:
            E += 1
        else:
            O += 1

    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:
        print(""Yes"")
    else:
        print(""No"")
</ans>",0,{}
149," <ans>
import sys
input = sys.stdin.readline
enum = enumerate
inf = 1001001001

import collections
import random

def linput(ty=int, cvt=list):
 print(""input: "", str(input()))
 return cvt(list(map(ty,input().split())))

def vinput(rep=1, ty=int, cvt=list):
 print(""input: "", str(input().rstrip()))
 return cvt(ty(input().rstrip()) for _ in ""*""*rep)

def gcd(a: int, b: int):
 print(""gcd: a, b = "", a, b)
 while b: a, b = b, a%b
 return a

def lcm(a: int, b: int):
 print(""lcm: a, b = "", a, b)
 return a * b // gcd(a, b)

def dist(x1,y1,x2,y2):
 print(""dist: x1, y1, x2, y2 = "", x1, y1, x2, y2)
 return abs(x1-x2)+abs(y1-y2)

#vD = [chr(ord(""a"")+i) for i in range(26)]

def ran():
 print(""ran:"")
 vRan = [random.randint(1, 10),
 random.randint(0, 10),
 random.randint(1, 100)]
 return vRan

def bye(res):
 print(""bye: res = "", res)
 #return

def sol_n(a,b,c):
 print(""sol_n: a, b, c = "", a, b, c)
 res = 0
 cnt = 0
 while cnt<c:
 res += 1
 cnt += a
 if res%7==0:
 cnt += b
 return res

def sol(a,b,c):
 print(""sol: a, b, c = "", a, b, c)
 #a,b,c = linput()
 ### 3 6 9 12 15
 ### 1 2 3 4  5
 res = 0
 L = -(-a//c)
 R = (b//c)
 res = R-L+1
 return res

def deb():
 print(""deb:"")
 #vI = linput()
 vI = ran()
 print(""vI: "", vI)
 I = sol_n(*vI)
 J = sol(*vI)
 if 1:#I!=J:
 print(""I, J: "", I, J)

def main():
 print(""main:"")
 vI = linput()
 print(""vI: "", vI)
 print(""sol: "", sol(*vI))

def __starting_point():
 #for _ in ""*""*1000:
 #	deb()
 main()

__starting_point()
</ans>",0,{}
150," <ans>
from math import sqrt, pow, log, log2, log10, exp
from copy import deepcopy
from fractions import gcd

def read_ints():
 print(""read_ints: "",)
 return list(map(int, input().split()))

def read_int():
 print(""read_int: "",)
 return read_ints()[0]

def read_floats():
 print(""read_floats: "",)
 return list(map(float, input().split()))

def read_float():
 print(""read_float: "",)
 return read_floats()[0]

def format_list(l):
 return ' '.join(list(map(str, l)))

def one_dim_array(n, value=0):
 print(""one_dim_array: "", [deepcopy(value) for x in range(n)])
 return [deepcopy(value) for x in range(n)]

def two_dim_array(n, m, value=0):
 print(""two_dim_array: "", [[deepcopy(value) for x in range(m)] for x in range(n)])
 return [[deepcopy(value) for x in range(m)] for x in range(n)]

def is_prime(n):
 if n == 2:
 print(""is_prime: "", True)
 return True
 if n % 2 == 0:
 print(""is_prime: "", False)
 return False
 for i in range(3, int(sqrt(n)) + 1):
 if n % i == 0:
 print(""is_prime: "", False)
 return False
 print(""is_prime: "", True)
 return True

def max_len_sublist(l, f):
 start, max_length, length = 0, 0, 0
 for i in range(1, len(l)):
 if f(l[i], l[i - 1]):
 length += 1
 else:
 if max_length < length:
 start = i - length
 max_length = length
 length = 0
 return start, max_length

def tf_to_yn(b):
 print(""tf_to_yn: "", 'YES' if b else 'NO')
 return 'YES' if b else 'NO'

l = read_int()
 print(""l: "", l)
 p = read_int()
 print(""p: "", p)
 q = read_int()
 print(""q: "", q)
 t = l / (p + q)
 print(""t: "", t)
 print(""t*p: "", t*p)
</ans>",0,{}
151," <ans>
```python
z=[int(p) for p in input().split()]
print(""z: "", str(z))
m=z[2]
lst=[]
lst.append(z[0])
lst.append(z[1])
print(""lst: "", str(lst))
tempi=min(lst)
tempa=max(lst)
print(""tempi: "", str(tempi), ""tempa: "", str(tempa))

count=0
fibo=[]

n=1000000000000000000
print(""n: "", str(n))

def fib(n):
        a, b = 0, 1
        print(""a: "", str(a), ""b: "", str(b))
        while b < n:
                fibo.append(b)
                print(""fibo: "", str(fibo))
                a, b = b, a+b

def add(m):
        n=10**18
        tempi=min(lst)
        tempa=max(lst)
        count=0
        print(""tempi: "", str(tempi), ""tempa: "", str(tempa), ""m: "", str(m))
        if(tempi>0 and tempa>0 and m>tempa):
                fib(n)
                for p in range(1,len(fibo)+1):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count
        elif(tempi==0 or tempa==0):
                count=1
                print(""count: "", str(count))
                fib(n)
                tempi=tempa+(tempi)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count

        elif(tempi<0 and tempa>0):
                val=(-(tempi)//tempa)+1
                count=val
                tempi=tempi+(val*tempa)
                fib(n)
                for p in range(1,len(fibo)):
                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):
                                count+=p
                                print(""count: "", str(count))
                                return count

        

if(tempi>0 and tempa>0 and m>tempa):
        cou=add(m)
        print(""cou: "", str(cou))

elif(tempi>0 and tempa>0 and m<=tempa):
        print(""0"")

elif(tempi==0 ):
        if(tempi==0 and tempa==0 and m>0):
                print(""-1"")
        elif(tempi==0 and tempa==0 and m<=0):
                print(""0"")
        elif(tempa==0 and tempi<0 and m>0):
                print(""-1"")

        else:
                cou=add(m)
                print(""cou: "", str(cou))
elif(tempi<0 and tempa>0):
        if(m<=tempa):
                print(""0"")
        else:
                cou=add(m)
                print(""cou: "", str(cou))
elif(tempi<0 and tempa==0):
        if(m>0):
                print(""-1"")
        else:
                print(""0"")
elif(tempi<0 and tempa<0):
        if(m>=0):
                print(""-1"")
        elif(m<0 and m<=tempa):
                print(""0"")
        elif(m<0 and m>tempa):
                print(""-1"")
</ans>
```",0,{}
152," <ans>
from types import GeneratorType

def bootstrap(f, stack=[]):
# print(""bootstrap: f: "", f, ""stack: "", stack)
 def wrappedfunc(*args, **kwargs):
 # print(""wrappedfunc: args: "", args, ""kwargs: "", kwargs)
 to = f(*args, **kwargs)
 if stack:
 # print(""wrappedfunc: to: GeneratorType: "", type(to) == GeneratorType, ""stack: "", stack)
 return to
 else:
 while True:
 if type(to) is GeneratorType:
 # print(""wrappedfunc: to: GeneratorType, appending to stack: "", to)
 stack.append(to)
 to = next(to)
 else:
 # print(""wrappedfunc: popping from stack: "", stack.pop())
 if not stack:
 # print(""wrappedfunc: returning from stack: "", stack[-1])
 return stack[-1]
 to = stack[-1].send(to)
 return to
 return wrappedfunc

import sys
input=sys.stdin.readline
from collections import defaultdict as dd

n, m = list(map(int, input().split()))
# print(""n, m: "", n, m)
s = input()
# print(""s: "", s)
d = dd(list)
lol = 0
for i in range(m):
 u, v = list(map(int, input().split()))
 # print(""u, v: "", u, v)
 if u == v:
 lol = 1
 print(""lol: "", lol)
 if lol:
 print(-1)
 return
 d[u].append(v)
# print(""d: "", d)

vis = [0] * (n + 1)
rvis = [0] * (n + 1)
cou = [0]
dp = [dd(int) for i in range(n + 1)]
mx = [0]
h = [0]
# print(""dfs: "", dfs)
@bootstrap
def dfs(u):
 if h[0] == 1:
 yield
 h[0] = 1
 vis[u] = 1
 rvis[u] = 1
 for i in d[u]:
 if h[0] == 1:
 yield
 if vis[i] == 0:
 yield from dfs(i)
 if h[0] == 1:
 yield
 if rvis[i] == True:
 h[0] = 1
 yield
 rvis[u] = 0
 if h[0] == 1:
 yield
 for i in d[u]:
 for j in dp[i]:
 dp[u][j] = max(dp[u][j], dp[i][j])
 mx[0] = max(mx[0], dp[u][j])
 dp[u][s[u - 1]] += 1
 mx[0] = max(mx[0], dp[u][s[u - 1]])
 yield
# print(""dp: "", dp)
for i in range(1, n + 1):
 if vis[i] == 0:
 cou = [0]
 yield from dfs(i)
 if h[0]:
 print(-1)
 else:
 print(mx[0])
</ans>",0,{}
153," <ans>
#!/usr/bin/env python3
import sys
from collections import defaultdict

INF = float(""inf"")


def solve(N: int, X: int, D: int):
 print(""N: "", str(N), ""X: "", str(X), ""D: "", str(D))
 if D == 0:
 if X == 0:
 print((1))
 else:
 print((N+1))
 return

 if D < 0:
 X = X + (N-1)*D
 D = abs(D)
 print(""X: "", str(X))

 segs = defaultdict(list)
 for k in range(N+1):
 L = k*(k-1)//2
 R = k*N - k*(k+1)//2
 Ck = k*X + D*L
 Rk = R-L
 seg = (Ck//D, Ck//D+Rk+1)
 s = Ck % D
 segs[s].append(seg)

 print(""segs: "", str(segs))
 tot = 0
 for k in segs:
 event = defaultdict(int)
 for l, r in segs[k]:
 event[l] += 1
 event[r] -= 1

 curr = 0
 pre = -1
 for k in sorted(event.keys()):
 if curr > 0:
 tot += k - pre
 curr += event[k]
 pre = k
 print(""tot: "", str(tot))
 return

def main():

 def iterate_tokens():
 for line in sys.stdin:
 for word in line.split():
 yield word
 tokens = iterate_tokens()
 N = int(next(tokens)) # type: int
 X = int(next(tokens)) # type: int
 D = int(next(tokens)) # type: int
 solve(N, X, D)

def __starting_point():
 main()

__starting_point()
</ans>",0,{}
154," <ans>
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n = int(input())
print(""n: "", str(n))
p = list(map(int, input().split()))
print(""p: "", str(p))
odd = (n+1)//2
even = n-odd
print(""odd: "", str(odd), ""even: "", str(even))
for i in p:
 print(""i: "", str(i))
 if i:
 if i%2 == 0:
 even -= 1
 else:
 odd -= 1

if even == 0:
 p = [i if i else 1 for i in p]
 print(""p: "", str(p))
if odd*even == 0:
 ans = 0
 prev = p[0]
 for pi in p:
 print(""pi: "", str(pi))
 ans += (pi+prev)%2
 prev = pi
 print(""ans: "", str(ans))
 return

DP = [[float(""inf"")]*(even+1) for i in range(2)]
print(""DP: "", str(DP))
for i in range(n):
 print(""i: "", str(i))
 nxt = [[float(""inf"")]*(even+1) for i in range(2)]
 if i == 0:
 if p[i]:
 if p[i]%2 == 0:
 print(""nxt[0]: "", str(nxt[0]))
 nxt[0][0] = 0
 else:
 print(""nxt[1]: "", str(nxt[1]))
 nxt[1][0] = 0
 else:
 if p[i]:
 if p[i]%2 == 0:
 for j in range(even+1):
 print(""DP[0][j]: "", str(DP[0][j]))
 print(""DP[1][j]: "", str(DP[1][j]))
 nxt[0][j] = min(DP[0][j], DP[1][j]+1)
 else:
 for j in range(1, even+1):
 print(""DP[0][j-1]: "", str(DP[0][j-1]))
 print(""DP[1][j-1]: "", str(DP[1][j-1]))
 nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)
 for j in range(even+1):
 print(""DP[0][j]: "", str(DP[0][j]))
 print(""DP[1][j]: "", str(DP[1][j]))
 nxt[1][j] = min(DP[0][j]+1, DP[1][j])
 else:
 for j in range(even+1):
 print(""DP[0][j]: "", str(DP[0][j]))
 print(""DP[1][j]: "", str(DP[1][j]))
 nxt[0][j] = min(DP[0][j]+1, DP[1][j])
 DP = nxt
 print(""DP: "", str(DP))
print(""min(DP[0][-1], DP[1][-1]): "", str(min(DP[0][-1], DP[1][-1])))
</ans>",0,{}
155," <ans>
# E
N = int(input())
print(""N: "", N)
P_list = list(map(int, input().split()))
print(""P_list: "", str(P_list))
X_list = list(map(int, input().split()))
print(""X_list: "", str(X_list))

# graph
child_list = [[] for _ in range(N+1)]
print(""child_list: "", str(child_list))
for i in range(2, N+1):
 print(""i: "", i)
 print(""P_list[i-2]: "", P_list[i-2])
 print(""child_list[P_list[i-2]]: "", str(child_list[P_list[i-2]]))
 child_list[P_list[i-2]].append(i)

# from root
# minimize local total weight

color1 = [0]+X_list
print(""color1: "", str(color1))
color2 = [0]*(N+1)
print(""color2: "", str(color2))

# solve knapsack
def solve_knapsack(L, M):
 print(""L: "", str(L))
 print(""M: "", M)
 min_acc = sum([min(color1[j], color2[j]) for j in L])
 print(""min_acc: "", min_acc)
 if min_acc > M:
 return -1
 else:
 add_can = M - min_acc
 add_set = set([0])
 for j in L:
 add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])
 add_set_ = set(add_set)
 for s in add_set:
 if s + add_j <= add_can:
 add_set_.add(s + add_j)
 add_set = add_set_
 total = sum([color1[j]+color2[j] for j in L])
 print(""total: "", total)
 return total - max(add_set) - min_acc

res = ""POSSIBLE""
</ans>",0,{}
156," <ans>
def prime_factor(n):
    i = 2
    factors = []
    print(""factors: []"")
    while i * i <= n:
        if n % i:
            i += 1
        else:
            while n % i == 0:
                n //= i
                print(""factors: "", str(factors), ""i: "", i)
                factors.append(i)
    if n > 1:
        factors.append(n)
        print(""factors: "", str(factors), ""n: "", n)
    return factors


def divisors(n):
    divisors = []
    print(""divisors: []"")
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)
    divisors.sort()
    print(""divisors: "", str(divisors))
    return divisors


def mebius(n):
    res = {}
    print(""res: {}"")
    primes = prime_factor(n)
    m = len(primes)
    for i in range(1 << m):
        mu = 1
        d = 1
        print(""i: "", i, ""m: "", m)
        for j in range(m):
            if i >> j & 1:
                mu *= -1
                d *= primes[j]
        res[d] = mu
    print(""res: "", str(res))
    return res

mod = 10**9+7
N, K = list(map(int, input().split()))
print(""N: "", N, ""K: "", K)
div = divisors(N)
print(""div: "", str(div))

ans = 0
for x in div:
    print(""x: "", x)
    div2 = divisors(x)
    print(""div2: "", str(div2))
    mu = mebius(x)
    print(""mu: "", str(mu))
    cnt = 0
    for y in list(mu.keys()):
        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]
    print(""cnt: "", cnt)
    if x % 2 == 0:
        cnt *= pow(2, mod-2, mod)
        print(""cnt: "", cnt)
    ans += x*cnt
    print(""ans: "", ans)
    ans %= mod
print(""ans: "", ans)
</ans>",0,{}
157," <ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

n = int(minp())
m = [None]*n
k = [None]*3
dp = [None]*3
dp[0] = [None]*(n*n)
dp[1] = [None]*(n*n)
dp[2] = [None]*(n*n)
path = [None]*(n*n)
for i in range(n):
	m[i] = list(map(int, minp().split()))
	print(""m["", i, ""]: "", str(m[i]))
	for j in range(n):
		path[m[i][j]-1] = (i,j)
for z in range(3):
	k_[z] = [None]*n
	for i in range(n):
		kk = [None]*n
		for j in range(n):
			kkk_ = [None]*3
			for zz in range(3):
				kkk = [None]*n
				for w in range(n):
					kkk[w] = [(1000000,0)]*n
				kkk_[zz] = kkk
			kk[j] = kkk_
		k_[z] = kk
	k[z] = k_

q = [0]*(10*n*n)
qr = 0
km = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
sm = [(1,1),(1,-1),(-1,1),(-1,-1)]
lm = [(0,1),(0,-1),(-1,0),(1,0)]
mm = [km,sm,lm]
for z in range(3):
	for i in range(n):
		for j in range(n):
			ql = 0
			qr = 1
			q[0] = (z, i, j, (0,0))
			kc = k[z][i][j]
			kc[z][i][j] = (0, 0)
			print(""kc["", z, "","", i, "","", j, ""]: "", str(kc[z][i][j]))
			while ql < qr:
				t, x, y, dd = q[ql]
				print(""q["", ql, ""]: "", str(q[ql]))
				d = kc[t][x][y]
				ql += 1
				if d != dd:
					continue
				dd = (d[0]+1, d[1]+1)
				for tt in range(3):
					if t != tt and kc[tt][x][y] > dd:
						kc[tt][x][y] = dd
						q[qr] = (tt,x,y,dd)
						qr += 1
						print(""updated kc["", tt, "","", x, "","", y, ""]: "", str(kc[tt][x][y]))
				dd = (d[0]+1,d[1])
				if t == 0:
					for w in mm[t]:
						xx,yy = w[0]+x,w[1]+y
						if xx >= 0 and xx < n and yy >= 0 and yy < n:
							if kc[t][xx][yy] > dd:
								kc[t][xx][yy] = dd
								q[qr] = (t,xx,yy,dd)
								qr += 1
								print(""updated kc["", t, "","", xx, "","", yy, ""]: "", str(kc[t][xx][yy]))
				else:
					for w in mm[t]:
						for hm in range(n*2):
							xx,yy = w[0]*hm+x,w[1]*hm+y
							if xx >= 0 and xx < n and yy >= 0 and yy < n:
								if kc[t][xx][yy] > dd:
									kc[t][xx][yy] = dd
									q[qr] = (t,xx,yy,dd)
									qr += 1
									print(""updated kc["", t, "","", xx, "","", yy, ""]: "", str(kc[t][xx][yy]))
							else:
								break
dp[0][0] = (0,0)
dp[1][0] = (0,0)
dp[2][0] = (0,0)
for i in range(0,n*n-1):
	x,y = path[i]
	xx,yy = path[i+1]
	for z in range(3):
		for j in range(3):
			dist = k[j][x][y][z][xx][yy]
			if dp[j][i] != None:
				nd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])
				if dp[z][i+1] == None:
					dp[z][i+1] = nd
				else:
					dp[z][i+1] = min(dp[z][i+1],nd)
					print(""updated dp["", z, "","", i+1, ""]: "", str(dp[z][i+1]))
for j in range(n*n-1,n*n):
	qq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]
	qm = min(qq)
	print(""qm: "", str(qm))
	print(qm[0], qm[1])
</ans>",0,{}
158," <ans>
def increasing(arr):
 print(""arr: "", str(arr))
 n = len(arr)
 for i in range(n-1):
 if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
 print(""False"")
 return False

 print(""True"")
 return True

 def getFacts(n,mod):
 print(""n: "", str(n))
 facts = [1]*n
 for i in range(1,n):
 facts[i] = facts[i-1]*i
 facts[i] %= mod
 print(""facts[i]: "", str(facts[i]))
 return facts

 def solve(arr1,arr2,n,mod):
 print(""n: "", str(n))
 facts = getFacts(4*10**5+1,mod)
 total = facts[n]
 print(""total: "", str(total))
 dist1 = {}
 for i in arr1:
 if i[0] not in list(dist1.keys()):
 dist1[i[0]] = 1
 else:
 dist1[i[0]] += 1
 print(""dist1: "", str(dist1))

 dist2 = {}
 for i in arr2:
 if i[0] not in list(dist2.keys()):
 dist2[i[0]] = 1
 else:
 dist2[i[0]] += 1
 print(""dist2: "", str(dist2))

 count = 1
 for i in dist1:
 count *= facts[dist1[i]]
 count = count%mod
 print(""count: "", str(count))
 total -= count

 count = 1
 for i in dist2:
 count *= facts[dist2[i]]
 count = count%mod
 print(""count: "", str(count))
 total -= count

 arr1.sort()
 if increasing(arr1):
 count = 1
 else:
 count = 0
 dist3 = {}
 for i in arr1:
 if i not in list(dist3.keys()):
 dist3[i] = 1
 else:
 dist3[i] += 1

 for i in dist3:
 count *= facts[dist3[i]]
 count = count%mod
 print(""count: "", str(count))
 total += count
 total = total%mod
 print(""total: "", str(total))
 print(""------------------"")
</ans>",0,{}
159," <ans>
import sys

#f新しく定義された変数: n, k
print(""n: "", str(n), ""k: "", str(k))

x = []
y = []
mx = []
my = []

#fx, y, mx, my 新しく定義された変数
print(""x: [], y: [], mx: [], my: []"")

for _ in range(n):
 #fx, yy, c 新しく定義された変数
 print(""xx, yy, c: "", str(xx), str(yy), str(c))
 xx, yy, c = sys.stdin.readline().strip().split()
 xx = int(xx)
 yy = int(yy)
 if c == 'W':
 xx += k
 xx %= 2 * k
 yy %= 2 * k
 if xx >= k:
 if yy >= k:
 x.append(xx - k)
 y.append(yy - k)
 else:
 mx.append(xx - k)
 my.append(yy)
 else:
 if yy >= k:
 mx.append(xx)
 my.append(yy - k)
 else:
 x.append(xx)
 y.append(yy)

graph = [[0 for _ in range(k)] for __ in range(k)]

#lx, lmx 新しく定義された変数
print(""lx: 0, lmx: 0"")
lx = len(x)
lmx = len(mx)

graph[0][0] += lx
for i in range(lx):
 graph[x[i]][0] -= 1
 graph[0][y[i]] -= 1
 graph[x[i]][y[i]] += 2

graph[0][0] -= lmx
for i in range(lmx):
 graph[mx[i]][0] += 1
 graph[0][my[i]] += 1
 graph[mx[i]][my[i]] -= 2

for i in graph:
 for j in range(k-1):
 i[j+1] += i[j]

for i in range(k):
 for j in range(k-1):
 graph[j+1][i] += graph[j][i]

big = max([max(i) for i in graph]) + lmx
small = min([min(i) for i in graph]) - lx

#big, small 新しく定義された変数
print(""big: 0, small: 0"")
print(""big: "", str(big), ""small: "", str(small))

if big + small >= 0:
 print(""big"")
else:
 print(""-small"")
</ans>",0,{}
160," <ans>
# coding: utf-8
import sys
#from operator import itemgetter
sys.setrecursionlimit(10**7)
#import math
from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque
#from decimal import Decimal
#from numba import jit

INF = 1 << 50
EPS = 1e-8
mod = 10 ** 9 + 7

def run():
 print(""N: "", N)
 N = int(input())
 nines = []
 for i in range(1, 10):
 if 9 ** i <= N:
 nines.append(9 ** i)
 print(""nines: "", nines)
 sixes = []
 for i in range(1, 10):
 if 6 ** i <= N:
 sixes.append(6 ** i)
 print(""sixes: "", sixes)
 L = len(nines)
 min_ans = INF
 for K in product(list(range(9)), repeat = L):
 print(""K: "", K)
 ans = 0
 s = 0
 for k, x in zip(K, nines):
 if k:
 ans += k
 s += x * k
 print(""ans: "", ans, ""s: "", s)
 if s > N:continue
 resid = N - s
 print(""resid: "", resid)
 for six in sixes:
 tmp = resid // six
 if tmp:
 ans += tmp
 resid -= six * tmp
 print(""ans: "", ans, ""resid: "", resid)
 ans += resid
 min_ans = min(min_ans,ans)
 print(""min_ans: "", min_ans)
 print(""------------------"")
 print()
 print(""Final answer: "", min_ans)

def __starting_point():
 run()

__starting_point()
</ans>",0,{}
161," <ans>
def main():
    n = ii()
    print(""n: "", str(n))
    a = lmi()
    print(""a: "", str(a))
    q = ii()
    print(""q: "", str(q))
    bit = BIT(n, a)
    # print(bit)
    for i in range(q):
        l, r = mi()
        print(""l, r: "", str(l), str(r))
        a = bit.query(l, r+1)
        print(""a: "", str(a))
        print((a-a % 10)//10)
</ans>",0,{}
162," <ans>
def __starting_point():
print(""n: "", n)
w = [int(x) for x in input().strip().split()]
print(""w: "", w)
s = input().strip()
print(""s: "", s)
result = solve(w, s)
print(""result: "", result)
</ans>",0,{}
163," <ans>
#!/usr/bin/env python3
from sys import stdin
from bisect import bisect_left, bisect_right

INF = int(1e9)

def find(par, a):
 print(""find par[a]: "", a)
 if par[a] == a:
 return a
 par[a] = find(par, par[a])
 return par[a]

def union(par, rnk, a, b):
 print(""union a, b: "", a, b)
 a = find(par,a)
 b = find(par,b)
 if a==b:
 return

 union(par, rnk, a, b)
 if rnk[a]<rnk[b]:
 rnk[a] += 1

def solve():
 n, m, k = map(int, stdin.readline().split())
 print(""n, m, k: "", n, m, k)
 cnts = list(map(int, stdin.readline().split()))
 print(""cnts: "", cnts)
 for i in range(1,k):
 cnts[i] += cnts[i-1]

 group = list(range(n))
 print(""group: "", group)
 rnk = [0 for i in range(n)]
 print(""rnk: "", rnk)
 adj = [[INF for j in range(k)] for i in range(k)]
 print(""adj: "", adj)
 for i in range(m):
 u, v, x = map(int, stdin.readline().split())
 if x==0:
 union(group, rnk, u-1, v-1)
 tu = bisect_left(cnts, u)
 tv = bisect_left(cnts, v)
 adj[tu][tv] = min(adj[tu][tv], x)
 adj[tv][tu] = min(adj[tv][tu], x)

 p = 0
 for i in range(k):
 cur = group[p]
 print(""cur: "", cur)
 while p<cnts[i]:
 if group[p]!=cur:
 print(""No"")
 return
 p += 1
 print(""Yes"")

 for i in range(k):
 for j in range(k):
 adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])
 print(""adj[i][j]: "", i, j, adj[i][j])

 for i in range(k):
 adj[i][i] = 0
 for j in range(k):
 if adj[i][j] == INF:
 adj[i][j] = -1

 for i in range(k):
 print(' '.join(map(lambda x: str(x), adj[i])))
</ans>",0,{}
164," <ans>
from sys import stdin, stdout

st = lambda: list(stdin.readline().strip())
li = lambda: list(map(int, stdin.readline().split()))
mp = lambda: list(map(int, stdin.readline().split()))
inp = lambda: int(stdin.readline())
pr = lambda n: stdout.write(str(n) + ""\n"")

n, m = mp()
l = [st() for i in range(n)]
print(""l: "", str(l))
val = 0
k = [[0 for i in range(m)] for j in range(n)]
print(""k: "", str(k))
v = [[False for i in range(m)] for j in range(n)]
print(""v: "", str(v))

for i in range(n):
 for j in range(m):
 if l[i][j] == '.' and not v[i][j]:
 DFS(i, j, val)
 val += 1
 print(""val: "", str(val))

for i in range(n):
 for j in range(m):
 if l[i][j] == '*':
 connected = set()
 s = set()
 for x in range(4):
 newX, newY = i + dx[x], j + dy[x]
 if valid(newX, newY):
 stack.append((newX, newY))
 DFS(newX, newY, val)
 k[i][j] = 1
 for a, b in connected:
 k[i][j] += l[a][b][0]
 k[i][j] %= 10
 s.update(set(map(lambda x: l[x][y][0] for x, y in connected)))
 k[i][j] += sum(s)
 print(""i, j: "", str(i), str(j), ""k[i][j]: "", str(k[i][j]))

pr('\n'.join([''.join([str(i) for i in j]) for j in k]))

def valid(x, y):
 if x >= n or y >= m or x < 0 or y < 0:
 return False
 if v[x][y] or l[x][y] == '*':
 return False
 return True

dx = [-1, 1, 0, 0]
dy = [0, 0, 1, -1]
</ans>",0,{}
165," <ans>
from bisect import bisect_left as bl, bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)

for _ in range(val()):
 print(""_: "", _) # new variable ""_""
 n,l,r = li() # new variables ""n"", ""l"", ""r""
 orig = r # variable ""orig"" assigned a new value
 print(""orig: "", orig)
 l -= 1 # variable ""l"" is modified
 r -= l # variable ""r"" is modified

 currleft = 0 # new variable ""currleft""
 curs = n - 1 # variable ""curs"" is modified

 while curs and currleft + 2*curs <= l: # while condition is modified
 currleft += 2*curs # variable ""currleft"" is modified
 curs -= 1 # variable ""curs"" is modified

 start = n - curs # new variable ""start""
 ans = [] # new variable ""ans""
 head = start # variable ""head"" is modified
 last = head + 1 # variable ""last"" is modified

 half = 0 # variable ""half"" is modified
 while l: # while condition is modified
 half = 1 # variable ""half"" is modified
 start = last # variable ""start"" is modified
 last += 1 # variable ""last"" is modified
 l -= 1 # variable ""l"" is modified

 if not l: break # if condition is modified
 half = 0 # variable ""half"" is modified
 start = head # variable ""start"" is modified
 l -= 1 # variable ""l"" is modified

 if half: # if condition is modified
 ans.append(start) # variable ""ans"" is modified
 if last == n + 1: # if condition is modified
 head += 1 # variable ""head"" is modified
 last = head + 1 # variable ""last"" is modified
 start = head # variable ""start"" is modified
 r -= 1 # variable ""r"" is modified

 while r: # while condition is modified
 ans.append(start) # variable ""ans"" is modified
 r -= 1 # variable ""r"" is modified
 if not r: break # if condition is modified
 start = last # variable ""start"" is modified
 last += 1 # variable ""last"" is modified
 r -= 1 # variable ""r"" is modified
 start = head # variable ""start"" is modified
 </ans>",0,{}
166," <ans>
array2 = input("""").split(' ')
print(""array2: "", str(array2))
summ = 0
array = list()
print(""array: "", str(array))
for t in range(0, int(array2[0])):
 print(""t: "", str(t))
 g = input("""")
 array.append(g)
 print(""g: "", str(g))
if int(array2[1]) == 0:
 for b in range(0, int(array2[0])):
 if '0' in array[b]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 1:
 for c in range(0, int(array2[0])):
 if '0' in array[c] and '1' in array[c]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 2:
 for d in range(0, int(array2[0])):
 if '0' in array[d] and '1' in array[d] and '2' in array[d]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 3:
 for e in range(0, int(array2[0])):
 if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 4:
 for f in range(0, int(array2[0])):
 if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 5:
 for g in range(0, int(array2[0])):
 if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 6:
 for h in range(0, int(array2[0])):
 if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 7:
 for i in range(0, int(array2[0])):
 if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 8:
 for j in range(0, int(array2[0])):
 if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:
 summ = summ + 1
 print(""summ: "", str(summ))

if int(array2[1]) == 9:
 for k in range(0, int(array2[0])):
 if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:
 summ = summ + 1
 print(""summ: "", str(summ))
</ans>",0,{}
167," <ans>
import sys
import random
from math import *

def input():
 return sys.stdin.readline().strip()

def iinput():
 return int(input())

def finput():
 return float(input())

def tinput():
 return input().split()

def linput():
 return list(input())

def rinput():
 return map(int, tinput())

def fiinput():
 return map(float, tinput())

def rlinput():
 return list(map(int, input().split()))
def trinput():
 return tuple(rinput())

def srlinput():
 return sorted(list(map(int, input().split())))

def NOYES(fl):
 if fl:
 print(""NO"")
 else:
 print(""YES"")

def YESNO(fl):
 if fl:
 print(""YES"")
 else:
 print(""NO"")

def main(): # New variable 'x, y, n' are defined
 print(""x: "", str(x), ""y: "", str(y), ""n: "", str(n))
 res = n - y
 print(""res: "", str(res))
 print(""x * (res // x) + y: "", str(x * (res // x) + y))

for inytd in range(iinput()): # New variable 'inytd' is defined
 print(""inytd: "", str(inytd))
 main()
</ans>",0,{}
168," <ans>
def bitmake(digit):#bit文字列生成（取り扱い注意）
    print(""digit: "", str(digit))
    bit_list =list()

    for i in range(2 ** digit):
        bit = []
        for j in range(digit):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                bit.append(j)
        bit_list.append(bit)
    print(""bit_list: "", str(bit_list))
h,w,k = list(map(int,input().split()))
print(""h: "", str(h), ""w: "", str(w), ""k: "", str(k))
grid = [""""]*h
print(""grid before input: "", str(grid))
for i in range(h):
    grid[i] = list(map(str,input()))
print(""grid after input: "", str(grid))

bit_list = bitmake(h+w)
print(""bit_list: "", str(bit_list))
blackh = [0]*h#横
blackw = [0]*w#縦
blacksum = 0
for i in range(h):
    for j in range(w):
        if(grid[i][j] == ""#""):
            blackh[i]+=1
            blackw[j]+=1
            grid[i][j] = 1
            blacksum += 1
        else:
            grid[i][j] = 0
print(""blackh: "", str(blackh), ""blackw: "", str(blackw))
ans = 0
for i in range(2**(h+w)):
    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1
    remove = 0
    hight = []
    width = []
    for j in range(len(bit)):
        l = bit[j]
        if(l <= h-1):
            remove += blackh[l]
            hight.append(l)
        else:
            ind = l - h
            remove += blackw[ind]
            width.append(ind)
    print(""hight: "", str(hight), ""width: "", str(width))
    rid = 0
    for j in range(len(hight)):
        for l in range(len(width)):
            if(grid[hight[j]][width[l]] == 1):
                rid += 1
    
    if((blacksum - remove) + rid == k):
        print(""blacksum: "", str(blacksum), ""remove: "", str(remove), ""rid: "", str(rid))
        ans += 1
print(ans)
</ans>",0,{}
169," <ans>
n = int(input())
print(""n: "", str(n))
if n == 1:
 print(""Washington"")
elif n == 2:
 print(""Adams"")
elif n == 3:
 print(""Jefferson"")
elif n == 4:
 print(""Madison"")
elif n == 5:
 print(""Monroe"")
elif n == 6:
 print(""Adams"")
elif n == 7:
 print(""Jackson"")
elif n == 8:
 print(""Van Buren"")
elif n == 9:
 print(""Harrison"")
elif n == 10:
 print(""Tyler"")
elif n == 11:
 print(""Polk"")
elif n == 12:
 print(""Taylor"")
elif n == 13:
 print(""Fillmore"")
elif n == 14:
 print(""Pierce"")
elif n == 15:
 print(""Buchanan"")
elif n == 16:
 print(""Lincoln"")
elif n == 17:
 print(""Johnson"")
elif n == 18:
 print(""Grant"")
elif n == 19:
 print(""Hayes"")
elif n == 20:
 print(""Garfield"")
elif n == 21:
 print(""Arthur"")
elif n == 22:
 print(""Cleveland"")
elif n == 23:
 print(""Harrison"")
elif n == 24:
 print(""Cleveland"")
elif n == 25:
 print(""McKinley"")
elif n == 26:
 print(""Roosevelt"")
elif n == 27:
 print(""Taft"")
elif n == 28:
 print(""Wilson"")
elif n == 29:
 print(""Harding"")
elif n == 30:
 print(""Coolidge"")
elif n == 31:
 print(""Hoover"")
elif n == 32:
 print(""Roosevelt"")
elif n == 33:
 print(""Truman"")
elif n == 34:
 print(""Eisenhower"")
elif n == 35:
 print(""Kennedy"")
elif n == 36:
 print(""Johnson"")
elif n == 37:
 print(""Nixon"")
elif n == 38:
 print(""Ford"")
elif n == 39:
 print(""Carter"")
elif n == 40:
 print(""Reagan"")
</ans>",0,{}
170," <ans>
import math
from decimal import Decimal
import heapq

def na():
 n, b = list(map(int, input().split()))
 print(""n: "", n, ""b: "", b)
 return n,b

 def nab():
 n, b, c = list(map(int, input().split())), list(map(int, input().split()))
 print(""n: "", n, ""b: "", b, ""c: "", c)
 return n,b,c

 def dv():
 n, m = list(map(int, input().split()))
 print(""n: "", n, ""m: "", m)
 return n,m

 def dva():
 n, m, a = list(map(int, input().split())), list(map(int, input().split()))
 print(""n: "", n, ""m: "", m, ""a: "", a, ""b: "", b)
 return n,m,a

 def eratosthenes(n):
 sieve = list(range(n + 1))
 print(""sieve before filtering: "", sieve)
 for i in sieve:
 if i > 1:
 for j in range(i + i, len(sieve), i):
 sieve[j] = 0
 print(""sieve after filtering: "", sieve)
 return sorted(set(sieve))

 def lol(lst,k):
 k=k%len(lst)
 ret=[0]*len(lst)
 print(""lst: "", lst)
 print(""k: "", k)
 for i in range(len(lst)):
 if i+k<len(lst) and i+k>=0:
 ret[i]=lst[i+k]
 print(""ret[i]: "", ret[i])
 if i+k>=len(lst):
 ret[i]=lst[i+k-len(lst)]
 print(""ret[i]: "", ret[i])
 if i+k<0:
 ret[i]=lst[i+k+len(lst)]
 print(""ret[i]: "", ret[i])
 return(ret)

 def nm():
 n, b, m, c = list(map(int, input().split())), list(map(int, input().split())), int(input()), list(map(int, input().split()))
 print(""n: "", n, ""b: "", b, ""m: "", m, ""c: "", c)
 return n,b,m,c

 def dvs():
 n, m = list(map(int, input().split()))
 print(""n: "", n, ""m: "", m)
 return n, m

 def Factor(n):
 Ans = []
 d = 2
 print(""n: "", n)
 while d * d <= n:
 if n % d == 0:
 Ans.append(d)
 print(""Ans: "", Ans)
 n //= d
 print(""n: "", n)
 else:
 d += 1
 if n > 1:
 Ans.append(n)
 print(""Ans: "", Ans)
 return Ans

 s = input()
 a1 = 'Mike'
 a2 = 'Ann'
 print(""s: "", s)
 if len(s) == 1:
 print(a1)
 print(""a1: "", a1)
 return
 print(""a1: "", a1)
 tc = s[0]
 pre = []
 n = len(s)
 print(""n: "", n)
 for i in range(1, n):
 d = min(s[i], tc)
 pre.append(d)
 print(""pre: "", pre)
 tc = d
 for i in range(1, n):
 if pre[i - 1] < s[i]:
 print(a2)
 print(""a2: "", a2)
 else:
 print(a1)
 print(""a1: "", a1)
</ans>",0,{}
171," <ans>
t, sx, sy, ex, ey = map(int, input().split())
print(""t: "", str(t), ""sx: "", str(sx), ""sy: "", str(sy), ""ex: "", str(ex), ""ey: "", str(ey))
w = input()
n = len(w)
w += "" ""
ans = -1
i = 0
dx = ex - sx
dy = ey - sy
print(""dx: "", str(dx), ""dy: "", str(dy))
if abs(dx) + abs(dy) > t:
 print(""abs(dx)+abs(dy): "", str(abs(dx) + abs(dy)))
 else:
 while i <= t and i < n:
 if dx == 0 and dy == 0:
 ans = i
 break
 print(""i: "", str(i), ""ans: "", str(ans))
 if dx >= 0 and dy >= 0:
 if ((w[i] != ""E"" and w[i] != ""N"") or (dx == 0 and w[i] == ""E"") or (dy == 0 and w[i] == ""N"")) and i < n:
 i += 1
 if dx > 0 and w[i] == ""E"" and i < n:
 i += 1
 dx -= 1
 if dy > 0 and w[i] == ""N"" and i < n:
 i += 1
 dy -= 1
 print(""i: "", str(i), ""dx: "", str(dx), ""dy: "", str(dy))
 elif dx >= 0 and dy <= 0:
 if ((w[i] != ""E"" and w[i] != ""S"") or (dx == 0 and w[i] == ""E"") or (dy == 0 and w[i] == ""S"")) and i < n:
 i += 1
 if dx > 0 and w[i] == ""E"" and i < n:
 i += 1
 dx -= 1
 if dy < 0 and w[i] == ""S"" and i < n:
 i += 1
 dy += 1
 print(""i: "", str(i), ""dx: "", str(dx), ""dy: "", str(dy))
 elif dx <= 0 and dy >= 0:
 if ((w[i] != ""W"" and w[i] != ""N"") or (dx == 0 and w[i] == ""W"") or (dy == 0 and w[i] == ""N"")) and i < n:
 i += 1
 if dx < 0 and w[i] == ""W"" and i < n:
 i += 1
 dx += 1
 if dy > 0 and w[i] == ""N"" and i < n:
 i += 1
 dy -= 1
 print(""i: "", str(i), ""dx: "", str(dx), ""dy: "", str(dy))
 elif dx <= 0 and dy <= 0:
 if ((w[i] != ""W"" and w[i] != ""S"") or (dx == 0 and w[i] == ""W"") or (dy == 0 and w[i] == ""S"")) and i < n:
 i += 1
 if dx < 0 and w[i] == ""W"" and i < n:
 i += 1
 dx += 1
 if dy < 0 and w[i] == ""S"" and i < n:
 i += 1
 dy += 1
 print(""i: "", str(i), ""dx: "", str(dx), ""dy: "", str(dy))
 </ans>",0,{}
172," <ans>
def __starting_point():
    inp = input()
    print(""inp: "", str(inp))
    arr = inp.split(' ')
    print(""arr: "", str(arr))
    L = [int(x) for x in arr]
    print(""L: "", str(L))
    ans = [0,0,0]
    print(""ans: "", str(ans))
    s = 0
    print(""s: "", str(s))
    for l in L:
        s+=l
    print(""s after sum: "", str(s))
    imp = False
    print(""imp before for loop: "", str(imp))
    for l in L:
        if l>s/2:
            imp = True
    print(""imp after for loop: "", str(imp))
    if imp:
        print('Impossible')
    else:
        print(""Before min check:"")
        if L[0]==min(L):
            print(""L[0] is min:"")
            if L[1]>L[2]:
                bonds = L[1]-L[2]
                print(""bonds: "", str(bonds))
                ans[0] += bonds
                print(""ans[0] after update: "", str(ans[0]))
                L[0]-= bonds
                print(""L[0] after update: "", str(L[0]))
                L[1] -=bonds
                print(""L[1] after update: "", str(L[1]))
                if L[0]%2==1:
                    print(""L[0] is odd: "", str(L[0]%2))
                    imp = True
                    print(""imp after L[0] odd check: "", str(imp))
                else:
                    bonds = L[0]//2
                    print(""bonds after L[0] even check: "", str(bonds))
                    ans[0] += bonds
                    print(""ans[0] after update with L[0] even: "", str(ans[0]))
                    ans[2] += bonds
                    print(""ans[2] after update with L[0] even: "", str(ans[2]))
                    ans[1] += (L[1]+L[2])//2 - bonds
                    print(""ans[1] after update with L[0] even: "", str(ans[1]))

        elif L[1]==min(L):
            print(""L[1] is min:"")
            if L[0]>L[2]:
                bonds = L[0]-L[2]
                print(""bonds: "", str(bonds))
                ans[0] += bonds
                print(""ans[0] after update: "", str(ans[0]))
                L[1]-= bonds
                print(""L[1] after update: "", str(L[1]))
                L[0] -= bonds
                print(""L[0] after update: "", str(L[0]))
            else:
                bonds = L[2]-L[0]
                print(""bonds: "", str(bonds))
                ans[1] += bonds
                print(""ans[1] after update: "", str(ans[1]))
                L[1] -= bonds
                print(""L[1] after update: "", str(L[1]))
                L[2] -= bonds
                print(""L[2] after update: "", str(L[2]))
            if L[1]%2==1:
                print(""L[1] is odd: "", str(L[1]%2))
                imp = True
                print(""imp after L[1] odd check: "", str(imp))
            else:
                bonds = L[1]//2
                print(""bonds after L[1] even check: "", str(bonds))
                ans[0] += bonds
                print(""ans[0] after update with L[1] even: "", str(ans[0]))
                ans[1] += bonds
                print(""ans[1] after update with L[1] even: "", str(ans[1]))
                ans[2] += (L[0]+L[2])//2 - bonds
                print(""ans[2] after update with L[1] even: "", str(ans[2]))

        else:
            print(""L[2] is min:"")
            if L[0]>L[1]:
                bonds = L[0]-L[1]
                print(""bonds: "", str(bonds))
                ans[2] += bonds
                print(""ans[2] after update: "", str(ans[2]))
                L[2]-= bonds
                print(""L[2] after update: "", str(L[2]))
                L[0] -= bonds
                print(""L[0] after update: "", str(L[0]))
            else:
                bonds = L[1]-L[0]
                print(""bonds: "", str(bonds))
                ans[1] += bonds
                print(""ans[1] after update: "", str(ans[1]))
                L[2] -= bonds
                print(""L[2] after update: "", str(L[2]))
                L[1] -= bonds
                print(""L[1] after update: "", str(L[1]))
            if L[2]%2==1:
                print(""L[2] is odd: "", str(L[2]%2))
                imp = True
                print(""imp after L[2] odd check: "", str(imp))
            else:
                bonds = L[2]//2
                print(""bonds after L[2] even check: "", str(bonds))
                ans[2] += bonds
                print(""ans[2] after update with L[2] even: "", str(ans[2]))
                ans[1] += bonds
                print(""ans[1] after update with L[2] even: "", str(ans[1]))
                ans[0] += (L[0]+L[1])//2 - bonds
                print(""ans[0] after update with L[2] even: "", str(ans[0]))

        for i in ans:
            print(""ans[i] before imp check: "", str(i))
            if i<0:
                imp = True
                print(""imp after ans[i] < 0 check: "", str(imp))
        if imp:
            print('Impossible')
        else:
            for i in range(3):
                print(ans[i],end=' ')
            print()

__starting_point()
</ans>",0,{}
173," <ans>
import math as ma
import sys
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

print(""li: "", str(li))

def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	print(""x: "", str(x), ""m: "", str(m))
	return x

print(""n,k: "", str(n), str(k))
h = li()
print(""h: "", str(h))
a = [0]*(max(h)+5)
print(""a: "", str(a))
mx = max(h)
mn = min(h)
print(""mx: "", str(mx), ""mn: "", str(mn))
fo = True
for i in range(1,n):
	if(h[i]!=h[i-1]):
		fo=False
		break
print(""fo: "", str(fo))
for i in range(n):
	a[0]+=1
	print(""a[0]: "", str(a[0]))
	a[h[i]+1]-=1
	print(""a[h[i]+1]: "", str(a[h[i]+1]))
for i in range(1,len(a)):
	a[i]=a[i]+a[i-1]
	print(""a[i]: "", str(a[i]))
s = a[mx]
print(""s: "", str(s))
cc = 0
fl = False
for i in range(mx-1,mn,-1):
	if(s+a[i]>k):
		fl=True
		s = a[i]
		cc += 1
		print(""s: "", str(s), ""cc: "", str(cc), ""fl: "", str(fl))
	else:
		fl = False
		s += a[i]
		print(""s: "", str(s), ""cc: "", str(cc), ""fl: "", str(fl))
if(s <= k and fo == False):
	cc += 1
	print(""s: "", str(s), ""cc: "", str(cc), ""fo: "", str(fo))
print(cc)
</ans>",0,{}
174," <ans>
MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]
print(""MOVS: "", str(MOVS))

def check(a):
 return 0<=a<8
set1 = set()
set2 = set()
dic1 = dict()
dic2 = dict()
print(""set1: "", str(set1), ""set2: "", str(set2), ""dic1: "", str(dic1), ""dic2: "", str(dic2))

def cango1(matrix,pos,lap):
 for dx,dy in MOVS:
 nx,ny = dx+pos[0],dy+pos[1]
 if not check(nx) or not check(ny):
 continue
 if (nx,ny) in set1:
 continue
 dic1[(nx,ny)]=lap%2
 set1.add((nx,ny))
 print(""set1: "", str(set1), ""dic1: "", str(dic1))
 cango1(matrix,(nx,ny),lap+1)

def cango2(matrix,pos,lap):
 for dx,dy in MOVS:
 nx,ny = dx+pos[0],dy+pos[1]
 if not check(nx) or not check(ny):
 continue
 if (nx,ny) in set2:
 continue
 dic2[(nx,ny)]=lap%2
 set2.add((nx,ny))
 print(""set2: "", str(set2), ""dic2: "", str(dic2))
 cango2(matrix,(nx,ny),lap+1)

q = int(input())
print(""q: "", str(q))
for ww in range(q):
 matrix = [input().strip() for i in range(8)]
 pos = []
 bad = set()
 print(""matrix: "", str(matrix), ""pos: "", str(pos), ""bad: "", str(bad))
 for i in range(8):
 for j in range(8):
 if matrix[i][j] == 'K':
 pos.append((i,j))
 if matrix[i][j]=='#':
 bad.add((i,j))
 set1,set2,dic1,dic2=set(),set(),dict(),dict()
 print(""set1: "", str(set1), ""set2: "", str(set2), ""dic1: "", str(dic1), ""dic2: "", str(dic2))
 cango1(matrix, pos[0],0)
 cango2(matrix,pos[1],0)
 if ww!=q-1:
 input()
 sec = (set1&set2) - bad
 print(""sec: "", str(sec))
 for x,y in sec:
 if dic1[(x,y)]==dic2[(x,y)]:
 print(""YES"")
 break
 else:
 print(""NO"")
</ans>",0,{}
175," <ans>
'''input
3
0 2 0
1 0 3
'''
from sys import stdin
from copy import deepcopy
from collections import deque

def find_start(pile):
 print(""pile: "", pile)
 start = 1
 index = -1
 for i in range(len(pile)):
 if pile[i] == start:
 index = i
 break
 latest = start
 if index != -1:
 flag = True
 for i in range(index, len(pile)):
 if pile[i] == latest:
 latest += 1
 else:
 flag = False
 break
 if flag:
 start = latest
 return start

def check_start(num, op):
 print(""num: "", num, ""op: "", op)
 op[0] = 0
 nonlocal arr
 nonlocal barr
 mydict = [0] * (n + 1)
 for i in range(len(arr)):
 mydict[arr[i]] += 1
 # print(""mydict: "", mydict)
 zeroes = mydict[0]
 pile = deque(barr[:])
 # print(""pile: "", pile)
 for i in range(num):
 if zeroes > 0:
 op[0] += 1
 pile.append(0)
 zeroes -= 1
 mydict[0] -= 1
 # print(""mydict: "", mydict)
 # print(""pile: "", pile)
 element = pile.popleft()
 mydict[element] += 1
 # print(""mydict: "", mydict)
 # print(""pile: "", pile)
 if element == 0:
 zeroes += 1
 # print(""mydict: "", mydict)
 if i == num - 1:
 # print(""mydict: "", mydict)
 # print(""pile: "", pile)
 if all(mydict[i] == 0 for i in range(1, n + 1)):
 return True
 return False

n = int(stdin.readline().strip())
 arr = list(map(int, stdin.readline().split()))
 barr = list(map(int, stdin.readline().split()))
 start = 0
 end = 2 * n
 op = [0]

if check_start(0, op):
 print(""op[0]: "", op[0])
 return

pos = [0] * (n + 1)
 for i in range(n):
 pos[barr[i]] = i + 1

ans = -float('inf')
 for i in range(1, n + 1):	
 ans = max(pos[i] - i + 1 + n, ans)
 print(""ans: "", ans)
</ans>",0,{}
176," <ans>
def xmax(x, y):
 print(""x: "", str(x), ""y: "", str(y))
 if x[1] > y[1]:
 return x
 return y

class SegTree:
 print(""N: "", N, ""M: "", M)
 def __init__(self, init_val, n, ide_ele, seg_func):
 self.segfunc = seg_func
 self.num = 2**(n-1).bit_length()
 self.ide_ele = ide_ele
 self.seg=[self.ide_ele]*2*self.num
 for i in range(n):
 print(""init_val[i]: "", init_val[i])
 self.seg[i+self.num-1]=init_val[i]
 for i in range(self.num-2,-1,-1) :
 self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])

 print(""seg: "", str(self.seg))

 def update(self, k, x):
 print(""k: "", k, ""x: "", x)
 ll = k
 k += self.num-1
 self.seg[k] = (ll, self.seg[k][1] + x)
 while k+1:
 k = (k-1)//2
 self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
 print(""seg: "", str(self.seg))

 def update2(self, k, x):
 print(""k: "", k, ""x: "", x)
 k += self.num-1
 self.seg[k] = x
 while k+1:
 k = (k-1)//2
 self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])
 print(""seg: "", str(self.seg))

 def query(self, p, q):
 print(""p: "", p, ""q: "", q)
 if q<=p:
 return self.ide_ele
 p += self.num-1
 q += self.num-2
 res=self.ide_ele
 while q-p>1:
 if p&1 == 0:
 res = self.segfunc(res,self.seg[p])
 if q&1 == 1:
 res = self.segfunc(res,self.seg[q])
 q -= 1
 p = p//2
 q = (q-1)//2
 if p == q:
 res = self.segfunc(res,self.seg[p])
 else:
 res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])
 print(""res: "", res)
 return res

import sys;input=sys.stdin.readline
N, M = map(int, input().split())
 print(""N: "", N, ""M: "", M)
 X = list(map(int, input().split()))
 print(""X: "", X)
 sts = [[] for _ in range(N)]
 for i in range(1, M+1):
 print(""i: "", i)
 a, b = map(int, input().split())
 print(""a: "", a, ""b: "", b)
 sts[a-1].append((i, b-1))
 sts[b-1].append((i, a-1))
 print(""sts[a-1]: "", sts[a-1])
 print(""sts[b-1]: "", sts[b-1])
 X[a-1] -= 1
 X[b-1] -= 1
 print(""X: "", X)
 minf = -(10 ** 18)-1
 ss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)
 print(""ss: "", ss)
 f = False
 R = []
 vs = set()
 while True:
 j, mx = ss.query(0, N)
 print(""j: "", j, ""mx: "", mx)
 if mx<0:
 f=True
 break
 while sts[j]:
 i, co = sts[j].pop()
 print(""i: "", i)
 if i in vs:
 continue
 vs.add(i)
 print(""vs: "", vs)
 ss.update(co, 1)
 R.append(i)
 if len(R) == M:break
 ss.update2(j, (j, minf))
 print(""R: "", R)
 if f or len(R) != M:print(""DEAD"")
 else:print(""ALIVE"")
 print(""R[::-1]: "", R[::-1])
</ans>",0,{}
177," <ans>
import sys
import math

def ii():
 return sys.stdin.readline().strip()

def idata():
 return [int(x) for x in ii().split()]

def bfs(graph1, root1):
 visited1 = set()
 print(""visited1: "", visited1)
 queue1 = [[root1, 0]]
 visited1.add(root1)
 qw, ver = 0, 1
 while queue1:
 vertex1 = queue1[0]
 queue1 = queue1[1:]
 for neig1 in graph1[vertex1[0]]:
 if neig1 not in visited1:
 visited1.add(neig1)
 print(""neig1: "", neig1)
 queue1 += [[neig1, vertex1[1] + 1]]
 if qw < vertex1[1] + 1:
 ver, qw = neig1, vertex1[1] + 1
 print(""ver, qw: "", ver, qw)
 return ver, qw

def dfs(graph, ver):
 used_v = set()
 print(""used_v: "", used_v)
 depth = [0] * (len(graph) + 1)
 level = [ver]
 num_of_level = 0
 while level:
 new_level = []
 for v in level:
 depth[v] = num_of_level
 used_v.add(v)
 print(""v: "", v)
 for v1 in graph[v]:
 if v1 not in used_v:
 new_level += [v1]
 level = new_level
 num_of_level += 1
 return depth

def binary_search(array, x):
 left, right = -1, len(array)
 print(""left: "", left, ""right: "", right)
 while left + 1 != right:
 middle = (left + right) // 2
 print(""middle: "", middle)
 if array[middle] >= x:
 right = middle
 elif array[middle] < x:
 left = middle
 print(""left: "", left, ""right: "", right)
 return right

def c_mod(n1, k1, mod1):
 num = den = 1
 print(""n1: "", n1, ""k1: "", k1, ""mod1: "", mod1)
 for i in range(n1 - k1):
 num = (num * (n1 - i)) % mod1
 den = (den * (i + 1)) % mod1
 print(""num: "", num, ""den: "", den)
 return (num * pow(den, mod1 - 2, mod1)) % mod1

def c(n1, k1):
 num = den = 1
 print(""n1: "", n1, ""k1: "", k1)
 for i in range(n1 - k1):
 num = num * (n1 - i)
 den = den * (i + 1)
 print(""num: "", num, ""den: "", den)
 return num // den

def v_sistemu(x, k):
 x = int(x)
 z = ''
 print(""x: "", x)
 while x:
 z += str(x % k)
 x //= k
 print(""x: "", x)
 return z[::-1]

def iz_sistemi(x, k):
 x = str(x)[::-1]
 ans = 0
 print(""x: "", x)
 for i in range(len(x)):
 ans += int(x[i]) * pow(k, i)
 print(""ans: "", ans)
 return ans

def solve_of_problem():
 n = int(ii())
 print(""n: "", n)
 ans = 2
 for i in range(n):
 ans *= 2
 if n % (ans - 1) == 0:
 print(""ans: "", ans)
 print(""n // (ans - 1): "", n // (ans - 1))
 return
 print(""ans: "", ans)

for ______ in range(int(ii())):
 solve_of_problem()
</ans>",0,{}
178," <ans>
import sys

def Min(x, y):
 print(""Min: X: "", str(x), ""Y: "", str(y))
 if x > y:
 return y
 else:
 return x

def Gcd(x, y):
 print(""Gcd: X: "", str(x), ""Y: "", str(y))
 if x == 0:
 return y
 else:
 return Gcd(y % x, x)

def Lcm(x, y):
 print(""Lcm: X: "", str(x), ""Y: "", str(y))
 return x * y // Gcd(x, y)

n = int(input())
a = [int(0) for i in range(0, n)]
d = [int(0) for i in range(0, n)]

print(""n: "", str(n))
print(""a: "", str(a))
print(""d: "", str(d))

ok = 0

cur = 0

len = Lcm(7, n)

for i in range(0, 7 * n):
 print(""i: "", str(i), ""n: "", str(n), ""i % n: "", str(i % n))
 if i % n >= n:
 continue
 if a[i % n] == 0 :
 print(""i % n + 1: "", str(i % n + 1))
 ok = 1
 break
 if cur != 6:
 a[i % n] -= 1
 d[i % n] += 1
 cur = (cur + 1) % 7

if ok == 0:
 k = 10**20
 print(""k: "", str(k))
 for i in range(0, n):
 print(""i: "", str(i), ""a[i]: "", str(a[i]), ""d[i]: "", str(d[i]))
 if d[i] == 0:
 continue
 if a[i] % d[i] > 0:
 k = Min(k, a[i] // d[i])
 else:
 k = Min(k, a[i] // d[i] - 1)
 print(""k: "", str(k))

 if k == 10**20:
 k = 0

 for i in range(0, n):
 print(""i: "", str(i), ""a[i]: "", str(a[i]), ""d[i]: "", str(d[i]))
 a[i] -= k * d[i]
 print(""a[i]: "", str(a[i]))

 iter = 0
 cur = 0

 while True:
 print(""iter: "", str(iter), ""n: "", str(n), ""iter % n: "", str(iter % n), ""a[iter % n]: "", str(a[iter % n]))
 if iter % n >= n:
 break
 if a[iter % n] == 0:
 print(iter % n + 1)
 break
 else:
 if cur != 6:
 a[iter % n] -= 1
 cur = (cur + 1) % 7
 iter = (iter + 1) % n
</ans>",0,{}
179," <ans>
if A, B, C, X, Y = map(int, input().split()):
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))

if 2 * C > A + B:
 print(""before if statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 print(""A * X + B * Y"")
 print(""after if statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 else:
 print(""before if-else statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 if X > Y:
 print(""before if statement in if-else statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 print(""min(2 * C * X, 2 * C * Y + A * (X - Y))"")
 print(""after if statement in if-else statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 else:
 print(""before if statement in if-else statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
 print(""min(2 * C * Y, 2 * C * X + B * (Y - X))"")
 print(""after if statement in if-else statement"")
 print(""A: "", str(A), ""B: "", str(B), ""C: "", str(C), ""X: "", str(X), ""Y: "", str(Y))
</ans>",0,{}
180," <ans>
import sys
sys.setrecursionlimit(10**9)
N,M=map(int,input().split())

print(""N: "", N, ""M: "", M)

def find_negative_loop(n,w,es):
 dist=[float(""inf"")]\*n
 print(""dist: "", dist)
 #この始点はどこでもよい
 dist[1]=0
 print(""dist[1]: "", dist[1])

 for i in range(n):
 print(""i: "", i)
 for j in range(w):
 e = es[j]
 if dist[e[1]] > dist[e[0]] + e[2]:
 dist[e[1]] = dist[e[0]] + e[2]
 print(""dist[e[1]]: "", dist[e[1]])
 if i == n - 1:
 return True
 return False

def shortest_path(s, n, w, es):
 dist = [float(""inf"")] * n
 print(""dist: "", dist)
 dist[s] = 0
 print(""dist[s]: "", dist[s])

 while True:
 update = False
 for p, q, r in es:
 if dist[p] != float(""inf"") and dist[q] > dist[p] + r:
 dist[q] = dist[p] + r
 print(""dist[q]: "", dist[q])
 update = True
 if not update:
 break

 return dist

graph = [[] for _ in range(N+1)]
 elist = []
 print(""elist before: "", elist)
 for _ in range(M):
 a, b, c = map(int, input().split())
 graph[a].append(b)
 elist.append((a, b, -c))
 print(""elist after: "", elist)

 #remove unnecessary vertex and edge
 visited = [None]*(N+1)
 print(""visited: "", visited)
 def check_reachable(u):
 visited[u] = True
 if u == N:
 reachable[u] = True
 return True
 elif reachable[u] is not None:
 return reachable[u]

 cnt = 0
 for v in graph[u]:
 if not visited[v]:
 ret = check_reachable(v)
 if ret:
 cnt += 1

 reachable[u] = True
 if cnt > 0:
 return True
 else:
 reachable[u] = False
 return False

reachable = [None]*(N+1)
 print(""reachable: "", reachable)
 for i in range(1, N+1):
 if reachable[i] is None:
 visited = [False]*(N+1)
 check_reachable(i)
 print(""reachable after: "", reachable)

 elist2 = []
 print(""elist2: "", elist2)
 for a, b, nc in elist:
 if reachable[b]:
 elist2.append((a, b, nc))
 print(""elist2 after: "", elist2)

 M2 = len(elist2)
 print(""M2: "", M2)
 res1 = find_negative_loop(N+1, M2, elist2)
 print(""res1: "", res1)

 if res1:
 print(""inf"")
 else:
 res2 = shortest_path(1, N+1, M2, elist2)
 print(""res2: "", res2)
 print(""-res2[N]: "", -res2[N])
</ans>",0,{}
181," <ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
 print(""n: "", str(n))
 if n < 2: return list()
 prime = [True for _ in range(n + 1)]
 p = 3
 while p * p <= n:
 print(""p: "", str(p))
 if prime[p]:
 for i in range(p * 2, n + 1, p):
 print(""i: "", str(i))
 prime[i] = False
 p += 2
 return r = [2] + [p for p in range(3, n + 1, 2) if prime[p]]

def divs(n, start=1):
 print(""n: "", str(n))
 divisors = []
 for i in range(start, int(math.sqrt(n) + 1)):
 print(""i: "", str(i))
 if n % i == 0:
 if n / i == i:
 divisors.append(i)
 else:
 divisors.extend([i, n // i])
 return divisors

def divn(n, primes):
 print(""n: "", str(n))
 print(""primes: "", str(primes))
 divs_number = 1
 for i in primes:
 print(""i: "", str(i))
 while n % i == 0:
 print(""t: "", str(t))
 t += 1
 n //= i
 divs_number *= t

def flin(d, x, default=-1):
 print(""d: "", str(d))
 print(""x: "", str(x))
 print(""default: "", str(default))
 left = right = -1
 for i in range(len(d)):
 if d[i] == x:
 if left == -1: left = i
 right = i
 if left == -1:
 return default, default
 else:
 return left, right

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
 print(""_: "", str(_))
 n, k = mi()
 print(""n: "", str(n))
 print(""k: "", str(k))
 even = n - 2*(k - 1)
 print(""even: "", str(even))
 odd = n - (k - 1)
 print(""odd: "", str(odd))
 if odd > 0 and odd % 2:
 res = [1]*(k - 1) + [odd]
 print(""res: "", str(res))
 print('YES')
 else:
 print('NO')
</ans>",0,{}
182," <ans>
from sys import stdin, stdout
import collections
import math

def isSubSequence(str1,str2):
# print(str1: """", str(str1), ""str2: "", str(str2))
 m = len(str1)
 n = len(str2)
 j = 0 # Index of str1 
 i = 0 # Index of str2 
 while j<m and i<n: # print(j: """", str(j), "" i: "", str(i))
 if str1[j] == str2[i]: # print(""str1[j]: "", str(str1[j]), ""str2[i]: "", str(str2[i]))
 j = j+1
 i = i + 1
 else:
 i = i + 1
 return j==m

T = int(input())

for t in range(T):
 s = input() # print(""s: "", str(s))
 t = input() # print(""t: "", str(t))
 p = input() # print(""p: "", str(p))

 freq_s = collections.defaultdict(int) # print(""freq_s: "", str(freq_s))
 freq_t = collections.defaultdict(int) # print(""freq_t: "", str(freq_t))
 freq_p = collections.defaultdict(int) # print(""freq_p: "", str(freq_p))

 for i in range(26):
 freq_s[chr(97+i)] = 0 # print(""freq_s[chr(97+i)]: "", str(freq_s[chr(97+i)]))
 freq_t[chr(97+i)] = 0 # print(""freq_t[chr(97+i)]: "", str(freq_t[chr(97+i)]))
 freq_p[chr(97+i)] = 0 # print(""freq_p[chr(97+i)]: "", str(freq_p[chr(97+i)]))

 for letter in s:
 freq_s[letter] += 1 # print(""freq_s[letter]: "", str(freq_s[letter]))
 for letter in t:
 freq_t[letter] += 1 # print(""freq_t[letter]: "", str(freq_t[letter]))
 for letter in p:
 freq_p[letter] += 1 # print(""freq_p[letter]: "", str(freq_p[letter]))

 sub = isSubSequence(s,t) # print(""sub: "", str(sub))
 if sub==0:
 print('NO')
 else:
 flag = 0
 for i in range(26):
 d = freq_t[chr(97+i)] - freq_s[chr(97+i)]
 if d>0:
 if freq_p[chr(97+i)]<d and flag==0:
 print('NO')
 flag = 1
 if flag==0:
 print('YES')
 </ans>",0,{}
183," <ans>
#
# abc147 c
#
import sys
from io import StringIO
import unittest

class TestClass(unittest.TestCase):
def assertIO(self, input, output):
stdout, stdin = sys.stdout, sys.stdin
sys.stdout, sys.stdin = StringIO(), StringIO(input)
resolve()
sys.stdout.seek(0)
out = sys.stdout.read()[:-1]
sys.stdout, sys.stdin = stdout, stdin
self.assertEqual(out, output)

def test\_入力例\_1(self):
input = """"""3
1
2 1
1
1 1
1
2 0""""""
output = """"""2""""""
self.assertIO(input, output)
print(""N: "", N)

def test\_入力例\_2(self):
input = """"""3
2
2 1
3 0
2
3 1
1 0
2
1 1
2 0""""""
output = """"""0""""""
self.assertIO(input, output)
print(""N: "", N)
print(""C: "", C)

def test\_入力例\_3(self):
input = """"""2
1
2 0
1
1 0""""""
output = """"""1""""""
self.assertIO(input, output)
print(""N: "", N)
print(""C: "", C)

def resolve():
global N, C
N = int(input())
print(""N: "", N)
C = []
for i in range(N):
print(""i: "", i)
a = int(input())
print(""a: "", a)
C.append([list(map(int, input().split())) for j in range(a)])
print(""C: "", C)
ans = 0
for bit in range(1 << N):
print(""bit: "", bin(bit))
f = True
for i in range(N):
if bit & (1 << i):
for c in C[i]:
if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
f = False
break
if f == True:
ans = max(ans, bin(bit).count(""1""))
print(""ans: "", ans)
print("""")

def __starting\_point():
# unittest.main()
resolve()

__starting\_point()
</ans>",0,{}
184," <ans>
# alpha = ""abcdefghijklmnopqrstuvwxyz""
prime = 998244353
t = 1#int(input())
from heapq import heappop, heappush
for test in range(t):
 print(""t: "", t)
 n = int(input())
 # n,m = (map(int, input().split()))
 print(""n: "", n)
 s = input()
 # ans = 1
 # start = 1
 # cur = s[0]
 # tmp = 0
 grp = []
 cnt = []
 tmp = 0
 cur = s[0]
 for i in s:
 print(""i: "", i, ""cur: "", cur)
 if i==cur:
 tmp+=1
 else:
 grp.append(cur)
 cnt.append(tmp)
 cur = i
 tmp = 1
 if len(grp)==1:
 print(((n*(n+1))//2)%prime)
 else:
 if grp[0]==grp[-1]:
 ans = ((cnt[0]+1)*(cnt[-1]+1))%prime
 print(""grp: "", grp, ""cnt: "", cnt, ""ans: "", ans)
 else:
 ans = cnt[0]+1+cnt[-1]
 print(""grp: "", grp, ""cnt: "", cnt, ""ans: "", ans)
</ans>",0,{}
185," <ans>
n, l, r = [int(i) for i in input().split()]
print(""n: "", str(n), ""l: "", str(l), ""r: "", str(r))

number_of_zeros = 0
number_of_ones = 0
number_of_twos = 0

if l%3 == 0:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
elif l%3 == 1:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3
    if r%3 == 2:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3 + 1
        number_of_twos = (r-l+1)//3 + 1
elif l%3 == 2:
    if r%3 == 0:
        number_of_zeros = (r-l+1)//3 + 1
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1
    if r%3 == 1:
        number_of_zeros = (r-l+1)//3
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3
    elif r%3 == 2:
        number_of_zeros = (r-l+1)//3 
        number_of_ones = (r-l+1)//3
        number_of_twos = (r-l+1)//3 + 1

dp = [[-1 for i in range(3)] for j in range(n+1)]
print(""dp: "", str(dp))

MOD = 10**9 + 7
dp[1][0] = number_of_zeros%MOD
dp[1][1] = number_of_ones%MOD
dp[1][2] = number_of_twos%MOD
print(""dp[1]: "", str(dp[1]))

for i in range(2,n+1):
    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD
    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD
    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD
    print(""dp[{}]: "".format(i), str(dp[i]))

if dp[n][0]!=-1:
    print(dp[n][0]%MOD)
else:
    print(0)
</ans>",0,{}
186," <ans>
from sys import stdin, stdout 
from bisect import bisect_left, bisect_right
from collections import defaultdict
import math
from fractions import Fraction as frac
from random import random
cin = stdin.readline
def cout(x):
	stdout.write(str(x)+'\n')
def var(type = int):
	return type(stdin.readline())
def readline(type = int):
	return list(map(type,stdin.readline().split()))
def readlist(type = int):
	return list(map(type,stdin.readline().split()))
def sorted_indexes(arr):
	return sorted(list(range(len(arr))),key=arr.__getitem__)
def printr(arr):
	[stdout.write(str(x)+' ')   for x in arr]
	cout('')
def find_lt(a, x):#'Find rightmost value less than x'
	i = bisect_left(a, x)
	if i:
		return a[i-1]
	raise ValueError
def find_gt(a, x):#'Find leftmost value greater than x'
	i = bisect_right(a, x)
	if i != len(a):
		return a[i]
	raise ValueError
def dist(x,y):
	return math.sqrt(x*x + y*y)
def binary_search(arr, x):
	i = bisect_left(arr, x)
	if i == len(arr) or arr[i] != x:
		return -1
	return i

n, a, b = readline(int)
price = [a,b]
arr = readlist(int)
half = n//2
cost = 0
flg = True
for i in range(half):
	print(""i: "", i)
	print(""arr[i]: "", arr[i])
	print(""arr[n-1-i]: "", arr[n-1-i])
	if arr[i] == arr[n-1-i] == 2:
		cost += 2*min(a,b)
		print(""cost: "", cost)
	elif arr[i] == 2 and arr[n-1-i] <= 1:
		cost += price[arr[n-1-i]]
		print(""cost: "", cost)
	elif arr[i] <= 1 and arr[n-1-i] == 2:
		cost += price[arr[i]]
		print(""cost: "", cost)
	elif arr[i] != arr[n-1-i]:
		flg = False
		print(""flg: "", flg)
		break
if n%2 == 1:
	if arr[half] == 2:
		cost += min(a,b)
		print(""cost: "", cost)
if not flg:
	print(-1)
else:
	print(cost)
</ans>",0,{}
187," <ans>
from sys import stdin
import sys
import numpy as np
import collections
from functools import cmp_to_key
import heapq
sys.setrecursionlimit(100000)

class mint:
 ...

def main():
 N = ri()
 print(""N: "", N)
 A = ria()
 print(""A: "", A)
 A = sorted(A)
 print(""sorted A: "", A)
 A = list(reversed(A))
 Pow2 = [mint(0)] * (N + 1)
 print(""Pow2: "", Pow2)
 Pow2[0] = mint(1)
 for i in range(1,N+1):
 Pow2[i] = Pow2[i-1] * 2
 print(""Pow2 after calculation: "", Pow2)
 tot = mint(0)
 for i in range(N):
 tot += mint(A[i]) * Pow2[N-1]
 print(""tot after first loop: "", tot)
 if i > 0: tot += mint(A[i]) * i * Pow2[N-2]
 print(""tot after second loop: "", tot)
 tot *= Pow2[N]
 print(""tot after multiplying with Pow2[N]: "", tot)
 print(tot)

def __starting_point():
 main()

__starting_point()
</ans>",0,{}
188," <ans>
r1 = input()
print(""r1: "", str(r1))
r2 = input()
print(""r2: "", str(r2))
n = len(r1)
print(""n: "", str(n))
l = [0]
print(""l: "", str(l))
for i in range(n):
 print(""i: "", str(i), ""r1[i]: "", str(r1[i]), ""r2[i]: "", str(r2[i]))
 if r1[i]=='0':
 if r2[i]=='0':
 l.append(2)
 print(""l[i]: "", str(l[i]))
 else:
 l.append(1)
 print(""l[i]: "", str(l[i]))
 else:
 if r2[i]=='X':
 l.append(0)
 print(""l[i]: "", str(l[i]))
 else:
 l.append(-1)
 print(""l[i]: "", str(l[i]))
 l.append(0)
 print(""l: "", str(l))
 s = len(l)
 print(""s: "", str(s))
 count = 0
 print(""count: "", str(count))
 u = 1
 print(""u: "", str(u))
 e = 1
 print(""e: "", str(e))
 while(u<s-1):
 if l[u]==2 and e==1:
 if l[u+1]==2:
 e = 2
 print(""e: "", str(e))
 u = u + 1
 continue
 elif l[u+1]==1 or l[u+1]==-1:
 count = count + 1
 print(""count: "", str(count))
 u = u + 2
 continue
 elif l[u+1]==2:
 count = count + 2
 print(""count: "", str(count))
 u = u + 2
 e = 1
 continue
 if l[u]==2 and e==2:
 if l[u+1]==2:
 count = count + 2
 print(""count: "", str(count))
 u = u + 2
 e = 1
 continue
 if l[u]==1 or l[u]==-1:
 if l[u+1]==2:
 count = count + 1
 print(""count: "", str(count))
 u = u + 2
 continue
 if l[u]==0:
 u = u + 1
 print(""count: "", str(count))
</ans>",0,{}
189," <ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

opr = ['#', '^', '&', '$']
namespace = { ""res"" : (False, ""res"") }
rules = dict()
lookup = dict()
cnt = -1

def get_tag(var):
 if var in namespace:
 return namespace[var][1]
 else:
 return var

N = int(input())
print(""N: "", N)
for _ in range(N):
 lval, rval = input().split('=')
 print(""lval: "", lval, ""rval: "", rval)
 for c in opr:
 if c in rval:
 arg1, arg2 = list(map(get_tag, rval.split(c)))
 rule = (arg1, arg2, c)
 if rule in rules:
 namespace[lval] = (True, rules[rule])
 print(""rule: "", rule)
 else:
 cnt += 1
 namespace[lval] = (True, cnt)
 rules[rule] = cnt
 lookup[cnt] = rule
 break
 else:
 if rval in namespace:
 namespace[lval] = namespace[rval]
 else:
 namespace[lval] = (False, rval)

if namespace[""res""] == (False, ""res""):
 print(""namespace[res]: "", namespace[""res""])
 print(""0"")
 return

program = []
myvars = dict()

def reserve():
 return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4))

def implement(rule, final):
 if type(rule) == str:
 return rule
 elif rule in myvars:
 return myvars[rule]
 else:
 if final:
 name = ""res""
 else:
 name = reserve()
 myvars[rule] = name
 arg1, arg2, op = lookup[rule]
 var1, var2 = implement(arg1, False), implement(arg2, False)
 program.append(name + ""="" + var1 + op + var2)
 return name

seed(123)
if namespace[""res""][0]:
 implement(namespace[""res""][1], True)
 else:
 program.append(""res="" + namespace[""res""][1])
 print(""namespace[res]: "", namespace[""res""])
 print(""len(program): "", len(program))
 print(""\n"".join(program))
</ans>",0,{}
190," <ans>
''' CODED WITH LOVE BY SATYAM KUMAR '''

from sys import stdin, stdout
import heapq
import cProfile, math
from collections import Counter, defaultdict, deque
from bisect import bisect_left, bisect, bisect_right
import itertools
from copy import deepcopy
from fractions import Fraction
import sys, threading
import operator as op
from functools import reduce
import sys

sys.setrecursionlimit(10 ** 6)  # max depth of recursion
threading.stack_size(2 ** 27)  # new thread will get stack of such size
fac_warm_up = False
printHeap = str()
memory_constrained = False
P = 10 ** 9 + 7


class MergeFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n
        self.lista = [[_] for _ in range(n)]

    def find(self, a):
        to_update = []
        while a != self.parent[a]:
            to_update.append(a)
            a = self.parent[a]
        for b in to_update:
            self.parent[b] = a
        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return
        if self.size[a] < self.size[b]:
            a, b = b, a
        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]
        self.lista[a] += self.lista[b]

    def set_size(self, a):
        return self.size[self.find(a)]

    def __len__(self):
        return self.num_sets


def display(string_to_print):
    stdout.write(str(string_to_print) + ""\n"")


def prime_factors(n):  # n**0.5 complex
    factors = dict()
    for i in range(2, int(math.sqrt(n)) + 1):
        while n % i == 0:
            if i in factors:
                factors[i] += 1
            else:
                factors[i] = 1
            n = n // i
    if n > 2:
        factors[n] = 1
    print(""factors: "", str(factors))
    return factors


def all_factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


def fibonacci_modP(n, MOD):
    if n < 2: return 1
    print(""fibonacci_modP: "", str(n), str(MOD))
    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(
        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD


def factorial_modP_Wilson(n, p):
    if (p <= n):
        print(""factorial_modP_Wilson: "", str(p), ""is not a prime factor"")
        return 0
    res = (p - 1)
    for i in range(n + 1, p):
        print(""factorial_modP_Wilson: "", str(i), ""is not a prime factor"")
        res = (res * cached_fn(InverseEuler, i, p)) % p
    print(""factorial_modP_Wilson: "", str(res))
    return res


def binary(n, digits=20):
    b = bin(n)[2:]
    b = '0' * (digits - len(b)) + b
    print(""binary: "", str(b))
    return b


def is_prime(n):
    """"""Returns True if n is prime.""""""
    if n < 4:
        print(""is_prime: "", str(n), ""is prime"")
        return True
    if n % 2 == 0:
        print(""is_prime: "", str(n), ""is not prime"")
        return False
    if n % 3 == 0:
        print(""is_prime: "", str(n), ""is not prime"")
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            print(""is_prime: "", str(n), ""is not prime"")
            return False
        i += w
        w = 6 - w
    print(""is_prime: "", str(n), ""is prime"")
    return True


def generate_primes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    print(""generate_primes: "", str(p))
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    print(""generate_primes: "", str(prime))
    return prime


factorial_modP = []


def warm_up_fac(MOD):
    nonlocal factorial_modP, fac_warm_up
    if fac_warm_up: return
    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]
    for i in range(2, fac_warm_up_size):
        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD
    fac_warm_up = True


def InverseEuler(n, MOD):
    return pow(n, MOD - 2, MOD)


def nCr(n, r, MOD):
    nonlocal fac_warm_up, factorial_modP
    if not fac_warm_up:
        warm_up_fac(MOD)
        fac_warm_up = True
    print(""nCr: "", str(n), str(r), str(MOD))
    return (factorial_modP[n] * (
            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD


def get_int():
    return int(stdin.readline().strip())


def get_tuple():
    return list(map(int, stdin.readline().split()))


def get_list():
    return list(map(int, stdin.readline().split()))


memory = dict()


def clear_cache():
    nonlocal memory
    memory = dict()


def cached_fn(fn, *args):
    nonlocal memory
    if args in memory:
        return memory[args]
    else:
        result = fn(*args)
        memory[args] = result
        return result


def ncr(n, r):
    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))


def binary_search(i, li):
    fn = lambda x: li[x] - x // i
    x = -1
    b = len(li)
    while b >= 1:
        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like
            x += b
        b = b // 2
    return x


# -------------------------------------------------------------- MAIN PROGRAM


TestCases = True
optimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3


def main():
    global a, b, c, d, k, x, y
    a, b, c, d, k = get_tuple()
    x = (a+c-1)//c
    y = (b+d-1)//d
    print(""x: "", str(x), ""y: "", str(y))
    if x+y<=k:
        print(""x, y: "", str(x), str(y))
    else: print(""x, y: -1"")
# --------------------------------------------------------------------- END=


if TestCases:
    for i in range(get_int()):
        main()
else:
    main() if not optimise_for_recursion else threading.Thread(target=main).start()
</ans>",0,{}
191," <ans>
import sys
input = sys.stdin.readline

n, m, k = list(map(int, input().split()))
print(""n: "", n, ""m: "", m, ""k: "", k)
a = list(map(int, input().split()))
par = [0] * (n+1)
for i in range(1, n+1):
 par[i] = i
 print(""par: "", str(par))
 edges = []
 for i in range(m):
 edge = tuple(map(int, input().split()))
 edges.append(edge)
 print(""edges: "", str(edges))
 edges.sort(key=lambda x: x[2])
 print(""sorted edges: "", str(edges))
 edges = mst()
 print(""mst: "", str(edges))
 adj = [list() for i in range(n+1)]
 for edge in edges:
 u, v, w = edge
 adj[u].append((v, w))
 adj[v].append((u, w))
 print(""adj: "", str(adj))
 dist = [0] * (n+1)
 bfs(a[0])
 print(""dist: "", str(dist))
 ans = [0] * k
 for x in a:
 ans[x-1] = dist[x]
 print(""ans: "", str(ans))
 print(""Final answer: "", str(ans))
</ans>",0,{}
192," <ans>
n = int(input())
s1 = [int(x) for x in input().split()]
s2 = [int(x) for x in input().split()]
S1 = sorted(s1)
S2 = sorted(s2)
S1 = [0] + S1
S2 = [0] + S2
S1 = S1[::-1]
S2 = S2[::-1]
pta = 0
ptb = 0
sm1 = 0
sm2 = 0
print(""n: "", n)
for j in range(0, (2 * n) + 1):
    if j % 2 == 0:
        if S2[ptb] > S1[pta]:
            ptb += 1
        else:
            sm1 += S1[pta]
            pta += 1
        print(""pta: "", pta, ""S1[pta]: "", S1[pta])
        print(""ptb: "", ptb, ""S2[ptb]: "", S2[ptb])
    else:
        if S1[pta] > S2[ptb]:
            pta += 1
        else:
            sm2 += S2[ptb]
            ptb += 1
        print(""pta: "", pta, ""S1[pta]: "", S1[pta])
        print(""ptb: "", ptb, ""S2[ptb]: "", S2[ptb])
    if pta == n + 1 and ptb == n + 1:
        break
print(""sm1: "", sm1, ""sm2: "", sm2)
print(sm1 - sm2)
</ans>",0,{}
193," <ans>
import sys

# from collections import deque
input=sys.stdin.readline

n = int(input())
print(""n: "", str(n))
l = list(map(int, input().split()))
print(""l: "", str(l))
u = list(map(int, input().split()))
print(""u: "", str(u))
extra = [0] * n
print(""extra: "", str(extra))
pre = [0] * n
print(""pre: "", str(pre))
t = [0] * n
t[0] = u[0]
print(""t[0]: "", str(t[0]))

for i in range(1, n):
 t[i] += t[i-1] + u[i]
 print(""t[i]: "", str(t[i]))

for i in range(n):
 index = binary_search(l[i], t, i, n-1, n-1, i, t[i-1])
 value = t[index] - t[index-1]
 remain = l[i] - (t[index-1] - t[i-1])
 print(""i: "", str(i), ""index: "", str(index), ""value: "", str(value), ""remain: "", str(remain))
 if value >= remain:
 extra[index] += remain
 print(""extra[index]: "", str(extra[index]))
 elif remain > value:
 extra[index] += value
 print(""extra[index]: "", str(extra[index]))
 if i > 0 and index > 0:
 pre[i-1] -= 1
 pre[index-1] += 1
 elif i == 0 and index > 0:
 pre[index-1] += 1
 elif i == 0 and index == 0:
 continue
 print(""pre[i-1]: "", str(pre[i-1]), ""pre[index-1]: "", str(pre[index-1]))

for i in range(n-2, -1, -1):
 pre[i] += pre[i+1]
 print(""pre[i]: "", str(pre[i]))

r = [0] * n
for i in range(n):
 r[i] = (u[i] * pre[i]) + extra[i]
 print(""r[i]: "", str(r[i]))
</ans>",0,{}
194," <ans>
for _ in range(int(input())):
    n, k = arrIN()
    print(""n: "", str(n), ""k: "", str(k))
    ans = 0
    while 1:
        print(""n: "", str(n))
        if n % k == 0:
            n //= k
            ans += 1
        else:
            x = n % k
            ans += x
            n -= x
        if n == 0:
            print(""ans: "", str(ans))
            break
</ans>",0,{}
195," <ans>
MOD = 1000000007

print(""MOD: "", str(MOD))

def isSubset(a, b):
return (a & b) == a

print(""isSubset: function defined"")

def isIntersect(a, b):
return (a & b) != 0

print(""isIntersect: function defined"")

# Solve for each weakly connected component (WCC)
def cntOrder(s, t):
p = len(s)
m = len(t)

print(""p: "", str(p), ""m: "", str(m))

inMask = [0 for i in range(m)]

print(""inMask: list initialized"")

for x in range(p):
for i in range(m):
if t[i] % s[x] == 0:
inMask[i] |= 1 << x

print(""inMask: updated"")

cnt = [0 for mask in range(1<<p)]
for mask in range(1<<p):
for i in range(m):
if isSubset(inMask[i], mask):
cnt[mask] += 1

print(""cnt: list initialized"")

dp = [[0 for mask in range(1<<p)] for k in range(m+1)]
for i in range(m):
dp[1][inMask[i]] += 1
for k in range(m):
for mask in range(1<<p):
for i in range(m):
if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
print(""dp: 2D list initialized"")

for k in range(m):
for mask in range(1<<p):
for i in range(m):
if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
print(""dp: updated"")

return dp[m][(1<<p)-1]

print(""cntOrder: function defined"")

def dfs(u):
nonlocal a, graph, degIn, visited, s, t

visited = [False for u in range(n)]
print(""visited: list initialized"")

def main():
nonlocal a, graph, degIn, visited, s, t

# Reading input
n = int(input())
print(""n: "", str(n))
a = list(map(int, input().split()))
print(""a: list initialized"")

# Pre-calculate C(n, k)
c = [[0 for j in range(n)] for i in range(n)]
print(""c: 2D list initialized"")

for i in range(n):
c[i][0] = 1
for j in range(1, i+1):
c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD
print(""c: updated"")

# Building divisibility graph
degIn = [0 for u in range(n)]
graph = [[] for u in range(n)]
print(""degIn: list initialized"")
print(""graph: list of lists initialized"")

for u in range(n):
for v in range(n):
if u != v and a[v] % a[u] == 0:
graph[u].append(v)
graph[v].append(u)
degIn[v] += 1
print(""graph: updated"")

# Solve for each WCC of divisibility graph and combine result
ans = 1
curLen = 0
print(""ans: initialized"")
print(""curLen: initialized"")

visited = [False for u in range(n)]
for u in range(n):
if not visited[u]:
s = []
t = []
dfs(u)

if len(t) > 0:
sz = len(t) - 1
cnt = cntOrder(s, t)

ans = (ans * cnt) % MOD
ans = (ans * c[curLen + sz][sz]) % MOD
curLen += sz

print(""ans: updated"")

print(ans)

print(""main: function defined"")

def __starting_point():
main()
__starting_point()
</ans>",0,{}
196," <ans>
N: <int>, S: [1, -1]\*N
tmp: [0]*N (multiple assignments)
print(""N: "", str(N), ""S: "", str(S))
print(""tmp: "", str(tmp))

for i in range(2, N-1):
tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]
if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:
ans=['S' if tmp[i]==1 else 'W' for i in range(N)]
print(""tmp after for loop: "", str(tmp))
print(""ans: "", str(ans))
print(''.join(ans))
return
</ans>",0,{}
197," <ans>
n = int(input())
print(""n: "", str(n))
l = list(map(int, input().split()))
print(""l: "", str(l))
s = input()
print(""s: "", str(s))
water = 0
print(""water: "", str(water))
grass = 0
print(""grass: "", str(grass))
cgrass = 0
print(""cgrass: "", str(cgrass))
time = 0
print(""time: "", str(time))
seen = False
for i in range(n):
 if s[i] == ""G"":
 print(""i: "", str(i))
 dist = l[i]
 if water >= dist:
 print(""water: "", str(water))
 water -= dist
 time += 2 * dist
 cgrass += dist
 else:
 print(""water: "", str(water))
 dist -= water
 time += 2 * water
 water = 0
 time += 3 * dist
 grass += dist
 print(""grass: "", str(grass))
 if cgrass >= dist:
 print(""cgrass: "", str(cgrass))
 cgrass -= dist
 else:
 print(""cgrass: "", str(cgrass))
 dist -= cgrass
 grass += cgrass
 cgrass = 0
 if grass >= dist:
 print(""grass: "", str(grass))
 grass -= dist
 else:
 print(""grass: "", str(grass))
 dist -= grass
 grass = 0
 if seen:
 time += 4 * dist
 else:
 time += 6 * dist
 else:
 if s[i] == ""W"":
 print(""i: "", str(i))
 water += l[i]
 print(""water: "", str(water))
 time += 2 * l[i]
 seen = True
 else:
 dist = l[i]
 if water >= dist:
 print(""water: "", str(water))
 water -= dist
 print(""time: "", str(time))
 time += 2 * dist
 else:
 print(""water: "", str(water))
 dist -= water
 print(""water: "", str(water))
 water = 0
 if cgrass >= dist:
 print(""cgrass: "", str(cgrass))
 cgrass -= dist
 print(""grass: "", str(grass))
 grass += dist
 time += 3 * dist
 else:
 print(""cgrass: "", str(cgrass))
 dist -= cgrass
 print(""cgrass: "", str(cgrass))
 cgrass = 0
 if grass >= dist:
 print(""grass: "", str(grass))
 grass -= dist
 print(""grass: "", str(grass))
 else:
 print(""grass: "", str(grass))
 dist -= grass
 print(""grass: "", str(grass))
 grass = 0
 if seen:
 print(""time: "", str(time))
 time += 4 * dist
 else:
 print(""time: "", str(time))
 time += 6 * dist
 print(""time: "", str(time))
</ans>",0,{}
198," <ans>
from math import gcd

m, a, b = list(map(int, input().split()))

print(""m: "", str(m), ""a: "", str(a), ""b: "", str(b))

g = gcd(a, b)

print(""g: "", str(g))

vis = [0] * (a + b + 1)
vis[0] = 1

print(""vis: "", str(vis))

nvis = 1

count = 0
last = 0
t = 0
while True:
 if t >= b:
 print(""back"")
 t -= b
 if vis[t]:
 break
 vis[t] = 1
 nvis += 1
 else:
 t += a
 if t > m:
 break
 if t > last:
 print(""forward"", t - last, ""with"", nvis)
 count += (t - last) * nvis
 last = t
 if vis[t]:
 break
 vis[t] = 1
 nvis += 1

if t > m:
 count += (m - last + 1) * nvis
 else:
 sumto_m = sumto(m)
 sumto_last = sumto(last - 1)
 count += sumto_m - sumto_last

print(""count: "", str(count))

def sumto(n):
 whole = n // g + 1
 r = whole * (whole + 1) // 2 * g
 corr = whole * (g - 1 - (n % g))
 r -= corr
 return r
</ans>",0,{}
