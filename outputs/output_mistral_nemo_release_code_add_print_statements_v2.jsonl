{"idx": 2, "result": 0, "generated": "<ans>\nfrom math import sqrt,gcd\n\ndef gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    \"\"\"\n    #\n    D = {}\n\n    # The running integer that's checked for primeness\n    q = 2\n\n    while True:\n        if q not in D:\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations\n            #\n            yield q\n            print(\"q: \", str(q))\n            D[q * q] = [q]\n        else:\n            # q is composite. D[q] is the list of primes that\n            # divide it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next\n            # multiples of its witnesses to prepare for larger\n            # numbers\n            #\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n\n        q += 1\n\ndef is_prime(n):\n    if n<=1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 ==0:\n        return False\n    return all(n%i for i in range(3,int(sqrt(n))+1))\n\ndef calculate_colors(n):\n    primes = gen_primes()\n    sqr_n = int(sqrt(n)) + 1\n    if n == 1:\n        return 1\n    for p in primes:\n        if n % p == 0:\n            while n % p == 0:\n                g= gcd(p,n)\n                n = int(n//g)\n            if n > 1:\n                return 1\n            else:\n                return p\n        if p > sqr_n:\n            return n\n\nn = int(input())\nprint(calculate_colors(n))\n</ans>", "format_properties": {}}
{"idx": 5, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import deque\nimport heapq\ninput = sys.stdin.readline\n\nN = int(input())\nprint(\"N: \", str(N))\nEDGE = [list(map(int, input().split())) for i in range(N - 1)]\nprint(\"EDGE: \", str(EDGE))\n\nEDGELIST = [[] for i in range(N + 1)]\nprint(\"EDGELIST: \", str(EDGELIST))\n\nfor i, j in EDGE:\n    EDGELIST[i].append(j)\n    EDGELIST[j].append(i)\n\nREDG = [None for i in range(N + 1)]\nprint(\"REDG: \", str(REDG))\nQUE = deque([1])\ncheck = [0] * (N + 1)\nDEPTH = [None] * (N + 1)\ni = 0\nwhile QUE:\n    NQUE = deque()\n    i += 1\n\n    while QUE:\n        x = QUE.pop()\n        DEPTH[x] = i\n        check[x] = 1\n        for to in EDGELIST[x]:\n            if check[to] == 1:\n                continue\n            else:\n                REDG[to] = x\n                NQUE.append(to)\n    QUE = NQUE\n\ncheck = [0] * (N + 1)\ncheck[1] = 1\nLEAF = []\nfor i in range(2, N + 1):\n    if len(EDGELIST[i]) == 1:\n        LEAF.append((-DEPTH[i], i))\n\nQUE = LEAF\nheapq.heapify(QUE)\nANS = 0\n\nwhile QUE:\n    dep, x = heapq.heappop(QUE)\n    if check[x] != 0 or dep >= -3:\n        continue\n\n    if check[REDG[x]] == 2:\n        continue\n\n    if check[x] == 0:\n        check[x] = 1\n    if check[REDG[REDG[x]]] == 0:\n        check[REDG[REDG[x]]] = 1\n    check[REDG[x]] = 2\n    heapq.heappush(QUE, (-DEPTH[REDG[REDG[REDG[x]]]], REDG[REDG[REDG[x]]]))\n    ANS += 1\n\nprint(ANS)\n\n</ans>", "format_properties": {}}
{"idx": 0, "result": 0, "generated": "<ans>\n'''input\n9 4 8\n6 8 5 1 8 1 1 2 1\n9 2\n8 4\n5 3\n9 7\n'''\nfrom sys import stdin\nimport math\nfrom copy import deepcopy\nfrom collections import defaultdict\n\n\ndef process_offer(offers):\n\tprint(\"offers: \", str(offers))\n\taux = []\n\tfor i in offers:\n\t\ttemp = offers[i]\n\t\ttemp.sort()\n\t\taux.append([i, temp[-1]])\n\tprint(\"aux: \", str(aux))\n\taux = sorted(aux, key = lambda x: x[0])\n\tprint(\"sorted aux: \", str(aux))\n\treturn aux\n\n\ndef make(first, second):\n\tprint(\"first: \", str(first), \"second: \", str(second))\n\treturn str(first) + ' ' + str(second)\n\n\ndef brute(arr, dp, offers, index, remain):\n\tprint(\"index: \", str(index), \"remain: \", str(remain))\n\t# base case:\n\tif remain == 0:\n\t\treturn 0\n\n\tif make(index, remain) in dp:\n\t\treturn dp[make(index, remain)]\n\n\tmin_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)\n\tprint(\"min_cost: \", str(min_cost))\n\tfor i in range(len(offers)):\n\t\tcost = 0\n\t\tif offers[i][0] <= remain:\n\t\t\tfree = offers[i][1]\n\t\t\tfor  j in range(index + free, index + offers[i][0]):\n\t\t\t\tcost += arr[j]\n\t\t\tcost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])\n\t\t\tmin_cost = min(min_cost, cost)\n\t\telse:\n\t\t\tbreak\n\tdp[make(index, remain)] = min_cost\n\treturn min_cost\n\n\n\n# main starts\nn, m, k = list(map(int, stdin.readline().split()))\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\narr = list(map(int, stdin.readline().split()))\nprint(\"arr: \", str(arr))\narr.sort()\nprint(\"sorted arr: \", str(arr))\noffers = defaultdict(list)\nfor _ in range(m):\n\tx, y = list(map(int, stdin.readline().split()))\n\tprint(\"x: \", str(x), \"y: \", str(y))\n\toffers[x].append(y)\n\noffers = process_offer(offers)\ndp = dict()\nprint(brute(arr, dp, offers, 0, k))\n#print(dp)\n\n\n</ans>", "format_properties": {}}
{"idx": 4, "result": 0, "generated": "<ans>\nimport math\nfrom collections import defaultdict\nimport sys\n#input = sys.stdin.readline\n\ndef main():\n    n, m = list(map(int, input().split()))\n    print(\"n: \", str(n), \"m: \", str(m))\n    k = list(map(int, input().split()))\n    print(\"k: \", str(k))\n    sales = [(0, 0)] * m\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        sales[i] = (b, a)\n\n    def check(days):\n        last_sale = {}\n        print(\"last_sale: \", str(last_sale))\n        for sale in sales:\n            if sale[1] <= days:\n                if sale[0] not in last_sale or sale[1] > last_sale[sale[0]]:\n                    last_sale[sale[0]] = sale[1]\n\n        date_last_sales = {}\n        print(\"date_last_sales: \", str(date_last_sales))\n        for t, d in list(last_sale.items()):\n            if d not in date_last_sales:\n                date_last_sales[d] = [t]\n            else:\n                date_last_sales[d].append(t)\n\n        balance = 0\n        required = [0] + k.copy()\n        print(\"required: \", str(required))\n\n        end = 0\n        for d in range(1, days+1):\n            balance += 1\n            if d in date_last_sales:\n                for t in date_last_sales[d]:\n                    if required[t] > 0:\n                        if required[t] > balance:\n                            end += required[t] - balance\n                        balance -= min(required[t], balance)\n                        required[t] = 0\n            if d == days:  # last day\n                for r in required:\n                    if r > 0:\n                        end += r\n\n        return 2*end <= balance\n\n    total = sum(k)\n    print(\"total: \", str(total))\n    hi = 2*total\n    lo = 1\n    print(\"hi: \", str(hi), \"lo: \", str(lo))\n\n    while lo + 1 < hi:\n        mid = (lo + hi) // 2\n        print(\"mid: \", str(mid))\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid\n\n    if check(lo):\n        print(lo)\n    else:\n        print(hi)\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 8, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\n\ndef ii(): return int(input())\nprint(\"ii: \", str(ii))\ndef mi(): return list(map(int, input().split()))\nprint(\"mi: \", str(mi))\ndef li(): return list(map(int, input().split()))\nprint(\"li: \", str(li))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\nprint(\"lcm: \", str(lcm))\ndef wr(arr): return ' '.join(map(str, arr))\nprint(\"wr: \", str(wr))\ndef revn(n): return str(n)[::-1]\nprint(\"revn: \", str(revn))\ndef dd(): return collections.defaultdict(int)\nprint(\"dd: \", str(dd))\ndef ddl(): return collections.defaultdict(list)\nprint(\"ddl: \", str(ddl))\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\nprint(\"sieve: \", str(sieve))\ndef divs(n, start=1):\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\nprint(\"divs: \", str(divs))\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\nprint(\"divn: \", str(divn))\ndef prime(n):\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\nprint(\"prime: \", str(prime))\ndef convn(number, base):\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\nprint(\"convn: \", str(convn))\ndef cdiv(n, k): return n // k + (n % k != 0)\nprint(\"cdiv: \", str(cdiv))\n\nt = ii()\nprint(\"t: \", str(t))\nfor _ in range(t):\n    r, g, b = sorted(mi())\n    print(\"r: \", str(r), \"g: \", str(g), \"b: \", str(b))\n    if b > r + g + 1:\n        print('No')\n    else:\n        print('Yes')\n\n</ans>", "format_properties": {}}
{"idx": 6, "result": 0, "generated": "<ans>\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        print(\"_parent: \", str(self._parent))\n        self._size = [1] * N\n        print(\"_size: \", str(self._size))\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def calc_group_num(self):\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i) == i:\n                ans += 1\n        return ans\n\nimport sys\n\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nt=list(map(int,input().split()))\nprint(\"t: \", str(t))\nt=[t[i]-1 for i in range(n)]\nquery=[]\nfor i in range(m-1):\n    a,b=list(map(int,input().split()))\n    print(\"a: \", str(a), \"b: \", str(b))\n    query.append((a-1,b-1))\n\ntower=[[] for i in range(m)]\nfor i in range(n):\n    id=t[i]\n    if not tower[id]:\n        tower[id].append((i+1,i+1))\n    else:\n        start,end=tower[id].pop()\n        if end+1==i+1:\n            tower[id].append((start,i+1))\n        else:\n            tower[id].append((start,end))\n            tower[id].append((i+1,i+1))\n\n#print(tower)\ntest=[]\nfor i in range(m):\n    for start,end in tower[i]:\n        if end!=n:\n            test.append((t[start-1],t[end]))\n\n#print(test)\nstart=[-1]*len(test)\nend=[m-1]*len(test)\ntemp=[[] for i in range(m)]\nfor i in range(len(test)):\n    T=(end[i]+start[i])//2\n    temp[T].append(i)\n\ndef parabisect():\n    uf=UnionFindVerSize(m)\n    for i in range(m-1):\n        a,b=query[i]\n        uf.unite(a,b)\n        while temp[i]:\n            j=temp[i].pop()\n            id1,id2=test[j]\n            if uf.is_same_group(id1,id2):\n                end[j]=i\n            else:\n                start[j]=i\n            if end[j]-start[j]>1:\n                T=(end[j]+start[j])//2\n                temp[T].append(j)\n\nfor i in range(20):\n    parabisect()\n\nres=[0]*m\nfor i in range(len(test)):\n    res[end[i]+1]-=1\n\nfor i in range(1,m):\n    res[i]+=res[i-1]\n\nfor i in range(m):\n    print(\"res: \", str(res[i]))\n</ans>", "format_properties": {}}
{"idx": 10, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import defaultdict\n\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * n\n        print(\"self.n: \", str(self.n))\n        print(\"self.tree: \", str(self.tree))\n\n    def _get_sum(self, r):\n        '''\n        sum on interval [0, r)\n        '''\n        result = 0\n        while r > 0:\n            result += self.tree[r-1]\n            r &= (r - 1)\n        return result\n\n    def get_sum(self, l, r):\n        '''\n        sum on interval [l, r)\n        '''\n        return self._get_sum(r) - self._get_sum(l)\n\n    def add(self, i, value=1):\n        while i < self.n:\n            self.tree[i] += value\n            i |= (i + 1)\n\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\nprint(\"n: \", str(n))\nswaps = []\nfor _ in range(n):\n    i, j = list(map(int, input().split()))\n    swaps.append(i)\n    swaps.append(j)\n\npos = defaultdict(list)\nfor i, val in enumerate(swaps):\n    pos[val].append(i)\n\nc = 0\nprev = -1\ncompr = [0] * (2*n)\ndecompr = {}\nfor val in sorted(swaps):\n    if prev == val: continue\n    for j in pos[val]:\n        compr[j] = c\n    decompr[c] = val\n    c += 1\n    prev = val\n\narr = list(range(c))\nfor t in range(n):\n    i, j = compr[t<<1], compr[t<<1|1]\n    arr[i], arr[j] = arr[j], arr[i]\n\nbit = BIT(c)\ntotal_inv = 0\nfor i, val in enumerate(arr):\n    total_inv += bit.get_sum(val+1, c)\n    if i != val:\n        total_inv += abs(decompr[val] - decompr[i]) - abs(val - i)\n    bit.add(val)\nprint(total_inv)\n\n</ans>", "format_properties": {}}
{"idx": 1, "result": 0, "generated": "<ans>\ndef PrimeDecomp(N, ConcFlag):\n    if ConcFlag:\n        if N <= 1:\n            print(\"N: \", str(N))\n            return [1], 1\n        else:\n            I = 2\n            PrimeDec = []\n            DivCount = 1\n            while I * I <= N:\n                Cnt = 0\n                while N % I == 0:\n                    N //= I\n                    PrimeDec.append(I)\n                DivCount *= (Cnt + 1)\n                I += 1\n            if N >= 2:\n                PrimeDec.append(N)\n                DivCount *= 2\n            print(\"PrimeDec: \", str(PrimeDec))\n            print(\"DivCount: \", str(DivCount))\n            return PrimeDec, DivCount\n    else:\n        if N <= 1:\n            print(\"N: \", str(N))\n            return [1], [1], 1\n        else:\n            I = 2\n            PrimeDec = []\n            PrimeCnt = []\n            DivCount = 1\n            while I * I <= N:\n                Cnt = 0\n                while N % I == 0:\n                    N //= I\n                    Cnt += 1\n                if Cnt >= 1:\n                    PrimeDec.append(I)\n                    PrimeCnt.append(Cnt)\n                    DivCount *= (Cnt + 1)\n                I += 1\n            if N >= 2:\n                PrimeDec.append(N)\n                PrimeCnt.append(1)\n                DivCount *= 2\n            print(\"PrimeDec: \", str(PrimeDec))\n            print(\"PrimeCnt: \", str(PrimeCnt))\n            print(\"DivCount: \", str(DivCount))\n            return PrimeDec, PrimeCnt, DivCount\n\ndef DivisorFactorial(N, FactDec, FactCnt, MemoFlag, Mod, ModFlag):\n    if MemoFlag:\n        if N <= 1:\n            print(\"N: \", str(N))\n            FDivCnt = 1\n            return FactDec, FactCnt, FDivCnt\n        else:\n            PrimeDec, PrimeCnt, _ = PrimeDecomp(N, False)\n            for TP in range(0, len(PrimeDec)):\n                if PrimeDec[TP] in set(FactDec):\n                    FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]\n                else:\n                    FactDec.append(PrimeDec[TP])\n                    FactCnt.append(PrimeCnt[TP])\n            print(\"FactDec: \", str(FactDec))\n            print(\"FactCnt: \", str(FactCnt))\n            FDivCnt = 1\n            for TF in FactCnt:\n                FDivCnt = [FDivCnt * (TF + 1), (FDivCnt * (TF + 1)) % Mod][ModFlag]\n            print(\"FDivCnt: \", str(FDivCnt))\n            return FactDec, FactCnt, FDivCnt\n    else:\n        if N <= 1:\n            print(\"N: \", str(N))\n            FDivCnt = 1\n            return FactDec, FactCnt, FDivCnt\n        else:\n            for TN in range(2, N + 1):\n                PrimeDec, PrimeCnt, _ = PrimeDecomp(TN, False)\n                for TP in range(0, len(PrimeDec)):\n                    if PrimeDec[TP] in set(FactDec):\n                        FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]\n                    else:\n                        FactDec.append(PrimeDec[TP])\n                        FactCnt.append(PrimeCnt[TP])\n            print(\"FactDec: \", str(FactDec))\n            print(\"FactCnt: \", str(FactCnt))\n            FDivCnt = 1\n            for TF in FactCnt:\n                FDivCnt = [FDivCnt * (TF + 1), (FDivCnt * (TF + 1)) % Mod][ModFlag]\n            print(\"FDivCnt: \", str(FDivCnt))\n            return FactDec, FactCnt, FDivCnt\nFactDec, FactCnt, FDivCnt = DivisorFactorial(int(input()), [], [], False, 10**9+7, True)\nprint(FDivCnt)\n</ans>", "format_properties": {}}
{"idx": 11, "result": 0, "generated": "<ans>\nfrom math import sqrt\n\neps = 1e-9\n\ndef mysqrt(x):\n    if x <= 0:\n        return 0\n    return sqrt(x)\n\ndef good(R):\n    nonlocal xs\n    nonlocal ys\n    nonlocal n\n\n    left = -10**20\n    right = 10**20\n\n    for i in range(n):\n        # (x - xi)**2 + (y - yi)**2 = R**2\n        # y = R\n        xi = xs[i]\n        yi = abs(ys[i])\n\n        D = 2 * R * yi - yi**2\n\n        if D + eps < 0:\n            return False\n\n        sD = mysqrt(D)\n\n        new_left = xi - sD\n        new_right = xi + sD\n\n        left = max(left, new_left)\n        right = min(right, new_right)\n\n        if left + eps > right:\n            return False\n\n    return True\n\ndef solve(lower, high, md):\n    R = 0\n    for _ in range(150):\n        R = md(lower, high)\n\n        if good(R):\n            high = R\n        else:\n            lower = R\n\n    return R\n\nn = int(input())\n\nxs = [0.0 for _ in range(n)]\nys = [0.0 for _ in range(n)]\n\nfor i in range(n):\n    xs[i], ys[i] = list(map(float, input().split()))\n    if i > 0:\n        if ys[i] * ys[0] < 0:\n            print(-1)\n            return\n\nR = None\nif good(1):\n    R = solve(0, 1, lambda x, y: (x + y) / 2)\nelse:\n    R = solve(1, 1e16, lambda x, y: sqrt(x * y))\n\nprint('{:.16}'.format(R))\n</ans>", "format_properties": {}}
{"idx": 7, "result": 0, "generated": "<ans>\n# from collections import deque\nimport io\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # \u795e\u5947\u5feb\u8bfb\uff0c\u65e0\u6cd5\u8fd0\u884c\u8c03\u8bd5\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nprint(\"BUFSIZE: \", str(BUFSIZE))\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        print(\"_fd: \", str(self._fd))\n        self.buffer = BytesIO()\n        print(\"buffer: \", str(self.buffer))\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        print(\"writable: \", str(self.writable))\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        print(\"buffer: \", str(self.buffer))\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        print(\"writable: \", str(self.writable))\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn, m = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m))\ninc = {\n    # chr(97+i):0 for i in range(26)\n}\nprint(\"inc: \", str(inc))\nl = [None for i in range(n*m)]\nprint(\"l: \", str(l))\n\nfor i in range(n):\n    t = int(input())\n    print(\"t: \", str(t))\n    for j in range(m):\n        ipt = input()\n        print(\"ipt: \", str(ipt))\n        l[t*m+j] = ipt\n        if len(inc)==26:continue\n        for q in ipt:\n            inc.setdefault(q, 0)\nprint(\"inc: \", str(inc))\n\nd = {}\nprint(\"d: \", str(d))\n\nf = l[0][0]\n\ndef ae(u, v):\n    t = d.setdefault(u, set())\n    print(\"u: \", str(u), \"v: \", str(v), \"t: \", str(t))\n    if v not in t:\n        t.add(v)\n        inc[v] = inc.get(v, 0) + 1\n        print(\"inc[v]: \", str(inc[v]))\n\nfor p, i in enumerate(l[1:]):\n    for j in range(min(len(l[p]), len(i))):\n        if l[p][j] != i[j]:\n            # if len(l[p])-1 != j:\n                # ae(l[p][j],i[j])\n            ae(i[j], l[p][j])\n            break\n        if len(i)-1==j and len(l[p])-1 > j:\n            print(\"IMPOSSIBLE\")\n            return\n\nans = []\ndq = []\n# dq = deque()\nptr = 0\n\nninc = {}\n\nfor k, v in inc.items():\n    if v == 0:\n        dq.append(k)\n    else:\n        ninc[k] = v\nprint(\"ninc: \", str(ninc))\n\nif len(inc):\n    print(\"IMPOSSIBLE\")\n    return\n\nprint(*reversed(ans), sep='')\n\n</ans>", "format_properties": {}}
{"idx": 12, "result": 0, "generated": "<ans>\n```\ndef bin_pow(num, degree , module):\n    if degree == 0:\n        return 1\n    if degree == 1:\n        return num % module\n\n    if degree % 2 == 0:\n        val = bin_pow(num, degree // 2, module)\n        return (val * val) % module\n\n    return (num * bin_pow(num , degree - 1, module)) % module\n\nx, y = list(map(int,input().split()))\nprint(\"x: \", str(x), \"y: \", str(y))\n\nif y % x != 0:\n    print(0)\n    return\n\ny //= x\n\ndivs = set()\nto_gen = []\n\nnum = 2\nval = y\n\nwhile num * num <= val:\n    degree = 0\n    while y % num == 0:\n        degree+=1\n        y //= num\n    if degree != 0:\n        to_gen.append((num, degree))\n\n    if num == 2:\n        num += 1\n    else:\n        num += 2\n\nif y != 1:\n    to_gen.append((y, 1))\n\nprint(\"to_gen: \", str(to_gen))\n\nto_gen_len = len(to_gen)\n\ndef generate(ind):\n    if ind == to_gen_len:\n        yield 1\n        return\n    gen_val = to_gen[ind][0]\n\n    for deg in range(1 + to_gen[ind][1]):\n        for each in generate(ind  + 1):\n            yield gen_val**deg * each\n\nfor each in generate(0):\n    divs.add(each)\n\ndivs = list(divs)\ndivs.sort()\ndivs_answers = {}\nmod = 10**9 + 7\nans = bin_pow(2, val - 1, mod)\n\nfor el in divs:\n    if el == 1:\n        divs_answers[el] = 1\n        ans -= 1\n    else:\n        curr_val = bin_pow(2, el - 1 ,mod)\n        for other_el in divs:\n            if other_el >= el:\n                break\n            if el % other_el !=0:\n                continue\n\n            curr_val -= divs_answers[other_el]\n\n        divs_answers[el] = curr_val % mod\n        ans -= curr_val\n\nprint(\"divs_answers: \", str(divs_answers))\nprint(divs_answers[val])\n```\n</ans>", "format_properties": {}}
{"idx": 15, "result": 0, "generated": "<ans>\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        print(\"parent: \", str(self.parent))\n        self.size = [1] * n\n        print(\"size: \", str(self.size))\n        self.num_sets = n\n\n    def find(self, a):\n        to_update = []\n\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n\n        for b in to_update:\n            self.parent[b] = a\n\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n\n        if a == b:\n            return\n\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n, m = read_int_array()\n    uf = UnionFind(n)\n    for _ in range(m):\n        nums = read_int_array()\n        sz = nums[0]\n        leader = None\n        for i in range(sz):\n            p = nums[1 + i] - 1\n            if leader is None:\n                leader = p\n            else:\n                uf.merge(p, leader)\n\n    ans = [uf.set_size(i) for i in range(n)]\n    write(*ans)\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 17, "result": 0, "generated": "<ans>\nn=input().split()\nprint(\"n: \", str(n))\nr=int(n[0])\nprint(\"r: \", str(r))\nk=int(n[1])\nprint(\"k: \", str(k))\nl=[]\nfor i in range(r):\n    li=input()\n    l.append(li)\nprint(\"l: \", str(l))\nrl=[]\nfor i in range(r):\n    x=[]\n    for j in range(r):\n        x.append(0)\n    rl.append(x)\nprint(\"rl: \", str(rl))\nfor i in range(r):\n    for j in range(len(l[i])):\n        flag=0\n        f=0\n        if j+k<=r:\n            for q in range(k):\n                if l[i][j+q:j+q+1]=='.':\n                    continue\n                else:\n                    flag=1\n                    break\n            if flag==0:\n                for q in range(k):\n                    rl[i][j+q]=rl[i][j+q]+1\n            if flag==1:\n                j=q+1\nfor i in range(r):\n    for j in range(r):\n        flag=0\n        f=0\n        if j+k<=r:\n            for q in range(k):\n                if l[j+q][i:i+1]=='.':\n                    continue\n                else:\n                    flag=1\n                    break\n            if flag==0:\n                for q in range(k):\n                    rl[j+q][i]=rl[j+q][i]+1\n            if flag==1:\n                j=q+1\nmaxi=0\nprint(\"maxi: \", str(maxi))\nmaxj=0\nprint(\"maxj: \", str(maxj))\nm=0\nprint(\"m: \", str(m))\nfor i in range(r):\n    for j in range(r):\n        if rl[i][j]>m:\n            m=rl[i][j]\n            maxi=i\n            maxj=j\nprint(\"maxi: \", str(maxi))\nprint(\"maxj: \", str(maxj))\nprint(maxi+1,maxj+1)\n\n</ans>", "format_properties": {}}
{"idx": 13, "result": 0, "generated": "<ans>\nimport bisect\n\nclass BTreeNode:\n    def __init__(self):\n        self.key = []\n        self.child = []\n\nclass BTree:\n    def __init__(self):\n        self.root = BTreeNode()\n        print(\"self.root: \", str(self.root))\n\n    def search_higher(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_right(ptr.key, key)\n            if i != len(ptr.key):\n                ret = ptr.key[i]\n            ptr = ptr.child[i]\n        i = bisect.bisect_right(ptr.key, key)\n        if i != len(ptr.key):\n            ret = ptr.key[i]\n        return ret\n\n    def search_lower(self, key):\n        ptr = self.root\n        ret = None\n        while ptr.child:\n            i = bisect.bisect_left(ptr.key, key)\n            if i != 0:\n                ret = ptr.key[i - 1]\n            ptr = ptr.child[i]\n        i = bisect.bisect_left(ptr.key, key)\n        if i != 0:\n            ret = ptr.key[i - 1]\n        return ret\n\n    def insert(self, key):\n        def insert_rec(ptr):\n            b_size = 10\n            if not ptr.child:\n                bisect.insort(ptr.key, key)\n                print(\"ptr.key: \", str(ptr.key))\n                if len(ptr.key) == b_size * 2 - 1:\n                        ret = BTreeNode()\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            else:\n                i = bisect.bisect(ptr.key, key)\n                temp = insert_rec(ptr.child[i])\n                if temp is not None:\n                    ptr.key.insert(i, temp.key.pop(-1))\n                    ptr.child.insert(i, temp)\n                    if len(ptr.child) == b_size * 2:\n                        ret = BTreeNode()\n                        ret.child = ptr.child[:b_size]\n                        ptr.child = ptr.child[b_size:]\n                        ret.key = ptr.key[:b_size]\n                        ptr.key = ptr.key[b_size:]\n                        return ret\n            return None\n        temp = insert_rec(self.root)\n        if temp is not None:\n            root = BTreeNode()\n            root.key = [temp.key.pop(-1)]\n            root.child = [temp, self.root]\n            self.root = root\n            print(\"self.root: \", str(self.root))\n\n    def dump(self):\n        def dump_rec(ptr, dep):\n            for _ in range(0, dep):\n                print(\"  \", end=\"\")\n            print(ptr.key)\n            for c in ptr.child:\n                dump_rec(c, dep + 1)\n        dump_rec(self.root, 0)\n        print(\"\")\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    idx = [0] * n\n    for i in range(0, n):\n        idx[i] = i\n    idx.sort(key=lambda i: - p[i])\n    t = BTree()\n    t.insert(-1)\n    t.insert(n)\n    ans = 0\n    for i in idx:\n        nex = t.search_higher(i)\n        nexnex = t.search_higher(nex)\n        pre = t.search_lower(i)\n        prepre = t.search_lower(pre)\n        if prepre != None:\n            ans += p[i] * (pre - prepre) * (nex - i)\n        if nexnex != None:\n            ans += p[i] * (i - pre) * (nexnex - nex)\n        t.insert(i)\n        print(\"t.root: \", str(t.root))\n\n    print(ans)\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 19, "result": 0, "generated": "<ans>\nimport math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\nprint(\"VI: \", str(VI))\ndef I(): return int(input())\nprint(\"I: \", str(I))\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\nprint(\"LIST: \", str(LIST))\ndef ELIST(n): return [[] for i in range(n)]\nprint(\"ELIST: \", str(ELIST))\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\nprint(\"MI: \", str(MI))\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\nprint(\"MS: \", str(MS))\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\nprint(\"MIT: \", str(MIT))\n\n\ndef run(n,a):\n    for i in range(n+1):\n        if a[0]==0:\n            if sum([i==a[i] for i in range(n)])==n:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n            return\n        for j in range(n):\n            if j%2==0:\n                a[j] = (a[j]+1)%n\n            else:\n                a[j] = (a[j]-1)%n\n    print(\"n: \", str(n), \"a: \", str(a))\n\ndef main(info=0):\n    n = I()\n    a = VI()\n\n    run(n,a)\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 9, "result": 0, "generated": "<ans>\n#!/usr/bin/env python\n# 560B_art.py - Codeforces.com 560B Art program\n#\n# Copyright (C) 2015 Sergey\n\n\"\"\"\nGerald asks whether it is possible to place the paintings on the board,\nor is the board he bought not large enough?\nInput\n\nThe first line contains two space-separated numbers a1 and b1 the sides\nof the board. Next two lines contain numbers a2 b2 a3 and b3 the sides\nof the paintings. All numbers ai,?bi in the input are integers and fit into\nthe range from 1 to 1000.\n\nOutput\n\nIf the paintings can be placed on the wall, print \"YES\" (without the quotes),\nand if they cannot, print \"NO\" (without the quotes).\n\"\"\"\n\n# Standard modules\nimport unittest\nimport sys\n\n# Additional modules\n\n\n###############################################################################\n# Art Class\n###############################################################################\n\n\nclass Art:\n    \"\"\" Art representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        print(\"args: \", str(args))\n        self.numa, self.numb = args\n        print(\"numa: \", str(self.numa), \"numb: \", str(self.numb))\n\n        self.r = self.rect(self.numa[0], self.numb[0])\n        print(\"r: \", str(self.r))\n        self.rmax = self.rect(self.numa[1], self.numb[1])\n        print(\"rmax: \", str(self.rmax))\n        self.rmin = self.rect(self.numa[2], self.numb[2])\n        print(\"rmin: \", str(self.rmin))\n        if self.rmax[0] < self.rmax[1]:\n            self.rmax, self.rmin = self.rmin, self.rmax\n        print(\"rmax after swap: \", str(self.rmax), \"rmin after swap: \", str(self.rmin))\n\n        self.remain = []\n        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:\n            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))\n        print(\"remain after first condition: \", str(self.remain))\n        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:\n            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))\n        print(\"remain after second condition: \", str(self.remain))\n        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:\n            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))\n        print(\"remain after third condition: \", str(self.remain))\n        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:\n            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))\n        print(\"remain after fourth condition: \", str(self.remain))\n\n    def rect(self, a, b):\n        if a > b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n        for rec in self.remain:\n            print(\"rec: \", str(rec))\n            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:\n                return \"YES\"\n            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:\n                return \"YES\"\n        return \"NO\"\n\n\n###############################################################################\n# Helping classes\n###############################################################################\n\n\n###############################################################################\n# Art Class testing wrapper code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    imax = 3\n    numnums = list(map(int, \" \".join(uinput() for i in range(imax)).split()))\n\n    # Splitting numnums into n arrays\n    numa = []\n    numb = []\n    for i in range(0, 2*imax, 2):\n        numa.append(numnums[i])\n        numb.append(numnums[i+1])\n\n    # Decoding inputs into a list\n    return [numa, numb]\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Art(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_Art_class__basic_functions(self):\n        \"\"\" Art class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Art([[3, 1, 2], [2, 3, 1]])\n        self.assertEqual(d.numa[0], 3)\n\n        self.assertEqual(d.r, (3, 2))\n        self.assertEqual(d.rmax, (3, 1))\n        self.assertEqual(d.rmin, (2, 1))\n\n        self.assertEqual(d.remain, [(3, 1)])\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"3 2\\n1 3\\n2 1\"\n        self.assertEqual(calculate(test), \"YES\")\n        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])\n        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])\n\n        # Sample test 2\n        test = \"5 5\\n3 3\\n3 3\"\n        self.assertEqual(calculate(test), \"NO\")\n\n        # Sample test 3\n        test = \"4 2\\n2 3\\n1 2\"\n        self.assertEqual(calculate(test), \"YES\")\n\n        # My test 4\n        test = \"5 5\\n1 5\\n1 5\"\n        self.assertEqual(calculate(test), \"YES\")\n\n    def test_time_limit_test(self):\n        \"\"\" Quiz time limit test \"\"\"\n\n        import random\n\n        # Time limit test\n        test = \"1000 1000\"\n        test += \"\\n900 900\"\n        test += \"\\n50 50\"\n\n        import timeit\n\n        start = timeit.default_timer()\n        args = get_inputs(test)\n\n        init = timeit.default_timer()\n        d = Art(args)\n\n        calc = timeit.default_timer()\n        d.calculate()\n\n        stop = timeit.default_timer()\n        print((\n            \"\\nTime Test: \" +\n            \"{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)\".\n            format(stop-start, init-start, calc-init, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate())\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 18, "result": 0, "generated": "<ans>\n\"\"\" ATSTNG's ejudge Python3 solution template \"\"\"\nimport sys, queue\n\ntry:\n    import dev_act_ffc429465ab634\n    print(\"DEV: \", str(DEV))\nexcept:\n    DEV = False\n\ndef log(*s):\n    if DEV: print('L',list(s),sep='')\n\nclass EJudge:\n    def __init__(self, problem=\"default\", reclim=1<<30):\n        print(\"problem: \", str(problem))\n        print(\"reclim: \", str(reclim))\n        self.problem = problem\n        sys.setrecursionlimit(reclim)\n\n    def use_files(self, infile='', outfile=''):\n        if infile!='':\n            print(\"infile: \", str(infile))\n            self.infile = open(infile)\n            sys.stdin = self.infile\n        if infile!='':\n            print(\"outfile: \", str(outfile))\n            self.outfile = open(outfile, 'w')\n            sys.stdout = self.outfile\n\n    def use_bacs_files(self):\n        self.use_files(self.problem+'.in', self.problem+'.out')\n\n    def get_tl(self):\n        while True: pass\n\n    def get_ml(self):\n        tmp = [[[5]*100000 for _ in range(1000)]]\n        print(\"tmp: \", str(tmp))\n        while True: tmp.append([[5]*100000 for _ in range(1000)])\n\n    def get_re(self):\n        s = (0,)[8]\n        print(\"s: \", str(s))\n\n    def get_wa(self, wstr='blablalblah'):\n        for _ in range(3): print(wstr)\n        return\n\nclass IntReader:\n    def __init__(self):\n        print(\"ost: \", str(self.ost))\n        self.ost = queue.Queue()\n\n    def get(self):\n        print(\"return: \", str(int(self.sget())))\n        return int(self.sget())\n\n    def sget(self):\n        if self.ost.empty():\n            for el in input().split():\n                self.ost.put(el)\n        print(\"return: \", str(self.ost.get()))\n        return self.ost.get()\n\n    def release(self):\n        res = []\n        while not self.ost.empty():\n            res.append(self.ost.get())\n        print(\"return: \", str(res))\n        return res\n\n###############################################################################\nej = EJudge(  )\nprint(\"ej: \", str(ej))\nint_reader = IntReader()\nprint(\"int_reader: \", str(int_reader))\nfmap = lambda f,l: list(map(f,l))\nprint(\"fmap: \", str(fmap))\nparse_int = lambda: fmap(int, input().split())\nprint(\"parse_int: \", str(parse_int))\nsign = lambda x: (x>0)-(x<0)\nprint(\"sign: \", str(sign))\n\n# input\nn,x = parse_int()\nprint(\"n: \", str(n))\nprint(\"x: \", str(x))\nst = [0]*100500\nprint(\"st: \", str(st))\nxored = [0]*100500\nprint(\"xored: \", str(xored))\nfor _ in range(n): st[int_reader.get()] += 1\nfor idx in range(100500):\n    pair = idx^x\n    if pair < 100500:\n        xored[pair] = st[idx]\n\nans = 0\nfor idx in range(100500):\n    ans += st[idx]*xored[idx]\n\nif x == 0: ans -= n\n\nprint(\"ans: \", str(ans//2))\n</ans>", "format_properties": {}}
{"idx": 20, "result": 0, "generated": "<ans>\nimport collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ndef e_gcd(a, b ):\n    if a==0 and b==0:\n        return -1, 0, 0\n    if b==0:\n        return a, 1,0\n    d, y,x = e_gcd(b, a%b )\n    y-=  a //b *x\n    return d , x,y\n\ndef m_reverse(a,n):\n    d,x,y = e_gcd(a,n)\n    dprint(x,y,a,n)\n    assert x*a + y*n == d\n    if d==1:\n        if x%n<=0:\n           return x%n+n\n        else:\n            return x%n\n    else:\n        return -1\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\nbase = 998244353\nd = 1233\nt = m_reverse( d, base)\ndprint(t)\nz = t * d % base\ndprint(z)\nN, M, K= getIntList()\ndprint(\"N: \", str(N), \"M: \", str(M), \"K: \", str(K))\n\nJ = N-1 - K   # same\ndprint(\"J: \", str(J))\n\nZ = N - J\ndprint(\"Z: \", str(Z))\n\nR = M\nfor i in range(Z-1):\n    R *= M-1\n    R%= base\ndprint(\"R: \", str(R))\n\nn0 = J\nm0 = Z\ndprint(\"n0: \", str(n0), \"m0: \", str(m0))\n\n#comb(n0 + m0 -1, m0-1)\nfor i in range(m0 -1):\n    g = n0 + m0 -1  -i\n    R*= g\n    R%= base\n\nfor i in range(2, m0):\n    t = m_reverse(i,base)\n    R*=t\n    R%=base\n\nprint(R)\n</ans>", "format_properties": {}}
{"idx": 16, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\n# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Sponge Class (Main Program)\n###############################################################################\n\n\nclass Sponge:\n    \"\"\" Sponge representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        print(\"n, m: \", str([self.n, self.m]))\n        [self.n, self.m] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        print(\"numf: \", str(self.numf))\n        self.numf = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        print(\"numb: \", str(self.numb))\n        self.numb = list(map(int, uinput().split()))\n\n        self.fd = {}\n        self.fdn = {}\n        for (i, n) in enumerate(self.numf):\n            self.fd[n] = self.fd.setdefault(n, 0) + 1\n            self.fdn[n] = i + 1\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = []\n        for n in self.numb:\n            if n not in self.fd:\n                return \"Impossible\"\n            result.append(self.fdn[n])\n        for n in self.numb:\n            if self.fd[n] > 1:\n                return \"Ambiguity\"\n\n        return \"Possible\\n\" + \" \".join(map(str, result))\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Sponge class testing \"\"\"\n\n        # Constructor test\n        test = \"3 3\\n3 2 1\\n1 2 3\"\n        d = Sponge(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.m, 3)\n        self.assertEqual(d.numf, [3, 2, 1])\n        self.assertEqual(d.numb, [1, 2, 3])\n\n        # Sample test\n        self.assertEqual(Sponge(test).calculate(), \"Possible\\n3 2 1\")\n\n        # Sample test\n        test = \"3 3\\n1 1 3\\n1 2\"\n        self.assertEqual(Sponge(test).calculate(), \"Impossible\")\n\n        # Sample test\n        test = \"3 3\\n1 1 1\\n1 1 1\"\n        self.assertEqual(Sponge(test).calculate(), \"Ambiguity\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Sponge(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Sponge(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Sponge().calculate())\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 14, "result": 0, "generated": "<ans>\nk = 72\nprint(\"k: \", str(k))\nK = 1<<k\nprint(\"K: \", str(K))\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\nprint(\"nu: \", str(nu))\nst = lambda n: bin(n)[2:] + \"0\"\nprint(\"st: \", str(st))\nli = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(l)]]\nprint(\"li: \", str(li))\n\ndef grow(d, v, h):\n    h += [0] * d\n    print(\"h: \", str(h))\n    f = [(-1 if (i+d) % 2 else 1) * fainv[i] * fainv[d-i] % P * h[i] % P for i in range(d+1)]\n    print(\"f: \", str(f))\n\n    for idx, a in enumerate([d+1, d * fa[v-1] * fainv[v] % P, (d * fa[v-1] * fainv[v] + d + 1) % P]):\n        t = [1] * (2*d+2)\n        print(\"t: \", str(t))\n        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % P\n        ti = [1] * (2*d+2)\n        ti[-1] = pow(t[-1], P-2, P)\n        print(\"ti: \", str(ti))\n        for i in range(1, 2*d+2)[::-1]: ti[i-1] = ti[i] * (a - d + i - 1) % P\n\n        g = [ti[i+1] * t[i] % P for i in range(2*d+1)]\n        print(\"g: \", str(g))\n        fg = li(st(nu(f) * nu(g)), d * 2 + 2)\n        print(\"fg: \", str(fg))\n\n        if idx == 1:\n            for i in range(d+1):\n                h[i] = h[i] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n        elif idx == 0:\n            for i in range(d):\n                h[i+d+1] = fg[d+i] * t[d+i+1] % P * ti[i] % P\n        elif idx == 2:\n            for i in range(d):\n                h[i+d+1] = h[i+d+1] * (fg[d+i] * t[d+i+1] % P * ti[i] % P) % P\n    return h\n\n# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]\ndef create_table(v):\n    s = 1\n    X = [1, v+1]\n    print(\"X: \", str(X))\n    while s < v:\n        X = grow(s, v, X)\n        s *= 2\n    table = [1]\n    for x in X:\n        table.append(table[-1] * x % P)\n    print(\"table: \", str(table))\n    return table\n\ndef fact(i, table):\n    a = table[i//v]\n    print(\"a: \", str(a))\n    for j in range(i//v*v+1, i+1):\n        a = a * j % P\n    print(\"a: \", str(a))\n    return a\n\nP = 10**9+7\nprint(\"P: \", str(P))\nv = 1 << 11\nprint(\"v: \", str(v))\nfa = [1] * (2*v+2)\nfainv = [1] * (2*v+2)\nfor i in range(2*v+1):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(2*v+1)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nT = create_table(v)\n\nf = lambda a, b: fact(a+b+2, T) * pow(fact(a+1, T) * fact(b+1, T), P-2, P) % P\nprint(\"f: \", str(f))\nr1, c1, r2, c2 = list(map(int, input().split()))\nprint(\"r1, c1, r2, c2: \", str(r1), \", \", str(c1), \", \", str(r2), \", \", str(c2))\nprint(((f(r2, c2) - f(r2, c1-1) - f(r1-1, c2) + f(r1-1, c1-1)) % P))\n\n</ans>", "format_properties": {}}
{"idx": 23, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport random\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')):\n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def I():return (int(input()))\n def In():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def I():return (int(stdin.readline()))\n def In():return(map(int,stdin.readline().split()))\n#sys.setrecursionlimit(1500)\ndef dict(a):\n d={}\n print(\"d: \", str(d))\n for x in a:\n  if d.get(x,-1)!=-1:\n   d[x]+=1\n  else:\n   d[x]=1\n print(\"d: \", str(d))\n return d\ndef find_gt(a, x):\n 'Find leftmost value greater than x'\n i = bi.bisect_right(a, x)\n if i != len(a):\n  return i\n else:\n  return -1\n\ndef find_ge(a, x):\n 'Find leftmost item greater than or equal to x'\n i = bi.bisect_left(a, x)\n if i != len(a):\n  return i\n else:\n  return -1\ndef main():\n try:\n  n,Q=In()\n  print(\"n: \", str(n), \"Q: \", str(Q))\n  l=list(In())\n  print(\"l: \", str(l))\n  l.sort()\n  print(\"l: \", str(l))\n  pre=[0]\n  su=0\n  for x in range(n):\n   su+=l[x]\n   pre.append(su)\n  print(\"pre: \", str(pre))\n  for x in range(Q):\n   q=I()\n   print(\"q: \", str(q))\n   q*=2\n   pos=find_ge(l,q)\n   print(\"pos: \", str(pos))\n   if pos==-1:\n    print(0)\n   else:\n    ans=pre[-1]-pre[pos]\n    print(\"ans: \", str(ans))\n    print(ans)\n except:\n  pass\n\nM = 998244353\nP = 1000000007\n\ndef __starting_point():\n #for _ in range(I()):main()\n for _ in range(1):main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 22, "result": 0, "generated": "<ans>\ndef solve(printing):\n\n    n = int(input())\n    nums = [int(st)-1 for st in input().split(\" \")]\n    print(\"n: \", str(n))\n    print(\"nums: \", str(nums))\n    numdupe = [0] * n\n    print(\"numdupe: \", str(numdupe))\n    dupeindex = []\n    dupeindexindv = {}\n    missing = []\n\n    if printing:\n        print(\"nums\"); print(nums)\n\n    for i in range(n):\n        numdupe[nums[i]] += 1\n\n    for i in range(n):\n        if numdupe[i] == 0:\n            missing.append(i)\n\n        if numdupe[nums[i]] >= 2:\n            dupeindex.append(i)\n            if nums[i] in dupeindexindv:\n                dupeindexindv[nums[i]][1].append(i)\n            else:\n                dupeindexindv[nums[i]] = [0, [i], False]\n                # left location, dupe indexs, if already located original\n\n    for num in dupeindexindv:\n        dupeindexindv[num][0] = len(dupeindexindv[num][1])\n\n    if printing:\n        print(\"missing\"); print(missing)\n        print(\"dupeindexindv\"); print(dupeindexindv)\n\n    misslen = len(missing)\n    misindex = 0\n    #answer = 0\n    for index in dupeindex:\n\n        if misslen <= misindex:\n            break\n\n        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:\n            # one spot left but original not located yet.\n            # locate original.\n            dupeindexindv[nums[index]][0] -= 1\n            dupeindexindv[nums[index]][2] = True\n\n        elif dupeindexindv[nums[index]][0] > 0:\n\n            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:\n                # num is smaller or original is already located.\n                # locate missing number.\n                dupeindexindv[nums[index]][0] -= 1\n                nums[index] = missing[misindex]\n                misindex += 1\n                #answer += 1\n\n            else: # locate original\n                dupeindexindv[nums[index]][0] -= 1\n                dupeindexindv[nums[index]][2] = True\n\n    print(misslen)\n    for num in nums:\n        print(num+1, end = \" \")\n\nsolve(False)\n\n</ans>", "format_properties": {}}
{"idx": 28, "result": 0, "generated": "<ans>\n```\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  print(\"readInts: \", str(readInts))\n  return list(map(int,readline().split()))\ndef readTuples():\n    print(\"readTuples: \", str(readTuples))\n    return tuple(map(int,readline().split()))\ndef I():\n    print(\"I: \", str(I))\n    return int(readline())\nn = I()\nprint(\"n: \", str(n))\nans = 0\nprint(\"ans: \", str(ans))\ndef dfs(v):\n    if len(v) != 0:\n        if int(v) > n:\n            return\n    if v.count('3') and v.count('5') and v.count('7'):\n        nonlocal ans\n        ans += 1\n    for s in \"357\":\n        v += s\n        dfs(v)\n        v = v[:-1]\ndfs(\"\")\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 27, "result": 0, "generated": "<ans>\nclass Ddict:\n    def __init__(self):\n        self.dicts={}\n        print(\"self.dicts: \", str(self.dicts))\n    def add(self,key):\n        d=self.dicts\n        for i in key:\n            if i not in d:\n                d[i]={}\n            d=d[i]\n        d[' ']=''\n    def find(self,key):\n        if key=='':\n            return '',''\n        d=self.dicts\n        q=[]\n        h=[key[0]]\n        for i in key:\n            if i not in d:\n                if ' ' in d and len(d)==1:\n                    return ''.join(q),''.join(h)\n                return '',''\n            q.append(i)\n            if len(d)!=1:\n                h=q[:]\n            d=d[i]\n        if ' ' in d and len(d)==1:\n            return ''.join(q),''.join(h)\n        return '',''\nwords = Ddict()\nprint(\"words: \", str(words))\nans=0\nwhile True:\n    try:\n        x=input()\n        if not x:\n            break\n    except:\n        break\n    ans+=len(x)+1\n    ws=[[]]\n    for i in x:\n        if i in '.,?!\\'- ':\n            if ws[-1]:\n                ws.append([])\n        else:\n            ws[-1].append(i)\n    ws=list([''.join(e) for e in ws])\n    for w in ws:\n        next_word,helped_word = words.find(w)\n        if next_word and next_word!=helped_word:\n            ans-=len(next_word)-len(helped_word)-1\n        words.add(w)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 21, "result": 0, "generated": "<ans>\nimport math\nimport bisect\nimport itertools\nimport sys\nI=lambda : sys.stdin.readline()\nmod=10**9 +7\nprint(\"mod: \", str(mod))\n'''fact=[1]*100001\nifact=[1]*100001\nfor i in range(1,100001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    print(\"b: \", str(b))\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n\ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\n\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2\n    print(\"mid: \", str(mid))\n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n\ndef is_prime(num):\n    if num == 1: return False\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n\ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\n\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n\ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s\n\ndef modu(a,n):\n    if a%n==0:\n        return n\n    return a%n\n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfor i in range(1):\n    n,k=map(int,input().split())\n    print(\"n: \", str(n), \"k: \", str(k))\n    a=list(map(int,input().split()))\n    print(\"a: \", str(a))\n    s=input()\n    print(\"s: \", str(s))\n    c=1;b=[]\n    for i in range(1,n):\n        if s[i-1]==s[i]:\n            c+=1\n            f=True\n        else:\n            b.append(c)\n            c=1\n            f=False\n    if True:\n        b.append(c)\n    print(\"b: \", str(b))\n    ans=0\n    su=0\n    for i in b:\n        c=a[su:min(su+i,10**9)]\n        print(\"c: \", str(c))\n        c.sort(reverse=True)\n        c=c[:min(i,k)]\n        su+=i\n        ans+=sum(c)\n    print(ans)\n</ans>", "format_properties": {}}
{"idx": 31, "result": 0, "generated": "<ans>\nfrom math import*\nfrom random import*\n\nn = int(input()) * 2\nprint(\"n: \", str(n))\nA = list(map(int, input().split()))\nprint(\"A: \", str(A))\namount = [0] * 101\nprint(\"amount: \", str(amount))\n\nB = []\nfor i in range(n):\n    if amount[A[i]] < 2:\n        amount[A[i]] += 1\n        B += [(A[i], i)]\nprint(\"B: \", str(B))\nB.sort()\nx, y = [], []\nfor i in range(len(B)):\n    if(i % 2 == 0):\n        x.append(B[i][1])\n    else:\n        y.append(B[i][1])\nprint(\"x: \", str(x))\nprint(\"y: \", str(y))\nlolka = 0\naaa = 0\nprint(len(x) * len(y))\nfor i in range(n):\n    if i in x:\n        lolka += 1\n        aaa += 1\n        print(1, end = ' ')\n    elif i in y:\n        print(2, end = ' ')\n    else:\n        if len(x) - lolka + aaa < n // 2:\n            print(1, end = ' ')\n            aaa += 1\n        else:\n            print(2, end = ' ')\nprint()\n\n# B, C = [], []\n# for i in range(n):\n\n\n# S = list(set(A))\n# where = [0] * 101\n# am1, am2 = 0, 0\n# for i in range(len(S)):\n#     if(i % 2 == 0):\n#         where[S[i]] = 1\n#         am1 += 1\n#     else:\n#         where[S[i]] = 2\n#         am2 += 1\n# used = [0] * 201\n# for i in range(n):\n#     if not used[A[i]]:\n#         print(where[A[i]])\n#         used[A[i]] = True\n#     else:\n#         print(3 - where[A[i]])\n</ans>", "format_properties": {}}
{"idx": 30, "result": 0, "generated": "<ans>\n```\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport math\n\n#T = int(input())\n#N = int(input())\n#print(N)\nN, r = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\nvisited = [0]*N\n\na = [0]*N\nb = [0]*N\n\npos = 0\n\nfor i in range(N):\n    arr = [int(x) for x in stdin.readline().split()]\n    a[i] = arr[0]\n    b[i] = arr[1]\n\n    if b[i]>=0:\n        pos += 1\n\nprint(\"N: \", str(N), \"r: \", str(r), \"visited: \", str(visited), \"a: \", str(a), \"b: \", str(b), \"pos: \", str(pos))\n\nfor i in range(pos):\n    idx = -1\n    start = 0\n    gain = -50000\n    for j in range(N):\n        # find available and largest gain\n        # if gain tie, find largest start r\n        if visited[j]==1 or b[j]<0:\n            continue\n\n        if b[j]>gain and r>=a[j]:\n            gain = b[j]\n            idx = j\n            start = a[j]\n        elif b[j]==gain and r>=a[j]:\n            if a[j]>start:\n                idx = j\n                start = a[j]\n\n    if idx==-1:\n        print('NO')\n        quit()\n    else:\n        visited[idx] = 1\n        r += b[idx]\n        print(\"idx: \", str(idx), \"r: \", str(r))\n\ntmp = []\nfor i in range(N):\n    if visited[i]==1 or b[i]>=0:\n        continue\n    tmp.append((a[i],b[i],i))\n\nprint(\"tmp: \", str(tmp))\n\ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\n\nfor i in range(len(tmp)):\n    require = tmp[i][0]\n    bias = tmp[i][1]\n\n    if r>=require:\n        r += bias\n    else:\n        print('NO')\n        quit()\n\nif r<0:\n    print('NO')\n    quit()\n\nprint('YES')\n```", "format_properties": {}}
{"idx": 24, "result": 0, "generated": "<ans>\nimport sys\n\ndef gcd(l):\n\tif len(l)==0:\n\t\treturn 0\n\tif len(l)==1:\n\t\treturn l[0]\n\tif len(l)==2:\n\t\tprint(\"l: \", str(l))\n\t\tif l[1]==0:\n\t\t\treturn l[0]\n\t\treturn gcd([l[1],l[0]%l[1]])\n\treturn gcd([gcd(l[:-1]),l[-1]])\n\ndef brute_force(l1,l2,l,sol):\n\tif len(l)==0:\n\t\tg1=gcd(l1)\n\t\tg2=gcd(l2)\n\t\tprint(\"g1: \", str(g1), \"g2: \", str(g2))\n\t\treturn g1==1 and g2==1,sol\n\n\tres,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])\n\tif res:\n\t\treturn True,s\n\treturn brute_force(l1,l2+[l[0]],l[1:],sol+[2])\n\ndef factor(n):\n\tres=[]\n\ti=2\n\twhile i*i<=n:\n\t\tif n%i==0:\n\t\t\tres.append(i)\n\t\twhile n%i==0:\n\t\t\tn=int(n/i)\n\t\ti+=1\n\n\tif n!=1:\n\t\tres.append(n)\n\n\treturn res\n\ndef dumpsol(sol):\n\tfor v in sol:\n\t\tprint(v,end=' ')\n\nn=int(sys.stdin.readline())\nl=sys.stdin.readline().strip().split(\" \")[0:n]\nl=[int(x) for x in l]\nprint(\"l: \", str(l))\nif n<12:\n\tret,sol=brute_force([],[],l,[])\n\tif ret:\n\t\tprint(\"YES\")\n\t\tdumpsol(sol)\n\telse:\n\t\tprint(\"NO\")\n\treturn\n\nfactors={}\nfor i in range(10):\n\tfor key in factor(l[i]):\n\t\tfactors[key]=0\n\nflists={}\nfor f in factors:\n\tflists[f]=[]\n\tpos=0\n\tfound=False\n\tfor v in l:\n\t\tif v%f!=0:\n\t\t\tfound=True\n\t\t\tfactors[f]+=1\n\t\t\tflists[f].append(pos)\n\t\t\tif (factors[f]>9):\n\t\t\t\tbreak\n\t\tpos+=1\n\tif not found:\n\t\tprint(\"NO\")\n\t\treturn\n\noftf=[]\nisoftf={}\nfor f in factors:\n\tif factors[f]==0:\n\t\tprint(\"NO\")\n\t\treturn\n\n\tif factors[f]<10:\n\t\toftf.append(f)\n\t\tisoftf[f]=1\n\nsol=[1 for i in range(len(l))]\nx=l[0]\nsol[0]=2\noxf=factor(x)\nxf=[]\nnxf=0\nisxoftf={}\nfor f in oxf:\n\tif f in isoftf:\n\t\tnxf+=1\n\t\tisxoftf[f]=1\n\t\txf.append(f)\n\telse:\n\t\tsol[flists[f][0]]=2\n\nnonxf=[]\nfor f in oftf:\n\tif not f in isxoftf:\n\t\tnonxf.append(f)\n\nmasks={}\npos=0\n\nfor f in xf+nonxf:\n\tfor v in flists[f]:\n\t\tif not v in masks:\n\t\t\tmasks[v]=0\n\t\tmasks[v]|=1<<pos\n\tpos+=1\n\nvals=[{} for i in range(len(masks)+1)]\nvals[0][0]=0\npos=0\nmlist=[]\nfor mask in masks:\n\tmlist.append(mask)\n\tcmask=masks[mask]\n\tcmask1=cmask<<10\n\tfor v in vals[pos]:\n\t\tvals[pos+1][v|cmask]=v\n\t\tif (mask!=0):\n\t\t\tvals[pos+1][v|cmask1]=v\n\tpos+=1\n\ntest_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)\nfor v in vals[pos]:\n\tif (v&test_val)==test_val:\n\t\tprint(\"YES\")\n\t\twhile (pos!=0):\n\t\t\tnv=vals[pos][v]\n\t\t\tif (nv^v<1024 and nv^v!=0):\n\t\t\t\tsol[mlist[pos-1]]=2\n\t\t\tv=nv\n\t\t\tpos-=1\n\t\tdumpsol(sol)\n\t\treturn\n\nprint(\"NO\")\n</ans>", "format_properties": {}}
{"idx": 26, "result": 0, "generated": "<ans>\nimport heapq\nn,m,k = list(map(int,input().split()))\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\nconnectionList = []\nfor _ in range(n):\n    connectionList.append([])\nprint(\"connectionList: \", str(connectionList))\nedgeList = []\nfor _ in range(m):\n    x,y,w = list(map(int,input().split()))\n    edgeList.append((x,y,w))\nprint(\"edgeList: \", str(edgeList))\nedgeList.sort(key = lambda x: x[2])\nif k < m:\n    maxDist = edgeList[min(m,k) - 1][2]\nelse:\n    maxDist = sum([x[2] for x in edgeList])\nprint(\"maxDist: \", str(maxDist))\ncolorList = {}\ncolorVertex = []\nfor i in range(n):\n    colorList[i] = [i]\n    colorVertex.append(i)\nprint(\"colorList: \", str(colorList), \"colorVertex: \", str(colorVertex))\n\nfor i in range(min(m,k)):\n    x,y,w = edgeList[i]\n    connectionList[x-1].append((y-1,w))\n    connectionList[y-1].append((x-1,w))\n    if colorVertex[x-1] != colorVertex[y-1]:\n        if len(colorList[colorVertex[x-1]]) >= len(colorList[colorVertex[y-1]]):\n            prevColor = colorVertex[y-1]\n            for elem in colorList[colorVertex[y-1]]:\n                colorVertex[elem] = colorVertex[x-1]\n                colorList[colorVertex[x-1]].append(elem)\n            del colorList[prevColor]\n        else:\n            prevColor = colorVertex[x-1]\n            for elem in colorList[colorVertex[x-1]]:\n                colorVertex[elem] = colorVertex[y-1]\n                colorList[colorVertex[y-1]].append(elem)\n            del colorList[prevColor]\nprint(\"colorList: \", str(colorList), \"colorVertex: \", str(colorVertex))\n\npathList = []\nfor key in colorList:\n    vertexList = colorList[key]\n    for mainVertex in vertexList:\n        vertexPQueue = []\n        isCovered = {}\n        distanceDic = {}\n        for elem in vertexList:\n            isCovered[elem] = False\n            distanceDic[elem] = maxDist\n        isCovered[mainVertex] = True\n        for elem in connectionList[mainVertex]:\n            heapq.heappush(vertexPQueue,(elem[1],elem[0]))\n            distanceDic[elem[0]] = elem[1]\n        while vertexPQueue:\n            distance, curVertex = heapq.heappop(vertexPQueue)\n            if isCovered[curVertex]:\n                continue\n            elif distance >= maxDist:\n                break\n            for elem in connectionList[curVertex]:\n                if distance + elem[1] < distanceDic[elem[0]]:\n                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))\n                    distanceDic[elem[0]] = distance + elem[1]\n        for key in distanceDic:\n            if distanceDic[key] <= maxDist and key > mainVertex:\n                pathList.append(distanceDic[key])\n        if len(pathList) > k:\n            pathList.sort()\n            pathList = pathList[0:k]\n            if pathList[-1] < maxDist:\n                maxDist = pathList[-1]\nprint(\"pathList: \", str(pathList))\npathList.sort()\nprint(\"pathList[k-1]: \", str(pathList[k-1]))\n</ans>", "format_properties": {}}
{"idx": 34, "result": 0, "generated": "<ans>\nfrom math import log2, floor\n\ndef is_power2(num):\n    print(\"num: \", str(num))\n    return num != 0 and ((num & (num - 1)) == 0)\n\ndef next_two_pow(val):\n    print(\"val: \", str(val))\n    pw=0\n    while 2**pw <= val:\n        pw=+1\n    return pw\n\nn = int(input())\narr=[int(x) for x in input().split()]\n\nwin_idx =-1\nselected=[]\n\nfor i in range(1,n+1):\n    val = arr[i-1]\n    if win_idx ==-1:\n       if  val == -1:\n           win_idx =i\n    else:\n         if is_power2(i):\n             selected.append(val)\n             selected.sort()\n         else:\n             if len(selected) > 0 and val < selected[-1]:\n                 selected.pop()\n                 selected.append(val)\n                 selected.sort()\n\nprint(sum(selected))\n</ans>", "format_properties": {}}
{"idx": 32, "result": 0, "generated": "<ans>\n```\ndef check(mid):\n    ans = []\n    res = 0\n    for c, count in d:\n        tmp = count // mid\n        if (count % mid != 0):\n            tmp += 1\n        ans.append((c, tmp))\n        res += tmp\n    print(\"ans: \", str(ans))\n    print(\"res: \", str(res))\n    return res <= n, ans\n\na = input()\nn = int(input())\nd = dict()\nt = 0\nfor i in a:\n    if i not in d:\n        d[i] = 1\n        t += 1\n    else: d[i] += 1\nprint(\"d: \", str(d))\nprint(\"t: \", str(t))\nans = []\nres = \"\"\nfor i in d:\n    ans.append(i)\n    res = i\nif n >= len(a):\n    print(1)\n    print(a, end = '')\n    n -= len(a)\n    for u in range(n):\n        print(res, end ='')\nelse:\n    d = (sorted(d.items(), key = lambda d:(d[1], d[0])))\n    l = 1\n    r = len(a)\n    res = []\n    count_res = 0\n    while (l <= r):\n        mid = (l + r) // 2\n        flag, tmp = check(mid)\n        print(\"flag: \", str(flag))\n        print(\"tmp: \", str(tmp))\n        if (flag):\n            r = mid - 1\n            count_res = mid\n            res = tmp\n        else:\n            l = mid + 1\n        #print(l, r, tmp)\n    if (len(res) == 0):\n        print(-1)\n    else:\n        ttt = 0\n        print(\"count_res: \", str(count_res))\n        for c, sl in res:\n            for j in range(sl):\n                print(c, end = '')\n                ttt += 1\n        print(\"ttt: \", str(ttt))\n        n -= ttt\n        for i in range(n):\n            print(a[0], end = '')\n</ans>", "format_properties": {}}
{"idx": 25, "result": 0, "generated": "<ans>\na, b, f, k = [int(i) for i in input().split()]\nprint(\"a: \", str(a), \"b: \", str(b), \"f: \", str(f), \"k: \", str(k))\n\n##tank = b\n##journeys = 0\n##refuels = 0\n##current = 0\n##while(journeys != k):\n##    print(\"current = %d, tank = %d, refuels = %d, journeys = %d\" % (current, tank, refuels, journeys))\n##    if (tank // a >= k):\n##        print(refuels)\n##        return\n\n##    if current == 0:\n##        if tank >= a + (a-f):\n##            tank -= a\n##        elif tank >= f and b >= a-f:\n##            refuels += 1\n##            tank = b-(a-f)\n##        else:\n##            break\n\n##        current = a\n\n##    elif current == a:\n##        if tank >= a + f:\n##            tank -= a\n##        elif tank >= a-f and b >= f:\n##            refuels += 1\n##            tank = b-f\n##        else:\n##            break\n\n##        current = 0\n\n##    journeys += 1\n\nif b < f:\n    print(-1)\n    return\n\njourneys = 0\nprevious = 0\nrefuels1 = 0\ntank = b-f\nprint(\"journeys: \", str(journeys), \"previous: \", str(previous), \"refuels1: \", str(refuels1), \"tank: \", str(tank))\nwhile(journeys != k): ## necessary? while(True) ?\n    if previous == 0:\n        if tank >= a-f + a*(k-journeys-1):\n            print(refuels1)\n            return\n        if b >= a-f + a*(k-journeys-1):\n            print(refuels1+1)\n            return\n        if tank >= 2*(a-f):\n            tank -= 2*(a-f)\n        elif b >= 2*(a-f):\n            refuels1 += 1\n            tank = b - 2*(a-f)\n        else:\n            print(-1)\n            return\n\n        journeys += 1\n        previous = a\n\n    if previous == a:\n        if tank >= f + a*(k-journeys-1):\n            print(refuels1)\n            return\n        if b >= f + a*(k-journeys-1):\n            print(refuels1+1)\n            return\n        if tank >= 2*f:\n            tank -= 2*f\n        elif b >= 2*f:\n            refuels1 += 1\n            tank = b-2*f\n        else:\n            print(-1)\n            return\n\n        journeys += 1\n        previous = 0\n\nprint(\"journeys: \", str(journeys), \"previous: \", str(previous), \"refuels1: \", str(refuels1), \"tank: \", str(tank))\n\nif journeys == k:\n    print(refuels1)\nelse:\n    print(-1)\n\n##journeys = 0\n##previous = 0\n##refuels2 = 1\n##tank = b\n##cant2 = False\n##while(journeys != k):\n##    if previous == 0:\n##        if tank >= a-f + a*(k-journeys-1):\n##            break\n##        if tank >= 2*(a-f):\n##            tank -= 2*(a-f)\n##        elif b >= 2*(a-f):\n##            refuels2 += 1\n##            tank = b - 2*(a-f)\n##        else:\n##            cant2 = True\n##            break\n\n##        journeys += 1\n##        previous = a\n\n##    if previous == a:\n##        if tank >= f + a*(k-journeys-1):\n##            break\n##        if tank >= 2*f:\n##            tank -= 2*f\n##        elif b >= 2*f:\n##            refuels2 += 1\n##            tank = b-2*f\n##        else:\n##            cant2 = True\n##            break\n\n##        journeys += 1\n##        previous = 0\n\n##if cant1 and not cant2:\n##    print(refuels2)\n##elif not cant1 and cant2:\n##    print(refuels1)\n##elif cant1 and cant2:\n##    print(-1)\n##else:\n##    print(min(refuels1, refuels2))\n</ans>", "format_properties": {}}
{"idx": 29, "result": 0, "generated": "<ans>\n```\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom itertools import accumulate\n\n#T = int(input())\ns = input()\n#N,M,K,Q = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\ndef computeGCD(x, y):\n    print(\"x: \", str(x), \"y: \", str(y))\n    while(y):\n        x, y = y, x % y\n    return x\n\nrecord = {}\nprint(\"record: \", str(record))\n\nfor x in range(10):\n    for y in range(10):\n        for d in range(10):\n            m = 9999\n            if (x==0 or y==0) and d==0:\n                record[(x,y,d)] = 0\n                print(\"record[(x,y,d)]: \", str(record[(x,y,d)]))\n            elif x==0 and y==0 and d!=0:\n                record[(x,y,d)] = -1\n                print(\"record[(x,y,d)]: \", str(record[(x,y,d)]))\n            else:\n                for k in range(10):\n                    d_tmp = d + 10*k\n                    if x==0:\n                        if d_tmp%y==0:\n                            record[(x,y,d)] = d_tmp//y - 1\n                            print(\"record[(x,y,d)]: \", str(record[(x,y,d)]))\n                            break\n\n                    elif y==0:\n                        if d_tmp%x==0:\n                            record[(x,y,d)] = d_tmp//x - 1\n                            print(\"record[(x,y,d)]: \", str(record[(x,y,d)]))\n                            break\n\n                    else:\n                        for a in range((d_tmp//x)+1):\n                            for b in range((d_tmp//y)+1):\n                                if x*a+y*b==d_tmp and d_tmp!=0:\n                                    m = min(m,a+b-1)\n\n                if (x,y,d) not in record:\n                    if m==9999:\n                        m = -1\n                    record[(x,y,d)] = m\n                    print(\"record[(x,y,d)]: \", str(record[(x,y,d)]))\n\ndata = [[0]*10 for _ in range(10)]\nprint(\"data: \", str(data))\n\nlen_s = len(s)\ns = list(s)\nfreq = [0]*10\nfor i in range(len_s-1):\n    A = s[i]\n    B = s[i+1]\n\n    d = ord(B)-ord(A)\n    if d<0:\n        d += 10\n\n    freq[d] += 1\n\nfor x in range(10):\n    for y in range(10):\n        for d in range(10):\n            if freq[d]==0:\n                data[x][y] += 0\n            elif record[(x,y,d)]==-1:\n                data[x][y] = -10000000\n            else:\n                data[x][y] += freq[d]*record[(x,y,d)]\n            print(\"data[x][y]: \", str(data[x][y]))\n\nfor x in range(10):\n    for y in range(10):\n        if data[x][y]<0:\n            print(-1,end=' ')\n        else:\n            print(data[x][y],end=' ')\n    print('',end='\\n')\n\n```", "format_properties": {}}
{"idx": 3, "result": 0, "generated": "<ans>\nimport numpy as np\nmod = 998244353\n\ndef poly_mul(f, g):\n    Lf = len(f)\n    print(\"Lf: \", str(Lf))\n    Lg = len(g)\n    print(\"Lg: \", str(Lg))\n    L = Lf + Lg - 1\n    if Lf <= 16 or Lg <= 16:\n        if Lf == 0 or Lg == 0:\n            return np.zeros((0,), dtype=np.int64)\n        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % mod).astype(np.int64)\n    fft = np.fft.rfft; ifft = np.fft.irfft\n    fft_len = 1 << L.bit_length()\n    fl = f & (1 << 15) - 1\n    print(\"fl: \", str(fl))\n    fh = f >> 15\n    print(\"fh: \", str(fh))\n    gl = g & (1 << 15) - 1\n    print(\"gl: \", str(gl))\n    gh = g >> 15\n    print(\"gh: \", str(gh))\n    x = (ifft(fft(fl, fft_len) * fft(gl, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    y = (ifft(fft(fl+fh, fft_len) * fft(gl+gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    z = (ifft(fft(fh, fft_len) * fft(gh, fft_len))[:L] + 0.5).astype(np.int64) % mod\n    return (x + ((y - x - z) << 15) + (z << 30)) % mod\n\ndef poly_inv(fps, n=None):\n    assert fps[0] != 0\n    if n is None:\n        n = len(fps)\n    res = np.zeros(1<<(n-1).bit_length(), dtype=np.int64)\n    res[0] = pow(int(fps[0]), mod-2, mod)\n    i = 1\n    while i < n:\n        i <<= 1\n        res[:i] = ((res[:i]<<1) - poly_mul(poly_mul(res[:i>>1], res[:i>>1]), fps[:i])[:i]) % mod\n    return res[:n]\n\ndef poly_div(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return np.zeros((0,), dtype=np.int64)\n    n = n1 - n2 + 1\n    res = poly_mul(fps1[-1:-n-1:-1], poly_inv(fps2[::-1], n))[n-1::-1]\n    return res\n\ndef poly_mod(fps1, fps2):\n    n1, n2 = len(fps1), len(fps2)\n    if n1 < n2:\n        return fps1\n    res = fps1[:n2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:n2-1]\n    return res % mod\n\ndef multipoint_evaluation(fps, xs):\n    threshold = 8\n    n_xs = len(xs)\n    bit = (n_xs-1).bit_length()\n    if bit <= threshold:\n        res = np.zeros_like(xs)\n        xs_cumprod = np.ones_like(xs)\n        for coef in fps:\n            res += xs_cumprod * coef\n            xs_cumprod *= xs\n            xs_cumprod %= mod\n        return res\n    k = 1<<bit\n    fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)\n    fpss[0, :n_xs] = -xs % mod\n    fpss[1, :k:2] = fpss[0, :k:2] * fpss[0, 1::2] % mod\n    fpss[1, 1::2] = (fpss[0, :k:2] + fpss[0, 1::2]) % mod\n    for i in range(1, bit):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+step] = f[:-1]\n    f = poly_mod(fps, f)\n    fpss[-1, :len(f)] = f\n    fpss[-1, len(f):] = 0\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, k, step):\n            f = fpss[i+1, j:j+step]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss[i, j:j+half] = poly_mod(f, f1)\n            fpss[i, j+half:j+step] = poly_mod(f, f2)\n    xs = (-fpss[0, :k] % mod).reshape(-1, 1<<threshold)\n    xs_cumprod = np.ones_like(xs)\n    res = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        res += fpss[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    return res.reshape(-1)[:n_xs] % mod\n\ndef poly_differential(fps):\n    return fps[1:] * np.arange(1, len(fps)) % mod\n\ndef lagrange_interpolation(X, Y, mod):\n    n = len(X)\n    g = [0]*(n+1)\n    g[0] = 1\n    for i, x in enumerate(X):\n        for j in range(i, -1, -1):\n            g[j+1] += g[j] * (-x) % mod\n    res = [0]*n\n    for x, y in zip(X, Y):\n        f = g[:]\n        denom = 0\n        v = 1\n        pow_x = [1]  # x \u306e idx \u4e57\n        for _ in range(n-1):\n            v = v * x % mod\n            pow_x.append(v)\n        pow_x.reverse()  # n-1 \u4e57 ~ 0 \u4e57\n        for i, po in enumerate(pow_x):\n            f_i = f[i]\n            f[i+1] += f_i * x % mod  # f = g / (x - x_i) \u3092\u7d44\u7acb\u9664\u6cd5\u3067\u6c42\u3081\u308b\n            denom = (denom + f_i * po) % mod\n        denom_inv = pow(denom, mod-2, mod)\n        for i, f_i in enumerate(f[:n]):\n            res[i] += (f_i * y * denom_inv) % mod  # mod \u304c\u5927\u304d\u3044\u3068 64bit \u306b\u53ce\u307e\u3089\u306a\u304f\u306a\u308b\u306e\u3067\u3072\u3068\u3064\u305a\u3064 mod \u53d6\u3063\u305f\u65b9\u304c\u3044\u3044\u304b\uff1f\n    return [v % mod for v in res]\n\ndef polynomial_interpolation(xs, ys):\n    assert len(xs) == len(ys)\n    threshold = 8\n    as_strided = np.lib.stride_tricks.as_strided\n    n = len(xs)\n    if n==1:\n        return ys.copy()\n    bit = (n-1).bit_length()\n    if bit <= threshold:\n        res = lagrange_interpolation(xs.tolist(), ys.tolist(), mod)\n        return np.array(res[::-1], dtype=np.int64)\n    k = 1<<bit\n    fpss = np.zeros((bit+1, n+1), dtype=np.int64)\n    fpss[0, :n] = -xs % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss[i+1, j:n] = fpss[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            f = poly_mul(f1, f2)\n            fpss[i+1, j:j+len(f)-1] = f[:-1]\n    fpss2 = np.zeros((bit+1, k+1), dtype=np.int64)\n    fpss2[bit, :n] = poly_differential(f)\n    for i in range(bit-1, threshold-1, -1):\n        step = 2<<i\n        half = step>>1\n        for j in range(0, n, step):\n            if j+half >= n:\n                fpss2[i, j:n] = fpss2[i+1, j:n]\n                continue\n            f = fpss2[i+1, j:min(j+step, n)]\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:min(j+step, n)+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i, j:j+half] = poly_mod(f, f1)\n            fpss2[i, j+half:min(j+step, n)] = poly_mod(f, f2)\n    xs = as_strided(xs, (k>>threshold, 1<<threshold), (8<<threshold, 8))\n    xs_cumprod = np.ones_like(xs)\n    f = np.zeros_like(xs)\n    for i in range(1<<threshold):\n        f += fpss2[threshold, i:k:1<<threshold, None] * xs_cumprod % mod\n        xs_cumprod *= xs\n        xs_cumprod %= mod\n    f = f.ravel()\n    for j in range(n):\n        fpss2[0, j] = ys[j] * pow(int(f[j]), mod-2, mod) % mod\n    for i in range(bit):\n        step = 2 << i\n        half = step >> 1\n        for j in range(0, k, step):\n            if j+half >= n:\n                fpss2[i+1, j:n] = fpss2[i, j:n]\n                continue\n            f1 = fpss[i, j:j+half+1].copy()\n            f2 = fpss[i, j+half:j+step+1].copy()\n            f1[-1] = f2[-1] = 1\n            fpss2[i+1, j:min(j+step, n)] = (\n                poly_mul(fpss2[i, j:j+half], f2)\n                + poly_mul(fpss2[i, j+half:min(j+step, n)], f1)\n            ) % mod\n    return fpss2[bit, :n]\n\nmod = int(input())\nA = np.array(input().split(), dtype=np.int64)\nX = np.arange(mod, dtype=np.int64)\nAns = polynomial_interpolation(X, A)\nprint((\" \".join(map(str, Ans.tolist()))))\n</ans>", "format_properties": {}}
{"idx": 36, "result": 0, "generated": "<ans>\n```\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  print(\"readInts: \", str(readInts))\n  return list(map(int,readline().split()))\ndef readTuples():\n    print(\"readTuples: \", str(readTuples))\n    return tuple(map(int,readline().split()))\ndef I():\n    print(\"I: \", str(I))\n    return int(readline())\nn = I()\nA = readInts()\nprint(\"A: \", str(A))\nB = readInts()\nprint(\"B: \", str(B))\nans = 0\nfor i in range(n):\n    v = B[i]\n    print(\"v: \", str(v))\n    # kill = A[i] + A[i+1]\n    nya = min(v, A[i])\n    print(\"nya: \", str(nya))\n    A[i] -= nya\n    print(\"A[i]: \", str(A[i]))\n    v -= nya\n    print(\"v: \", str(v))\n    ans += nya\n    print(\"ans: \", str(ans))\n    nya = min(A[i+1], v)\n    print(\"nya: \", str(nya))\n    ans += nya\n    print(\"ans: \", str(ans))\n    A[i+1] -= nya\n    print(\"A[i+1]: \", str(A[i+1]))\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 43, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\narr=list(map(int,input().split()))\nprint(\"arr: \", str(arr))\ndict1={}\nprint(\"dict1: \", str(dict1))\nfor i in range(2*n):\n\ttry:\n\t\tdict1[arr[i]].append(i+1)\n\t\tdict1[arr[i]].sort()\n\texcept KeyError:\n\t\tdict1[arr[i]]=[i+1]\nprint(\"dict1: \", str(dict1))\nans=0\nprint(\"ans: \", str(ans))\ncurr1=1\nprint(\"curr1: \", str(curr1))\ncurr2=1\nprint(\"curr2: \", str(curr2))\nfor i in range(1,n+1):\n\t# ... (rest of the code)\n</ans>", "format_properties": {}}
{"idx": 35, "result": 0, "generated": "<ans>\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n\ndef go():\n    n = int(input())\n    print(\"n: \", str(n))\n    # n, h, l, r = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(\"a: \", str(a))\n    e = {i: set() for i in range(n)}\n    print(\"e: \", str(e))\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u, v = u - 1, v - 1\n        e[u].add(v)\n        e[v].add(u)\n    ranks = [len(e[i]) for i in range(n)]\n    print(\"ranks: \", str(ranks))\n    leafs = [i for i in range(n) if ranks[i] == 1]\n    print(\"leafs: \", str(leafs))\n    index = 0\n    vs = {i: {} for i in range(n)}\n    print(\"vs: \", str(vs))\n    done = set()\n    while index < len(leafs):\n        cur = leafs[index]\n        mysum = sum(vs[cur].values())\n\n        if a[cur] == 0:\n            mysum -= 1\n        else:\n            mysum += 1\n\n        for i in e[cur] - done:\n            vs[i][cur] = max(mysum, 0)\n            ranks[i] -= 1\n            if ranks[i] == 1:\n                leafs.append(i)\n        done.add(cur)\n        index += 1\n\n    sums = [0] * n\n    print(\"sums: \", str(sums))\n    que = [ranks.index(0)]\n    done = set()\n    index = 0\n    while index < len(que):\n        cur = que[index]\n\n        mysum = sum(vs[cur].values())\n\n        if a[cur] == 0:\n            mysum -= 1\n        else:\n            mysum += 1\n\n        sums[cur] = mysum\n\n        for i in e[cur] - done:\n            vs[i][cur] = max(mysum - vs[cur][i], 0)\n            que.append(i)\n\n        done.add(cur)\n        index += 1\n\n    return ' '.join(map(str,sums))\n\n# t = int(input())\nfor _ in range(1):\n    print(go())\n\n</ans>", "format_properties": {}}
{"idx": 37, "result": 0, "generated": "<ans>\ndef solve(s,t):\n    hash_s = [False] * 256\n    print(\"hash_s: \", str(hash_s))\n    hash_t = [False] * 256\n    print(\"hash_t: \", str(hash_t))\n    arr = []\n    print(\"arr: \", str(arr))\n    n = len(s)\n    print(\"n: \", str(n))\n    for c in s:\n        hash_s[ord(c)] = True\n    for c in t:\n        hash_t[ord(c)] = True\n    for i in range(256):\n        if not hash_s[i] and hash_t[i]:\n            print(-1)\n            return\n    rev = s[::-1]\n    print(\"rev: \", str(rev))\n    i,j = 0,0\n    while i < len(t):\n        flag = True\n        temp = t[i]\n        j = i + 1\n        while j < len(t):\n            temp += t[j]\n            if temp not in s and temp not in rev:\n                flag = False\n                break\n            j += 1\n        if flag:\n            x = s.find(temp)\n            if x != -1:\n                arr.append((x + 1,x + len(temp)))\n                print('1',x + 1,x + len(temp))\n            else:\n                y = rev.find(temp)\n                arr.append((n - y,n - y - len(temp) + 1))\n                print('2',n - y,n - y - len(temp) + 1)\n        else:\n            x = s.find(temp[:-1])\n            if x != -1:\n                arr.append((x + 1,x + len(temp) - 1))\n                print('3',x + 1,x + len(temp) - 1)\n            else:\n                x = rev.find(temp[:-1])\n                arr.append((n - x,n - x - len(temp) + 2))\n                print('4',n - x,n - x - len(temp) + 2)\n        i = j\n    print(\"arr: \", str(arr))\n    print(len(arr))\n    for x,y in arr:\n        print(x,y)\n\ns = input()\nprint(\"s: \", s)\nt = input()\nprint(\"t: \", t)\n\nsolve(s,t)\n\n</ans>", "format_properties": {}}
{"idx": 33, "result": 0, "generated": "<ans>\n\"\"\"\nCodeforces Contest Good Bye 2014 Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n\"\"\"\n\n################################################### SOLUTION\n\ndef main():\n    n, = read()\n    print(\"n: \", str(n))\n    p = read()\n    print(\"p: \", str(p))\n    dsu = DSU()\n    print(\"dsu: \", str(dsu))\n    for i in range(n):\n        a = read(0)\n        print(\"a: \", str(a))\n        dsu.make()\n        for j in range(i):\n            if a[j] == \"1\":\n                dsu.union(j, i)\n    used = [0] * n\n    print(\"used: \", str(used))\n    res = [0] * n\n    print(\"res: \", str(res))\n    for i in range(n):\n        if not used[i]:\n            pr = dsu.find(i)\n            print(\"pr: \", str(pr))\n            indices = []\n            elements = []\n            for j in range(n):\n                if dsu.find(j) == pr:\n                    used[j] = 1\n                    indices.append(j)\n                    elements.append(p[j])\n            elements.sort()\n            for i,e in zip(indices, elements):\n                res[i] = e\n    write(res)\n\n#################################################### HELPERS\n\nclass DSU(object):\n    \"\"\"\n    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.\n\n    Methods:\n    make(): add a new element and returns its index\n    find(x): return representative of x\n    union(x, y): merge the sets containing x and y\n\n    Not to be used publicly:\n    _parent: a list of ints for the parent of each vertex, used internally; call find instead\n    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case\n    __init__(): called when initialization, initialize DSU to be empty\n    __str__(): return a readable string description of the DSU; meant to be printed while debugging\n    \"\"\"\n\n    def __init__(self):\n        self._parent = []\n        self._rank = []\n        print(\"dsu._parent: \", str(self._parent))\n        print(\"dsu._rank: \", str(self._rank))\n\n    def make(self):\n        i = len(self._parent)\n        self._parent.append(i)\n        self._rank.append(0)\n        print(\"dsu._parent: \", str(self._parent))\n        print(\"dsu._rank: \", str(self._rank))\n        return i\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr == yr: return\n        if self._rank[xr] < self._rank[yr]:\n            self._parent[xr] = yr\n        elif self._rank[yr] < self._rank[xr]:\n            self._parent[yr] = xr\n        else:\n            self._parent[yr] = xr\n            self._rank[xr] += 1\n        print(\"dsu._parent: \", str(self._parent))\n        print(\"dsu._rank: \", str(self._rank))\n\n    def __str__(self):\n        s = \"DSU\\n\"\n        for i in range(len(self._parent)):\n            s += str(i) + \" in set \" + str(self.find(i)) + \" with rank \" + str(self._rank[self.find(i)]) + \"\\n\"\n        return s\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())\n</ans>", "format_properties": {}}
{"idx": 45, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nA = [list(map(int, input().split())) for i in range(n)]\nprint(\"A: \", str(A))\n\nfor i in range(m):\n    ANSR = [0] * n\n    print(\"ANSR: \", str(ANSR))\n    ANSC = [0] * m\n    print(\"ANSC: \", str(ANSC))\n\n    # ... rest of the code ...\n\n    ANSR = [0] * n\n    print(\"ANSR: \", str(ANSR))\n    ANSC = [0] * m\n    print(\"ANSC: \", str(ANSC))\n\n    flag = 0\n    print(\"flag: \", str(flag))\n\n    # ... rest of the code ...\n\n    print(\"NO\")\n\n</ans>", "format_properties": {}}
{"idx": 44, "result": 0, "generated": "<ans>\ndef gcd(a,b):\n    while b:\n        a, b = b, a%b\n    return a\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\nprint(\"L: \", str(L))\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nprint(\"L: \", str(L))\nres = 0\n\nC = dd(int)\nprint(\"C: \", str(C))\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\nprint(\"ss: \", str(ss))\n\nfor x in C.values():\n    res += (ss-x)*x\n\nprint(\"res: \", str(res))\n\nprint(res//2)\n</ans>", "format_properties": {}}
{"idx": 38, "result": 0, "generated": "<ans>\nfrom itertools import chain\nimport sys\n\ndef main():\n    N = int(input())\n    # TLEs were caused mostly by slow input (1s+)\n    # S = list(input() for _ in range(N))\n    S = sys.stdin.read().split('\\n')\n    print(\"S: \", str(S))\n    print((solve(S)))\n\ndef get_count(args):\n    s, result = args # messy input to work with map.\n    cum_sum = 0\n    for c in s:\n        if c == ')':\n            cum_sum -= 1\n        else:\n            cum_sum += 1\n        result[0] = max(result[0], -cum_sum)\n    result[1] = result[0] + cum_sum\n    return result\n\n# Made-up name, don't remember what to call this. Radix-ish\ndef silly_sort(array, value_min, value_max, get_value):\n    if len(array) == 0:\n        return\n    cache = [None for _ in range(value_max - value_min + 1)]\n    for elem in array:\n        # Assume elem[0] is the value\n        value = get_value(elem) - value_min\n        if cache[value] is None:\n            cache[value] = []\n        cache[value].append(elem)\n    for values in cache:\n        if values is None:\n            continue\n        for value in values:\n            yield value\n\ndef solve(S):\n    counts = [[0,0] for _ in range(len(S))]\n    print(\"counts: \", str(counts))\n    counts = list(map(get_count, list(zip(S,counts))))\n    print(\"counts after get_count: \", str(counts))\n    first_group = []\n    second_group = []\n    min_first_group = float('inf')\n    max_first_group = 0\n    min_second_group = float('inf')\n    max_second_group = 0\n\n    for c in counts:\n        if c[0] - c[1] <= 0:\n            first_group.append(c)\n            max_first_group = max(max_first_group, c[0])\n            min_first_group = min(min_first_group, c[0])\n        else:\n            second_group.append(c)\n            max_second_group = max(max_second_group, c[1])\n            min_second_group = min(min_second_group, c[1])\n    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])\n    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))\n\n    order = chain(first_group, second_group)\n\n    cum_sum = 0\n    for c in order:\n        cum_sum -= c[0]\n        if cum_sum < 0:\n            return 'No'\n        cum_sum += c[1]\n    if cum_sum == 0:\n        return 'Yes'\n    return 'No'\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 39, "result": 0, "generated": "<ans>\nimport math\nfrom functools import reduce\nclass SegmentTree():\n    def __init__(self, L, function = lambda x,y: x+y):\n        self.function = function\n        N = self.size = len(L)\n        M = 1 << N.bit_length()\n        self.margin = 2*M - N\n        self.L = [None for i in range(self.margin)] + L\n        for i in range(M-1, 0, -1):\n            x, y = self.L[i<<1], self.L[i<<1|1]\n            self.L[i] = None if x is None or y is None else function(x, y)\n    def modify(self, pos, value):\n        p = pos + self.margin\n        self.L[p] = value\n        print(\"L[\", p, \"]: \", str(self.L[p]))\n        while p > 1:\n            x, y = self.L[p], self.L[p^1]\n            if p&1: x, y = y, x\n            self.L[p>>1] = None if x is None or y is None else self.function(x, y)\n            print(\"L[\", p>>1, \"]: \", str(self.L[p>>1]))\n            p>>=1\n    def query(self, left, right):\n        l, r = left + self.margin, right + self.margin\n        stack = []\n        void = True\n        while l < r:\n            if l&1:\n                if void:\n                    result = self.L[l]\n                    void = False\n                else:\n                    result = self.function(result, self.L[l])\n                l+=1\n            if r&1:\n                r-=1\n                stack.append(self.L[r])\n            l>>=1\n            r>>=1\n        init = stack.pop() if void else result\n        return reduce(self.function, reversed(stack), init)\n\nn = int(input())\npies, index, first_equal = [0]*n, [0]*n, [0]*n\nfor i in range(n):\n    r, h = [int(x) for x in input().split()]\n    pies[i] = r*r*h\nprint(\"pies: \", str(pies))\ns_pies = list(sorted(enumerate(pies), key = lambda p: p[1]))\nfor i in range(n): index[s_pies[i][0]] = i\nfor i in range(1, n):\n    first_equal[s_pies[i][0]] = i if s_pies[i][1] != s_pies[i-1][1] else first_equal[s_pies[i-1][0]]\ntowers = SegmentTree([0]*(n+1), max)\nfor j, pie in enumerate(pies):\n    i, k = index[j], first_equal[j]\n    q = towers.query(0, k+1)\n    towers.modify(i+1, q + pie)\nprint(\"towers.query(0, n+1): \", str(math.pi * towers.query(0, n+1)))\n\n</ans>", "format_properties": {}}
{"idx": 42, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import deque\n\nt=1\nprint(\"t: \", str(t))\nfor _ in range(int(input())):\n    n=int(input())\n    print(\"n: \", str(n))\n    val=set([0,2*10**5+1])\n    print(\"val: \", str(val))\n    seg=[(0,2*10**5+1)]\n    print(\"seg: \", str(seg))\n    for i in range(n):\n        l,r=map(int,input().split())\n        print(\"l: \", str(l), \"r: \", str(r))\n        val.add(l)\n        val.add(r)\n        seg.append((l,r))\n    val=list(val)\n    val.sort()\n    print(\"val: \", str(val))\n    comp={i:e+1 for e,i in enumerate(val)}\n    print(\"comp: \", str(comp))\n    for i in range(n+1):\n        l,r=seg[i]\n        print(\"l: \", str(l), \"r: \", str(r))\n        seg[i]=(comp[l],comp[r])\n    print(\"seg: \", str(seg))\n\n    deg=[0]*(n+1)\n    print(\"deg: \", str(deg))\n    out=[[] for i in range(n+1)]\n    print(\"out: \", str(out))\n    for i in range(n+1):\n        for j in range(i+1,n+1):\n            l,r=seg[i]\n            print(\"l: \", str(l), \"r: \", str(r))\n            L,R=seg[j]\n            print(\"L: \", str(L), \"R: \", str(R))\n            if L<=l and r<=R:\n                out[j].append(i)\n                deg[i]+=1\n            elif l<=L and R<=r:\n                out[i].append(j)\n                deg[j]+=1\n\n    ans=[0]\n    print(\"ans: \", str(ans))\n    deq=deque(ans)\n    print(\"deq: \", str(deq))\n\n    while deq:\n        v=deq.popleft()\n        print(\"v: \", str(v))\n        for nv in out[v]:\n            print(\"nv: \", str(nv))\n            deg[nv]-=1\n            if deg[nv]==0:\n                deq.append(nv)\n                ans.append(nv)\n\n    dp=[0]*(n+1)\n    print(\"dp: \", str(dp))\n\n    def solve(v):\n        query=[[] for i in range(2*n+3)]\n        for nv in out[v]:l,r=seg[nv];query[r].append((l,dp[nv]))\n        subdp=[0]*(2*n+3)\n        for i in range(1,2*n+3):\n            res=subdp[i-1]\n            for l,val in query[i]:test=subdp[l-1]+val;res=max(test,res)\n            subdp[i]=res\n\n        dp[v]=subdp[-1]+1\n\n    for v in ans[::-1]:solve(v)\n\n    print(dp[0]-1)\n</ans>", "format_properties": {}}
{"idx": 40, "result": 0, "generated": "<ans>\n# returns answer to the subproblem with interval range [start, end],\n# but with a total of \"extra\" additional stuff on the end\n# that must be deleted last.\nmemo = {}\ndef f(dat, rewards, start, end, extra):\n    curr = (start, end, extra)\n    print(\"curr: \", str(curr))\n    if curr in memo:\n        return memo[curr]\n\n    if start > end:\n        return 0\n    if start == end:\n        print(\"rewards[dat[start] + extra]: \", str(rewards[dat[start] + extra]))\n        memo[curr] = rewards[dat[start] + extra]\n        return memo[curr]\n\n    # test all possible \"cut points\".\n    # \"cut\" is the earliest index to die in the same deletion as \"end\".\n    out = 0\n    for cut in range(end, start-1, -2):\n        if cut == end:\n            # in this case, we're deleting the last interval right away.\n            print(\"out_curr: \", str(rewards[dat[cut] + extra]))\n            out_curr = rewards[dat[cut] + extra]\n            out_curr += f(dat, rewards, start, cut-1, 0)\n        else:\n            # split into 2 pieces:\n            # 1) slots [start, cut] plus [end + extra]\n            # 2) slots [cut+1, end-1] (with no extra, this needs to get deleted first).\n            print(\"f(dat, rewards, start, cut, extra + dat[end]): \", str(f(dat, rewards, start, cut, extra + dat[end])))\n            print(\"f(dat, rewards, cut+1, end-1, 0): \", str(f(dat, rewards, cut+1, end-1, 0)))\n            out_curr = f(dat, rewards, start, cut, extra + dat[end])\n            out_curr += f(dat, rewards, cut+1, end-1, 0)\n\n        out = max(out, out_curr)\n\n    memo[curr] = out\n    return memo[curr]\n\ndef solve(dat_str, rewards_orig):\n    # break into intervals.\n    dat = []\n    pos = 0\n    while pos < len(dat_str):\n        end = pos\n        while end < len(dat_str) and dat_str[pos] == dat_str[end]:\n            end += 1\n\n        dat.append(end - pos)\n        pos = end\n\n    # compute the highest-value way to remove a run of size k.\n    # (google translated from C++ thinking)\n    rewards = [0, rewards_orig[0]]\n    for k in range(2, len(rewards_orig) + 1):\n        print(\"k: \", str(k))\n        print(\"rewards[k-j] + rewards_orig[j-1]: \", str([rewards[k-j] + rewards_orig[j-1] for j in range(1, k+1)]))\n        rewards.append(\n            max(\n                rewards[k-j] + rewards_orig[j-1]\n                for j in range(1, k+1)\n            )\n        )\n\n    print(\"dat: \", str(dat))\n    print(\"rewards: \", str(rewards))\n\n    return f(dat, rewards, 0, len(dat)-1, 0)\n\n# get the integer\nint_dummy = input()\n# get the string\ndat_str = input().strip()\n# get the array\nrewards_input = input().strip().split()\nrewards_ints = [int(x) for x in rewards_input]\n\nprint((\n    solve(\n        dat_str,\n        rewards_ints,\n    )\n))\n\n# dat_test = \"10101\"\n# rewards_test = [3, 10, 15, 15, 15]\n# print(solve(dat_test, rewards_test))\n\n</ans>", "format_properties": {}}
{"idx": 49, "result": 0, "generated": "<ans>\n\"\"\"\ndef grundy(a,k): #\u77f3 a \u500b\u3001\u6700\u5927 x//k \u307e\u3067\u3068\u308c\u308b\n    #print(a,k)\n    if a < k:\n        return 0\n    q = a//k\n    r = (a-q*k)%(q+1)\n    if r==0:\n        return a//k\n    v = (a-q*k)//(q+1) + 1\n    #print(a,k,q,v)\n    return grundy(a-(q+1)*v,k)\n\"\"\"\n\n\"\"\"\nK = 10\nN = 50\nV = 5\nfor k in range(V,V+1):\n    a = [0]*N\n    for i in range(1,N):\n        s = set()\n        for j in range(1,1+i//k):\n            s.add(a[i-j])\n        for j in range(N):\n            if j not in s:\n                a[i] = j\n                break\n    print(\"a: \", str(a))\n    b = [grundy(i,k) for i in range(N)]\n    print(\"b: \", str(b))\n    assert a==b\n\"\"\"\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\nsys.setrecursionlimit(10**8)\n\nn, = list(map(int,readline().split()))\nprint(\"n: \", str(n))\ng = 0\nfor _ in range(n):\n    a,k = list(map(int,readline().split()))\n    print(\"a: \", str(a), \"k: \", str(k))\n    g ^= grundy(a,k)\nif g:\n    print(\"Takahashi\")\nelse:\n    print(\"Aoki\")\n\n</ans>", "format_properties": {}}
{"idx": 50, "result": 0, "generated": "<ans>\n```\na = input()\nprint(\"a: \", str(a))\nans=[]\nprint(\"ans: \", str(ans))\nt=''\nprint(\"t: \", str(t))\nqoute =0\nprint(\"qoute: \", str(qoute))\nspace =0\nprint(\"space: \", str(space))\nstart =1 if a[0]=='\"' else 0\nprint(\"start: \", str(start))\nfor i in range(len(a)):\n    v= a[i]\n    if start:\n        if t=='':\n            if v=='\"':\n                qoute+=1\n                t = '<'\n            elif v==' ':\n                pass\n            else:\n                space+=1\n                t='<'+v\n        elif qoute>0:\n            if v =='\"':\n                t+='>'\n                qoute=0\n                ans.append(t)\n                t=''\n                start=0\n            else:\n                t+=v\n        else:\n            if v ==' ':\n                if t!='<':\n                    t+='>'\n                    ans.append(t)\n                    t=''\n                    start=0\n            else:\n                t+=v\n    else:\n        if v==' ':\n            start=1\n        elif v=='\"':\n            start=1\n            t='<'\n            qoute=1\n        else:\n            t='<'+v\n            start=1\nif t!='':\n    t+='>'\n    ans.append(t)\nfor v in ans:\n    print(v)\n```\n</ans>", "format_properties": {}}
{"idx": 51, "result": 0, "generated": "<ans>\ndef main1():\n    buf = input()\n    buflist = buf.split()\n    print(\"n: \", str(n))\n    print(\"M: \", str(M))\n    buf = input()\n    buflist = buf.split()\n    print(\"t: \", str(t))\n    student = []\n    minimum = []\n    for i in range(n):\n        count = 0\n        pointer = 0\n        while pointer < i:\n            if count + student[pointer] <= M - t[i]:\n                count += student[pointer]\n                pointer += 1\n            else:\n                break\n        minimum.append(i - pointer)\n        student.append(t[i])\n        student.sort()\n    print(' '.join(list(map(str, minimum))))\n\ndef main2():\n    buf = input()\n    buflist = buf.split()\n    print(\"n: \", str(n))\n    print(\"M: \", str(M))\n    buf = input()\n    buflist = buf.split()\n    print(\"t: \", str(t))\n    bucket = []\n    for i in range(101):\n        bucket.append(0)\n    minimum = []\n    for i in range(n):\n        target = M - t[i]\n        count = 0\n        subtotal = 0\n        for j in range(1, 101):\n            if subtotal + bucket[j] * j > target:\n                count += (target - subtotal) // j\n                break\n            else:\n                count += bucket[j]\n                subtotal += bucket[j] * j\n        minimum.append(i - count)\n        bucket[t[i]] += 1\n    print(' '.join(list(map(str, minimum))))\n\ndef __starting_point():\n    #main1() # for C1\n    main2() # for C2\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 48, "result": 0, "generated": "<ans>\nn, k = list(map(int, input().split()))\nprint(\"n: \", str(n), \"k: \", str(k))\np  = {}\nnp = {}\npair    = []\nused    = {}\nrev_d   = {}\n\ndef push(d, s, v):\n    if s not in d:\n        d[s] = []\n    d[s].append(v)\n\ndef is_pal(s):\n    n = len(s)\n    flg=True\n    for i in range(n//2):\n        if s[i] != s[n-1-i]:\n            flg = False\n            break\n    return flg\n\ndef rev(s):\n    return s[::-1]\n\nfor _ in range(n):\n    s, val = input().split()\n    val    = int(val)\n\n    if is_pal(s):\n        push(p, s, val)\n    else:\n        push(np, s, val)\n\n        if s not in rev_d:\n            rev_d[s] = rev(s)\n\nfor k, v in list(p.items()):\n    p[k] = sorted(v, reverse=True)\n\nfor k, v in list(np.items()):\n    np[k] = sorted(v, reverse=True)\n\nfor s in np:\n    if s not in used and rev_d[s] in np:\n        pair.append([s, rev_d[s]])\n        used[s] = True\n        used[rev_d[s]] = True\n\nmax_remain = 0\nminus = 0\nmax_S = 0\n\nfor v_arr in list(p.values()):\n    n = len(v_arr)\n    for i in range(0, n, 2):\n        if i+1==n:\n            if v_arr[i] > 0:\n                max_remain = max(max_remain, v_arr[i])\n        else:\n            if v_arr[i] + v_arr[i+1] >= 0:\n                max_S += v_arr[i] + v_arr[i+1]\n\n                if v_arr[i+1] < 0:\n                    minus = min(minus, v_arr[i+1])\n            else:\n                if v_arr[i] > 0:\n                    max_remain = max(max_remain, v_arr[i])\n\nfor [u, v] in pair:\n    n = min(len(np[u]), len(np[v]))\n\n    for x, y in  zip(np[u][:n], np[v][:n]):\n        if x+y > 0:\n            max_S += x+y\n\nprint(max(max_S+max_remain, max_S-minus))\n</ans>", "format_properties": {}}
{"idx": 41, "result": 0, "generated": "<ans>\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nclass RAQ_RMQ():\n    def __init__(self, n, inf=2**31-1):\n        self.n0 = 1<<(n-1).bit_length()\n        print(\"self.n0: \", str(self.n0))\n        self.INF = inf\n        print(\"self.INF: \", str(self.INF))\n        self.data = [0]*(2*self.n0)\n        print(\"self.data: \", str(self.data))\n        self.lazy = [0]*(2*self.n0)\n        print(\"self.lazy: \", str(self.lazy))\n\n    def getIndex(self, l, r):\n        l += self.n0; r += self.n0\n        lm = (l // (l & -l)) >> 1\n        rm = (r // (r & -r)) >> 1\n        while l < r:\n            if r <= rm:\n                yield r\n            if l <= lm:\n                yield l\n            l >>= 1; r >>= 1\n        while l:\n            yield l\n            l >>= 1\n\n    def propagates(self, *ids):\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if not v:\n                continue\n            self.lazy[2*i-1] += v; self.lazy[2*i] += v\n            self.data[2*i-1] += v; self.data[2*i] += v\n            self.lazy[i-1] = 0\n\n    def update(self, l, r, x):\n        *ids, = self.getIndex(l, r)\n\n        l += self.n0; r += self.n0\n        while l < r:\n            if r & 1:\n                r -= 1\n                self.lazy[r-1] += x; self.data[r-1] += x\n            if l & 1:\n                self.lazy[l-1] += x; self.data[l-1] += x\n                l += 1\n            l >>= 1; r >>= 1\n        for i in ids:\n            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]\n\n    def query(self, l, r):\n        self.propagates(*self.getIndex(l, r))\n        l += self.n0; r += self.n0\n\n        s = self.INF\n        while l < r:\n            if r & 1:\n                r -= 1\n                s = min(s, self.data[r-1])\n            if l & 1:\n                s = min(s, self.data[l-1])\n                l += 1\n            l >>= 1; r >>= 1\n        return s\n\nn,m,k = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\nl = [0]*(n+1)\nprint(\"l: \", str(l))\nnow = k\npoint = [0]*n\nprint(\"point: \", str(point))\nfor i in range(n):\n    a,b,c = map(int, input().split())\n    point[i] = c\n    now = now-a\n    l[i] = now\n    now += b+a\nl[n] = now\n\nRMQ = RAQ_RMQ(n+1)\nfor i in range(n+1):\n    RMQ.update(i,i+1,l[i])\n\nportal = list(range(n))\nprint(\"portal: \", str(portal))\nfor i in range(m):\n    u,v = map(int, input().split())\n    u,v = u-1, v-1\n    if portal[v]<u:\n        portal[v] = u\n\nif RMQ.query(0, n+1) < 0:\n    print(-1)\n    return\n\nheap = [(-point[i], -portal[i]) for i in range(n)]\nprint(\"heap: \", str(heap))\nfrom heapq import heapify, heappop\nheapify(heap)\n\nans = 0\nwhile heap:\n    p,i = heappop(heap)\n    p,i = -p,-i\n    if RMQ.query(i+1, n+1)>0:\n        ans += p\n        RMQ.update(i+1, n+1, -1)\n\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 55, "result": 0, "generated": "<ans>\nH, W = map(int, input().split())\nprint(\"H: \", str(H), \"W: \", str(W))\nList = [list(input()) for i in range(H)]\nprint(\"List: \", str(List))\nres = \"Yes\"\nprint(\"res: \", str(res))\nflag = True\nprint(\"flag: \", str(flag))\n\ndef checkAround(List, i, j):\n  # ... (rest of the function remains the same)\n\nfor k in range(H):\n  for l in range(W):\n    if List[k][l] == \".\":\n      pass\n    else:\n      flag = checkAround(List, k, l)\n      if not flag:\n        res = \"No\"\n        print(\"res: \", str(res))\n        break\n  if not flag:\n    break\nprint(\"res: \", str(res))\n</ans>", "format_properties": {}}
{"idx": 47, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\nORDA = 97\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    print(\"n: \", str(n))\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    print(\"prime: \", str(prime))\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    print(\"r: \", str(r))\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    print(\"r: \", str(r))\n    return r\ndef divs(n, start=2):\n    print(\"n: \", str(n))\n    print(\"start: \", str(start))\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    print(\"r: \", str(r))\n    return r\ndef divn(n, primes):\n    print(\"n: \", str(n))\n    print(\"primes: \", str(primes))\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n    print(\"divs_number: \", str(divs_number))\n    return divs_number\ndef prime(n):\n    print(\"n: \", str(n))\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    print(\"sqr: \", str(sqr))\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    print(\"d: \", str(d))\n    return True\ndef convn(number, base):\n    print(\"number: \", str(number))\n    print(\"base: \", str(base))\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    print(\"newnumber: \", str(newnumber))\n    return newnumber\ndef cdiv(n, k): return n // k + (n % k != 0)\n\nfor _ in range(ii()):\n    n = ii()\n    a = li()\n    if n == 1 and a[0] & 1:\n        print(-1)\n    else:\n        for i in range(n):\n            if a[i] % 2 == 0:\n                print(1)\n                print(i + 1)\n                break\n        else:\n            print(2)\n            print(1, 2)\n\n</ans>", "format_properties": {}}
{"idx": 53, "result": 0, "generated": "<ans>\n```python\n#template\nimport sys\nsys.setrecursionlimit(10**9)\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nread_int = lambda: int(readline())\nread_ints = lambda: map(int,readline().split())\nread_ints_list = lambda: list(map(int,readline().split()))\nread_ints_grid = lambda h:list(list(map(int,readline().split())) for _ in range(h))\nread_strs_list = lambda: list(map(str,readline().rstrip().split()))\nread_strs_grid = lambda h:list(list(map(str,readline().rstrip().split())) for _ in range(h))\n\ndef read_allints_grid(w):\n    grid = map(int,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\ndef read_allstrs_grid(w):\n    grid = map(str,read().split())\n    grid = list(map(list,zip(*(grid for _ in range(w)))))\n    return grid\n\n#import\n# from copy import deepcopy\n# from decimal import Decimal\n# from math import ceil,floor\n# from collections import deque,Counter\n# from heapq import heapify,heappop,heappush\n# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement\n# from bisect import bisect_left,bisect_right\n\n#solution\ndef sol():\n    return None\n\ndef GCD(a:int,b:int)->int:\n    print(\"a: \", str(a), \"b: \", str(b))\n    '''\n    \u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\u306b\u3088\u308b\u6700\u5927\u516c\u7d04\u6570/O(log min(a,b))\n    '''\n    if b==0:\n        return a\n    else:\n        return GCD(b,a%b)\n\ndef GCD_multi(vec:list)->int:\n    print(\"vec: \", str(vec))\n    '''\n    \u6570\u5217\u306e\u8981\u7d20\u306e\u6700\u5927\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b/O(N log(a'))\n    '''\n    l = vec[0]\n    for i in range(len(vec)-1):\n        l = GCD(l,vec[i+1])\n    return l\n\ndef main():\n    #input data\n    print(\"n: \", str(n))\n    n = read_int()\n    print(\"A: \", str(A))\n    A = read_ints_list()\n\n    #solve\n    print(GCD_multi(A))\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 52, "result": 0, "generated": "<ans>\nimport itertools\nfrom collections import deque,defaultdict,Counter\nfrom itertools import accumulate\nimport bisect\nfrom heapq import heappop,heappush,heapify\nimport math\nfrom copy import deepcopy\nimport queue\n#import numpy as np\n# sympy as syp(\u7d20\u56e0\u6570\u5206\u89e3\u3068\u304b)\nMod = 1000000007\nprint(\"Mod: \", str(Mod))\nfact = [1, 1]\nprint(\"fact: \", str(fact))\nfactinv = [1, 1]\nprint(\"factinv: \", str(factinv))\ninv = [0, 1]\nprint(\"inv: \", str(inv))\nfor i in range(2, 10**5 + 1):\n    fact.append((fact[-1] * i) % Mod)\n    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)\n    factinv.append((factinv[-1] * inv[-1]) % Mod)\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n - r] % p\n\ndef sieve_of_eratosthenes(n):\n    if not isinstance(n,int):\n        raise TypeError(\"n is not int\")\n    if n<2:\n        raise ValueError(\"n is not effective\")\n    prime = [1]*(n+1)\n    for i in range(2,int(math.sqrt(n))+1):\n        if prime[i] == 1:\n            for j in range(2*i,n+1):\n                if j%i == 0:\n                    prime[j] = 0\n    res = []\n    for i in range(2,n+1):\n        if prime[i] == 1:\n            res.append(i)\n    return res\n\nclass UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n+1)]\n        self.rank = [0 for i in range(n+1)]\n        print(\"parent: \", str(self.parent))\n        print(\"rank: \", str(self.rank))\n\n    def findroot(self,x):\n        if x == self.parent[x]:\n            return x\n        else:\n            y = self.parent[x]\n            y = self.findroot(self.parent[x])\n            return y\n\n    def union(self,x,y):\n        px = self.findroot(x)\n        py = self.findroot(y)\n        if px < py:\n            self.parent[y] = px\n        else:\n            self.parent[px] = py\n\n    def same_group_or_no(self,x,y):\n        return self.findroot(x) == self.findroot(y)\n\ndef pow_k(x, n):\n    if n == 0:\n        return 1\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K *= x\n        x *= x\n        n //= 2\n    return K * x\n\ndef main():  #startline-------------------------------------------\n    n = int(input())\n    print(\"n: \", str(n))\n    a = list(map(int, input().split()))\n    print(\"a: \", str(a))\n    d = defaultdict(int)\n    print(\"d: \", str(d))\n    ans = 0\n    for i in range(n):\n        l = i - a[i]\n        ans += d[l]\n        d[a[i] + i] += 1\n    print(\"ans: \", str(ans))\n\ndef __starting_point():\n    main() #endline===============================================\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 59, "result": 0, "generated": "<ans>\nimport sys\n\nMOD = (int)(1e9+7)\n\ndef add(a, b):\n\ta += b\n\tif a >= MOD: a -= MOD\n\treturn a\n\ndef mul(a, b):\n\treturn (a * b) % MOD\n\nclass fenwickTree:\n\tdef __init__(self, max_val):\n\t\tself.max_val = max_val + 5\n\t\tself.tree = [0] * self.max_val\n\t\tprint(\"max_val: \", str(self.max_val))\n\t\tprint(\"tree: \", str(self.tree))\n\n\tdef update(self, idx, value):\n\t\tidx += 1\n\t\twhile idx < self.max_val:\n\t\t\tself.tree[idx] = add(self.tree[idx], value)\n\t\t\tidx += (idx & (-idx))\n\n\tdef read(self, idx):\n\t\tidx += 1\n\t\tres = 0\n\t\twhile idx > 0:\n\t\t\tres = add(res, self.tree[idx])\n\t\t\tidx -= (idx & (-idx))\n\t\treturn res\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn = inp[0]\nprint(\"n: \", str(n))\na = []\nfor i in range(1, n + 1):\n\ta.append(inp[i])\n\tprint(\"a: \", str(a))\n\nsorted_array = sorted(a)\nprint(\"sorted_array: \", str(sorted_array))\ndict = {}\nfor i in range(n):\n\tdict[sorted_array[i]] = i\n\tprint(\"dict: \", str(dict))\n\nfactor = [0] * n\nprint(\"factor: \", str(factor))\nfor i in range(0, n):\n\tfactor[i] = mul(i + 1, n - i)\n\tprint(\"factor: \", str(factor))\n\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n\tleft_tree.update(element_idx, i + 1)\n\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n\tright_tree.update(element_idx, n - i)\n\nans = 0\nfor i in range(n):\n\tans = add(ans, mul(a[i], factor[i]))\nprint(\"ans: \", str(ans))\n\n</ans>", "format_properties": {}}
{"idx": 58, "result": 0, "generated": "<ans>\nimport sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nprint(\"sys: \", str(sys))\n\nclass UnionFind:\n\n    def __init__(self, n: int):\n        self._n = n\n        self._parents = [i for i in range(n)]\n        self._size = [1 for _ in range(n)]\n        print(\"_parents: \", str(self._parents))\n        print(\"_size: \", str(self._size))\n\n    def unite(self, x: int, y: int) -> None:\n        px = self.find(x)\n        py = self.find(y)\n\n        # \u4e00\u81f4\u3057\u3066\u3044\u306a\u3044\u3068\u304d\u306f\u30ea\u30f3\u30af\u3092\u3064\u3051\u308b\n        if px != py:\n            self._link(px, py)\n\n    def _link(self, x: int, y: int):\n        if self._size[x] < self._size[y]:\n            self._parents[x] = y\n            self._size[y] += self._size[x]\n        else:\n            self._parents[y] = x\n            self._size[x] += self._size[y]\n\n    def same(self, x: int, y: int) -> bool:\n        px = self.find(x)\n        py = self.find(y)\n        return px == py\n\n    def find(self, x: int) -> int:\n        if self._parents[x] == x:\n            return x\n\n        self._parents[x] = self.find(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x: int):\n        return self._size[self.find(self._parents[x])]\n\nN, K, L = map(int, input().split())\nprint(\"N: \", str(N))\nprint(\"K: \", str(K))\nprint(\"L: \", str(L))\n\nroad = UnionFind(N + 1)\nrail = UnionFind(N + 1)\nshare = UnionFind(N + 1)\n\nroads = [list(map(int, input().split())) for _ in range(K)]\nprint(\"roads: \", str(roads))\n\nrails = [list(map(int, input().split())) for _ in range(L)]\nprint(\"rails: \", str(rails))\n\nm = {}\n\nfor i in range(1, N + 1):\n    cnt = m.get((road.find(i), rail.find(i)), 0)\n    m[(road.find(i), rail.find(i))] = cnt + 1\n\nans = [0] * N\nfor i in range(N):\n    ans[i] = m[(road.find(i + 1), rail.find(i + 1))]\n\nprint(\"ans: \", str(ans))\nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 46, "result": 0, "generated": "<ans>\n\"\"\"Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I\"\"\"\n# from fractions import Fraction\n\n# def convert_to_fractions(poly):\n#     \"\"\"convert polygon vertex to fractional type\"\"\"\n#     poly_frac = []\n#     for x, y, z in poly:\n#         vertex = (Fraction(x),\n#                   Fraction(y),\n#                   Fraction(z))\n#         poly_frac.append(vertex)\n#     return poly_frac\n\ndef convert_to_float(poly):\n    \"\"\"convert polygon vertex to float type\"\"\"\n    poly_float = []\n    for x, y, z in poly:\n        vertex = (float(x),\n                  float(y),\n                  float(z))\n        poly_float.append(vertex)\n    return poly_float\n\ndef cross_product(a, b):\n    \"\"\"3-vector product\"\"\"\n    return (a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0])\n\ndef dot_product(a, b):\n    \"\"\"scalar product of 3-vectors\"\"\"\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\ndef vect_diff(a, b):\n    \"\"\"vector difference\"\"\"\n    return a[0] - b[0], a[1] - b[1], a[2] - b[2]\n\ndef poly_normal(poly):\n    \"\"\"return normal vector for first three vertex\"\"\"\n    assert len(poly) >= 3\n    x, y, z = poly[:3]\n    u = vect_diff(y, x)\n    v = vect_diff(z, y)\n    return cross_product(u, v)\n\ndef intersect_list(poly, plain_norm, plain_point, proj_dir):\n    \"\"\"list of intersection points\n\n    find points where the edges enter or leave upper half-space over the plain\n    :return list of points projection on proj_dir\n    \"\"\"\n    # vertex projection\n    u = [dot_product(vert, proj_dir) for vert in poly]\n    print(\"u: \", str(u))\n\n    # plain anchor\n    vr = dot_product(plain_point, plain_norm)\n\n    # polygon vertex\n    v = [dot_product(vert, plain_norm) for vert in poly]\n    print(\"v: \", str(v))\n\n    u_list = []\n    for i in range(len(poly)):\n        if (v[i-1] > vr) != (v[i] > vr):\n            ur = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])\n            u_list.append(ur)\n\n    return u_list\n\ndef points_to_str(a_points, b_points):\n    \"\"\"string representing the order of points 'a' and 'b'\"\"\"\n    a_pairs = [('a', val) for val in a_points]\n    b_pairs = [('b', val) for val in b_points]\n    pairs = sorted(a_pairs + b_pairs, key=lambda pair: pair[1])\n    letters = [ch for ch, _ in pairs]\n    return ''.join(letters)\n\ndef recognize_str(s):\n    \"\"\"return True if string s belong to the grammar\n\n    The context-free grammar is given\n    S -> SS\n    S -> a S a\n    S -> b S b\n    S -> e\n\n    The recognising automaton is implemented\n    \"\"\"\n    toggle = {'a':'b', 'b':'a'}\n    cross_num = 0\n    top = None\n    for ch in s:\n        if not cross_num:\n            cross_num = 1\n            top = ch\n            continue\n\n        if ch == top:\n            cross_num -= 1\n        else:\n            cross_num += 1\n\n        if cross_num:\n            top = toggle[top]\n        else:\n            top = None\n    return not cross_num\n\ndef is_well_connected(a, b):\n    \"\"\"Two planar polygons are bind together in 3D\n\n    Arguments:\n        a_poly,\n        b_poly -- lists of vertex triples\n    \"\"\"\n    a = convert_to_float(a)\n    print(\"a: \", str(a))\n    b = convert_to_float(b)\n    print(\"b: \", str(b))\n\n    a_norm = poly_normal(a)\n    print(\"a_norm: \", str(a_norm))\n    b_norm = poly_normal(b)\n    print(\"b_norm: \", str(b_norm))\n\n    common_dir = cross_product(a_norm, b_norm)\n    print(\"common_dir: \", str(common_dir))\n    if not any(common_dir):\n        return False\n\n    a_list = intersect_list(a, b_norm, b[0], common_dir)\n    print(\"a_list: \", str(a_list))\n    b_list = intersect_list(b, a_norm, a[0], common_dir)\n    print(\"b_list: \", str(b_list))\n\n    char_str = points_to_str(a_list, b_list)\n    return not recognize_str(char_str)\n\ndef run_from_console():\n    a_len, = [int(num) for num in input().split()]\n\n    a = []\n    for _ in range(a_len):\n        vertex = tuple(int(num) for num in input().split())\n        a.append(vertex)\n\n    b_len, = [int(num) for num in input().split()]\n\n    b = []\n    for _ in range(b_len):\n        vertex = tuple(int(num) for num in input().split())\n        b.append(vertex)\n\n    if is_well_connected(a, b):\n        print('YES')\n    else:\n        print('NO')\n\ndef __starting_point():\n    run_from_console()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 54, "result": 0, "generated": "<ans>\n__author__ = \"Ryabchun Vladimir\"\n\nclass Stack:\n    \"\"\"\n    This is a stack class. There is 5 Procedures we can do with stack:\n    1. Push - we add one element at the end of the stack\n    2. Pop - we remove last element from the stack and return it\n    3. Last - We return last element but don't remove it\n    4. len() - returns the length of stack(we don't use len() because it's too\n    slow).\n    5. Clear - remove all elements from stack\n    \"\"\"\n    def __init__(self, element=None):\n        \"\"\"\n        self.length - length of the stack. When we append an element we increase it(length) by 1\n        __stack - this is our stack. Because we can't get any elements from the stack except the last one\n        we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,\n        but we mustn't do it).\n        :param element: Can be any type\n        \"\"\"\n        self.length = 0\n        print(\"self.length: \", str(self.length))\n        if element is None:\n            self.__stack = []\n            print(\"self.__stack: \", str(self.__stack))\n        else:\n            self.__stack = []\n            print(\"self.__stack: \", str(self.__stack))\n            for el in element:\n                self.__stack.append(el)\n                print(\"self.__stack: \", str(self.__stack))\n                self.length += 1\n            print(\"self.length: \", str(self.length))\n\n    def push(self, element):\n        \"\"\"\n        This function adds an element at the end of the stack.\n        When we append an element we increase self.length by 1.\n        :param element: Can be any type\n        :return: NoneType\n        \"\"\"\n        self.__stack.append(element)\n        print(\"self.__stack: \", str(self.__stack))\n        self.length += 1\n        print(\"self.length: \", str(self.length))\n        return None\n\n    def pop(self):\n        \"\"\"\n        This function removes an element from the end of the stack and\n        returns it's value.\n        When we append an element we decrease self.length by 1.\n        :return: Last element from the stack\n        \"\"\"\n        if self.length == 0:\n            raise IndexError(\"Stack is empty\")\n        else:\n            self.length -= 1\n            print(\"self.length: \", str(self.length))\n            return self.__stack.pop()\n            print(\"self.__stack: \", str(self.__stack))\n\n    def last(self):\n        \"\"\"\n        This function just returns an element from the end of the stack\n        but it doesn't remove it.\n        :return: Last element from the stack\n        \"\"\"\n        if self.length == 0:\n            raise IndexError(\"Stack is empty\")\n        else:\n            return self.__stack[-1]\n            print(\"self.__stack: \", str(self.__stack))\n\n    def __len__(self):\n        \"\"\"\n        This function returns the length of the stack.\n        :return: self.length(int)\n        \"\"\"\n        return self.length\n        print(\"self.length: \", str(self.length))\n\n    def clear(self):\n        \"\"\"\n        Clears the stack.\n        :return: NoneType\n        \"\"\"\n        self.__stack = []\n        print(\"self.__stack: \", str(self.__stack))\n        return None\n\nn = int(input())\nsnekovik = Stack()\nwrong_snaks = set()\nthe_biggest_snek = n\nsneks = list(map(int, input().split()))\nfor i in sneks:\n    printing = []\n    if i == the_biggest_snek:\n        snekovik.push(i)\n        printing.append(i)\n        the_biggest_snek -= 1\n        while the_biggest_snek in wrong_snaks:\n            snekovik.push(the_biggest_snek)\n            wrong_snaks.remove(the_biggest_snek)\n            printing.append(the_biggest_snek)\n            the_biggest_snek -= 1\n    else:\n        wrong_snaks.add(i)\n    print(*printing)\n\n</ans>", "format_properties": {}}
{"idx": 60, "result": 0, "generated": "<ans>\nimport sys\ninput = lambda: sys.stdin.readline().strip()\n\ndef f(A, r, c, l):\n  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]\n  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]\n\n  print(\"q: \", str(q), \"w: \", str(w), \"e: \", str(e), \"x: \", str(x), \"y: \", str(y), \"z: \", str(z), \"l: \", str(l))\n  if x != y and y != z and e >= l and  w == q == l:\n    return (l, z, y, x)\n  else:\n    return 0\n\nr, c = list(map(int, input().split()))\nprint(\"r: \", str(r), \"c: \", str(c))\ns = \"\"\nfor i in range(r):\n  s += input()\n\narr = []\nprint(\"arr: \", str(arr))\nnarr = [[0]*r for i in range(c)]\nprint(\"narr: \", str(narr))\nfor i in range(c):\n  arr.append(s[i:r*c:c])\n\nr, c = c, r\n\nlength_str = [ [0] * c for i in range(r) ]\nprint(\"length_str: \", str(length_str))\nfor i in range(r):\n  for j in range(c):\n    if j == 0:\n      length_str[i][j] = (1, arr[i][j])\n    elif arr[i][j-1] == arr[i][j]:\n      length_str[i][j] = (length_str[i][j-1][0] + 1, arr[i][j])\n    else:\n      length_str[i][j] = (1, arr[i][j])\n\nfor i in range(r):\n  for j in range(c):\n    l, _ = length_str[i][j]\n    print(\"l: \", str(l))\n    if j - l*3 + 1 < 0:\n      continue\n    else:\n      narr[i][j] = f(length_str, i, j, l)\n\ndp =[ [0] * c for i in range(r) ]\nprint(\"dp: \", str(dp))\n\nfor j in range(c):\n  cnt = 1\n  for i in range(r):\n    if narr[i][j] == 0:\n      cnt = 1\n      continue\n    else:\n      if i == 0:\n        dp[i][j] = 1\n\n      elif narr[i][j] == narr[i-1][j]:\n        cnt += 1\n        dp[i][j] = cnt\n        dp[i-1][j] = 0\n\n      else:\n        cnt = 1\n        dp[i][j] = 1\n\nans = 0\nfor i in dp:\n  for j in i:\n    ans += ((j)*(j+1))//2\n\nprint(ans)\n\n</ans>", "format_properties": {}}
{"idx": 56, "result": 0, "generated": "<ans>\nimport sys\nfrom collections import defaultdict\n\nclass MaxFlow(object):\n    def __init__(self):\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\n        print(\"self.edges: \", str(self.edges))\n\n    def add_edge(self, u, v, capacity=float('inf')):\n        self.edges[u][v] = capacity\n        print(\"self.edges[u][v]: \", str(self.edges[u][v]))\n\n    def bfs(self, s, t):\n        open_q = [s]\n        print(\"open_q: \", str(open_q))\n\n        visited = set()\n        print(\"visited: \", str(visited))\n        parent = dict()\n        print(\"parent: \", str(parent))\n        while open_q:\n            close_q = []\n            print(\"close_q: \", str(close_q))\n            for node in open_q:\n                for v, capacity in list(self.edges[node].items()):\n                    if v not in visited and capacity > 0:\n                        close_q.append(v)\n                        parent[v] = node\n                        visited.add(v)\n                        if v == t:\n                            result = []\n                            n2 = v\n                            n1 = node\n                            while n1 != s:\n                                result.append((n1, n2))\n                                n2 = n1\n                                n1 = parent[n1]\n                            result.append((n1, n2))\n                            return result\n\n            open_q = close_q\n\n        return None\n\n    def solve(self, s, t):\n        flow = 0\n        print(\"flow: \", str(flow))\n        route = self.bfs(s, t)\n        print(\"route: \", str(route))\n        while route is not None:\n            new_flow = float('inf')\n            print(\"new_flow: \", str(new_flow))\n            for _, (n1, n2) in enumerate(route):\n                new_flow = min(new_flow, self.edges[n1][n2])\n            for _, (n1, n2) in enumerate(route):\n                self.edges[n1][n2] -= new_flow\n                self.edges[n2][n1] += new_flow\n            flow += new_flow\n\n            route = self.bfs(s, t)\n\n        return flow\n\n    def __str__(self):\n        result = \"{ \"\n        for k, v in list(self.edges.items()):\n            result += str(k) + \":\" + str(dict(v)) + \", \"\n        result += \"}\"\n        return result\n\ndef main():\n    (n, m) = tuple([int(x) for x in input().split()])\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    r = []\n    xs = set()\n    ys = set()\n    for i in range(m):\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\n        r.append((x1, y1, x2, y2))\n        xs.add(x1)\n        xs.add(x2 + 1)\n        ys.add(y1)\n        ys.add(y2 + 1)\n\n    xx = sorted(xs)\n    print(\"xx: \", str(xx))\n    yy = sorted(ys)\n    print(\"yy: \", str(yy))\n    xsize = len(xs)\n    print(\"xsize: \", str(xsize))\n    ysize = len(ys)\n    print(\"ysize: \", str(ysize))\n    grid = []\n    for i in range(ysize):\n        grid.append([False] * xsize)\n    print(\"grid: \", str(grid))\n\n    for rect in r:\n        x1 = rect[0]\n        y1 = rect[1]\n        x2 = rect[2]\n        y2 = rect[3]\n        for i, y in enumerate(yy):\n            for j, x in enumerate(xx):\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\n                    grid[i][j] = True\n\n    f = MaxFlow()\n    for i in range(len(yy)):\n        for j in range(len(xx)):\n            if grid[i][j]:\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\n    for i in range(len(yy) - 1):\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\n    for i in range(len(xx) - 1):\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\n\n    # print(xx)\n    # print(yy)\n    # print(f)\n    print(f.solve(0, len(xx) + len(yy) + 1))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 62, "result": 0, "generated": "<ans>\n```\ndef _3():\n    from collections import defaultdict\n\n    print(\"defaultdict: \", str(defaultdict))\n\n    def can_pair(s1, s2):\n        l = []\n        for c1, c2 in zip(s1, s2):\n            c = sorted([c1, c2])\n            if c in l:\n                l.remove(c)\n            else:\n                l.append(c)\n\n        if len(s1) % 2 == 0:\n            return len(l) == 0\n        else:\n            return len(l) == 1 and l[0][0] == l[0][1]\n\n    print(\"can_pair: \", str(can_pair))\n\n    def pair_graph(s1, s2):\n        N = len(s1)\n        G = np.zeros([N, N])\n        for i in range(N):\n            for j in range(i+1, N):\n                if s1[i] == s2[j] and s1[j] == s2[i]:\n                    G[i, j] = 1\n                    G[j, i] = 1\n        return G\n\n    print(\"pair_graph: \", str(pair_graph))\n\n    import numpy as np\n    H, W = list(map(int, input().split(' ')))\n    print(\"H: \", str(H), \"W: \", str(W))\n\n    S = []\n    d = defaultdict(list)\n\n    for h in range(H):\n        s = input()\n        S.append(s)\n        d[''.join(sorted(S))].append(h)\n\n    already_paired = np.zeros(H)\n    print(\"already_paired: \", str(already_paired))\n\n    Gs = []\n\n    for i in range(H):\n        if already_paired[i]:\n            continue\n\n        for j in range(i+1, H):\n            if already_paired[j]:\n                continue\n\n            if can_pair(S[i], S[j]):\n                already_paired[i] = 1\n                already_paired[j] = 1\n                G = pair_graph(S[i], S[j])\n                Gs.append(G)\n                break\n\n    if already_paired.sum() < H - 1:\n        print('NO')\n        return\n\n    elif already_paired.sum() == H - 1:\n        for i in range(H):\n            if already_paired[i] == 0:\n                G = pair_graph(S[i], S[i])\n                Gs.append(G)\n                break\n\n    G = np.array(Gs).sum(axis=0) // len(Gs)\n    print(\"G: \", str(G))\n\n    def is_perfect_matching(G):\n        N = len(G)\n        if N == 1:\n            return True\n\n        for i in range(N):\n            for j in range(i+1, N):\n                if G[i, j] == 1:\n                    l = list(range(N))\n                    l.remove(i)\n                    l.remove(j)\n                    if len(l) == 0:\n                        return True\n                    if is_perfect_matching(G[l][:, l]):\n                        return True\n        return False\n\n    print(\"is_perfect_matching: \", str(is_perfect_matching))\n\n    if is_perfect_matching(G):\n        print('YES')\n    else:\n        print('NO')\n\ndef __starting_point():\n    _3()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 57, "result": 0, "generated": "<ans>\n```\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h\nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\nimport math, string\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\ndef getMat(n):\n    return [getInts() for _ in range(n)]\n\nMOD = 10**9+7\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\ndef solve():\n    N, K = getInts()\n    print(\"N: \", str(N), \"K: \", str(K))\n    graph = dd(set)\n    for i in range(N-1):\n        A, B = getInts()\n        print(\"A: \", str(A), \"B: \", str(B))\n        graph[A].add(B)\n        graph[B].add(A)\n    dp_count = [[0 for j in range(5)] for i in range(N+1)]\n    print(\"dp_count: \", str(dp_count))\n    dp_total = [0 for j in range(N+1)]\n    print(\"dp_total: \", str(dp_total))\n    nonlocal ans\n    ans = 0\n    @bootstrap\n    def dfs(node,parent,depth):\n        nonlocal ans\n        dp_count[node][depth % K] = 1\n        dp_total[node] = 1\n        for neigh in graph[node]:\n            if neigh != parent:\n                yield dfs(neigh,node,depth+1)\n                for i in range(K):\n                    for j in range(K):\n                        diff = (i+j-2*depth)%K\n                        req = (-diff)%K\n                        ans += req * dp_count[node][i] * dp_count[neigh][j]\n                for i in range(K):\n                    dp_count[node][i] += dp_count[neigh][i]\n                dp_total[node] += dp_total[neigh]\n        ans += dp_total[node] * (N - dp_total[node])\n        yield\n    dfs(1,-1,0)\n    return ans//K\n\nprint(solve())\n</ans>", "format_properties": {}}
{"idx": 61, "result": 0, "generated": "<ans>\nfrom random import random\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10 ** 6)\n\nclass TreapNode:\n    _value = None\n    _priority = None\n    _count = None\n    _left = None\n    _right = None\n\n    def __init__(self, value):\n        self._value = value\n        self._priority = random()\n        self._count = 1\n        print(\"_value: \", str(self._value))\n        print(\"_priority: \", str(self._priority))\n        print(\"_count: \", str(self._count))\n\ndef treap_rotate_right(n):\n    l = n._left\n    n._left = l._right\n    l._right = n\n    return l\n\ndef treap_rotate_left(n):\n    r = n._right\n    n._right = r._left\n    r._left = n\n    return r\n\ndef treap_insert(n, v):\n    if n is None:\n        return TreapNode(v)\n    if n._value == v:\n        n._count += 1\n        print(\"n._count: \", str(n._count))\n        return n\n    if n._value > v:\n        n._left = treap_insert(n._left, v)\n        if n._priority > n._left._priority:\n            n = treap_rotate_right(n)\n    else:\n        n._right = treap_insert(n._right, v)\n        if n._priority > n._right._priority:\n            n = treap_rotate_left(n)\n    return n\n\ndef treap_delete(n, v):\n    if n is None:\n        raise Exception('no nodes')\n    if n._value > v:\n        n._left = treap_delete(n._left, v)\n        return n\n    if n._value < v:\n        n._right = treap_delete(n._right, v)\n        return n\n\n    # n._value == v\n    if n._count > 1:\n        n._count -= 1\n        print(\"n._count: \", str(n._count))\n        return n\n\n    if n._left is None and n._right is None:\n        return None\n\n    if n._left is None:\n        n = treap_rotate_left(n)\n    elif n._right is None:\n        n = treap_rotate_right(n)\n    else:\n        # n._left is not None and n._right is not None\n        if n._left._priority < n._right._priority:\n            n = treap_rotate_right(n)\n        else:\n            n = treap_rotate_left(n)\n    return treap_delete(n, v)\n\ndef treap_size(n):\n    if n is None:\n        return 0\n    return n._count + treap_size(n._left) + treap_size(n._right)\n\ndef treap_str(n):\n    if n is None:\n        return \"\"\n    result = []\n    if n._left is not None:\n        result.append(treap_str(n._left))\n    result.append(\"%d:%d\" % (n._value, n._count))\n    if n._right is not None:\n        result.append(treap_str(n._right))\n    return ' '.join(result)\n\ndef treap_search(n, v):\n    # v \u672a\u6e80\u3067\u6700\u5927\u306e\u30ce\u30fc\u30c9\u3092\u691c\u7d22\u3059\u308b. v \u672a\u6e80\u306e\u30ce\u30fc\u30c9\u304c\u306a\u3051\u308c\u3070 None \u3092\u8fd4\u3059\n    if n is None:\n        return None\n    if n._value >= v:\n        if n._left is None:\n            return None\n        return treap_search(n._left, v)\n    # n._value < v\n    if n._right is None:\n        return n\n    r = treap_search(n._right, v)\n    if r is None:\n        return n\n    return r\n\nclass Treap:\n    _root = None\n    _size = 0\n\n    def insert(self, v):\n        self._root = treap_insert(self._root, v)\n        self._size += 1\n        print(\"_size: \", str(self._size))\n\n    def delete(self, v):\n        self._root = treap_delete(self._root, v)\n        self._size -= 1\n        print(\"_size: \", str(self._size))\n\n    def __len__(self):\n        return self._size\n\n    def __str__(self):\n        return treap_str(self._root)\n\n    def search(self, v):\n        return treap_search(self._root, v)\n\nN = int(input())\nA = [int(input()) for _ in range(N)]\n\nt = Treap()\nfor a in A:\n    n = t.search(a)\n    if n is not None:\n        t.delete(n._value)\n    t.insert(a)\nprint((len(t)))\n\n</ans>", "format_properties": {}}
{"idx": 63, "result": 0, "generated": "<ans>\nimport sys\nreadline = sys.stdin.readline\n\ndef accumulate2d(X):\n    N = len(X)\n    M = len(X[0])\n\n    for i in range(0, N):\n        for j in range(1, M):\n            X[i][j] += X[i][j-1]\n    print(\"X after first loop: \", str(X))\n\n    for j in range(0, M):\n        for i in range(1, N):\n            X[i][j] += X[i-1][j]\n    print(\"X after second loop: \", str(X))\n\n    return X\n\nN, M, Q = map(int, readline().split())\nprint(\"N: \", str(N), \"M: \", str(M), \"Q: \", str(Q))\n\ntable = [None]*100\ntable[ord('R')] = 0\ntable[ord('G')] = 1\ntable[ord('B')] = 2\ntable[ord('Y')] = 3\nprint(\"table: \", str(table))\n\nINF = 10**3\nD = [[table[ord(s)] for s in readline().strip()] for _ in range(N)]\nprint(\"D: \", str(D))\n\nG = [[0]*M for _ in range(N)]\nprint(\"G: \", str(G))\n\nBS = 25\ncandi = []\ngeta = M\nfor i in range(N-1):\n    for j in range(M-1):\n        if D[i][j] == 0 and D[i][j+1] == 1 and D[i+1][j+1] == 2 and D[i+1][j] == 3:\n            G[i][j] = 1\n            print(\"G[i][j] after first condition: \", str(G[i][j]))\n            nh, nw = i, j\n            while True:\n                k = G[nh][nw]\n                fh, fw = nh-k, nw-k\n                k2 = 2*(k+1)\n                kh = k+1\n                if fh < 0 or fw < 0 or N < fh+k2-1 or M < fw+k2-1:\n                    break\n                if any(D[fh][j] != 0 for j in range(fw, fw+kh)) or\\\n                any(D[j][fw] != 0 for j in range(fh, fh+kh)) or\\\n                any(D[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\\\n                any(D[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\\\n                any(D[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\\\n                any(D[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\\\n                any(D[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\\\n                any(D[j][fw] != 3 for j in range(fh+kh, fh+k2)):\n                    break\n                G[nh][nw] += 1\n            print(\"G[nh][nw] after while loop: \", str(G[nh][nw]))\n            if G[nh][nw] > BS:\n                candi.append((nh, nw))\n                print(\"candi after appending: \", str(candi))\n\nGnum = [None] + [[[0]*M for _ in range(N)] for _ in range(BS)]\nfor h in range(N):\n    for w in range(M):\n        if G[h][w] > 0:\n            for k in range(1, min(BS, G[h][w])+1):\n                Gnum[k][h][w] = 1\n                print(\"Gnum[k][h][w] after assignment: \", str(Gnum[k][h][w]))\n\nGnum = [None] + [accumulate2d(g) for g in Gnum[1:]]\nprint(\"Gnum after accumulate2d: \", str(Gnum))\n\nAns = [None]*Q\nfor qu in range(Q):\n    h1, w1, h2, w2 = map(lambda x: int(x)-1, readline().split())\n    print(\"h1: \", str(h1), \"w1: \", str(w1), \"h2: \", str(h2), \"w2: \", str(w2))\n    res = 0\n    for k in range(min(BS, h2-h1+1, w2-w1+1), 0, -1):\n        hs, ws = h1+k-1, w1+k-1\n        he, we = h2-k, w2-k\n        if hs <= he and ws <= we:\n            cnt = Gnum[k][he][we]\n            if hs:\n                cnt -= Gnum[k][hs-1][we]\n            if ws:\n                cnt -= Gnum[k][he][ws-1]\n            if hs and ws:\n                cnt += Gnum[k][hs-1][ws-1]\n            if cnt:\n                res = k\n                break\n            print(\"res after k loop: \", str(res))\n\n    for nh, nw in candi:\n        if h1 <= nh <= h2 and w1 <= nw <= w2:\n            res = max(res, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, G[nh][nw]))\n            print(\"res after candi loop: \", str(res))\n    Ans[qu] = 4*res**2\n    print(\"Ans[qu] after assignment: \", str(Ans[qu]))\n\nprint('\\n'.join(map(str, Ans)))\n</ans>", "format_properties": {}}
{"idx": 68, "result": 0, "generated": "<ans>\nN, S = input().split()\nprint(\"N: \", str(N), \"S: \", str(S))\nN = int(N)\nprint(\"N: \", str(N))\nans = 0\nfor i in range(N):\n    a = 0;t = 0;c = 0;g = 0;\n    print(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\n    for j in range(i,N):\n        if S[j] == 'A':\n            a += 1\n        elif S[j] == 'T':\n            t += 1\n        elif S[j] == 'C':\n            c += 1\n        else:\n            g += 1\n        print(\"a: \", str(a), \"t: \", str(t), \"c: \", str(c), \"g: \", str(g))\n        if a == t and c == g:\n            ans += 1\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 69, "result": 0, "generated": "<ans>\nfrom collections import deque\nimport math\n\ndef dfs(edges, s):\n    stack = deque([s])\n    used  = {s}\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y not in used:\n                used.add(y)\n                stack.append(y)\n    return used\n\ndef bfs(edges, s):\n    queue = deque([s])\n    used  = {s}\n    while queue:\n        x = queue.popleft()\n        for y in edges[x]:\n            if y in used:\n                continue\n            used.add(y)\n            queue.append(y)\n    return used\n\ndef bellman(dist):  #\u8ca0\u8fba\u304c\u3042\u308b\u30b1\u30fc\u30b9\u3067\u306e\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\u30a2\u30eb\u30b4\u3002\n    cost = [float(\"inf\")] * n\n    cost[0] = 0\n    for _ in range(n): #\u9802\u70b9\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n        updated = False\n        for u,v,c in dist: #\u8fba\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n            if cost[u] + c < cost[v]:\n                cost[v] = cost[u] + c\n                updated = True\n    #\u53ce\u675f\u3057\u306a\u3044\u5834\u5408\u306f\u8ca0\u9589\u8def\u304c\u3042\u308b\u305f\u3081\u7121\u9650\u306b\u5c0f\u3055\u304f\u3067\u304d\u308b\u3002\n    if updated==True:\n        return -1\n    else:\n        return max(0, cost[n-1]*-1)\n\nn,m,p = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m), \"p: \", str(p))\ndist  = []\nedge1 = [[] for _ in range(n)]\nedge2 = [[] for _ in range(n)]  # rev_edge\nfor _ in range(m):\n    u,v,c = map(int, input().split())\n    u -= 1\n    v -= 1\n    dist.append((u,v,(c-p)*-1))\n    edge1[u].append(v)\n    edge2[v].append(u)\nprint(\"dist: \", str(dist), \"edge1: \", str(edge1), \"edge2: \", str(edge2))\n\nuse = dfs(edge1, 0) & dfs(edge2, n-1)\nprint(\"use: \", str(use))\ndist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]\nprint(\"dist2: \", str(dist2))\nprint(bellman(dist2))\n</ans>", "format_properties": {}}
{"idx": 71, "result": 0, "generated": "<ans>\nimport math\nimport bisect\nimport sys\n\ndef flrt(exp, x):\n    l = max(0, math.floor(x**(1/exp)) - 3)\n    print(\"l: \", str(l))\n    r = math.floor(x**(1/exp)) + 3\n    print(\"r: \", str(r))\n    while l < r:\n        mid = (l + r) // 2\n        print(\"mid: \", str(mid))\n        if mid**exp <= x:\n            l = mid + 1\n        else:\n            r = mid\n    return l - 1\n\ndef c1(r):\n    ans = set()\n    print(\"ans: \", str(ans))\n    pr = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    print(\"pr: \", str(pr))\n    for i in pr:\n        x = 2\n        while x**i <= r:\n            val = x**i\n            b2 = flrt(2, val)\n            b3 = flrt(3, val)\n            if b2**2 != val and b3**3 != val:\n                ans.add(val)\n            x += 1\n    return ans\n\ndef solve(r, pc):\n    if r == 0:\n        return 0\n    a = [2, 3]\n    print(\"a: \", str(a))\n    ans = 0\n    for i in range(1, 2**len(a)):\n        tot = 0\n        mult = 1\n        for j, x in enumerate(a):\n            if i & (1 << j):\n                mult *= x\n                tot += 1\n        d = flrt(mult, r)\n        ans += d if tot % 2 else -d\n    return ans + bisect.bisect_right(pc, r)\n\nq = int(input())\npc = c1(1e18 + 1)\npca = list(pc)\npca.sort()\nprint(\"pca: \", str(pca))\n\nfor i in range(q):\n    l, r = [int(x) for x in sys.stdin.readline().split()]\n    ans = solve(r, pca) - solve(l - 1, pca)\n    sys.stdout.write(str(ans) + '\\n')\n\n</ans>", "format_properties": {}}
{"idx": 65, "result": 0, "generated": "<ans>\na = list(map(int,input().split()))\nprint(\"a: \", str(a))\nb = [0,0,0,0,0];\nprint(\"b: \", str(b))\nc = [0,0,0,0,0];\nprint(\"c: \", str(c))\nipt = [];\nprint(\"ipt: \", str(ipt))\nans = [];\nprint(\"ans: \", str(ans))\nd = {\"S\" : 0,\"M\" : 1, \"L\" : 2, \"XL\" : 3, \"XXL\" : 4, \"XXXL\" : 5}\nprint(\"d: \", str(d))\n\nn = int(input())\n\nfor i in range(1,n+1) :\n    j = input()\n    ipt.append(j)\n    ans.append(j)\n    if j.find(',') == -1 :\n        a[d[j]] -= 1\n    else :\n        b[d[j[0:j.find(',')]]] += 1\n\nans = False;\nprint(\"ans: \", str(ans))\n\nfor i in range(0,6) :\n    if (a[i] < 0) and ans == False:\n        ans = True\n    elif i < 5:\n        if i==0 :\n            if b[i] > a[i] :\n                c[i] = b[i] - a[i];\n                b[i] -= a[i];\n                a[i] = 0;\n            else :\n                c[i] = 0;\n                a[i] -= b[i];\n                b[i] = 0;\n\n        else :\n            if b[i-1] > 0 :\n                if b[i-1] > a[i] :\n                    ans = True\n                else :\n                    a[i] -= b[i-1];\n            if b[i] > a[i] :\n                c[i] = b[i] - a[i];\n                b[i] -= a[i];\n                a[i] = 0;\n            else :\n                c[i] = 0;\n                a[i] -= b[i];\n                b[i] = 0;\n    elif i==5 :\n        if a[i] < b[i-1]:\n            ans = True\n\nif ans == True :\n    print(\"NO\");\n\nelse :\n    print(\"YES\")\n    for i in ipt :\n        if i.find(',') == -1 :\n            print(i)\n        else :\n            tmp = i[0:i.find(',')];\n            if (c[d[tmp]] > 0) :\n                print(i[i.find(',')+1:])\n                c[d[tmp]] -= 1\n            else :\n                print(tmp)\n</ans>", "format_properties": {}}
{"idx": 66, "result": 0, "generated": "<ans>\nn, m = list(map(int, input().split()))\nprint(\"n: \", str(n), \"m: \", str(m))\nA = list(map(int, input().split()))\nprint(\"A: \", str(A))\nif n > 300:\n    lst = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n    print(\"lst: \", str(lst))\n    answer = 0\n    print(\"answer: \", str(answer))\n    answer_1 = []\n    print(\"answer_1: \", str(answer_1))\n    m300 = [[-1, -10**6]]\n    for i in range(max(0, m-1)):\n        m300.append([-1, -10**6])\n    print(\"m300: \", str(m300))\n    for u in range(n):\n        if A[u] > min(m300)[1]:\n            m300[m300.index(min(m300))] = [u, A[u]]\n    print(\"m300: \", str(m300))\n    for i, mi in m300:\n        B = A.copy()\n        print(\"B: \", str(B))\n        kek = []\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                for q in range(a - 1, b):\n                    B[q] -= 1\n        elem = max(B)\n        if answer < elem - mi:\n            answer = elem - mi\n            answer_1 = kek.copy()\n    print(\"answer: \", str(answer))\n    print(\"answer_1: \", str(answer_1))\n    print(' '.join(map(str, answer_1)))\nelse:\n    lst = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n    print(\"lst: \", str(lst))\n    answer = 0\n    print(\"answer: \", str(answer))\n    answer_1 = []\n    print(\"answer_1: \", str(answer_1))\n    for i in range(n):\n        B = A.copy()\n        print(\"B: \", str(B))\n        kek = []\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                for q in range(a - 1, b):\n                    B[q] -= 1\n        elem = max(B)\n        if answer < elem - B[i]:\n            answer = elem - B[i]\n            answer_1 = kek.copy()\n    print(\"answer: \", str(answer))\n    print(\"answer_1: \", str(answer_1))\n    print(' '.join(map(str, answer_1)))\n</ans>", "format_properties": {}}
{"idx": 72, "result": 0, "generated": "<ans>\n'''\n    Auther: ghoshashis545 Ashis Ghosh\n    College: jalpaiguri Govt Enggineering College\n\n'''\nfrom os import path\nimport sys\nfrom functools import cmp_to_key as ctk\nfrom collections import deque,defaultdict as dd\nfrom bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\nfrom itertools import permutations\nfrom datetime import datetime\nfrom math import ceil,sqrt,log,gcd\ndef ii():return int(input())\ndef si():return input()\ndef mi():return list(map(int,input().split()))\ndef li():return list(mi())\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef bo(i):\n    return ord(i)-ord('a')\n\n\n\n\n\ndef solve():\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    print(\"w: \", str(w))\n    a = li()\n    print(\"a: \", str(a))\n\n    def fessible(mid):\n        print(\"mid: \", str(mid))\n        b = [0]*n\n        moves = 0\n        if(a[0]<mid):\n            b[0]+=(mid-a[0])\n            if(w<n):\n                b[w]-=(mid-a[0])\n            moves+=(mid-a[0])\n            if(moves>m):\n                return 0\n        for i in range(1,n):\n            b[i]+=b[i-1]\n            x=a[i]+b[i]\n            if(x<mid):\n                b[i]+=(mid-x)\n                if(i+w<n):\n                    b[i+w]-=(mid-x)\n                moves+=(mid-x)\n            if(moves>m):\n                return 0\n        return 1\n\n    l = 1\n    r = 1e10\n    while(l<=r):\n        mid=l+(r-l)//2\n        if(fessible(mid)):\n            l=mid+1\n            ans=mid\n        else:\n            r=mid-1\n    print(\"ans: \", str(int(ans)))\n\n\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 64, "result": 0, "generated": "<ans>\n# problem http://codeforces.com/contest/1100/problem/E\nimport copy\nimport sys\n\ndef find_loop(g, w, k, n):\n    visited = [False] * n\n    visited_int = [False] * n\n    print(\"visited: \", str(visited))\n    print(\"visited_int: \", str(visited_int))\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        visited_int[i] = True\n        while stack:\n            if not stack[-1]:\n                stack.pop()\n                visited_int[path[-1]] = False\n                path.pop()\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited_int[nxt]:\n                return True\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            visited_int[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n    return False\n\ndef top_sort(g, w, k, n):\n    visited = [False] * n\n    order = [-1] * n\n    cnt = 0\n    print(\"visited: \", str(visited))\n    print(\"order: \", str(order))\n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [g[i][:]]\n        path = [i]\n        visited[i] = True\n        while stack:\n            if not stack[-1]:\n                order[path[-1]] = cnt\n                path.pop()\n                stack.pop()\n                cnt += 1\n                continue\n            nxt = stack[-1][-1]\n            stack[-1].pop()\n            if w[(path[-1], nxt)] <= k:\n                continue\n            if visited[nxt]:\n                continue\n            visited[nxt] = True\n            stack.append(g[nxt][:])\n            path.append(nxt)\n\n    to_reverse = []\n    for a, b in list(w.items()):\n        if b > k:\n            continue\n        if order[a[0]] < order[a[1]]:\n            to_reverse.append(a)\n    return to_reverse\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    w = {}\n    g = [[] for _ in range(n)]\n    w_tmp = {}\n    c_m = 0\n    kk = [0]\n    lines = sys.stdin.readlines()\n    for i, line in enumerate(lines): #range(1, m + 1):\n        u, v, c = list(map(int, line.split()))\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        print(\"c: \", str(c))\n        g[u - 1].append(v - 1)\n        if (u - 1, v - 1) in list(w.keys()):\n            w[(u - 1, v - 1)] = max(w[(u - 1, v - 1)], c)\n        else:\n            w[(u - 1, v - 1)] = c\n        if (u - 1, v - 1) in list(w_tmp.keys()):\n            w_tmp[(u - 1, v - 1)].append(str(i + 1))\n        else:\n            w_tmp[(u - 1, v - 1)] = [str(i + 1)]\n        kk.append(c)\n        # c_m = max(c, c_m)\n\n    # print(find_loop(copy.deepcopy(g), copy.deepcopy(w), 0, n))\n\n    kk.sort()\n    l, r = 0, len(kk)\n    if not find_loop(g, w, kk[l], n):\n        print(0, 0)\n        return\n    if find_loop(g, w, kk[-1], n):\n        kkk = kk[-1]\n    else:\n        while l + 1 != r:\n            m = int((l + r) / 2)\n            # if find_loop(copy.deepcopy(g), copy.deepcopy(w), kk[m], n):\n            if find_loop(g, w, kk[m], n):\n                l = m\n            else:\n                r = m\n        kkk = kk[l+1]\n\n    to_reverse = top_sort(g, w, kkk, n)\n    num = 0\n    s = []\n    for t in to_reverse:\n        num += len(w_tmp[t])\n        s.extend(w_tmp[t])\n\n    print(kkk, num)\n    print(\" \".join(s))\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 76, "result": 0, "generated": "<ans>\n```\ndef indeksTurun(a):\n\tfor x in range(len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\tprint(\"a[x]: \", str(a[x]))\n\t\t\tprint(\"a[x+1]: \", str(a[x+1]))\n\t\t\treturn x+1\n\t\t\tpass\n\t\tpass\n\treturn -1\n\tpass\n\ndef menaik(a,i1):\n\tfor x in range(i1,len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\tprint(\"a[x]: \", str(a[x]))\n\t\t\tprint(\"a[x+1]: \", str(a[x+1]))\n\t\t\treturn False\n\t\t\tpass\n\t\tpass\n\treturn True\n\tpass\n\na=input()\na=list(map(int,input().split(\" \")))\n\nif len(a) == 1:\n\tprint (\"yes\")\n\tprint (\"1 1\")\nelse:\n\treversed_indeks1=-1\n\tfor x in range(len(a)-1):\n\t\tif a[x] > a[x+1]:\n\t\t\treversed_indeks1=x\n\t\t\tbreak\n\t\t\tpass\n\t\tpass\n\tif reversed_indeks1 == -1:\n\t\tprint (\"yes\")\n\t\tprint (\"1 1\")\n\telse:\n\t\treversed_indeks2=len(a)-1\n\t\tfor x in range(reversed_indeks1,len(a)-1):\n\t\t\tif a[x] < a[x+1]:\n\t\t\t\treversed_indeks2=x\n\t\t\t\tbreak\n\t\tasc=True\n\t\tif reversed_indeks2 != len(a)-1:\n\t\t\tasc=menaik(a,reversed_indeks2+1)\n\t\tif asc:\n\t\t\tkiri=True\n\t\t\tkanan=True\n\t\t\tif reversed_indeks1 != 0:\n\t\t\t\tif a[reversed_indeks2] < a[reversed_indeks1-1]:\n\t\t\t\t\tkiri=False\n\t\t\t\t\tpass\n\t\t\tif reversed_indeks2 != len(a)-1:\n\t\t\t\tif a[reversed_indeks1] > a[reversed_indeks2+1]:\n\t\t\t\t\tkanan=False\n\t\t\t\t\tpass\n\t\t\t\tpass\n\t\t\t\tpass\n\t\t\tif kiri and kanan:\n\t\t\t\tprint (\"yes\")\n\t\t\t\tprint (\"%d %d\"%(reversed_indeks1+1,reversed_indeks2+1))\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tprint (\"no\")\n\t\telse:\n\t\t\tprint (\"no\")\n\t\t\tpass\n\tpass\n```", "format_properties": {}}
{"idx": 77, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(1919810)\n\ndef dfs(i):\n    if i == 2 * n + 1:\n        nonlocal ans\n        ans = \"Yes\"\n        return\n    if ans == \"No\":\n        if y[i] == 0:\n            for k in range(1, n):\n                if ok(k, i):\n                    dfs(i + 2 * k)\n        else:\n            if ok(y[i], i):\n                dfs(i + 2 * y[i])\n    return\n\ndef ok(k, i):\n    if k + i >= 2 * n + 1:\n        return 0\n    f = 1\n    for l in range(k):\n        if k + i + l >= 2 * n + 1:\n            f = 0\n            break\n        if x[i + l] == 2 or x[k + i + l] == 1:\n            f = 0\n            break\n        if not (y[i + l] == 0 or y[i + l] == k):\n            f = 0\n            break\n        if not z[i + l] == z[k + i + l] and min(z[i + l], z[k + i + l]) >= 1:\n            f = 0\n            break\n    return f\n\nn = int(input())\nprint(\"n: \", str(n))\nans = \"Yes\"\nprint(\"ans: \", str(ans))\nx = [0] * (2 * n + 2)\nprint(\"x: \", str(x))\ny = [0] * (2 * n + 2)\nprint(\"y: \", str(y))\nz = [0] * (2 * n + 2)\nprint(\"z: \", str(z))\nfor i in range(1, n + 1):\n    a, b = map(int, input().split())\n    if a >= b and not (a == -1 or b == -1):\n        ans = \"No\"\n    if not (x[a] == 0 and x[b] == 0):\n        ans = \"No\"\n    if not a == -1:\n        x[a] = 1\n        z[a] = i\n    if not b == -1:\n        x[b] = 2\n        z[b] = i\n    if not (a == -1 or b == -1):\n        y[a] = b - a\nif ans == \"No\":\n    print(ans)\n    return\nans = \"No\"\nprint(\"ans: \", str(ans))\ndfs(1)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 75, "result": 0, "generated": "<ans>\nfrom copy import deepcopy\nn, k, m, a = [int(i) for i in input().split()]\nprint(\"n: \", str(n), \"k: \", str(k), \"m: \", str(m), \"a: \", str(a))\ncn = [0] * (n + 1)\nprint(\"cn: \", str(cn))\nlast = [-1] * (n + 1)\nprint(\"last: \", str(last))\nv = [int(i) for i in input().split()]\nprint(\"v: \", str(v))\n\nfor i in range(len(v)):\n    last[v[i]] = i\n    cn[v[i]] += 1\n\ncn1 = deepcopy(cn)\nprint(\"cn1: \", str(cn1))\nlast1 = deepcopy(last)\nprint(\"last1: \", str(last1))\n\nfor i in range(1, n + 1):\n    cn = deepcopy(cn1)\n    print(\"cn: \", str(cn))\n    last = deepcopy(last1)\n    print(\"last: \", str(last))\n    res = [i1 for i1 in range(1, n + 1)]\n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    #print(res)\n\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        j1 = j + 1\n        lft = m - a\n        while j1 < n and lft:\n            pls = min(lft, cn[i] - cn[res[j1]] + 1)\n            cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)\n            last[res[j1]] = m\n            lft -= pls\n            j1 += 1\n\n    res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)\n    sans = 0\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n\n    if sans == 1:\n        print(1, end= ' ')\n        continue\n\n    cn = deepcopy(cn1)\n    print(\"cn: \", str(cn))\n    last = deepcopy(last1)\n    print(\"last: \", str(last))\n\n    if m - a:\n        cn[i] += m - a\n        last[i] = m - 1\n\n    res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)\n    for j in range(len(res)):\n        if res[j] != i:\n            continue\n        if cn[i] == 0 or j >= k:\n            sans = 0\n        else:\n            sans = 1\n        break\n\n    if sans:\n        print(2, end=' ')\n    else:\n        print(3, end=' ')\n\n</ans>", "format_properties": {}}
{"idx": 79, "result": 0, "generated": "<ans>\n```\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\ndef good(nums):\n    for num in nums:\n        if nums[num] > 1:\n            return True\n    return False\n\nn = int(input())\n\na = [int(i) for i in input().split()]\n\nprint(\"n: \", str(n))\nprint(\"a: \", str(a))\n\ns = []\n\nprint(\"s: \", str(s))\n\nl, r = 0, 0\nnums = {}\n\nprint(\"l: \", str(l))\nprint(\"r: \", str(r))\nprint(\"nums: \", str(nums))\n\nfor i in range(n):\n    num = a[i]\n\n    if num in nums:\n        break\n    else:\n        nums[num] = True\nelse:\n    print(-1)\n    return\n\nprint(\"nums: \", str(nums))\n\nnums = {}\n\nwhile r < n:\n    while r < n:\n        num = a[r]\n\n        if num in nums:\n            r += 1\n            break\n        else:\n            nums[num] = True\n\n        r += 1\n\n    r -= 1\n\n    s.append([l, r])\n    print(\"s: \", str(s))\n    r += 1\n    l = r\n\n    nums = {}\n\nprint(\"nums: \", str(nums))\n\nlength = len(s)\n\nprint(\"length: \", str(length))\n\nlast = s[length-1]\n\nprint(\"last: \", str(last))\n\nfor i in range(last[0], last[1]+1):\n    num = a[i]\n    if num in nums:\n        print(length)\n        break\n    else:\n        nums[num] = True\nelse:\n    s.pop()\n\n    s[length-2][1] = n-1\n\n    print(length-1)\n\nfor st in s:\n    for c in st:\n        print(c+1, end=\" \")\n    print()\n</ans>", "format_properties": {}}
{"idx": 78, "result": 0, "generated": "<ans>\nn, m = map(int, input().split())\nprint(\"n: \", str(n), \"m: \", str(m))\n\nt = [0] * (n + 1)\nprint(\"t: \", str(t))\n\np = [0] * (n + 1)\nprint(\"p: \", str(p))\n\nq = [[] for i in range(n + 1)]\nprint(\"q: \", str(q))\n\ndef f(x):\n    for i in q[x]:\n        u, v = i[0], i[1]\n        if t[u] and t[v]: continue\n        if t[u] and not t[v]:\n            t[v] = 7 - t[x] - t[u]\n            for j in q[v]:\n                p[j[0]] |= t[v]\n                p[j[1]] |= t[v]\n            #f(u)\n            f(v)\n        elif not t[u] and t[v]:\n            t[u] = 7 - t[x] - t[v]\n            for j in q[u]:\n                p[j[0]] |= t[u]\n                p[j[1]] |= t[u]\n            f(u)\n            #f(v)\n        else:\n            for k in [1, 2, 4]:\n                t[u], t[v] = k, 7 - t[x] - k\n                if not (p[u] & t[u] or p[v] & t[v]): break\n\n            for j in q[v]:\n                p[j[0]] |= t[v]\n                p[j[1]] |= t[v]\n            for j in q[u]:\n                p[j[0]] |= t[u]\n                p[j[1]] |= t[u]\n            f(u)\n            f(v)\n\nif m == 49999:\n    for j in range(m):\n        a, b, c = map(int, input().split())\n        x = t[a] | t[b] | t[c]\n        for i in (a, b, c):\n            if not t[i]:\n                if not x & 1: t[i] = 1; x += 1;\n                elif not x & 2: t[i] = 2; x += 2;\n                else: t[i] = 4\nelse:\n    for i in range(m):\n        a, b, c = map(int, input().split())\n\n        q[a].append((b, c))\n        q[b].append((a, c))\n        q[c].append((a, b))\n\n    for x in range(1, n + 1):\n        if not t[x]:\n            t[x] = 1\n            for j in q[x]:\n                p[j[0]] |= 1\n                p[j[1]] |= 1\n            f(x)\n\np = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}\nprint(''.join(p[x] for x in t[1:]))\n</ans>", "format_properties": {}}
{"idx": 67, "result": 0, "generated": "<ans>\nimport math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self, Nodes, is_directed=False):\n        print(\"Nodes: \", str(Nodes))\n        print(\"is_directed: \", str(is_directed))\n        self.nodes = Nodes\n        self.adj_list = {}\n        self.is_directed = is_directed\n\n        for node in self.nodes:\n            self.adj_list[node] = []\n            print(\"adj_list[{}]: {}\".format(node, self.adj_list[node]))\n\n    def add_edge(self, u, v):\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed == False:\n            self.adj_list[v].append(u)\n            print(\"adj_list[{}]: {}\".format(v, self.adj_list[v]))\n\n    def print_graph(self):\n        for node in self.nodes:\n            print((node, \"->\", self.adj_list[node]))\n\n    def degree_node(self, node):\n        print(\"node: \", str(node))\n        return len(self.adj_list[node])\n\n    def dfsUTIL(self, v, visited, parents=[]):\n        # print(v, end=\" \")\n        visited[v] = True\n        for i in self.adj_list[v]:\n            if visited[i] == False:\n                self.dfsUTIL(i, visited, parents)\n                parents.append(i)\n\n    def dfs(self, v):\n        visited = [False] * (max(self.adj_list) + 1)\n        parents = [v]\n        self.dfsUTIL(v, visited, parents)\n        return len(parents)\n\n##### sorting a dictionary by the values #####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))\n\n##### naive method for testing prime or not O(n^.5) #####\ndef is_prime(n):\n    print(\"n: \", str(n))\n    if n == 1:\n        return 0\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n##### swap function #####\ndef swap(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    temp = a\n    a = b\n    b = temp\n    return a, b\n\n##### Primes till Nth O(n) #####\ndef seive_primes(n):\n    print(\"n: \", str(n))\n    flag = [0] * (n + 10)\n    flag[1] = flag[0] = 1\n    i = 2\n    while i * i <= n + 1:\n        if flag[i] == 0:\n            j = i * i\n            while j <= n + 1:\n                flag[j] = 1\n                j += i\n        i += 1\n    return flag\n\n##### greatest common divisor of two numbers #####\ndef gcd(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n##### least common multiplyer of two numbers #####\ndef lcm(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    return (a * b) // gcd(a, b)\n\n##### function that return all the letters #####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n##### binary search O(logN) #####\ndef binary_search(ls, n, flag):\n    print(\"ls: \", str(ls))\n    print(\"n: \", str(n))\n    print(\"flag: \", str(flag))\n    low = 0\n    hi = n - 1\n    while low <= hi:\n        mid = (low + hi) // 2\n        if ls[mid] == flag:\n            return mid\n        elif ls[mid] > flag:\n            hi = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\n##### quadratic #####\ndef qdrt(a, b, c):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    print(\"c: \", str(c))\n    chk = b * b - 4 * a * c\n    if chk >= 0:\n        ans1 = (-b + chk ** 0.5) / (2 * a)\n        ans2 = (-b - chk ** 0.5) / (2 * a)\n        return [int(ans1), int(ans2)]\n    return -1\n\n##### taking an array/list as input #####\ndef inp():\n    ls = list(map(int, input().split()))\n    print(\"ls: \", str(ls))\n    return ls\n\n##### taking multiple inputs #####\ndef mult_inp():\n    return list(map(int, input().split()))\n\n##### Main function starts from here #####\nn = int(input())\nprint(\"n: \", str(n))\nd = {}\nwhile n % 2 == 0:\n    if 2 in d:\n        d[2] += 1\n    else:\n        d[2] = 1\n    n /= 2\nfor i in range(3, int(n ** 0.5) + 1, 2):\n    while n % i == 0:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n        n /= i\nn = int(n)\nif n > 1:\n    d[n] = 1\nprint(\"d: \", str(d))\nn = 1\n# print(d,n)\nans = 0\nfor i in d:\n    c = -2 * d[i]\n    a = b = 1\n    ls = qdrt(a, b, c)\n    if ls[0] >= 0:\n        ans += ls[0]\n    elif ls[1] >= 0:\n        ans += ls[1]\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 70, "result": 0, "generated": "<ans>\nimport math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self, Nodes, is_directed=False):\n        print(\"Nodes: \", str(Nodes))\n        print(\"is_directed: \", str(is_directed))\n        self.nodes = Nodes\n        self.adj_list = {}\n        self.is_directed = is_directed\n\n        for node in self.nodes:\n            self.adj_list[node] = []\n            print(\"adj_list[{}]: {}\".format(node, self.adj_list[node]))\n\n    def add_edge(self, u, v):\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed == False:\n            self.adj_list[v].append(u)\n            print(\"adj_list[{}]: {}\".format(v, self.adj_list[v]))\n\n    def print_graph(self):\n        for node in self.nodes:\n            print((node, \"->\", self.adj_list[node]))\n\n    def degree_node(self, node):\n        print(\"node: \", str(node))\n        return len(self.adj_list[node])\n\n    def dfsUTIL(self, v, visited, parents=[]):\n        # print(v, end=\" \")\n        visited[v] = True\n        for i in self.adj_list[v]:\n            if visited[i] == False:\n                self.dfsUTIL(i, visited, parents)\n                parents.append(i)\n\n    def dfs(self, v):\n        visited = [False] * (max(self.adj_list) + 1)\n        parents = [v]\n        self.dfsUTIL(v, visited, parents)\n        return len(parents)\n\n##### sorting a dictionary by the values #####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))\n\n##### naive method for testing prime or not O(n^.5) #####\ndef is_prime(n):\n    print(\"n: \", str(n))\n    if n == 1:\n        return 0\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n##### swap function #####\ndef swap(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    temp = a\n    a = b\n    b = temp\n    return a, b\n\n##### Primes till Nth O(n) #####\ndef seive_primes(n):\n    print(\"n: \", str(n))\n    flag = [0] * (n + 10)\n    flag[1] = flag[0] = 1\n    i = 2\n    while i * i <= n + 1:\n        if flag[i] == 0:\n            j = i * i\n            while j <= n + 1:\n                flag[j] = 1\n                j += i\n        i += 1\n    return flag\n\n##### all the prime factors of a number #####\ndef factors(n):\n    print(\"n: \", str(n))\n    d = {}\n    while n % 2 == 0:\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n        n /= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            n /= i\n    n = int(n)\n    if n > 1:\n        d[n] = 1\n    return d\n\n##### greatest common divisor of two numbers #####\ndef gcd(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n##### least common multiplyer of two numbers #####\ndef lcm(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    return (a * b) // gcd(a, b)\n\n##### function that return all the letters #####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n##### binary search O(logN) #####\ndef binary_search(ls, n, flag):\n    print(\"ls: \", str(ls))\n    print(\"n: \", str(n))\n    print(\"flag: \", str(flag))\n    low = 0\n    hi = n - 1\n    while low <= hi:\n        mid = (low + hi) // 2\n        if ls[mid] == flag:\n            return mid\n        elif ls[mid] > flag:\n            hi = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\n##### quadratic roots #####\ndef qdrt(a, b, c):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    print(\"c: \", str(c))\n    chk = b * b - 4 * a * c\n    if chk >= 0:\n        ans1 = (-b + chk ** 0.5) / (2 * a)\n        ans2 = (-b - chk ** 0.5) / (2 * a)\n        return [int(ans1), int(ans2)]\n    return -1\n\n##### permutations #####\ndef permutation(n, r):\n    print(\"n: \", str(n))\n    print(\"r: \", str(r))\n    if n < r:\n        return 0\n    ans = 1\n    for i in range(n - r + 1, n + 1):\n        ans *= i\n    return ans\n\n##### combinations #####\ndef combination(n, r):\n    print(\"n: \", str(n))\n    print(\"r: \", str(r))\n    if n < r:\n        return 0\n    ans = 1\n    for i in range(r):\n        ans *= (n - i)\n    div = 1\n    for i in range(2, r + 1):\n        div *= i\n    return ans // div\n\n##### taking an array/list as input #####\ndef arinp():\n    ls = list(map(int, input().split()))\n    print(\"ls: \", str(ls))\n    return ls\n\n##### taking multiple inputs #####\ndef mult_inp():\n    return list(map(int, input().split()))\n\n##### Main function starts from here #####\ndef main():\n    n, m = mult_inp()\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    print(combination(n, 2) + combination(m, 2))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 81, "result": 0, "generated": "<ans>\ndef dist(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\nx0, y0, a1, a2, b1, b2 = list(map(int, input().split()))\nprint(\"x0: \", str(x0), \"y0: \", str(y0), \"a1: \", str(a1), \"a2: \", str(a2), \"b1: \", str(b1), \"b2: \", str(b2))\nxs, ys, t = list(map(int, input().split()))\nprint(\"xs: \", str(xs), \"ys: \", str(ys), \"t: \", str(t))\narr = []\narr.append((x0, y0))\nprint(\"arr: \", str(arr))\nnow1 = x0\nnow2 = y0\nwhile (1):\n    now1 = a1 * now1 + b1\n    now2 = a2 * now2 + b2\n    print(\"now1: \", str(now1), \"now2: \", str(now2))\n    if (now1 < xs or now2 < ys):\n        arr.append((now1, now2))\n        continue\n    arr.append((now1, now2))\n    if (dist(now1, now2, xs, ys) > t):\n        break\nans = 0\nN = len(arr)\nfor i in range(N):\n    need = dist(arr[i][0], arr[i][1], xs, ys)\n    if (need > t):\n        continue\n    left = t - need\n    now = 1\n    flag = 1\n    now1 = arr[i][0]\n    now2 = arr[i][1]\n    for j in range(i - 1, -1, -1):\n        d = dist(now1, now2, arr[j][0], arr[j][1])\n        if (d > left):\n            flag = 0\n            break\n        left -= d\n        now1 = arr[j][0]\n        now2 = arr[j][1]\n        now += 1\n    if (not flag):\n        ans = max(ans, now)\n        continue\n    for j in range(i + 1, N):\n        d = dist(now1, now2, arr[j][0], arr[j][1])\n        if (d > left):\n            break\n        left -= d\n        now1 = arr[j][0]\n        now2 = arr[j][1]\n        now += 1\n    ans = max(ans, now)\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 80, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\nG0=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nprint(\"G0: \", str(G0))\nG1=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nprint(\"G1: \", str(G1))\nG2=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]\nprint(\"G2: \", str(G2))\n\nfor x in range(1,6):\n    for y in range(1,6):\n        for z in range(1,6):\n\n            for i in range(1,5500):\n                s=G0[x][y][z][max(0,i-x)]\n                t=G1[x][y][z][max(0,i-y)]\n                u=G2[x][y][z][max(0,i-z)]\n\n                for j in range(5):\n                    if j==s or j==t or j==u:\n                        continue\n                    else:\n                        G0[x][y][z][i]=j\n                        break\n\n                for j in range(5):\n                    if j==s or j==u:\n                        continue\n                    else:\n                        G1[x][y][z][i]=j\n                        break\n\n                for j in range(5):\n                    if j==s or j==t:\n                        continue\n                    else:\n                        G2[x][y][z][i]=j\n                        break\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\nt=int(input())\nfor tests in range(t):\n    n,x,y,z=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n    A=[]\n    for a in B:\n        if a<=5400:\n            A.append(a)\n        else:\n            A.append(a%2520+2520)\n\n    XOR=0\n    print(\"XOR: \", str(XOR))\n    for a in A:\n        XOR^=G0[x][y][z][a]\n\n    ANS=0\n    print(\"ANS: \", str(ANS))\n    for a in A:\n        k=XOR^G0[x][y][z][a]\n\n        if G0[x][y][z][max(0,a-x)]==k:\n            ANS+=1\n\n        if G1[x][y][z][max(0,a-y)]==k:\n            ANS+=1\n\n        if G2[x][y][z][max(0,a-z)]==k:\n            ANS+=1\n\n    print(ANS)\n\n</ans>", "format_properties": {}}
{"idx": 82, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\n\n\"\"\"\ncreated by shhuan at 2017/10/6 22:19\n\n\"\"\"\n\nprint(\"t0: \", str(time.time()))\na, b, c = list(map(int, input().split()))\nprint(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n\ndef ct(a, b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    if a > b:\n        a, b = b, a\n    L=998244353\n    s=1\n    sx=1\n    for k in range(1,a+1):\n        s = s*(a+1-k)*(b+1-k)//k\n        sx += s % L\n    return sx\n\nL=998244353\n\nprint(\"ct(a, b): \", str(ct(a, b)), \"ct(a, c): \", str(ct(a, c)), \"ct(b, c): \", str(ct(b, c)))\nprint(ct(a,b)*ct(a,c)*ct(b,c)%L)\n\n# print(time.time()-t0)\n\n# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]\n# for i in range(1, MAXN):\n#     p[i][0] = 1\n#     for j in range(1, i+1):\n#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD\n# print(time.time() - t0)\n# pre = [0] * MAXN\n# pre[0] = 1\n# for i in range(1, MAXN):\n#     pre[i] = (i*pre[i-1]) % MOD\n#\n#\n# def solve(x, y):\n#     ans = 0\n#     for k in range(min(x, y)+1):\n#         d = pre[k]\n#         d = (d*p[x][k]) % MOD\n#         d = (d*p[y][k]) % MOD\n#         ans = (ans+d) % MOD\n#\n#     return ans\n#\n# ans = 1\n# ans = (ans * solve(a, b)) % MOD\n# ans = (ans * solve(b, c)) % MOD\n# ans = (ans * solve(a, c)) % MOD\n# print(ans)\n#\n# print(time.time() - t0)\n\n</ans>", "format_properties": {}}
{"idx": 86, "result": 0, "generated": "<ans>\n#n, m = map(int, input().split())\nn = int(input())\nprint(\"n: \", str(n))\ns = input()\nprint(\"s: \", str(s))\nans = int(n * (n - 1) / 2)\nprint(\"ans: \", str(ans))\nc = 0\nprint(\"c: \", str(c))\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\nc = 0\nprint(\"c: \", str(c))\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\ns = s[::-1]\nprint(\"s: \", str(s))\nc = 0\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\nc = 0\nprint(\"c: \", str(c))\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    else:\n        if c > 1:\n            ans -= (c - 1)\n        c = 0\nc = 0\nprint(\"c: \", str(c))\nif s[0] == 'A':\n    c += 1\nfor i in range(n):\n    if s[i] == 'A':\n        c += 1\n    elif c >= 1:\n        ans -= 1\n        c = 0\nc = 0\nprint(\"c: \", str(c))\nif s[0] == 'B':\n    c += 1\nfor i in range(n):\n    if s[i] == 'B':\n        c += 1\n    elif c >= 1:\n        ans -= 1\n        c = 0\nprint(\"ans: \", str(ans))\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 74, "result": 0, "generated": "<ans>\nfrom collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n\ndef DFS_Discriminiting():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                if attacked_city[u]:\n                    count_attacked_cities_subtree[u]+=1\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\n        if count_attacked_cities_subtree[v]==0:\n            important_cities[v]=False\n\ndef DFS_Heigths():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    intrudoction_order=[]\n    stack.append(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                stack.append(u)\n                intrudoction_order.append(u)\n    for v in intrudoction_order[::-1]:\n        if heights1[pi[v]] < heights1[v]+1:\n            heights2[pi[v]]=heights1[pi[v]]\n            heights1[pi[v]]=heights1[v]+1\n        elif heights2[pi[v]]<heights1[v]+1:\n            heights2[pi[v]]=heights1[v]+1\n\ndef Distance_Root(s):\n    for v in adjacents_list[s]:\n        if heights1[v]+1>distances1[s]:\n            distances2[s]=distances1[s]\n            distances1[s]=heights1[v]+1\n        elif heights1[v]+1>distances2[s]:\n            distances2[s]=heights1[v]+1\n\ndef DFS_Distances():\n    #visitados\n    visited=[False for x in range(n)]\n    print(\"visited: \", str(visited))\n    visited[numbers_of_attacked_cities[0]]=True\n    stack=[]\n    stack.append(numbers_of_attacked_cities[0])\n    Distance_Root(numbers_of_attacked_cities[0])\n    while len(stack)>0:\n        v=stack.pop()\n        for u in adjacents_list[v]:\n            if not visited[u]:\n                pi[u]=v\n                visited[u]=True\n                determinate=False\n                stack.append(u)\n                if heights1[u]+1==distances1[v]:\n                    if heights1[u]+1>distances2[v]:\n                        determinate=True\n                        distances1[u]=max(heights1[u],distances2[v]+1)\n                        if distances1[u]==heights1[u]:\n                            distances2[u]=max(distances2[v]+1,heights2[u])\n                        else:\n                            distances2[u]=heights1[u]\n                if not determinate:\n                    distances1[u]=distances1[v]+1\n                    distances2[u]=heights1[u]\n\ndef BFS(s):\n    distance=[-1 for x in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance\n\n\nn,m=parser()\n#Creando los arrays necesarios para la ejecucion de DFS\n#padres\npi=[0 for x in range(n)]\nprint(\"pi: \", str(pi))\n#ciudades atacadas en el subarbol\ncount_attacked_cities_subtree=[0 for x in range(n)]\nprint(\"count_attacked_cities_subtree: \", str(count_attacked_cities_subtree))\n#ciudad atacada o no atacada\nattacked_city=[False for x in range(n)]\nprint(\"attacked_city: \", str(attacked_city))\n#ciudades_que_son atacadas o sirven para llegar a las mismas\nimportant_cities=[True for x in range(n)]\nprint(\"important_cities: \", str(important_cities))\n\nadjacents_list=[[] for x in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#numero de ciudades atacadas\nnumbers_of_attacked_cities=[x-1 for x in parser()]\n\nif m==1:\n    print(numbers_of_attacked_cities[0]+1)\n    print(0)\n    return\n\n#marcando las ciudades atacadas\nfor i in numbers_of_attacked_cities:\n    attacked_city[i]=True\n\nDFS_Discriminiting()\n\nadjacents_list=[[] for x in range(n)]\n\ncount_edges=0\nfor v in range(n):\n    if v==numbers_of_attacked_cities[0]:\n        continue\n    elif important_cities[v] and important_cities[pi[v]]:\n        adjacents_list[v].append(pi[v])\n        adjacents_list[pi[v]].append(v)\n        count_edges+=1\n\n#padres\npi=[0 for x in range(n)]\nprint(\"pi: \", str(pi))\n\n#alturas\nheights1=[0 for x in range(n)]\nprint(\"heights1: \", str(heights1))\nheights2=[0 for x in range(n)]\nprint(\"heights2: \", str(heights2))\n\nDFS_Heigths()\n\n#distances\ndistances1=[0 for x in range(n)]\nprint(\"distances1: \", str(distances1))\ndistances2=[0 for x in range(n)]\nprint(\"distances2: \", str(distances2))\n\nDFS_Distances()\n\nlower=distances1[numbers_of_attacked_cities[0]]\nfor i in range(n):\n    if important_cities[i] and lower>distances1[i]:\n        lower=distances1[i]\n\ncenters=[]\nfor i in range(n):\n    if distances1[i]==lower:\n        centers.append(i)\n\nposibles_begin_cities=[]\n\nfor i in centers:\n    distances_center=BFS(i)\n    max_distance=0\n    for j in range(n):\n        if distances_center[j]>max_distance:\n            max_distance=distances_center[j]\n    for j in range(n):\n        if distances_center[j]==max_distance:\n            posibles_begin_cities.append(j)\n\nprint(min(posibles_begin_cities)+1)\n\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))\n</ans>", "format_properties": {}}
{"idx": 84, "result": 0, "generated": "<ans>\ndef local_right_to_global(test, local_right):\n    print(\"test: \", str(test), \"local_right: \", str(local_right))\n    return(len(test) + local_right)\n\ndef local_left_to_global(test, local_left):\n    print(\"test: \", str(test), \"local_left: \", str(local_left))\n    return(local_left)\n\ndef check_left(test, template, good_symbols):\n    print(\"test: \", str(test), \"template: \", str(template), \"good_symbols: \", str(good_symbols))\n    left_idx = -1\n    for symbol in template:\n        left_idx += 1\n        if symbol == '*':\n            print(\"left_idx: \", str(left_idx))\n            return(local_left_to_global(test, left_idx))\n        try:\n            if test[left_idx] != template[left_idx]:\n                if template[left_idx] != '?':\n                    print('NO')\n                    return('NO')\n                elif test[left_idx] not in good_symbols:\n                    print('NO')\n                    return('NO')\n        except:\n            print('NO')\n            return('NO')\n\ndef check_right(test, template, good_symbols):\n    print(\"test: \", str(test), \"template: \", str(template), \"good_symbols: \", str(good_symbols))\n    right_idx = 0\n    for symbol in reversed(template):\n        right_idx -= 1\n        if symbol == '*':\n            print(\"right_idx: \", str(right_idx))\n            return(local_right_to_global(test, right_idx))\n        try:\n            if test[right_idx] != template[right_idx]:\n                if template[right_idx] != '?':\n                    print('NO')\n                    return('NO')\n                elif test[right_idx] not in good_symbols:\n                    print('NO')\n                    return('NO')\n        except:\n            print('NO')\n            return('NO')\n\ngood_symbols = set(list(input()))\nprint(\"good_symbols: \", str(good_symbols))\ntemplate = input()\nprint(\"template: \", str(template))\ntests_nr = int(input())\nprint(\"tests_nr: \", str(tests_nr))\ntests = []\nfor _ in range(tests_nr):\n    tests.append(input())\nprint(\"tests: \", str(tests))\n\nabaca = '*' not in template\nprint(\"abaca: \", str(abaca))\nfor test in tests:\n    if abaca:\n        pos = -1\n        flag = True\n        if len(test) != len(template):\n            print('NO')\n            continue\n        for symbol in template:\n            pos += 1\n            try:\n                if test[pos] != template[pos]:\n                    if template[pos] != '?':\n                        print('NO')\n                        flag = False\n                        break\n                    elif test[pos] not in good_symbols:\n                        print('NO')\n                        flag = False\n                        break\n            except:\n                print('NO')\n                flag = False\n                break\n        if flag:\n            print('YES')\n        continue\n    left_idx = check_left(test, template, good_symbols)\n    right_idx = check_right(test, template, good_symbols)\n    print(\"left_idx: \", str(left_idx), \"right_idx: \", str(right_idx))\n    if left_idx == 'NO':\n        print('NO')\n    elif right_idx == 'NO':\n        print('NO')\n    else:\n        if right_idx < left_idx - 1:\n            print('NO')\n            continue\n        flag = True\n        for pos in range(left_idx, right_idx + 1):\n            if test[pos] in good_symbols:\n                print('NO')\n                flag = False\n                break\n        if flag:\n            print('YES')\n\n</ans>", "format_properties": {}}
{"idx": 83, "result": 0, "generated": "<ans>\nimport sys\nfrom functools import reduce\n\nzz=1\n\nsys.setrecursionlimit(10**5)\nprint(\"zz: \", str(zz))\nif zz:\n\tinput=sys.stdin.readline\nelse:\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef fori(n):\n\treturn [fi() for i in range(n)]\nprint(\"fori: \", str(fori))\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\nprint(\"inc: \", str(inc))\ndef ii():\n\treturn input().rstrip()\nprint(\"ii: \", str(ii))\ndef li():\n\treturn [int(xx) for xx in input().split()]\nprint(\"li: \", str(li))\ndef fli():\n\treturn [float(x) for x in input().split()]\nprint(\"fli: \", str(fli))\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\nprint(\"comp: \", str(comp))\ndef gi():\n\treturn [xx for xx in input().split()]\nprint(\"gi: \", str(gi))\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\nprint(\"gtc: \", str(gtc))\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\nprint(\"cil: \", str(cil))\ndef fi():\n\treturn int(input())\nprint(\"fi: \", str(fi))\ndef pro(a):\n\treturn reduce(lambda a,b:a*b,a)\nprint(\"pro: \", str(pro))\ndef swap(a,i,j):\n\ta[i],a[j]=a[j],a[i]\nprint(\"swap: \", str(swap))\ndef si():\n\treturn list(input().rstrip())\nprint(\"si: \", str(si))\ndef mi():\n\treturn \tlist(map(int,input().split()))\nprint(\"mi: \", str(mi))\ndef gh():\n\tsys.stdout.flush()\nprint(\"gh: \", str(gh))\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m\nprint(\"isvalid: \", str(isvalid))\ndef bo(i):\n\treturn ord(i)-ord('a')\nprint(\"bo: \", str(bo))\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\nprint(\"graph: \", str(graph))\n\nt=1\nuu=t\nprint(\"t: \", str(t))\nprint(\"uu: \", str(uu))\n\ndef can(val):\n\tp=val;c=0\n\tfor i in range(n):\n\t\tc+=abs(a[i]-p)\n\t\tp+=1\n\treturn c\nprint(\"can: \", str(can))\n\nwhile t>0:\n\tt-=1\n\tn=fi()\n\ta=li()\n\tprint(\"n: \", str(n))\n\tprint(\"a: \", str(a))\n\tl=-2*max(a)\n\tr=2*max(a)\n\tprint(\"l: \", str(l))\n\tprint(\"r: \", str(r))\n\tmini=10**18\n\tprint(\"mini: \", str(mini))\n\twhile l<=r:\n\t\tlmid=l+(r-l)//3\n\t\trmid=r-(r-l)//3\n\t\tp1=can(lmid)\n\t\tp2=can(rmid)\n\t\tmini=min([mini,p1,p2])\n\t\tif p1>=p2:\n\t\t\tl=lmid+1\n\t\telse:\n\t\t\tr=rmid-1\n\tprint(mini)\n\n</ans>", "format_properties": {}}
{"idx": 90, "result": 0, "generated": "<ans>\nimport collections, atexit, math, sys, bisect\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))\n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\ninId = 0\noutId = 0\nprint(\"inId: \", str(inId))\nprint(\"outId: \", str(outId))\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\nN, = getIntList()\nprint(\"N: \", str(N))\nre = 1\nmc = 1\nzc = []\nfor i in range(2, 10000):\n    if N%i != 0 : continue\n    re *= i\n    c = 0\n    while N%i==0:\n        N//=i\n        c+=1\n\n    zc.append(c)\nif N>1:\n    re*=N\n    zc.append(1)\nif zc:\n    mc = max(zc)\nt =1\nfor i in range(100):\n    if mc<=t:\n        break\n    t*=2\ndprint(t)\ndprint(zc)\ng = i\nfor x in zc:\n    if x<t:\n        g+=1\n        break\n\nprint(re,g)\n\n</ans>", "format_properties": {}}
{"idx": 85, "result": 0, "generated": "<ans>\nn = int(input())\nprint(\"n: \", str(n))\nx0, y0 = map(int, input().split())\nprint(\"x0: \", str(x0), \"y0: \", str(y0))\nNord = 10 ** 9 + 1\nprint(\"Nord: \", str(Nord))\nfNord = '-'\nprint(\"fNord: \", str(fNord))\nEast = 10 ** 9 + 1\nprint(\"East: \", str(East))\nfEast = '-'\nprint(\"fEast: \", str(fEast))\nSouth = -10 ** 9 - 1\nprint(\"South: \", str(South))\nfSouth = '-'\nprint(\"fSouth: \", str(fSouth))\nWest = -10 ** 9 - 1\nprint(\"West: \", str(West))\nfWest = '-'\nprint(\"fWest: \", str(fWest))\n\nNE = 10 ** 9 + 1\nprint(\"NE: \", str(NE))\nfNE = '-'\nprint(\"fNE: \", str(fNE))\nNW = 10 ** 9 + 1\nprint(\"NW: \", str(NW))\nfNW = '-'\nprint(\"fNW: \", str(fNW))\nSE = -10 ** 9 - 1\nprint(\"SE: \", str(SE))\nfSE = '-'\nprint(\"fSE: \", str(fSE))\nSW = -10 ** 9 - 1\nprint(\"SW: \", str(SW))\nfSW = '-'\nprint(\"fSW: \", str(fSW))\n\nfor i in range(n):\n    f, x, y = input().split()\n    x = int(x)\n    y = int(y)\n    if x == x0:\n        if y0 < y < Nord:\n            fNord = f\n            Nord = y\n            print(\"fNord: \", str(fNord), \"Nord: \", str(Nord))\n        elif y0 > y > South:\n            fSouth = f\n            South = y\n            print(\"fSouth: \", str(fSouth), \"South: \", str(South))\n    if y == y0:\n        if x0 < x < East:\n            fEast = f\n            East = x\n            print(\"fEast: \", str(fEast), \"East: \", str(East))\n        elif x0 > x > West:\n            fWest = f\n            West = x\n            print(\"fWest: \", str(fWest), \"West: \", str(West))\n\n    if x + y == x0 + y0:\n        if y0 < y < NW:\n            fNW = f\n            NW = y\n            print(\"fNW: \", str(fNW), \"NW: \", str(NW))\n        elif y0 > y > SE:\n            fSE = f\n            SE = y\n            print(\"fSE: \", str(fSE), \"SE: \", str(SE))\n    if x - y == x0 - y0:\n        if y0 < y < NE:\n            fNE = f\n            NE = y\n            print(\"fNE: \", str(fNE), \"NE: \", str(NE))\n        elif y0 > y > SW:\n            fSW = f\n            SW = y\n            print(\"fSW: \", str(fSW), \"SW: \", str(SW))\n\nans  = False\nprint(\"ans: \", str(ans))\nif fSW == 'Q' or fSE == 'Q' or fNW == 'Q' or fNE == 'Q':\n    ans = True\n    print(\"ans: \", str(ans))\nif fNord == 'Q' or fSouth == 'Q' or fWest == 'Q' or fEast == 'Q':\n    ans = True\n    print(\"ans: \", str(ans))\nif fSW == 'B' or fSE == 'Q' or fNW == 'B' or fNE == 'B':\n    ans = True\n    print(\"ans: \", str(ans))\nif fNord == 'R' or fSouth == 'R' or fWest == 'R' or fEast == 'R':\n    ans = True\n    print(\"ans: \", str(ans))\n\nprint('YES' if ans else 'NO')\n</ans>", "format_properties": {}}
{"idx": 87, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\n\n\nclass CantException(Exception):\n    pass\n\n\ndef odd_v(value):\n    return 1 if value % 2 == 1 else -1\n\nchange_idx = 1\n\nacceptable = {-1: set(), 1: set()}\n\nprint(\"change_idx: \", str(change_idx))\nprint(\"acceptable: \", str(acceptable))\n\ndef change(card_values, oddv, m):\n    nonlocal change_idx\n\n    if acceptable[oddv]:\n        res = acceptable[oddv].pop()\n        card_values.add(res)\n        print(\"card_values: \", str(card_values))\n        return res\n\n    change_idx_start = change_idx\n\n    while change_idx in card_values or odd_v(change_idx) != oddv:\n        if change_idx not in card_values:\n            acceptable[odd_v(change_idx)].add(change_idx)\n            print(\"acceptable[odd_v(change_idx)]: \", str(acceptable[odd_v(change_idx)]))\n        change_idx += 1\n        if change_idx > m:\n            change_idx = 1\n        if change_idx == change_idx_start:\n            raise CantException()\n\n    res = change_idx\n    card_values.add(res)\n    print(\"card_values: \", str(card_values))\n\n    change_idx += 1\n    if change_idx > m:\n        change_idx = 1\n    return res\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    cards = list(map(int, input().split()))\n\n    odd_balance = 0\n    card_values = set()\n    indices_to_be_changed = set()\n\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n        if c in card_values:\n            indices_to_be_changed.add(i)\n        card_values.add(c)\n\n    print(\"indices to be changed: \", str(indices_to_be_changed))\n    change_count = len(indices_to_be_changed)\n\n    for i in indices_to_be_changed:\n        if odd_v(cards[i]) * odd_balance <= 0:\n            print(\"Changing \", cards[i])\n            cards[i] = change(card_values, odd_v(cards[i]), m)\n            print(\"Changed to \", cards[i])\n        else:\n            print(\"For the balance changing \", cards[i])\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, - odd_v(cards[i]), m)\n            print(\"Changed to \", cards[i])\n\n    print(\"current odd balance:\", odd_balance)\n    for i in range(len(cards)):\n        if odd_balance == 0:\n            break\n        if odd_v(cards[i]) * odd_balance > 0:\n            print(\"gonna change\")\n            change_count += 1\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, -odd_v(cards[i]), m)\n\n    odd_balance = 0\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n    if odd_balance != 0:\n        print(odd_balance)\n        print(\"WTFFFFF\")\n\n    return change_count, cards\n\ndef __starting_point():\n    try:\n        change_cnt, cards = solve()\n        print(change_cnt)\n        print(\" \".join(map(str, cards)))\n    except CantException:\n        print(\"-1\")\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 88, "result": 0, "generated": "<ans>\ndef dp(ind, max_covered):\n\tmax_covered = min(m, max_covered)\n\n\tif ind not in cache:\n\t\tcache[ind] = {}\n\n\td = cache[ind]\n\tif max_covered in d:\n\t\treturn d[max_covered]\n\n\tans = blah(ind, max_covered)\n\n\td[max_covered] = ans\n\tprint(\"cache[ind]: \", str(cache[ind]))\n\treturn ans\n\n\n# path = {}\n\nclass Node:\n\tdef __init__(self, key, val, next=None):\n\t\tself.key = key\n\t\tself.val = val\n\t\tself.next = next\n\ndef blah(ind, max_covered):\n\tx, s = antenna[ind]\n\t# key = (ind, max_covered)\n\n\tif max_covered >= m:\n\t\t# path[key] = Node(key, 0)\n\t\treturn 0\n\n\tif ind == len(antenna) - 1:\n\t\tif max_covered < x - s - 1:\n\t\t\tleft_needed = x - s - (max_covered + 1)\n\t\t\tright_needed = max(m - (x + s), 0)\n\t\t\tans = max(left_needed, right_needed)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\t\telse:\n\t\t\tright_boundary = max(max_covered, x + s)\n\t\t\tans = max(0, m - right_boundary)\n\t\t\t# path[key] = Node(key, ans)\n\t\t\treturn ans\n\n\tif max_covered < x - s - 1:\n\t\tnum_needed = x - s - (max_covered + 1)\n\t\tnew_boundary = min(x + s + num_needed, m)\n\t\tuse_i = num_needed + dp(ind + 1, new_boundary)\n\t\tdont_use_i = dp(ind + 1, max_covered)\n\n\t\t# if use_i < dont_use_i:\n\t\t# \tpath[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])\n\t\t# else:\n\t\t# \tpath[key] = Node(key, 0, path[(ind + 1, max_covered)])\n\n\t\treturn min(use_i, dont_use_i)\n\telse:\n\t\tnew_boundary = min(max(max_covered, x + s), m)\n\t\tans = dp(ind + 1, new_boundary)\n\t\t# path[key] = Node(key, 0, path[(ind + 1, new_boundary)])\n\t\treturn ans\n\nimport sys\n\ncache = {}\n\nn, m = [int(x) for x in sys.stdin.readline().split(\" \")]\n\nantenna = []\n\nfor i in range(n):\n\tx, s = [int(x) for x in sys.stdin.readline().split(\" \")]\n\n\tantenna.append((x, s))\n\nantenna.sort(key=lambda a: a[0])\n\nprint(dp(0, 0))\n\n</ans>", "format_properties": {}}
{"idx": 97, "result": 0, "generated": "<ans>\nN, K = readInts()\nprint(\"N: \", str(N), \"K: \", str(K))\ndef calc(n):\n    print(\"n: \", str(n))\n    if n <= 0 or n > 2*N:\n        return 0\n    else:\n        return min(n-1, 2*N-n+1)\nans = 0\nfor AB in range(2*N+1):\n    print(\"AB: \", str(AB))\n    #print(AB,calc(AB),AB-K, calc(K-AB))\n    ans += calc(AB) * calc(AB-K)\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 91, "result": 0, "generated": "<ans>\n#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\nfrom fractions import *\nfrom bisect import *\nfrom heapq import*\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=1000000007\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\nvsInput()\n\nn, m, o = value()\nprint(\"n: \", str(n), \"m: \", str(m), \"o: \", str(o))\nfor i in range(n):\n    input()\n\nprint(\"m*(m-1)//2: \", str(m*(m-1)//2))\nfor i in range(1, m+1):\n    for j in range(i+1, m+1):\n        if(o == 0):\n            print(\"i: \", str(i), \"j: \", str(j))\n        else:\n            print(\"m-i+1: \", str(m-i+1), \"m-j+1: \", str(m-j+1))\n</ans>", "format_properties": {}}
{"idx": 89, "result": 0, "generated": "<ans>\nimport math;\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u043f\u043e \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c \u0446\u0435\u043d\u0442\u0440\u0430, \u0443\u0433\u043b\u0443, \u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u043c \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0446\u0435\u043d\u0442\u0440\u0430\ndef getCoordinate(gx, gy, alpha, x, y):\n    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);\n    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);\n    print(\"x1: \", str(x1), \"y1: \", str(y1))\n    return x1, y1\n#\u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0443\u0433\u043b\u0430, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0442\u043e\u0447\u043a\u0443 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438 x, y,\n#\u0447\u0442\u043e\u0431\u044b \u043e\u043d\u0430 \u043e\u043a\u0430\u0437\u0430\u043b\u0430\u0441\u044c \u043f\u0440\u044f\u043c\u043e \u043d\u0430\u0434 gx, gy\ndef getAngle(gx, gy, x, y):\n    x=x-gx;\n    y=y-gy;\n    cos=x/math.sqrt(x**2+y**2);\n    alpha=math.acos(cos);\n    if y<0:\n        alpha=-alpha;\n    print(\"alpha: \", str(alpha))\n    return math.pi/2-alpha;\nn, q = list(map(int, input().split(' ')));\nprint(\"n: \", str(n), \"q: \", str(q))\nx=[0]*n;\ny=[0]*n;\nfor i in range(n):\n    x[i], y[i]=list(map(int, input().split(' ')));\nprint(\"x: \", str(x), \"y: \", str(y))\nr=[0]*q;\nf=[0]*q;\nt=[0]*q;\nv=[0]*q;\nfor i in range(q):\n    l=list(map(int, input().split(' ')));\n    r[i]=l[0];\n    if r[i]==1:\n        f[i]=l[1]-1;\n        t[i]=l[2]-1;\n    else:\n        v[i]=l[1]-1;\nprint(\"r: \", str(r), \"f: \", str(f), \"t: \", str(t), \"v: \", str(v))\ngx=0;\ngy=0;\ns=0;\nfor i in range(n):\n    ip=i+1;\n    if ip==n:\n        ip=0;\n    ds=x[i]*y[ip]-x[ip]*y[i];\n    s+=ds;\n    gx+=(x[i]+x[ip])*ds;\n    gy+=(y[i]+y[ip])*ds;\ns/=2;\ngx/=6*s;\ngy/=6*s;\nprint(\"gx: \", str(gx), \"gy: \", str(gy))\nangles=[0]*n;\nfor i in range(n):\n    angles[i]=getAngle(gx, gy, x[i], y[i]);\nprint(\"angles: \", str(angles))\nfor i in range(n):\n    x[i]-=gx;\n    y[i]-=gy;\nalpha=0;\n#print('pos',gx, gy, alpha);\n#\u0412\u043e\u0441\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u0435\u043a \u0431\u0443\u0434\u0435\u043c \u043f\u043e \u0446\u0435\u043d\u0442\u0440\u0443 \u043c\u0430\u0441\u0441 \u0438 \u0443\u0433\u043b\u0443\n#\u0423\u0433\u043e\u043b - \u043f\u043e\u0432\u043e\u0440\u043e\u0442 \u043f\u0440\u043e\u0442\u0438\u0432 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u0432\u043e\u043a\u0440\u0443\u0433 \u0446\u0435\u043d\u0442\u0440\u0430 \u043c\u0430\u0441\u0441\nfix={0, 1}\nfor i in range(q):\n    if r[i]==2:\n        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);\n        print(\"currX: \", str(currX), \"currY: \", str(currY))\n    else:\n        if len(fix)==2:\n            fix.remove(f[i]);\n        #print('remove',f[i])\n        #j - \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0432 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0435\n        for j in fix:\n            #print(j);\n            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);\n            #print('fix:', currX, currY)\n            #dalpha=getAngle(gx, gy, currX, currY);\n            #alpha+=dalpha;\n            alpha=angles[j];\n            #\u0427\u0442\u043e\u0431\u044b \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b g, \u043d\u0443\u043d\u043e \u043f\u043e\u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0435\u0435 \u043d\u0430 \u0443\u0433\u043e\u043b\n            #dalpha \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e currX, currY\n            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);\n            print(\"gx: \", str(gx), \"gy: \", str(gy), \"alpha: \", str(alpha/math.pi))\n        fix.add(t[i]);\n</ans>", "format_properties": {}}
{"idx": 92, "result": 0, "generated": "<ans>\ndef solve1(a, n):\n    left = []\n    st = []\n    i = 0\n    while i < (n):\n        if not st:\n            left.append(-1)\n            st.append(i)\n        elif st and a[i] < a[st[-1]]:\n            left.append(st[-1])\n            st.append(i)\n        else:\n            while st and a[i] > a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                left.append(-1)\n            else:\n                left.append(st[-1])\n                st.append(i)\n        i += 1\n    print(\"left: \", str(left))\n    right = []\n    st = []\n    i = n - 1\n    while i > (-1):\n        if not st:\n            right.append(n)\n            st.append(i)\n        elif st and a[i] < a[st[-1]]:\n            right.append(st[-1])\n            st.append(i)\n        else:\n            while st and a[i] >= a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                right.append(n)\n            else:\n                right.append(st[-1])\n                st.append(i)\n        i -= 1\n    right = right[::-1]\n    print(\"right: \", str(right))\n    c = 0\n    for i in range(len(left)):\n        x = (right[i] - i) * (i - left[i]) * a[i]\n        print(\"x: \", str(x))\n        if x == 0:\n            c += a[i]\n        else:\n            c += x\n    print(\"c: \", str(c))\n    return c\n\ndef solve2(a, n):\n    left = []\n    st = []\n    i = 0\n    while i < (n):\n        if not st:\n            left.append(-1)\n            st.append(i)\n        elif st and a[i] > a[st[-1]]:\n            left.append(st[-1])\n            st.append(i)\n        else:\n            while st and a[i] < a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                left.append(-1)\n            else:\n                left.append(st[-1])\n                st.append(i)\n        i += 1\n    print(\"left: \", str(left))\n    right = []\n    st = []\n    i = n - 1\n    while i > (-1):\n        if not st:\n            right.append(n)\n            st.append(i)\n        elif st and a[i] > a[st[-1]]:\n            right.append(st[-1])\n            st.append(i)\n        else:\n            while st and a[i] <= a[st[-1]]:\n                st.pop()\n            if not st:\n                st.append(i)\n                right.append(n)\n            else:\n                right.append(st[-1])\n                st.append(i)\n        i -= 1\n    right = right[::-1]\n    print(\"right: \", str(right))\n    c = 0\n    for i in range(len(left)):\n        x = (right[i] - i) * (i - left[i]) * a[i]\n        print(\"x: \", str(x))\n        if x == 0:\n            c += a[i]\n        else:\n            c += x\n    print(\"c: \", str(c))\n    return c\n\nn = int(input())\narr = [int(x) for x in input().split()]\nprint(\"n: \", str(n))\nprint(\"arr: \", str(arr))\nprint(solve1(arr, n) - solve2(arr, n))\n</ans>", "format_properties": {}}
{"idx": 95, "result": 0, "generated": "<ans>\nfrom queue import Queue\nimport sys\n#sys.stdin = open('input.txt')\n\nn, m, k = [int(x) for x in input().split(' ')]\nprint(\"n: \", str(n), \"m: \", str(m), \"k: \", str(k))\n\nif k&1:\n  print('IMPOSSIBLE')\n  return\n\ns = [None]*n\nfor i in range(n):\n  s[i] = [None]*m\n  t = input()\n  for j in range(m):\n    s[i][j] = t[j]\n    if t[j] == 'X': x, y = j, i\nprint(\"x: \", str(x), \"y: \", str(y))\n\ndef bfs(x, y):\n  res = [[10000000]*m for i in range(n)]\n  if s[y][x] == '*': return res\n  q = Queue()\n  q.put((x, y))\n  step = 0\n\n  def add(x, y):\n    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return\n    q.put((x, y))\n    res[y][x] = step+1\n\n  res[y][x] = step\n\n  while not q.empty():\n    x, y = q.get()\n    step = res[y][x]\n    #print('-')\n    if y < n-1: add(x, y+1) #D\n    if x > 0: add(x-1, y)   #L\n    if x < m-1: add(x+1, y) #R\n    if y > 0: add(x, y-1)   #U\n  return res\n\nres = bfs(x, y)\nprint(\"res: \", str(res))\n\npath = []\nadd = lambda s: path.append(s)\nfor i in range(k):\n  step = k-i\n  #print(step, (y, x), k-i)\n  if y < n-1 and res[y+1][x] <= step: #D\n    add('D')\n    y = y+1\n  elif x > 0 and res[y][x-1] <= step: #L\n    add('L')\n    x = x-1\n  elif x < m-1 and res[y][x+1] <= step: #R\n    add('R')\n    x = x+1\n  elif y > 0 and res[y-1][x] <= step: #U\n    add('U')\n    y = y-1\n  else:\n    print('IMPOSSIBLE')\n    return\n\nprint(\"path: \", str(path))\nprint(str.join('', path))\n\n</ans>", "format_properties": {}}
{"idx": 94, "result": 0, "generated": "<ans>\nimport math\nfrom decimal import Decimal\nimport heapq\nfrom collections import deque\ndef na():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\treturn n,b\n\ndef nab():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tc = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\tprint(\"c: \", str(c))\n\treturn n,b,c\n\ndef dv():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\treturn n,m\n\ndef dva():\n\tn, m = list(map(int, input().split()))\n\ta = [int(x) for x in input().split()]\n\tb = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\tprint(\"a: \", str(a))\n\tprint(\"b: \", str(b))\n\treturn n,m,b\n\ndef eratosthenes(n):\n\tsieve = list(range(n + 1))\n\tprint(\"sieve: \", str(sieve))\n\tfor i in sieve:\n\t\tif i > 1:\n\t\t\tfor j in range(i + i, len(sieve), i):\n\t\t\t\tsieve[j] = 0\n\treturn sorted(set(sieve))\n\ndef lol(lst,k):\n\tk=k%len(lst)\n\tret=[0]*len(lst)\n\tprint(\"lst: \", str(lst))\n\tprint(\"k: \", str(k))\n\tprint(\"ret: \", str(ret))\n\tfor i in range(len(lst)):\n\t\tif i+k<len(lst) and i+k>=0:\n\t\t\tret[i]=lst[i+k]\n\t\tif i+k>=len(lst):\n\t\t\tret[i]=lst[i+k-len(lst)]\n\t\tif i+k<0:\n\t\t\tret[i]=lst[i+k+len(lst)]\n\treturn(ret)\n\ndef nm():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tm = int(input())\n\tc = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\tprint(\"m: \", str(m))\n\tprint(\"c: \", str(c))\n\treturn n,b,m,c\n\ndef dvs():\n\tn = int(input())\n\tm = int(input())\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\treturn n, m\n\ndef fact(a, b):\n\tc = []\n\tans = 0\n\tf = int(math.sqrt(a))\n\tprint(\"a: \", str(a))\n\tprint(\"b: \", str(b))\n\tprint(\"c: \", str(c))\n\tprint(\"ans: \", str(ans))\n\tprint(\"f: \", str(f))\n\tfor i in range(1, f + 1):\n\t\tif a % i == 0:\n\t\t\tc.append(i)\n\tl = len(c)\n\tfor i in range(l):\n\t\tc.append(a // c[i])\n\tfor i in range(len(c)):\n\t\tif c[i] <= b:\n\t\t\tans += 1\n\tif a / f == f and b >= f:\n\t\treturn ans - 1\n\treturn ans\n\nt = int(input())\nfor i in range(t):\n\tx, y = list(map(int, input().split()))\n\tprint(\"x: \", str(x))\n\tprint(\"y: \", str(y))\n\tif x >= y:\n\t\tprint('YES')\n\t\tcontinue\n\tif x == 2 and y == 3:\n\t\tprint('YES')\n\t\tcontinue\n\telif x <= 3 and y > 3:\n\t\tprint('NO')\n\t\tcontinue\n\tif x == 1:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n</ans>", "format_properties": {}}
{"idx": 98, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\nprint(\"int1: \", str(int1))\ndef II(): return int(input())\nprint(\"II: \", str(II))\ndef MI(): return list(map(int, input().split()))\nprint(\"MI: \", str(MI))\ndef MI1(): return list(map(int1, input().split()))\nprint(\"MI1: \", str(MI1))\ndef LI(): return list(map(int, input().split()))\nprint(\"LI: \", str(LI))\ndef LI1(): return list(map(int1, input().split()))\nprint(\"LI1: \", str(LI1))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\nprint(\"LLI: \", str(LLI))\ndef MS(): return input().split()\nprint(\"MS: \", str(MS))\ndef LS(): return list(input())\nprint(\"LS: \", str(LS))\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\nprint(\"LLS: \", str(LLS))\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nprint(\"printlist: \", str(printlist))\nINF = float('inf')\nprint(\"INF: \", str(INF))\n# from math import ceil, floor, log2\n# from collections import deque\nfrom itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np\n# from numpy import cumsum  # accumulate\n\ndef solve():\n    N, K = MI()\n    print(\"N: \", str(N), \"K: \", str(K))\n    A = LI()\n    print(\"A: \", str(A))\n\n    M = sum(A)\n    print(\"M: \", str(M))\n    divs = []\n    for i in range(1, int(pow(M, 0.5))+1):\n        if M % i: continue\n        divs.append(i)\n        if i != M//i: divs.append(M//i)\n    divs.sort(reverse=True)\n    print(\"divs: \", str(divs))\n\n    for d in divs:\n        B = list([x%d for x in A])\n        print(\"B: \", str(B))\n        B.sort()\n        C = list([d-x for x in B])\n        print(\"C: \", str(C))\n        Ba = list(accumulate(B))\n        print(\"Ba: \", str(Ba))\n        Ca = list(accumulate(C))\n        print(\"Ca: \", str(Ca))\n        for i in range(0, N-1):\n            b = Ba[i]\n            c = Ca[-1] - Ca[i]\n            print(\"b: \", str(b), \"c: \", str(c))\n            if b == c and b <= K:\n                print(d)\n                return\n    print((1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 100, "result": 0, "generated": "<ans>\nimport sys\n\ninp = sys.stdin.readline\ninput = lambda: inp().strip()\n\n# flush= sys.stdout.flush\n# import threading\n# sys.setrecursionlimit(10**6)\n# threading.stack_size(2**26)\n\ndef iin(): return int(input())\n\ndef lin(): return list(map(int, input().split()))\n\ndef main():\n    import heapq as hq\n    n = iin()\n    print(\"n: \", str(n))\n    a = lin()\n    print(\"a: \", str(a))\n    t = lin()\n    print(\"t: \", str(t))\n    dc = {}\n    for i in range(n):\n        try:\n            dc[a[i]].append(t[i])\n        except:\n            dc[a[i]] = [t[i], ]\n    print(\"dc: \", str(dc))\n    sa = list(dc.keys())\n    print(\"sa: \", str(sa))\n    sa.sort()\n    print(\"sa (sorted): \", str(sa))\n    n = len(sa)\n    ch = 0\n    pt = sa[ch]\n    temp = []\n    sm = 0\n    ans = 0\n    hq.heapify(temp)\n    done = 0\n    while ch < n:\n        # print(temp, sa[ch])\n        pt = sa[ch]\n        if len(dc[pt]) > 1 or done:\n            a1 = sorted(dc[pt])\n            for item in a1:\n                hq.heappush(temp, -item)\n                sm += item\n            x = hq.heappop(temp) * (-1)\n            dc[pt] = [x]\n            sm -= x\n            while len(temp):\n                # print('A', ch, pt, temp )\n                ans += sm\n                pt += 1\n                if pt in dc:\n                    ch += 1\n                    done = 1\n                    break\n                else:\n                    x = hq.heappop(temp) * (-1)\n                    sm -= x\n            else:\n                done = 0\n        else:\n            ch += 1\n            done = 0\n    # print(dc)\n    print(\"ans: \", str(ans))\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 99, "result": 0, "generated": "<ans>\nimport sys\n\ndef matching(node, visited, adj, assigned):\n\tif node == -1:\n\t\treturn True\n\tif visited[node]:\n\t\treturn False\n\tvisited[node] = True\n\tprint(\"visited: \", str(visited))\n\tfor neighbor in adj[node]:\n\t\tif matching(assigned[neighbor], visited, adj, assigned):\n\t\t\tassigned[neighbor] = node\n\t\t\tprint(\"assigned: \", str(assigned))\n\t\t\treturn True\n\treturn False\n\nINF = 1000 * 1000\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nprint(\"inp: \", str(inp))\n\nn, m = inp[0], inp[1]\nprint(\"n: \", str(n), \"m: \", str(m))\ninp_idx = 2\n\nG = [[INF] * n for _ in range(n)]\n\nprint(\"G: \", str(G))\n\nfor _ in range(m):\n\ta, b = inp[inp_idx] - 1, inp[inp_idx + 1] - 1\n\tinp_idx += 2\n\tG[a][b] = G[b][a] = 1\n\nfor v in range(n):\n\tG[v][v] = 0\n\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j])\n\ns, b, k, h = inp[inp_idx], inp[inp_idx + 1], inp[inp_idx + 2], inp[inp_idx + 3]\nprint(\"s: \", str(s), \"b: \", str(b), \"k: \", str(k), \"h: \", str(h))\ninp_idx += 4\n\nspaceships = []\nfor _ in range(s):\n\tx, a, f = inp[inp_idx] - 1, inp[inp_idx + 1], inp[inp_idx + 2]\n\tinp_idx += 3\n\tspaceships.append((x, a, f))\n\tprint(\"spaceships: \", str(spaceships))\n\nbases = []\nfor _ in range(b):\n\tx, d = inp[inp_idx] - 1, inp[inp_idx + 1]\n\tinp_idx += 2\n\tbases.append((x, d))\n\tprint(\"bases: \", str(bases))\n\nadj = [[] for _ in range(s)]\nassigned = [[] for _ in range(b)]\nfor i in range(s):\n\tspace = spaceships[i]\n\tfor j in range(b):\n\t\tbase = bases[j]\n\t\tu, v = space[0], base[0]\n\t\tfuel = space[2]\n\t\tif G[u][v] <= fuel and space[1] >= base[1]:\n\t\t\tadj[i].append(j)\n\tprint(\"adj: \", str(adj))\n\tprint(\"assigned: \", str(assigned))\n\nvisited = [False] * s\nassigned = [-1] * b\n\nmatched = 0\nfor i in range(s):\n\tvisited = [False] * s\n\tif matching(i, visited, adj, assigned):\n\t\tmatched += 1\n\nprint(\"matched: \", str(matched))\n\nprint(min(matched * k, h * s))\n</ans>", "format_properties": {}}
{"idx": 102, "result": 0, "generated": "<ans>\n```\ndef add(a,b):\n\ta = a%(1000000000+7)\n\tb=b%(1000000000+7)\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a+b)%(1000000000+7)\n\nn  =int(input())\nprint(\"n: \", str(n))\ni=1\nstatements = []\ndp = [[0 for i in range(n)] for i in range(n)]\nprefix = [[0 for i in range(n)] for i in range(n)]\nwhile(i<=n):\n\ts = input()\n\tstatements.append(s)\n\ti+=1\n\ndp[0][0]=1\nprefix[0][0]=1\nj=1\nwhile(j<n):\n\tdp[0][j]=0\n\tprefix[0][j] = dp[0][j] + prefix[0][j-1]\n\tj+=1\n\ni=1\nwhile(i<n):\n\tif(statements[i-1]=='f'):\n\t\tj=1\n\t\twhile(j<n):\n\t\t\tdp[i][0]=0\n\t\t\tprefix[i][0]=0\n\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\t\t\tprint(\"dp[i][j]: \", str(dp[i][j]), \"prefix[i][j]: \", str(prefix[i][j]))\n\t\t\tj+=1\n\telse:\n\t\tj=0\n\t\twhile(j<n):\n\t\t\tif(j==0):\n\t\t\t\tdp[i][j] = prefix[i-1][n-1]\n\t\t\telse:\n\t\t\t\tdp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]\n\t\t\tprefix[i][j] = add(prefix[i][j-1],dp[i][j])\n\t\t\tprint(\"dp[i][j]: \", str(dp[i][j]), \"prefix[i][j]: \", str(prefix[i][j]))\n\t\t\tj+=1\n\ti+=1\n\nans = 0\nj=0\nwhile(j<n):\n\tans=add(ans,dp[n-1][j])\n\tj+=1\n\nprint(\"ans: \", str(ans%(1000000000+7)))\n```\n</ans>", "format_properties": {}}
{"idx": 101, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport itertools\nimport functools\nimport collections\nimport operator\nimport fileinput\nimport copy\n\nORDA = 97\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return [int(i) for i in input().split()]\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef revn(n): return str(n)[::-1]\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\ndef sieve(n):\n    print(\"n: \", str(n))\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    print(\"prime: \", str(prime))\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    print(\"r: \", str(r))\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\ndef divs(n, start=1):\n    print(\"n: \", str(n))\n    print(\"start: \", str(start))\n    r = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if (n % i == 0):\n            if (n / i == i):\n                r.append(i)\n            else:\n                r.extend([i, n // i])\n    return r\ndef divn(n, primes):\n    print(\"n: \", str(n))\n    print(\"primes: \", str(primes))\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\ndef prime(n):\n    print(\"n: \", str(n))\n    if n == 2: return True\n    if n % 2 == 0 or n <= 1: return False\n    sqr = int(math.sqrt(n)) + 1\n    print(\"sqr: \", str(sqr))\n    for d in range(3, sqr, 2):\n        if n % d == 0: return False\n    return True\ndef convn(number, base):\n    print(\"number: \", str(number))\n    print(\"base: \", str(base))\n    newnumber = 0\n    while number > 0:\n        newnumber += number % base\n        number //= base\n    return newnumber\ndef cdiv(n, k): return n // k + (n % k != 0)\n\nfor _ in range(ii()):\n    a, b = mi()\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    print(b - a % b) if a % b else print(0)\n</ans>", "format_properties": {}}
{"idx": 93, "result": 0, "generated": "<ans>\nimport math\nN=int(input())\n\ndef get_circle_2p(p1,p2):\n  x1,y1=p1\n  x2,y2=p2\n\n  print(\"x1: \", str(x1), \"y1: \", str(y1), \"x2: \", str(x2), \"y2: \", str(y2))\n\n  x=(x1+x2)/2\n  y=(y1+y2)/2\n  print(\"x: \", str(x), \"y: \", str(y))\n\n  r=math.sqrt((x1-x2)**2+(y1-y2)**2)/2\n  print(\"r: \", str(r))\n  return x,y,r\n\ndef get_circle_3p(p1,p2,p3):\n  x1,y1=p1\n  x2,y2=p2\n  x3,y3=p3\n  print(\"x1: \", str(x1), \"y1: \", str(y1), \"x2: \", str(x2), \"y2: \", str(y2), \"x3: \", str(x3), \"y3: \", str(y3))\n\n  d=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))\n  print(\"d: \", str(d))\n\n  if d==0:\n    rad1=math.sqrt((x1-x2)**2+(y1-y2)**2)/2\n    rad2=math.sqrt((x1-x3)**2+(y1-y3)**2)/2\n    rad3=math.sqrt((x2-x3)**2+(y2-y3)**2)/2\n    print(\"rad1: \", str(rad1), \"rad2: \", str(rad2), \"rad3: \", str(rad3))\n\n    if rad1>=rad2 and rad1>=rad3:\n      x=(x1+x2)/2\n      y=(y1+y2)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad1\n    elif rad2>=rad1 and rad2>=rad3:\n      x=(x1+x3)/2\n      y=(y1+y3)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad2\n    elif rad3>=rad1 and rad3>=rad2:\n      x=(x2+x3)/2\n      y=(y2+y3)/2\n      print(\"x: \", str(x), \"y: \", str(y))\n      return x,y,rad3\n  else:\n    x=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/d\n    y=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-d\n    print(\"x: \", str(x), \"y: \", str(y))\n\n    r=math.sqrt((x-x1)**2+(y-y1)**2)\n    print(\"r: \", str(r))\n    return x,y,r\n\nxylist=[]\nfor i in range(N):\n  xi,yi=map(int,input().split())\n  print(\"xi: \", str(xi), \"yi: \", str(yi))\n  xylist.append((xi,yi))\n\n#print(xylist)\n\nif N==2:\n  x,y,r=get_circle_2p(xylist[0],xylist[1])\n  print(\"x: \", str(x), \"y: \", str(y), \"r: \", str(r))\n  print(r)\nelse:\n  min_radius=float(\"inf\")\n  for i in range(N):\n    for j in range(i+1,N):\n      #print(xylist[i],xylist[j])\n      x,y,r=get_circle_2p(xylist[i],xylist[j])\n      print(\"x: \", str(x), \"y: \", str(y), \"r: \", str(r))\n      if r>min_radius:\n        continue\n\n      for l in range(N):\n        if l==i or l==j:\n          continue\n\n        xl,yl=xylist[l]\n        print(\"xl: \", str(xl), \"yl: \", str(yl))\n\n        diff_xl=xl-x\n        diff_yl=yl-y\n        print(\"diff_xl: \", str(diff_xl), \"diff_yl: \", str(diff_yl))\n\n        if math.sqrt(diff_xl**2+diff_yl**2)>r:\n          break\n      else:\n        min_radius=r\n\n  for i in range(N):\n    for j in range(i+1,N):\n      for k in range(j+1,N):\n        #print(xylist[i],xylist[j],xylist[k])\n        x,y,r=get_circle_3p(xylist[i],xylist[j],xylist[k])\n        print(\"x: \", str(x), \"y: \", str(y), \"r: \", str(r))\n        if r>min_radius:\n          continue\n\n        for l in range(N):\n          if l==i or l==j or l==k:\n            continue\n\n          xl,yl=xylist[l]\n          print(\"xl: \", str(xl), \"yl: \", str(yl))\n\n          diff_xl=xl-x\n          diff_yl=yl-y\n          print(\"diff_xl: \", str(diff_xl), \"diff_yl: \", str(diff_yl))\n\n          if math.sqrt(diff_xl**2+diff_yl**2)>r:\n            break\n        else:\n          min_radius=r\n\n  print(\"min_radius: \", str(min_radius))\n  print(min_radius)\n</ans>", "format_properties": {}}
{"idx": 103, "result": 0, "generated": "<ans>\ndef compute():\n    n, m = [int(s) for s in input().split()]\n    print(\"n: \", str(n), \"m: \", str(m))\n    p = {}\n    print(\"p: \", str(p))\n    for i in range(m):\n        u, v = [int(s) for s in input().split()]\n        print(\"u: \", str(u), \"v: \", str(v))\n        if u > v:\n            if p.get(u) == 2:\n                return 0\n            if p.get(v) == 1:\n                return 0\n            p[u] = 1\n            p[v] = 2\n        else:\n            if p.get(v) == 2:\n                return 0\n            if p.get(u) == 1:\n                return 0\n            p[v] = 1\n            p[u] = 2\n    div1, div2 = [], []\n    print(\"div1: \", str(div1), \"div2: \", str(div2))\n    for k, v in list(p.items()):\n        if v == 1:\n            div1.append(k)\n        else:\n            div2.append(k)\n    p_left = [i for i in range(1, n + 1) if i not in p]\n    print(\"p_left: \", str(p_left))\n    if not div1:\n        if p_left:\n            div1.append(p_left[-1])\n            p_left.remove(p_left[-1])\n        else:\n            return 0\n    if not div2:\n        if p_left:\n            div2.append(p_left[0])\n            p_left.remove(p_left[0])\n        else:\n            return 0\n    div1_easiest = min(div1)\n    div2_hardest = max(div2)\n    print(\"div1_easiest: \", str(div1_easiest), \"div2_hardest: \", str(div2_hardest))\n    if div2_hardest > div1_easiest:\n        return 0\n\n    res = 1\n    for i in range(len(p_left)):\n        if p_left[i] > div1_easiest:\n            pass\n        elif p_left[i] < div2_hardest:\n            pass\n        else:\n            res += 1\n\n    return res\nres = compute()\nprint(res)\n</ans>", "format_properties": {}}
{"idx": 96, "result": 0, "generated": "<ans>\nfrom collections import deque, namedtuple\nfrom heapq import *\nfrom sys import stdin\n\ninf = float('inf')\nEdge = namedtuple('Edge', 'start, end, cost')\n\ndef make_edge(start, end, cost=1):\n    print(\"start: \", str(start), \"end: \", str(end), \"cost: \", str(cost))\n    return Edge(start, end, cost)\n\nclass Graph:\n    def __init__(self, edges, bi=True):\n        wrong_edges = [i for i in edges if len(i) not in [2, 3]]\n        if wrong_edges:\n            raise ValueError('Wrong edges data: {}'.format(wrong_edges))\n        self.edges = [make_edge(*edge) for edge in edges]\n        print(\"self.edges: \", str(self.edges))\n        self.vertices = set(\n            sum(\n                ([edge.start, edge.end] for edge in self.edges), []\n            ))\n        print(\"self.vertices: \", str(self.vertices))\n        self.neighbors = {vertex: set() for vertex in self.vertices}\n        print(\"self.neighbors: \", str(self.neighbors))\n        for edge in self.edges:\n            self.neighbors[edge.start].add(edge.end)\n\n    def get_node_pairs(self, n1, n2, both_ends=True):\n        print(\"n1: \", str(n1), \"n2: \", str(n2), \"both_ends: \", str(both_ends))\n        if both_ends:\n            node_pairs = [[n1, n2], [n2, n1]]\n        else:\n            node_pairs = [[n1, n2]]\n        return node_pairs\n\n    def remove_edge(self, n1, n2, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        edges = self.edges[:]\n        for edge in edges:\n            if[edge.start, edge.end] in node_pairs:\n                self.edges.remove(edge)\n\n    def add_edge(self, n1, n2, cost=1, both_ends=True):\n        node_pairs = self.get_node_pairs(n1, n2, both_ends)\n        for edge in self.edges:\n            if [edge.start, edge.end] in node_pairs:\n                return ValueError('Edge {} {} already exists'.format(n1, n2))\n\n        self.edges.append(Edge(start=n1, end=n2, cost=cost))\n        print(\"self.edges: \", str(self.edges))\n        if both_ends:\n            self.edges.append(Edge(start=n2, end=n1, cost=cost))\n\n    def dijkstra(self, source, dest):\n        assert source in self.vertices, 'Such source node doesn\\'t exist'\n        distances = {vertex: inf for vertex in self.vertices}\n        distances[source] = 0\n        print(\"distances: \", str(distances))\n\n        q, seen = [(0, source)], set()\n        while q:\n            (curr_cost, current_vertex) = heappop(q)\n            if current_vertex in seen:\n                continue\n            seen.add(current_vertex)\n            for neighbor in self.neighbors[current_vertex]:\n                cost = 1\n                if neighbor in seen:\n                    continue\n                alternative_route = distances[current_vertex] + cost\n                if alternative_route < distances[neighbor]:\n                    distances[neighbor] = alternative_route\n                    heappush(q, (alternative_route, neighbor))\n\n        return distances\n\nn, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]\nprint(\"n: \", str(n), \"m: \", str(m), \"s: \", str(s), \"t: \", str(t))\n\nverts = []\nfor i in range(m):\n    verts.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))\nprint(\"verts: \", str(verts))\nrev_verts = []\nfor i in verts:\n    rev_verts.append((i[1], i[0]))\nfor i in rev_verts:\n    verts.append(i)\nprint(\"verts: \", str(verts))\ngraph = Graph(verts)\nprint(\"graph: \", str(graph))\ns_dist = graph.dijkstra(s, t)\nprint(\"s_dist: \", str(s_dist))\nt_dist = graph.dijkstra(t, s)\nprint(\"t_dist: \", str(t_dist))\nSHORTEST_DIST = s_dist[t]\nprint(\"SHORTEST_DIST: \", str(SHORTEST_DIST))\ncount = 0\n\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if j not in graph.neighbors[i] and \\\n                i not in graph.neighbors[j] and \\\n                s_dist[i] + t_dist[j] + 1 >= SHORTEST_DIST and \\\n                s_dist[j] + t_dist[i] + 1 >= SHORTEST_DIST:\n            count = count + 1\n\nprint(\"count: \", str(count))\n\n</ans>", "format_properties": {}}
{"idx": 108, "result": 0, "generated": "<ans>\nn = int(input())\nprint(\"n: \", str(n))\ns = input()\nprint(\"s: \", str(s))\n\nflag = True\nprint(\"flag: \", str(flag))\nif n == 1:\n    if s == '0':\n        print(pow(10, 10))\n    elif s == '1':\n        print(pow(10, 10) * 2)\nelif n == 2:\n    if s in ['11', '10']:\n        print(pow(10, 10))\n    elif s == '01':\n        print(pow(10, 10) - 1)\n    else:\n        print(0)\nelse:\n    flag = True\n    f = n // 3\n    print(\"f: \", str(f))\n    r = n % 3\n    print(\"r: \", str(r))\n    for i in range(0, n, 3):\n        if i == 0:\n            ans = s[0:3]\n            print(\"ans: \", str(ans))\n            if ans not in ['110', '101', '011']:\n                flag = False\n                break\n        elif i < 3 * f:\n            tmp = s[i:i + 3]\n            print(\"tmp: \", str(tmp))\n            if tmp != ans:\n                flag = False\n                break\n        else:\n            tmp = s[i:n]\n            print(\"tmp: \", str(tmp))\n            if tmp != ans[0:n - i]:\n                flag = False\n                break\n    if not flag:\n        print(0)\n    else:\n        if ans == '110':\n            if r == 0:\n                print(pow(10, 10) - f + 1)\n            else:\n                print(pow(10, 10) - f)\n        elif ans == '101':\n            print(pow(10, 10) - f)\n        elif ans == '011':\n            if r < 2:\n                print(pow(10, 10) - f)\n            else:\n                print(pow(10, 10) - f - 1)\n</ans>", "format_properties": {}}
{"idx": 109, "result": 0, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef gcd(a,b):\n\twhile b != 0:\n\t\ta,b = b,a%b\n\treturn a\n\ndef stupid(x):\n\tr = 1\n\tfor i in range(1, x):\n\t\tr = max(r, gcd(i&x, i^x))\n\treturn r\n\nd = dict()\nd[511] = 73\nd[2047] = 89\nd[32767] = 4681\nd[2097151] = 299593\nd[8388607] = 178481\nd[33554431] = 1082401\ndef smart(x):\n\tif x in d:\n\t\treturn d[x]\n\tif (x & (x+1)) == 0:\n\t\ti = 0\n\t\twhile ((1<<i)-1) != x:\n\t\t\ti += 1\n\t\tif i % 2 == 0:\n\t\t\tz = 0\n\t\t\tfor i in range(0,i,2):\n\t\t\t\tz += (1<<i)\n\t\t\treturn z\n\t\telse:\n\t\t\treturn 1\n\telse:\n\t\ti = 1\n\t\tz = 0\n\t\twhile i < x:\n\t\t\tif (i & x) == 0:\n\t\t\t\tz += i\n\t\t\ti *= 2\n\t\treturn x+z\n\nq = mint()\nfor i in range(q):\n\tx = mint()\n\tprint(\"x: \", str(x))\n\tprint(smart(x))\n\t#if (x & (x+1)) == 0:\n\t#\ta = stupid(x)\n\t#\tb = smart(x)\n\t#\tif a != b:\n\t#\t\tprint(x,a,b)\n\n</ans>", "format_properties": {}}
{"idx": 104, "result": 0, "generated": "<ans>\nimport itertools\n\n\nclass SolutionImpossible(Exception):\n    pass\n\n\nblocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]\nprint(\"blocks_cnt: \", str(blocks_cnt), \"finish: \", str(finish), \"min_sprint: \", str(min_sprint), \"max_jump: \", str(max_jump))\n\ndef read_blocks_coords():\n    it = (int(x) for x in input().split())\n    return (x for x in it if x < finish)\nprint(\"read_blocks_coords: \", str(read_blocks_coords))\n\n# TODO: \u043a\u043e\u0434 \u043c\u043e\u0436\u043d\u043e \u0441\u043e\u043a\u0440\u0430\u0442\u0438\u0442\u044c \u0437\u0430 \u0441\u0447\u0435\u0442 \u0438\u0437\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442 \u043b\u0438\u0448\u043d\u0435\u0439 \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 `_grouper._current_key`\ndef _grouper(value):\n    if _grouper._prev_value is not None:\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        if value - _grouper._prev_value - 1 <= min_sprint:\n            # \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u0436\u0434\u0443 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f\u043c\u0438 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u0430\u043b\u043e\n            # \u0447\u0442\u043e\u0431\u044b \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0442\u044c\u0441\u044f, \u0438 \u0437\u0430\u0442\u0435\u043c \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f \u0434\u043b\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u0440\u044b\u0436\u043a\u0430, \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u0445 \u0437\u0430 \u043e\u0434\u043d\u043e\n            _current_key = _grouper._current_key\n        else:\n            _current_key = id(value)\n    else:\n        # \u043f\u0435\u0440\u0432\u043e\u0435 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0435, \u0441\u0442\u0430\u0432\u0438\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e\n        _current_key = id(_grouper)\n\n    _grouper._prev_value = value\n    _grouper._current_key = _current_key\n\n    return _current_key\nprint(\"_grouper._prev_value: \", str(_grouper._prev_value), \"_grouper._current_key: \", str(_grouper._current_key))\n\n_grouper._prev_value = None\n_grouper._current_key = None\nprint(\"_grouper._prev_value: \", str(_grouper._prev_value), \"_grouper._current_key: \", str(_grouper._current_key))\n\ndef check_chunk(run_from, block=None):\n    if block is None:\n        return\n\n    next_run_from = block[-1] + 1  # \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0437\u0430 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u044f (\u0442\u043e\u0447\u043a\u0430 \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u0435\u043d\u0438\u044f)\n    if next_run_from - block[0] >= max_jump:\n        # \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u0430 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043b\u0438\u043d\u043d\u0430\u044f, \u0442\u043e \u043c\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u043c \u0435\u0435 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u044c\n        raise SolutionImpossible\n\n    if abs(run_from - block[0]) <= min_sprint:\n        # \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u043b\u044f \u0440\u0430\u0437\u0431\u0435\u0433\u0430\n        raise SolutionImpossible\n\n\ndef solve_chunk(run_from, block=None):\n    if block is not None:\n        run_len = block[0] - run_from - 1  # \u0434\u043e\u0431\u0435\u0433\u0430\u0435\u043c \u0414\u041e \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u044b\n        jump_len = block[-1] - block[0] + 2  # \u043f\u0440\u044b\u0433\u0430\u0435\u043c \u0417\u0410 \u043d\u0435\u0435\n        print((\n            \"RUN {run_len}\\n\"\n            \"JUMP {jump_len}\".format(\n                run_len=run_len,\n                jump_len=jump_len,\n            )\n        ))\n\n    else:\n        run_len = finish - run_from\n        if run_len > 0:\n            print(\"RUN {run_len}\".format(run_len=run_len))\n\n\ndef main():\n    # \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u043c\u043e\u0433\u0443\u0442 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u044c\u0441\u044f \u0442\u0430\u043a \u0431\u043b\u0438\u0437\u043a\u043e, \u0447\u0442\u043e \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043d\u0435\u0442 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0437\u043e\u0433\u043d\u0430\u0442\u044c\u0441\u044f\n    # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0442\u0430\u043a\u0438\u0435 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u044f \u0437\u0430 \u043e\u0434\u043d\u043e\n    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))\n    print(\"blocks: \", str(blocks))\n\n    chunks = []\n\n    run_from = 0\n    while True:\n        block = next(blocks, None)\n\n        chunk = (run_from, block)\n        check_chunk(*chunk)\n\n        chunks.append(chunk)\n\n        if block is None:\n            break\n\n        # \u043f\u043e\u0441\u043b\u0435 \u043f\u0440\u044b\u0436\u043a\u0430 \u043c\u044b \u043f\u0440\u0438\u0437\u0435\u043c\u043b\u044f\u0435\u043c\u0441\u044f \u0417\u0410 \u043f\u0440\u0435\u043f\u044f\u0442\u0441\u0442\u0432\u0438\u0435\u043c, \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u044d\u0442\u043e\n        run_from = block[-1] + 1\n\n    #print(chunks)\n\n    for chunk in chunks:\n        solve_chunk(*chunk)\n\n\ndef __starting_point():\n    try:\n        main()\n    except SolutionImpossible:\n        print(\"IMPOSSIBLE\")\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 106, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nclass UnionFind:\n    # \u4f5c\u308a\u305f\u3044\u8981\u7d20\u6570n\u3067\u521d\u671f\u5316\n    # \u4f7f\u7528\u3059\u308b\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u5909\u6570\u306e\u521d\u671f\u5316\n    def __init__(self, n):\n        self.n = n\n        print(\"n: \", str(n))\n        # root[x]<0\u306a\u3089\u305d\u306e\u30ce\u30fc\u30c9\u304c\u6839\u304b\u3064\u305d\u306e\u5024\u304c\u6728\u306e\u8981\u7d20\u6570\n        # root\u30ce\u30fc\u30c9\u3067\u305d\u306e\u6728\u306e\u8981\u7d20\u6570\u3092\u8a18\u9332\u3059\u308b\n        self.root = [-1] * (n + 1)\n        print(\"root: \", str(self.root))\n        # \u6728\u3092\u304f\u3063\u3064\u3051\u308b\u6642\u306b\u30a2\u30f3\u30d0\u30e9\u30f3\u30b9\u306b\u306a\u3089\u306a\u3044\u3088\u3046\u306b\u8abf\u6574\u3059\u308b\n        self.rnk = [0] * (n + 1)\n        print(\"rnk: \", str(self.rnk))\n\n    # \u30ce\u30fc\u30c9x\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n    def Find_Root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            # \u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u308b\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n\n    # \u6728\u306e\u4f75\u5408\u3001\u5165\u529b\u306f\u4f75\u5408\u3057\u305f\u3044\u5404\u30ce\u30fc\u30c9\n    def Unite(self, x, y):\n        # \u5165\u529b\u30ce\u30fc\u30c9\u306eroot\u30ce\u30fc\u30c9\u3092\u898b\u3064\u3051\u308b\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\n        if x == y:\n            return\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408rnk\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b\n        elif self.rnk[x] > self.rnk[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            # rnk\u304c\u540c\u3058\uff08\u6df1\u3055\u306b\u5dee\u304c\u306a\u3044\u5834\u5408\uff09\u306f1\u5897\u3084\u3059\n            if self.rnk[x] == self.rnk[y]:\n                self.rnk[y] += 1\n\n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u5224\u65ad\n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    uf = UnionFind(n)\n\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        print(\"a: \", str(a))\n        print(\"b: \", str(b))\n        uf.Unite(a, b)\n\n    for i in range(n):\n        i += 1\n        uf.isSameGroup(i, i)\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, -uf.root[i + 1])\n\n    # print(uf.root)\n    print(\"ans: \", str(ans))\n\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 107, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    print(\"n: \", str(n))\n    if n < 2:\n        return False\n    if n == 2:\n        print(\"n: \", str(n))\n        return True\n    if not n & 1:\n        print(\"n: \", str(n))\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            print(\"n: \", str(n))\n            return False\n    return True\n\ndef mhd(a,b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    print(\"x: \", str(x))\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    print(\"x: \", str(x))\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    print(\"x: \", str(x), \"y: \", str(y))\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    print(\"a: \", str(a), \"b: \", str(b))\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    print(\"a: \", str(a))\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    print(\"a: \", str(a))\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    print(\"n: \", str(n), \"r: \", str(r))\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    a,b,c = arrIN()\n    print(\"a: \", str(a), \"b: \", str(b), \"c: \", str(c))\n    print((a+b+c)//2)\n\n</ans>", "format_properties": {}}
{"idx": 110, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\nfrom heapq import *\nfrom fractions import *\ngetcontext().prec = 30\nprint(\"getcontext().prec: \", str(getcontext().prec))\nMAX = sys.maxsize\nprint(\"MAX: \", str(MAX))\nMAXN = 1000010\nprint(\"MAXN: \", str(MAXN))\nMOD = 10**9+7\nprint(\"MOD: \", str(MOD))\nspf = [i for i in range(MAXN)]\nprint(\"spf: \", str(spf))\nspf[0]=spf[1] = -1\ndef sieve():\n    for i in range(2,MAXN,2):\n        spf[i] = 2\n    for i in range(3,int(MAXN**0.5)+1):\n        if spf[i]==i:\n            for j in range(i*i,MAXN,i):\n                if spf[j]==j:\n                    spf[j]=i\ndef fib(n,m):\n    if n == 0:\n        return [0, 1]\n    else:\n        a, b = fib(n // 2)\n        print(\"a: \", str(a), \"b: \", str(b))\n        c = ((a%m) * ((b%m) * 2 - (a%m)))%m\n        d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m\n        if n % 2 == 0:\n            return [c, d]\n        else:\n            return [d, c + d]\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    n = int(input())\n    if n%2:\n        print(n//2)\n    else:\n        print(n//2-1)\n\n</ans>", "format_properties": {}}
{"idx": 112, "result": 0, "generated": "<ans>\ns = input()\nprint(\"s: \", str(s))\ncur_len = 1\na = []\nchar = []\nfor i in range(1, len(s)):\n    if s[i] == s[i-1]: cur_len += 1\n    else:\n      a.append(cur_len)\n      char.append(s[i-1])\n      print(\"a: \", a, \"; char: \", char)\n      cur_len = 1\n\na.append(cur_len)\nchar.append(s[len(s)-1])\nprint(\"a: \", a, \"; char: \", char)\n\nans = 0\nwhile len(a) > 1:\n    n = len(a)\n    print(\"n: \", n)\n    inner_min = 100000000\n    for i in range(1,n-1):\n        if a[i] < inner_min: inner_min = a[i]\n\n    k = min(a[0], a[n-1],(inner_min + 1)//2)\n    print(\"a: \", a, \"; k = \", k)\n    b = []\n    new_char = []\n    for i in range(n):\n        if i == 0 or i == n-1:\n            if a[i] > k:\n                b.append(a[i]-k)\n                new_char.append(char[i])\n        else:\n            if a[i] > 2*k:\n                b.append(a[i] - 2*k)\n                new_char.append(char[i])\n    print(\"b: \", b, \"; new_char: \", new_char)\n    ans += k\n    if len(b) > 1:\n        c = [0]*n\n        newnew_char = [new_char[0]]\n        count = 0\n\n        for i in range(0,len(b)-1):\n            c[count] += b[i]\n            if new_char[i] == new_char[i+1]: continue\n            else:\n                count += 1\n                newnew_char.append(new_char[i+1])\n        if new_char[len(b)-2] == new_char[len(b) - 1]: c[count] += b[len(b)-1]\n        else:\n            newnew_char.append(new_char[i+1])\n            c[count] = b[len(b)-1]\n        a = c[:count+1]\n        char = newnew_char[:]\n        print(\"a: \", a, \"; char: \", char)\n    else:\n        a = b[:]\n        print(\"a: \", a)\n\nprint(ans)\n</ans>", "format_properties": {}}
{"idx": 105, "result": 0, "generated": "<ans>\n#import sys\n#sys.stdin = open('in.txt')\n#sys.setrecursionlimit(10000)\ndef isPrefix(sa, sb):\n    print(\"sa: \", str(sa), \"sb: \", str(sb))\n    if len(sa) <= len(sb):\n        return False\n    return sa[0:len(sb)] == sb\n\ndef getOrder(sa, sb):\n    print(\"sa: \", str(sa), \"sb: \", str(sb))\n    for i in range(0, min(len(sa), len(sb))):\n        if sa[i] != sb[i]:\n            return sa[i], sb[i]\n\ntest = False\nprint(\"test: \", str(test))\nif test:\n    fp = open(\"in.txt\", 'r')\n    print(\"fp: \", str(fp))\n    n = int(fp.readline().strip())\n    print(\"n: \", str(n))\n    names = [fp.readline().strip() for i in range(0, n)]\n    print(\"names: \", str(names))\n    fp.close()\nelse:\n    n = int(input().strip())\n    print(\"n: \", str(n))\n    names = [input().strip() for i in range(0, n)]\n    print(\"names: \", str(names))\n\ng = [[False] * 26 for i in range(0, 26)]\nprint(\"g: \", str(g))\n\nres = True\nprint(\"res: \", str(res))\nfor i in range(1, n):\n    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):\n        continue\n    elif isPrefix(names[i - 1], names[i]):\n        res = False\n        break\n    else:\n        ca, cb = getOrder(names[i - 1], names[i])\n        print(\"ca: \", str(ca), \"cb: \", str(cb))\n        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:\n            res = False\n            break\n        else:\n            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True\n\ndef printG():\n    print(\"   abcdefghijklmnopqrstuvwxyz\")\n    for i in range(0, 26):\n        print(chr(ord('a') + i), \"\".join([\"1\" if x else \"0\" for x in g[i]]), sep =\n\n\"\")\n#printG()\n\nif not res:\n    print(\"Impossible\")\nelse:\n\n    def getZeroIndegreeNode():\n        print(\"used: \", str(used), \"indegree: \", str(indegree))\n        for i in range(0, 26):\n            if not used[i] and indegree[i] == 0:\n                return i\n        return -1\n    print(\"getZeroIndegreeNode: \", str(getZeroIndegreeNode()))\n    #topo sort\n    theOrder = []\n    indegree = [0] * 26\n    used = [False] * 26\n    print(\"theOrder: \", str(theOrder), \"indegree: \", str(indegree), \"used: \", str(used))\n\n    #calc indegree\n    for i in range(0, 26):\n        ithIndegree = 0\n        for j in range(0, 26):\n           if g[j][i]: ithIndegree += 1\n        indegree[i] = ithIndegree\n    print(\"indegree: \", str(indegree))\n    for i in range(0, 26):\n        zeroIndegreeNode = getZeroIndegreeNode()\n        if zeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            used[zeroIndegreeNode] = True\n            theOrder.append(chr(ord('a') + zeroIndegreeNode))\n            for j in range(0, 26):\n                if g[zeroIndegreeNode][j]:\n                    indegree[j] -= 1\n    print(\"theOrder: \", str(theOrder), \"indegree: \", str(indegree), \"used: \", str(used))\n    if not res:\n        print(\"Impossible\")\n    else:\n        print(\"\".join(theOrder))\n</ans>", "format_properties": {}}
{"idx": 113, "result": 0, "generated": "<ans>\na, r, l, m = list(map(int, input().split()))\nprint(\"a: \", str(a), \"r: \", str(r), \"l: \", str(l), \"m: \", str(m))\n_l = list(map(int, input().split()))\nprint(\"_l: \", str(_l))\ns = set(_l)\nprint(\"s: \", str(s))\nif abs(a) > l:\n    print(0)\n    return\nif a == 0:\n    if 0 in s:\n        print(0)\n        return\n    else:\n        print(\"inf\")\n        return\nif r == 0:\n    if a == 0:\n        if 0 in s:\n            print(0)\n            return\n        else:\n            print(\"inf\")\n            return\n    else:\n        if a not in s:\n            if abs(a) <= l:\n                if 0 in s:\n                    print(1)\n                    return\n                else:\n                    print(\"inf\")\n                    return\n            else:\n                print(0)\n                return\n        else:\n            if 0 in s:\n                print(0)\n                return\n            else:\n                print(\"inf\")\n                return\nif r == 1:\n    if a in s or abs(a) > l:\n        print(0)\n        return\n    else:\n        print(\"inf\")\n        return\nif r == -1:\n    if a in s:\n        if 0 - a in s:\n            print(0)\n            return\n        else:\n            if abs(a) <= l:\n                print(\"inf\")\n                return\n            else:\n                print(0)\n                return\n    else:\n        if abs(a) <= l:\n            print(\"inf\")\n            return\n        else:\n            print(0)\n            return\ntot = 0\nwhile abs(a) <= l:\n    if a not in s:\n        tot += 1\n    a *= r\nprint(tot)\n</ans>", "format_properties": {}}
{"idx": 114, "result": 0, "generated": "<ans>\nimport datetime\nimport sys\nimport copy\nimport functools\nimport collections\nimport itertools\n\nclass Solution:\n    def __init__(self):\n        print(\"self.N: \", str(self.N))\n        print(\"self.boards: \", str(self.boards))\n        self.N = 0\n        self.boards = None\n\n    def test(self):\n        pass\n\n    def readInput(self):\n        self.N = int(input())\n        print(\"self.N: \", str(self.N))\n        self.boards = []\n        for i in range(self.N):\n            self.boards.append(list(input()))\n        print(\"self.boards: \", str(self.boards))\n\n    def readMockInput(self):\n        pass\n\n    def solve(self):\n        N = self.N\n        print(\"N: \", str(N))\n        impossibleMoves = set()\n        print(\"impossibleMoves: \", str(impossibleMoves))\n        chesses = list()\n        print(\"chesses: \", str(chesses))\n        notAttacked = list()\n        print(\"notAttacked: \", str(notAttacked))\n        # record all impossible moves\n        for r in range(N):\n            for c in range(N):\n                if self.boards[r][c] == 'o':\n                    chesses.append((r, c))\n                elif self.boards[r][c] == '.':\n                    notAttacked.append((r, c))\n        print(\"chesses: \", str(chesses))\n        print(\"notAttacked: \", str(notAttacked))\n        for r, c in chesses:\n            for i, j in notAttacked:\n                impossibleMoves.add((i-r, j-c))\n        print(\"impossibleMoves: \", str(impossibleMoves))\n\n        # ... rest of the code ...\n</ans>", "format_properties": {}}
{"idx": 73, "result": 0, "generated": "<ans>\n#!/bin/pypy3\nfrom itertools import*\nfrom timeit import*\nfrom typing import Optional\n\nS=lambda x:sum(map(int,str(x)))\n\ndef ceil_s_divisible_a(x:int,a:int) -> Optional[int]:\n\tz=S(x)%a\n\tprint(\"z: \", str(z))\n\tif z:\n\t\tz=a-z\n\t\ttail=[]\n\t\tx=list(str(x))\n\t\twhile x:\n\t\t\tdigit=x.pop()\n\t\t\tdiff=min(z,9-int(digit))\n\t\t\tz-=diff\n\t\t\ttail.append(str(int(digit)+diff))\n\t\t\tif z==0:break\n\t\telse:\n\t\t\treturn ceil_s_divisible_a(10**len(tail),a)\n\t\tx=''.join(x) + ''.join(reversed(tail))\n\n\tassert S(x)%a==0\n\tx=int(x)\n\treturn x\n\ndef smooth25(a):\n\ta=int(bin(a).rstrip('0'),2)\n\twhile a%5==0: a//=5\n\treturn a==1\n\ndef solve(a):\n\tfor first in range(1,60): # 120\n\t\tq=str((first*10**3000+a-1) // a) # 5000\n\t\tfor s1 in range(1,200):\n\t\t\ti=1\n\t\t\ts2=int(q[0])\n\t\t\twhile i<len(q) and s2<s1*a-10: s2+=int(q[i]); i+=1\n\t\t\tfor len1 in range(i,min(i+10,len(q))):\n\t\t\t\tsmall=int(q[:len1])\n\t\t\t\tfor z in range(4): # 10\n\t\t\t\t\tsmall=ceil_s_divisible_a(small,a)\n\t\t\t\t\tif S(small*a)*a==S(small):\n\t\t\t\t\t\treturn small\n\t\t\t\t\tsmall+=1\n\n\treturn None\n\ndef powform(x:int)->str:\n\ts=str(x)\n\ttry:\n\t\ti=s.find('00000')\n\t\treturn f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'\n\texcept IndexError:\n\t\treturn str(x)\n\nif 0:\n\t#for a in (a for a in range(2,1000)):\n\tfor a in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:\n\t#for a in [32]:\n\n\t\tdef work():\n\t\t\tnonlocal x\n\t\t\tx=solve(a)\n\n\t\tt=timeit(work,number=1)\n\t\tif t>0.5 or x==None:\n\t\t\tif x!=None:\n\t\t\t\tprint(a,t,'>>',powform(a*x))\n\t\t\telse:\n\t\t\t\tprint(a,t,'>> ?????')\n\n\t#print(solve(int(input())))\n\n\nspecial='''\n660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340\n803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614\n912 0.5136937369998122 >> 3 * 10 ** 1825 + 240\n918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104\n582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116\n612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348\n495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305\n927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003\n636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004\n531 0.5475810970001476 >> 2 * 10 ** 2140 + 439\n64 0.5633312410000144 >> ?????\n200 0.5639609099998779 >> ?????\n100 0.565854023000611 >> ?????\n125 0.5663040710005589 >> ?????\n160 0.5668467480008985 >> ?????\n800 0.5676178080002501 >> ?????\n128 0.5676772269998764 >> ?????\n80 0.5682811480000964 >> ?????\n256 0.5685735130000467 >> ?????\n250 0.5691464900000938 >> ?????\n512 0.569266141999833 >> ?????\n32 0.5692826909998985 >> ?????\n50 0.5692834940000466 >> ?????\n25 0.5696684799995637 >> ?????\n400 0.5703751219998594 >> ?????\n20 0.5706145570002263 >> ?????\n500 0.5742691679997733 >> ?????\n640 0.5749700739997934 >> ?????\n40 0.5768258159996549 >> ?????\n625 0.5775357299999087 >> ?????\n16 0.5789494729997386 >> ?????\n833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404\n792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008\n320 0.6031684260005932 >> ?????\n10 0.6464516910000384 >> ?????\n546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454\n5 0.6617960960002165 >> ?????\n907 0.664109037000344 >> 3 * 10 ** 2538 + 2223\n923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141\n723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185\n825 0.701172955000402 >> 4 * 10 ** 2476 + 123350\n906 0.7062042559991824 >> 4 * 10 ** 1998 + 104\n905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540\n911 0.711649564000254 >> 2 * 10 ** 2612 + 2044\n934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112\n765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725\n981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022\n333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934\n663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634\n444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956\n720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280\n867 0.9858260920000248 >> 5 * 10 ** 1739 + 121\n914 1.0558696210000562 >> 3 * 10 ** 1831 + 222\n606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318\n948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020\n1000 1.2245053040005587 >> ?????\n741 1.2366985769995154 >> 5 * 10 ** 2669 + 175\n819 1.292531102999419 >> 8 * 10 ** 2949 + 31312\n867 1.293641017000482 >> 5 * 10 ** 1739 + 121\n961 1.431375496000328 >> 4 * 10 ** 1935 + 1112\n913 2.0632996949998414 >> 5 * 10 ** 2323 + 16\n861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114\n992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504\n936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112\n996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300\n951 2.380345242999283 >> 11 * 10 ** 1820 + 412\n969 2.471255187000679 >> 11 * 10 ** 1942 + 241\n828 2.504634874999283 >> 11 * 10 ** 1595 + 11212\n693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014\n840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120\n983 2.618962229999852 >> 11 * 10 ** 1968 + 5011\n963 2.641272683999887 >> 11 * 10 ** 2026 + 133\n972 2.741184581000198 >> 12 * 10 ** 2130 + 312\n555 2.787974407000547 >> 11 * 10 ** 2497 + 444445\n873 2.8377116049996403 >> 11 * 10 ** 1774 + 133\n903 2.898315477000324 >> 13 * 10 ** 1726 + 32\n804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500\n864 3.032601443999738 >> 13 * 10 ** 2747 + 34016\n759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441\n871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405\n902 4.413119433999782 >> 12 * 10 ** 1506 + 1110\n997 4.446912733999852 >> 11 * 10 ** 1999 + 7\n993 5.025415283999791 >> 23 * 10 ** 2130 + 31\n837 5.286188959000356 >> 25 * 10 ** 2722 + 11063\n786 5.390603378999913 >> 21 * 10 ** 1572 + 4002\n801 5.4837765329994 >> 22 * 10 ** 1645 + 212\n882 6.045185064999714 >> 22 * 10 ** 1822 + 1130\n990 6.413724044000446 >> 39 * 10 ** 2970 + 302010\n666 6.967028857000514 >> 33 * 10 ** 2997 + 32934\n941 6.982767053000316 >> 21 * 10 ** 1885 + 312\n924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152\n858 8.089877333000004 >> 41 * ", "format_properties": {}}
{"idx": 116, "result": 0, "generated": "<ans>\nimport heapq\n\nINF = float('inf')\nN, M = map(int, input().split())\nprint(\"N: \", str(N), \"M: \", str(M))\nto = [[] for _ in range(N)]\nprint(\"to: \", str(to))\n\nsides = [[0] * N for _ in range(N)]\nprint(\"sides: \", str(sides))\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    a, b = a - 1, b - 1\n    to[a].append((c, b))\n    to[b].append((c, a))\n    sides[a][b] = 1 #a, b\u9593\u306b\u8fba\u304c\u3042\u308b\n    sides[b][a] = 1\nprint(\"sides after loop: \", str(sides))\n\ndef dijkstra(s):\n    hq = [(0, s)]\n    heapq.heapify(hq)\n    cost = [[INF, []] for i in range(N)]\n    cost[s][0] = 0\n    while hq:\n        c, v = heapq.heappop(hq)\n        if c > cost[v][0]:\n            continue\n        for d, u in to[v]:\n            tmp = d + cost[v][0]\n            if tmp < cost[u][0]:\n                cost[u][0] = tmp\n                cost[u][1] = [v] # \u66f4\u65b0\u3059\u308b\u5834\u5408\u306f\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301\n                heapq.heappush(hq, (tmp, u))\n            elif tmp == cost[u][0]:\n                cost[u][1].append(v) # \u8ddd\u96e2\u304c\u7b49\u3057\u3044\u5834\u5408\u306f\u30ea\u30b9\u30c8\u3067\u76f4\u524d\u306e\u9802\u70b9\u3092\u4fdd\u6301\n                heapq.heappush(hq, (tmp, u))\n    return cost\n\ndef dfs(v, tree, p=-1):\n    if p >= 0:\n        sides[v][p] = 0\n        sides[p][v] = 0\n    for nv in tree[v][1]:\n        dfs(nv, tree, v)\n\ndef main():\n    for s in range(N):\n        tree = dijkstra(s)\n        for g in range(N):\n            dfs(g, tree)\n\n    print(sum(sum(column) for column in sides) // 2)\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 117, "result": 1, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn, k = mints()\nprint(\"n: \", str(n), \"k: \", str(k))\nq = list(mints())\nprint(\"q: \", str(q))\nfor i in range(n):\n\tq[i] -= 1\ns = list(mints())\nprint(\"s: \", str(s))\na = [i for i in range(1,n+1)]\nprint(\"a: \", str(a))\nd = [0]*n\nprint(\"d: \", str(d))\nb = [False]*(k+1)\nprint(\"b: \", str(b))\nc = [False]*(k+1)\nprint(\"c: \", str(c))\ne = [10000]*2\nprint(\"e: \", str(e))\nf = [10000]*2\nprint(\"f: \", str(f))\nfor i in range(k+1):\n\t#print(a)\n\tb[i] = (a == s)\n\tif b[i]:\n\t\te[i%2] = min(e[i%2], i)\n\tfor j in range(n):\n\t\td[j] = a[q[j]]\n\ta,d = d,a\n#print('====')\na = [i for i in range(1,n+1)]\nprint(\"a: \", str(a))\nfor i in range(k+1):\n\t#print(a)\n\tc[i] = (a == s)\n\tif c[i]:\n\t\tf[i%2] = min(f[i%2], i)\n\tfor j in range(n):\n\t\td[q[j]] = a[j]\n\ta,d = d,a\n#print('====')\n#print(e)\n#print(f)\nif e[0] == 0:\n\tprint('NO')\nelif e[1] == 1:\n\tif f[1] == 1 and k > 1:\n\t\tprint('NO')\n\telif k%2 == 1 or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelif f[1] == 1:\n\tif k%2 == 1 or e[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nelse:\n\tif e[k%2] <= k or f[k%2] <= k:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\n</ans>", "format_properties": {}}
{"idx": 118, "result": 0, "generated": "<ans>\nimport sys\nimport os\nimport time\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\nimport random\nimport string\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    print(\"prime: \", str(prime))\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    print(\"r: \", str(r))\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return default, default\n    else:\n        return left, right\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' ', end='\\n'): print(sep.join(map(str, a)), end=end)\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n########################################################################################################################\n# input = sys.stdin.readline\n\nfor _ in range(ii()):\n    n, m = mi()\n    print(\"n: \", str(n), \"m: \", str(m))\n    if n == 1:\n        print(0)\n    elif n == 2:\n        print(m)\n    else:\n        print(2*m)\n</ans>", "format_properties": {}}
{"idx": 122, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10000)\n\n#file = open(\"btest\", \"r\")\n#f = lambda:file.readline()\nf = lambda:input()\n\nprint(\"f: \", str(f))\n\nn,m = list(map(int, f().split()))\n\nprint(\"n: \", str(n), \"m: \", str(m))\n\nmatrix = []\n\nprint(\"matrix: \", str(matrix))\n\ndisco = [[0 for _ in range(m)] for _ in range(n)]\n\nprint(\"disco: \", str(disco))\n\nfor i in range(n):\n    matrix.append(f())\n\ndef valid_node(i, j):\n    return 0 <= i < n and 0 <= j < m\n\ndef dfs(i, j, p, k, cc = 0):\n    if disco[i][j] == k:\n        return True\n\n    disco[i][j] = k\n\n    res = False\n    dd = [[0,1], [1,0], [-1,0], [0,-1]]\n    for d in dd:\n        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):\n            if matrix[i + d[0]][j+ d[1]] == matrix[i][j]:\n                res = res or dfs(i + d[0], j+d[1], [i,j], k, cc+1)\n\n    return res\n\nok = False\nk = 1\nfor i in range(n):\n    for j in range(m):\n        if disco[i][j] == 0:\n            ok = ok or dfs(i, j, [i, j], k)\n            k += 1\n\nif ok:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n</ans>", "format_properties": {}}
{"idx": 119, "result": 0, "generated": "<ans>\nfrom random import randint\n\ndef factMod(n, mod):\n    res = 1\n    for i in range(2, n+1):\n        res = (res * i) % mod\n    return res\n\ndef powMod(n, p, mod):\n    res = 1\n\n    while p > 0:\n        if p % 2 == 1:\n            res = (res * n) % mod\n\n        p //= 2\n        n = (n * n) % mod\n\n    return res\n\ndef invMod(n, mod):\n    print(\"n: \", str(n), \"mod: \", str(mod))\n    return powMod(n, mod - 2, mod)\n\n#t = 6\n#print(invMod(t, 97))\n#print( (invMod(t, 97) * t) % 97 )\n#return\n\ndef CnkMod(n, k, mod):\n    print(\"n: \", str(n), \"k: \", str(k), \"mod: \", str(mod))\n    return (\n        factMod(n, mod) *\n        invMod(factMod(k, mod) * factMod(n-k, mod), mod)\n    ) % mod\n\ndef computeCnksMod(N, mod):\n    print(\"N: \", str(N), \"mod: \", str(mod))\n    res = [[0] * (N+1) for i in range(N+1)]\n    res[0][0] = 1\n    for n in range(1, N+1):\n        res[n][0] = res[n-1][0]\n        for k in range(1, n+1):\n            res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod\n\n    return res\n\nmagic = 998244353\n\nn = int(input()) + 1\nprint(\"n: \", str(n))\naa = [1] + [int(s)+1 for s in input().split(' ')]\nprint(\"aa: \", str(aa))\n\ncnks = computeCnksMod(n, magic)\n\nd = [0] * (n + 1)\nprint(\"d: \", str(d))\nd[n] = 1\n\nfor i in reversed(list(range(n))):\n    if i != 0 and aa[i] < 2:\n        continue\n\n    cur = 0\n\n    tosel = aa[i] - 1\n    for j in range(i + tosel + 1, n + 1):\n        avail = j - i - 1\n        #cur = (cur + CnkMod(avail, tosel, magic) * d[j]) % magic\n        cur = (cur + cnks[avail][tosel] * d[j]) % magic\n\n    d[i] = cur\n\nprint(\"d: \", str(d))\nprint(d[0] - 1)\n\n</ans>", "format_properties": {}}
{"idx": 111, "result": 0, "generated": "<ans>\nfrom math import log\nfrom decimal import Decimal\n\ndef a1(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (y ** z) * Decimal(log(x))\n\ndef s1(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"x^y^z\"\n\ndef a2(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (z ** y) * Decimal(log(x))\n\ndef s2(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"x^z^y\"\n\ndef a3(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (y * z) * Decimal(log(x))\n\ndef s3(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(x^y)^z\"\n\ndef a4(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (y * z) * Decimal(log(x))\n\ndef s4(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(x^z)^y\"\n\ndef a5(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (x ** z) * Decimal(log(y))\n\ndef s5(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"y^x^z\"\n\ndef a6(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (z ** x) * Decimal(log(y))\n\ndef s6(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"y^z^x\"\n\ndef a7(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (x * z) * Decimal(log(y))\n\ndef s7(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(y^x)^z\"\n\ndef a8(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (z * x) * Decimal(log(y))\n\ndef s8(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(y^z)^x\"\n\ndef a9(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (x ** y) * Decimal(log(z))\n\ndef s9(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"z^x^y\"\n\ndef a10(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (y ** x) * Decimal(log(z))\n\ndef s10(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"z^y^x\"\n\ndef a11(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (x * y) * Decimal(log(z))\n\ndef s11(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(z^x)^y\"\n\ndef a12(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return (y * x) * Decimal(log(z))\n\ndef s12(x, y, z):\n    print(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\n    return \"(z^y)^x\"\n\nx, y, z = list(map(Decimal, input().split()))\nprint(\"x: \", str(x), \"y: \", str(y), \"z: \", str(z))\nans = s1(x, y, z)\na = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]\ns = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]\nmax = a1(x, y, z)\nfor i in range (12):\n    if max < a[i](x, y, z):\n        ans = s[i](x, y, z)\n        max = a[i](x, y, z)\nprint(ans)\n\n</ans>", "format_properties": {}}
{"idx": 120, "result": 0, "generated": "<ans>\nfrom math import sin\ndef mp():  return list(map(int,input().split()))\ndef lt():  return list(map(int,input().split()))\ndef pt(x):  print(x)\ndef ip():  return input()\ndef it():  return int(input())\ndef sl(x):  return [t for t in x]\ndef spl(x): return x.split()\ndef aj(liste, item): liste.append(item)\ndef bin(x):  return \"{0:b}\".format(x)\ndef listring(l): return ' '.join([str(x) for x in l])\ndef ptlist(l): print(' '.join([str(x) for x in l]))\n\nn = it()\nprint(\"n: \", str(n))\nstep = lt()\nprint(\"step: \", str(step))\ndict = {}\nprint(\"dict: \", str(dict))\ndef explosion(start,s,d):\n    (i,j) = start\n    t = s+1\n    if d == 0:\n        for k in range(j+1,j+t):\n            dict[(i,k)] = True\n        return ((i,j+t-1),(d+7)%8),((i,j+t-1),(d+1)%8)\n    if d == 1:\n        for k in range(1,t):\n            dict[(i+k,j+k)] = True\n        return ((i+t-1,j+t-1),(d+7)%8),((i+t-1,j+t-1),(d+1)%8)\n    if d == 2:\n        for k in range(1,t):\n            dict[(i+k,j)] = True\n        return ((i+t-1,j),(d+7)%8),((i+t-1,j),(d+1)%8)\n    if d == 3:\n        for k in range(1,t):\n            dict[(i+k,j-k)] = True\n        return ((i+t-1,j-t+1),(d+7)%8),((i+t-1,j-t+1),(d+1)%8)\n    if d == 4:\n        for k in range(1,t):\n            dict[(i,j-k)] = True\n        return ((i,j-t+1),(d+7)%8),((i,j-t+1),(d+1)%8)\n    if d == 5:\n        for k in range(1,t):\n            dict[(i-k,j-k)] = True\n        return ((i-t+1,j-t+1),(d+7)%8),((i-t+1,j-t+1),(d+1)%8)\n    if d == 6:\n        for k in range(1,t):\n            dict[(i-k,j)] = True\n        return ((i-t+1,j),(d+7)%8),((i-t+1,j),(d+1)%8)\n    if d == 7:\n        for k in range(1,t):\n            dict[(i-k,j+k)] = True\n        return ((i-t+1,j+t-1),(d+7)%8),((i-t+1,j+t-1),(d+1)%8)\n\nstart = [((0,0),0)]\nprint(\"start: \", str(start))\nfor i in range(n):\n    l = []\n    for p,q in start:\n        a,b = explosion(p,step[i],q)\n        l.append(a)\n        l.append(b)\n    start = set(l)\nprint(\"start: \", str(start))\npt(len(dict))\n</ans>", "format_properties": {}}
{"idx": 115, "result": 1, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\nprint(\"sys: \", str(sys))\nprint(\"math: \", str(math))\nprint(\"os: \", str(os))\nprint(\"itertools: \", str(itertools))\nprint(\"string: \", str(string))\nprint(\"heapq: \", str(heapq))\nprint(\"_collections: \", str(_collections))\nprint(\"Counter: \", str(Counter))\nprint(\"defaultdict: \", str(defaultdict))\nprint(\"deque: \", str(deque))\nprint(\"lru_cache: \", str(lru_cache))\nprint(\"bisect: \", str(bisect))\nprint(\"re: \", str(re))\nprint(\"queue: \", str(queue))\nprint(\"copy: \", str(copy))\nprint(\"decimal: \", str(decimal))\n\nclass Scanner():\n    @staticmethod\n    def int():\n        print(\"Scanner.int: \", str(Scanner.int))\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        print(\"Scanner.string: \", str(Scanner.string))\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        print(\"Scanner.map_int: \", str(Scanner.map_int))\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        print(\"Scanner.string_list: \", str(Scanner.string_list))\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        print(\"Scanner.int_list_list: \", str(Scanner.int_list_list))\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        print(\"Scanner.int_cols_list: \", str(Scanner.int_cols_list))\n        return [Scanner.int() for i in range(n)]\n\n\ndef pop_count(x):\n    print(\"x: \", str(x))\n    x = x - ((x >> 1) & 0x5555555555555555)\n    print(\"x: \", str(x))\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    print(\"x: \", str(x))\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    print(\"x: \", str(x))\n    x = x + (x >> 8)\n    print(\"x: \", str(x))\n    x = x + (x >> 16)\n    print(\"x: \", str(x))\n    x = x + (x >> 32)\n    print(\"x: \", str(x))\n    return x & 0x0000007f\n\ndef solve():\n    S = Scanner.string()\n    print(\"S: \", str(S))\n    N = len(S)\n    print(\"N: \", str(N))\n    K = Scanner.int()\n    print(\"K: \", str(K))\n    dp = [[[0 for _ in range(2)] for _ in range(K + 1)] for _ in range(N + 1)]\n    print(\"dp: \", str(dp))\n    dp[0][0][0] = 1\n    for i in range(N):\n        for j in range(4):\n            for k in range(2):\n                nd = int(S[i])\n                print(\"nd: \", str(nd))\n                for d in range(10):\n                    ni, nj, nk = i + 1, j, k\n                    if d != 0:\n                        nj += 1\n                    if nj > K:\n                        continue\n                    if k == 0:\n                        if d > nd:\n                            continue\n                        if d < nd:\n                            nk += 1\n                    dp[ni][nj][nk] += dp[i][j][k]\n    print((dp[N][K][0] + dp[N][K][1]))\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 126, "result": 0, "generated": "<ans>\n__author__ = 'Michael Ilyin'\n\nimport math\n\n# debug = True\ndebug = False\n\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))\n\ndef get_y(x1, y1, x2, y2, x):\n    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1\n\nif debug:\n    with open(\"input.txt\", \"r\") as inp:\n        firstLine = inp.readline()\n        secondLine = inp.readline()\n        thirdLine = inp.readline()\n        fourthLine = inp.readline()\nelse:\n    firstLine = input()\n    secondLine = input()\n    thirdLine = input()\n    fourthLine = input()\n\nfirst = firstLine.split()\nn = float(first[0])\nm = float(first[1])\na = float(first[2])\nb = float(first[3])\n\nA = [float(x) for x in secondLine.split()]\nB = [float(x) for x in thirdLine.split()]\nL = [float(x) for x in fourthLine.split()]\n\nif debug:\n    print(\"A: \", str(A))\n    print(\"B: \", str(B))\n    print(\"L: \", str(L))\n\noptimalLen = float(\"inf\")\noptimalBIdx = -1\nfor i, bi in enumerate(B):\n    d = dist(0, 0, b, bi) + L[i]\n    if d <= optimalLen:\n        optimalLen = d\n        optimalBIdx = i\n\nif debug:\n    print(\"optimalBIdx: \", str(optimalBIdx + 1), \"optimalLen: \", str(optimalLen))\n\nintersectY = get_y(0, 0, b, B[optimalBIdx], a)\n\nif debug:\n    print(\"intersectY: \", str(intersectY))\n\npointDist = float(\"inf\")\noptimalAIdx = -1\nfor i, ai in enumerate(A):\n    d = dist(a, ai, a, intersectY)\n    if d < pointDist:\n        pointDist = d\n        optimalAIdx = i\n\nif debug:\n    print(\"optimalAIdx: \", str(optimalAIdx + 1), \"pointDist: \", str(pointDist))\n\noptimalLen = float(\"inf\")\noptimalBIdx = -1\nfor i, bi in enumerate(B):\n    d = dist(a, A[optimalAIdx], b, bi) + L[i]\n    if d <= optimalLen:\n        optimalLen = d\n        optimalBIdx = i\n\nprint(\"optimalAIdx: \", str(optimalAIdx + 1), \"optimalBIdx: \", str(optimalBIdx + 1))\n</ans>", "format_properties": {}}
{"idx": 125, "result": 0, "generated": "<ans>\ndef main():\n    N, M = (int(i) for i in input().split())\n    print(\"N: \", str(N), \"M: \", str(M))\n    par = [i for i in range(N)]\n    print(\"par: \", str(par))\n    size = [1 for i in range(N)]\n    print(\"size: \", str(size))\n\n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            size[x] = size[par[x]]\n            return par[x]\n\n    def same(x, y):\n        return find(x) == find(y)\n\n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if size[x] < size[y]:\n            x, y = y, x\n        size[x] += size[y]\n        par[y] = x\n\n    def get_size(x):\n        return size[find(x)]\n\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        print(\"a: \", str(a), \"b: \", str(b))\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n        union(a-1, b-1)\n\n    S = [False]*4\n    for i in range(N):\n        S[min(3, get_size(i))] = True\n        if S[3]:\n            break\n    t = 0\n    if S[3]:\n        t = 1\n    elif S[2]:\n        t = 2\n    else:\n        t = 3\n\n    color = [-1]*N\n\n    def dfs(s):\n        stack = [s]\n        color[s] = 0\n        b = 1\n        w = 0\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if color[u] != -1:\n                    if color[u] == color[v]:\n                        return False, b*w\n                    continue\n                color[u] = color[v] ^ 1\n                if color[u] == 0:\n                    b += 1\n                else:\n                    w += 1\n                stack.append(u)\n        return True, b*(b-1)//2 + w*(w-1)//2\n\n    is_bipartite, _ = dfs(0)\n    if is_bipartite:\n        w = 0\n        if t == 3:\n            w = N*(N-1)*(N-2)//3//2\n        elif t == 2:\n            used = [False]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) == 2:\n                    w += (N-2)\n                    used[find(i)] = True\n        elif t == 1:\n            used = [False]*N\n            color = [-1]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) >= 3:\n                    _, ways = dfs(i)\n                    w += ways\n                    used[find(i)] = True\n        print(t, w)\n    else:\n        print(0, 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 124, "result": 0, "generated": "<ans>\nMOD = 998244353\n\ndef pop_count(x) :\n    ans = 0\n    while (x > 0) :\n        ans = ans + x % 2\n        x = x // 2\n    return ans\n\ndef check(x, k) :\n    mask = 0\n    nx = int(x)\n    while (nx > 0) :\n        mask = mask | (1 << (nx % 10))\n        nx = nx // 10\n    if (pop_count(mask) <= k) :\n        return x\n    return 0\n\npop = []\np10 = []\nf = [[0 for j in range(1 << 10)] for i in range(20)]\nw = [[0 for j in range(1 << 10)] for i in range(20)]\nprint(\"f: \", str(f))\nprint(\"w: \", str(w))\ndef prepare() :\n    p10.append(1)\n    for i in range(20) :\n        p10.append(p10[i] * 10 % MOD)\n    print(\"p10: \", str(p10))\n    for i in range(1 << 10) :\n        pop.append(pop_count(i))\n    print(\"pop: \", str(pop))\n    w[0][0] = 1\n    for i in range(1, 20) :\n        for j in range(1 << 10) :\n            for use in range(10) :\n                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD\n                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD\n\ndef solve(x, k) :\n    sx = [int(d) for d in str(x)]\n    n = len(sx)\n    ans = 0\n    for i in range(1, n) :\n        for use in range(1, 10) :\n            for mask in range(1 << 10) :\n                if (pop[(1 << use) | mask] <= k) :\n                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD\n    cmask = 0\n    csum = 0\n    for i in range(n) :\n        cdig = sx[i]\n        for use in range(cdig) :\n            if (i == 0 and use == 0) :\n                continue\n            nmask = cmask | (1 << use)\n            for mask in range(1 << 10) :\n                if (pop[nmask | mask] <= k) :\n                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD\n        cmask |= 1 << cdig\n        csum = (10 * csum + cdig) % MOD\n    return ans\n\nprepare()\nl, r, k = list(map(int, input().split()))\nprint(\"l: \", str(l))\nprint(\"r: \", str(r))\nprint(\"k: \", str(k))\nans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 121, "result": 0, "generated": "<ans>\nfrom heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom functools import *\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\ndef Golf():\n    *a,=map(int,open(0))\ndef S_():\n    return input()\ndef IS():\n    return input().split()\ndef LS():\n    return [i for i in input().split()]\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef LtoS(ls):\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\n    mp=[1]*(w+2)\n    found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[1]+[mp_def[j] for j in s]+[1]\n    mp+=[1]*(w+2)\n    return h+2,w+2,mp,found\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['YES','NO']\nYn=['Yes','No']\n\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\n#ts=time.time()\n#sys.setrecursionlimit(10**7)\ninput=lambda: sys.stdin.readline().rstrip()\n\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\nn=I()\nm=LI()\ntot=0\nfor i in range(n):\n    print(\"i: \", str(i))\n    l,r=[],[]\n    print(\"l: \", str(l))\n    print(\"r: \", str(r))\n    tmp=m[i]\n    print(\"tmp: \", str(tmp))\n    p=m[i]\n    print(\"p: \", str(p))\n    # right\n    for j in range(i+1,n):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        r+=[p]\n        print(\"r: \", str(r))\n    p=m[i]\n    # left\n    for j in range(i-1,-1,-1):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        l+=[p]\n        print(\"l: \", str(l))\n    if tmp>tot:\n        tot=tmp\n        ans=l[::-1]+[m[i]]+r\n        print(\"ans: \", str(ans))\nprint(*ans)\n</ans>", "format_properties": {}}
{"idx": 127, "result": 0, "generated": "<ans>\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\n# M = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nprint(\"n: \", str(n))\nprint(\"l: \", str(l))\nprint(\"l1: \", str(l1))\nprint(\"l2: \", str(l2))\n\ni = 0\nl1 = sorted(list(set(l1)))\nprint(\"l1: \", str(l1))\ndoit = tot1 = 0\nprint(\"doit: \", str(doit))\nprint(\"tot1: \", str(tot1))\ncn = Counter(l1)\nprint(\"cn: \", str(cn))\nl = l1[:]\nwhile i < len(l1):\n    if cn[l[i] - 1] > 0:\n        cn[l[i]] -= 1\n        cn[l[i] - 1] += 1\n        l[i] -= 1\n        i += 1\n    else:\n        cn[l[i]] -= 1\n        cn[l[i] + 1] += 1\n        l[i] += 1\n        if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2\n        else:i += 1\nprint(\"cn: \", str(cn))\ntot1 = sum(1 for i in cn if cn[i])\nprint(\"tot1: \", str(tot1))\n\n\n\n\n\n\n\n\n\n# print(l1)\n\n\n\ni = 0\n\ncnt = Counter(l2)\nprint(\"cnt: \", str(cnt))\nl2 = sorted(l2)\nprint(\"l2: \", str(l2))\n\nl = l2[:]\n\n\n\nfor i in range(n):\n    if cnt[l[i] - 1] == 0:\n        cnt[l[i] - 1] += 1\n        cnt[l[i]] -= 1\n        l[i] -= 1\n    elif cnt[l[i]] > 1:\n        cnt[l[i] + 1] += 1\n        cnt[l[i]] -= 1\n        l[i] += 1\n\n\ntot2 = sum(1 for i in cnt if cnt[i])\nprint(\"tot2: \", str(tot2))\n\n\n\n\n\nprint(tot1,tot2)\n</ans>", "format_properties": {}}
{"idx": 123, "result": 0, "generated": "<ans>\nD = {\n0: 0,\n100: 1423,\n200: 4006,\n300: 10171,\n400: 12223,\n500: 18010,\n600: 22231,\n700: 30520,\n800: 40150,\n900: 51121,\n1000: 100036,\n1100: 102034,\n1200: 106030,\n1300: 112024,\n1400: 120232,\n1500: 126100,\n1600: 140230,\n1700: 170101,\n1800: 202105,\n1900: 210322,\n2000: 220033,\n2100: 230410,\n2200: 261100,\n2300: 303130,\n2400: 313300,\n2500: 333100,\n2600: 402400,\n2700: 421210,\n2800: 504010,\n2900: 602020,\n3000: 1000027,\n3100: 1002025,\n3200: 1006021,\n3300: 1012015,\n3400: 1020223,\n3500: 1026010,\n3600: 1040221,\n3700: 1070020,\n3800: 1102060,\n3900: 1110313,\n4000: 1120024,\n4100: 1130401,\n4200: 1161010,\n4300: 1203121,\n4400: 1213210,\n4500: 1233010,\n4600: 1302310,\n4700: 1321201,\n4800: 1404001,\n4900: 1502011,\n5000: 2000008,\n5100: 2002312,\n5200: 2010700,\n5300: 2020222,\n5400: 2031211,\n5500: 2100052,\n5600: 2104111,\n5700: 2120014,\n5800: 2141002,\n5900: 2204011,\n6000: 2230003,\n6100: 2310202,\n6200: 2410102,\n6300: 3000151,\n6400: 3005101,\n6500: 3020131,\n6600: 3042100,\n6700: 3106000,\n6800: 3130210,\n6900: 3211021,\n7000: 3311020,\n7100: 4000330,\n7200: 4012012,\n7300: 4100203,\n7400: 4130002,\n7500: 4301200,\n7600: 5010031,\n7700: 5103100,\n7800: 6000121,\n7900: 6200020,\n8000: 9010000,\n8100: 10001710,\n8200: 10005310,\n8300: 10011601,\n8400: 10020151,\n8500: 10025101,\n8600: 10040131,\n8700: 10062100,\n8800: 10102024,\n8900: 10110232,\n9000: 10116100,\n9100: 10130230,\n9200: 10160101,\n9300: 10203031,\n9400: 10213102,\n9500: 10232101,\n9600: 10302202,\n9700: 10321030,\n9800: 10403020,\n9900: 10501201,\n10000: 10800100}\n\nk = int(input())\nprint(\"k: \", str(k))\nstart = k - k%100\nprint(\"start: \", str(start))\ni = D[start]\nprint(\"i: \", str(i))\nj = start\n\nwhile j < k:\n    i += 1\n    if sum(int(d) for d in str(i))==10:\n        j += 1\nprint(\"i: \", str(i))\n\n</ans>", "format_properties": {}}
{"idx": 135, "result": 0, "generated": "<ans>\n```\n#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n  return int(readline())\nprint(\"I: \", str(I()))\nn = I()\ns = input()\nprint(\"s: \", str(s))\nans = \"\"\nprv = None\nprint(\"ans: \", str(ans))\nprint(\"prv: \", str(prv))\nfor i in range(n):\n    if i == 0:\n        prv = s[i]\n        ans += s[i]\n        continue\n    if s[i] == prv:\n        continue\n    else:\n        prv = s[i]\n        ans += s[i]\nprint(\"ans: \", str(ans))\nprint((len(ans)))\n</ans>", "format_properties": {}}
{"idx": 133, "result": 0, "generated": "<ans>\nimport sys\nn=int(input())\nprint(\"n: \", str(n))\na=list(map(int,input().split()))\nprint(\"a: \", str(a))\nheight=n\nprint(\"height: \", str(height))\nans=[]\nprint(\"ans: \", str(ans))\nlast3=-1\nprint(\"last3: \", str(last3))\nfail=0\nprint(\"fail: \", str(fail))\nused=-1\nprint(\"used: \", str(used))\nfor i in range(n):\n    if a[i]==3:\n        if height==n:\n            ans.append((n-height+1,i+1))\n            height-=1\n        else:\n            ans.append((n+1-(height+1),i+1))\n            ans.append((n+1-height,i+1))\n            height-=1\n        last3=i\nprint(\"last3: \", str(last3))\nif last3==n-1:\n    print(-1)\n    return\nif last3>-1:\n    flag=0\n    for i in range(last3,n):\n        if a[i]==2:\n            flag=1\n            ans.append((n+1-(height+1),i+1))\n            height-=1\n            break\n    print(\"flag: \", str(flag))\n    if flag==0:\n        flag2=0\n        for i in range(last3,n):\n            if a[i]==1:\n                ans.append((n+1-(height+1),i+1))\n                height-=1\n                flag2=1\n                used=i\n                break\n        print(\"flag2: \", str(flag2))\n        if flag2==0:\n            print(-1)\n            return\nones=[]\nif used==-1:\n    height-=1\nfor i in range(n-1,-1,-1):\n    if a[i]==1 and i!=used:\n        ones.append(i)\n    if a[i]==2:\n        if len(ones)==0:\n            print(-1)\n            return\n        k=ones.pop()\n        ans.append((n+1-(height+1),i+1))\n        ans.append((n+1-(height+1),k+1))\n        height-=1\nif used>-1:\n    ones.append(used)\nfor i in ones:\n    ans.append((n+1-(height+1),i+1))\n    height-=1\nprint(\"ans: \", str(ans))\nprint(len(ans))\nfor x,y in ans:\n    print(x,y)\n</ans>", "format_properties": {}}
{"idx": 131, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\nMOD = int(1e09) + 7\nINF = int(1e15)\n\ndef solve():\n    N = Scanner.int()\n    print(\"N: \", str(N))\n    A = [0 for _ in range(N)]\n    B = [0 for _ in range(N)]\n    for i in range(N):\n        A[i], B[i] = Scanner.map_int()\n    print(\"A: \", str(A))\n    print(\"B: \", str(B))\n    A.sort()\n    B.sort()\n    if N % 2 == 0:\n        mA = A[N // 2] + A[N // 2 - 1]\n        mB = B[N // 2] + B[N // 2 - 1]\n        print(\"mA: \", str(mA))\n        print(\"mB: \", str(mB))\n        print((mB - mA + 1))\n    else:\n        mA = A[N // 2]\n        mB = B[N // 2]\n        print(\"mA: \", str(mA))\n        print(\"mB: \", str(mB))\n        print((mB - mA + 1))\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 130, "result": 0, "generated": "<ans>\nimport math\nfrom fractions import gcd\n\ndef primes(limit):\n    Ans=[]\n    C=[True]*(limit+1)\n    L=list(range(2,limit+1))\n    for item in L:\n        if(C[item]):\n            i=2\n            while(item*i<=limit):\n                C[item*i]=False\n                i+=1\n    for item in L:\n        if(C[item]):\n            Ans+=[item]\n    return Ans\n\nprint(\"limit: \", str(limit))\nprint(\"Ans: \", str(Ans))\nprint(\"C: \", str(C))\nprint(\"L: \", str(L))\n\na,b=list(map(int,input().split()))\naa=a\nbb=b\nprint(\"a: \", str(a))\nprint(\"b: \", str(b))\nprint(\"aa: \", str(aa))\nprint(\"bb: \", str(bb))\nA=[]\nB=[]\n\np=primes(int(math.sqrt(10**9)))\n\nprint(\"p: \", str(p))\n\nfor i in range(len(p)):\n    if(p[i]>a):\n        break\n    while(a%p[i]==0):\n        A.append(p[i])\n        a//=p[i]\nprint(\"A: \", str(A))\nprint(\"a: \", str(a))\n\nif(a!=1):\n    A.append(a)\nprint(\"A: \", str(A))\n\nfor i in range(len(p)):\n    if(p[i]>b):\n        break\n    while(b%p[i]==0):\n        B.append(p[i])\n        b//=p[i]\nprint(\"B: \", str(B))\nprint(\"b: \", str(b))\n\nif(b!=1):\n    B.append(b)\nprint(\"B: \", str(B))\n\nif(aa==1 and bb==1):\n    print(0)\n\nelif(aa==1):\n    Done=True\n    for item in B:\n        if(item>5):\n            Done=False\n            break\n    print(\"Done: \", str(Done))\n    if(Done):\n        print(len(B))\n    else:\n        print(-1)\nelif(bb==1):\n    Done=True\n    for item in A:\n        if(item>5):\n            Done=False\n            break\n    print(\"Done: \", str(Done))\n    if(Done):\n        print(len(A))\n    else:\n        print(-1)\n\nelse:\n\n    B.sort()\n    A.sort()\n    Done=True\n    ind=0\n    ans=0\n    while(A!=B):\n        if(ind>=len(A) and ind>=len(B)):\n            Done=False\n            break\n        elif(ind>=len(A)):\n            if(B[-1]>5):\n                Done=False\n                break\n            else:\n                ans+=len(B)-ind\n                break\n        elif(ind>=len(B)):\n            if(A[-1]>5):\n                Done=False\n                break\n            else:\n                ans+=len(A)-ind\n                break\n        if(A[ind]==B[ind]):\n            ind+=1\n            continue\n\n        if(A[ind]<B[ind]):\n            if(A[ind]>5):\n                Done=False\n                break\n            else:\n                ans+=1\n                A.pop(ind)\n        else:\n            if(B[ind]>5):\n                Done=False\n                break\n            else:\n                ans+=1\n                B.pop(ind)\n    print(\"Done: \", str(Done))\n    if(Done):\n        print(ans)\n    else:\n        print(-1)\n\n</ans>", "format_properties": {}}
{"idx": 128, "result": 0, "generated": "<ans>\nimport sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n\ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\nprint(\"N: \", str(N))\ndef main():\n    N = I()\n    print(\"N: \", str(N))\n    if N == 0:\n        print(0)\n        return\n    if N < 0:\n        N = -N\n        D = defaultdict(int)\n        index = 0\n        while N >= 1:\n            #bit\u30d5\u30e9\u30b0\u304c\u305f\u3063\u3066\u3044\u305f\u3089\n            if N & 1 == 1:\n                #2\u306e\u500d\u6570\u306e\u5834\u5408D[index]\u3068D[index+1]\u306b1\u3092\u8db3\u3059\n                if index % 2 == 0:\n                    D[index] += 1\n                    D[index+1] += 1\n                else:\n                    D[index] += 1\n            else:\n                D[index] = D[index]\n            N = N>>1\n            index += 1\n    else:\n        D = defaultdict(int)\n        if N & 1 == 1:\n            D[0] = 1\n        else:\n            D[0] = 0\n        index = 1\n        N = N >> 1\n\n        while N >= 1:\n            #bit\u30d5\u30e9\u30b0\u304c\u305f\u3063\u3066\u3044\u305f\u3089\n            if N & 1 == 1:\n                #2\u306e\u500d\u6570\u306e\u5834\u5408D[index]\u3068D[index+1]\u306b1\u3092\u8db3\u3059\n                if index % 2 == 1:\n                    D[index] += 1\n                    D[index+1] += 1\n                else:\n                    D[index] += 1\n            else:\n                D[index] = D[index]\n            N = N>>1\n            index += 1\n\n    print(\"D: \", str(D))\n    index = 0\n    while True:\n        if not index in D.keys():\n            break\n        if D[index] <= 1:\n            pass\n        else:\n            temp = D[index]\n            D[index] = temp % 2\n            D[index+1] += (temp // 2)\n            D[index+2] += (temp // 2)\n            if D[index+1] >= D[index+2] * 2:\n                temp = D[index+2]\n                D[index+2] -= temp\n                D[index+1] -= temp * 2\n        index += 1\n    print(\"D: \", str(D))\n    res = True\n\n    for i in reversed(D.values()):\n        if res and i == 1:\n            res = False\n        if not res:\n            print(i, end=\"\")\n    print()\n\ndef __starting_point():\n    main()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 136, "result": 0, "generated": "<ans>\nimport sys\n\nn = int(sys.stdin.readline().split()[0])\n\nprint(\"n: \", str(n))\n\nclass Polynomial:\n    def __init__(self, coef):\n        first_nonzero = False\n        index = len(coef) - 1\n        while not first_nonzero:\n            if not coef[index] == 0:\n                first_nonzero = True\n            else:\n                if index == 0:\n                    first_nonzero = True\n                else:\n                    index -= 1\n        self.degree = index\n        self.coef = [coef[j] for j in range(index + 1)]\n        print(\"self.degree: \", str(self.degree))\n        print(\"self.coef: \", str(self.coef))\n\n    def multiply_by_x(self):\n        new_coef = [0]\n        for j in range(self.degree + 1):\n            new_coef.append(self.coef[j])\n        return Polynomial(new_coef)\n        print(\"new_coef: \", str(new_coef))\n\n    def minus(self):\n        new_coef = [-self.coef[j] for j in range(self.degree + 1)]\n        return Polynomial(new_coef)\n        print(\"new_coef: \", str(new_coef))\n\n    def add(self, other):\n        other_coef = other.coef\n        new_coef = [0 for j in range(max(self.degree, other.degree) + 1)]\n        m = min(self.degree, other.degree)\n        M = max(self.degree, other.degree)\n        if self.degree > other.degree:\n            bigger_poly = self\n        else:\n            bigger_poly = other\n        for j in range(m + 1):\n            new_coef[j] = self.coef[j] + other_coef[j]\n        for j in range(m + 1, M+1):\n            new_coef[j] = bigger_poly.coef[j]\n        return Polynomial(new_coef)\n        print(\"new_coef: \", str(new_coef))\n\n    def is_legal(self):\n        result = True\n        bools = [None for j in range(self.degree + 1)]\n        bools[self.degree] = self.coef[self.degree] == 1\n        for j in range(self.degree):\n            bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1\n        for j in range(self.degree + 1):\n            result = result and bools[j]\n        return result\n\n    def print(self):\n        output = \"\"\n        for j in range(self.degree + 1):\n            output += str(self.coef[j]) + \" \"\n        print(output)\n\nf = []\n\nf.append(Polynomial([1]))\nf.append(Polynomial([0, 1]))\n\nfor j in range(2, 151):\n    xf = f[j-1].multiply_by_x()\n    t_1 = xf.add(f[j - 2])\n    t_2 = xf.add(f[j - 2].minus())\n    if t_1.is_legal():\n        f.append(t_1)\n    elif t_2.is_legal():\n        f.append(t_2)\n\nprint(\"f[n]: \", str(f[n]))\nf[n].print()\nprint(\"f[n-1]: \", str(f[n-1]))\nf[n-1].print()\n\n#for j in range(len(f)):\n    #f[j].print()\n\n</ans>", "format_properties": {}}
{"idx": 137, "result": 0, "generated": "<ans>\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        print(\"mod: \", str(mod))\n        self.modinv = self.make_modinv_list(n_max)\n        print(\"modinv: \", str(self.modinv))\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n        print(\"fac: \", str(self.fac))\n        print(\"facinv: \", str(self.facinv))\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\nmod = 998244353\nprint(\"mod: \", str(mod))\nK, N = map(int, input().split())\nprint(\"K: \", str(K))\nprint(\"N: \", str(N))\ncomb = Combination(10000, mod=mod)\ndef C(n, r):\n    if n<r or r<0:\n        return 0\n    else:\n        return comb(n, r)\ndef H(n, r):\n    return C(n+r-1, r)\nL = []\nfor i in range(2, 2*K+1, 2):\n    ans = 0\n    M = i//2\n    b = 1\n    for j, a in enumerate(range(M, K)):\n        if M-j<0:\n            break\n        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b\n        #print((j, a), C(M, j) , H(N, K-a), b, pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b)\n        ans %= mod\n        b = -b\n    print(\"ans: \", str(ans))\n    if i == K+1:\n        break\n    elif i == K:\n        print(\"ans: \", str(ans))\n        print(\"ans: \", str(ans))\n        break\n    L.append(ans)\n    print(\"L: \", str(L))\n    L.append(ans)\n\nprint(*L[::-1], sep=\"\\n\")\n\n</ans>", "format_properties": {}}
{"idx": 132, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\na=list(map(int,input().split()))\nprint(\"a: \", str(a))\n\nc=[0]*1001\nprint(\"c: \", str(c))\n\nfor i in range (len(a)):\n\tc[a[i]]+=1\nprint(\"c: \", str(c))\n\nsym=0\nsin=0\n\nfor i in range (1001):\n\tsym+=(c[i]//4)\n\tif(c[i]%2==1):\n\t\tsin+=1\n\nprint(\"sym: \", str(sym))\nprint(\"sin: \", str(sin))\n\nif(n%2==0 and sym==((n*n)//4)):\n\tmat= [([0]*(n//2)) for i in range (n//2)]\n\tprint(\"mat: \", str(mat))\n\tar=[]\n\tfor i in range (1001):\n\t\twhile(c[i]>=4):\n\t\t\tar.append(i)\n\t\t\tc[i]-=4\n\tprint(\"ar: \", str(ar))\n\n\tk=0\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tmat[i][j]=ar[k]\n\t\t\tk+=1\n\tprint(\"mat: \", str(mat))\n\n\tnewm=[([0]*n) for i in range (n)]\n\tprint(\"newm: \", str(newm))\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tnewm[i][j]=mat[i][j]\n\t\t\tnewm[n-i-1][j]=mat[i][j]\n\t\t\tnewm[n-i-1][n-j-1]=mat[i][j]\n\t\t\tnewm[i][n-j-1]=mat[i][j]\n\n\tprint(\"newm: \", str(newm))\n\nelif(n%2==1 and (((sym>=(((n//2) *(n//2)) ) ) and (sin==1)))):\n\tmat= [([0]*(n//2)) for i in range (n//2)]\n\tprint(\"mat: \", str(mat))\n\tar=[]\n\tfor i in range (1001):\n\t\twhile(c[i]>=4):\n\t\t\tar.append(i)\n\t\t\tc[i]-=4\n\tprint(\"ar: \", str(ar))\n\n\tk=0\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tmat[i][j]=ar[k]\n\t\t\tar.pop(k)\n\tprint(\"mat: \", str(mat))\n\n\tnewm=[([0]*n) for i in range (n)]\n\tprint(\"newm: \", str(newm))\n\tfor i in range (n//2):\n\t\tfor j in range (n//2):\n\t\t\tnewm[i][j]=mat[i][j]\n\t\t\tnewm[n-i-1][j]=mat[i][j]\n\t\t\tnewm[n-i-1][n-j-1]=mat[i][j]\n\t\t\tnewm[i][n-j-1]=mat[i][j]\n\n\tna=len(ar)\n\tar2=[]\n\tfor i in range (na):\n\t\tar2.append(ar[i])\n\t\tar2.append(ar[i])\n\n\tfor i in range (1001):\n\t\twhile(c[i]>=2):\n\t\t\tar2.append(i)\n\t\t\tc[i]-=2\n\tprint(\"ar2: \", str(ar2))\n\n\tfor i in range (n//2):\n\t\tnewm[n//2 ][i]=ar2[0]\n\t\tnewm[n//2 ][n-i-1]=ar2[0]\n\t\tar2.pop(0)\n\t\tnewm[i][n//2 ]=ar2[0]\n\t\tnewm[n-i-1][n//2 ]=ar2[0]\n\t\tar2.pop(0)\n\n\tfor i in range (1001):\n\t\tif(c[i]==1):\n\t\t\tnewm[n//2][n//2]=i\n\n\tprint(\"newm: \", str(newm))\n\nelse:\n\tprint(\"NO\")\n\n</ans>", "format_properties": {}}
{"idx": 138, "result": 0, "generated": "<ans>\nimport sys\nimport math\nimport random\nn, k, x = map(int, input().split())\nprint(\"n: \", str(n), \"k: \", str(k), \"x: \", str(x))\na = list(map(int, input().split()))\nprint(\"a: \", str(a))\nans = 0\nif n == 1:\n    print(0)\n    return\nfor i in range(0, n - 1):\n    if a[i] == a[i + 1] == x:\n        l = i\n        print(\"l: \", str(l))\n        while l >= 0 and a[i] == a[l]:\n            l -= 1\n        r = i + 1\n        print(\"r: \", str(r))\n        while r < n and a[r] == x:\n            r += 1\n        while (1):\n            if l == -1 or r == n:\n                break\n            if a[l] != a[r]:\n                break\n            if l == 0 and r == n - 1:\n                break\n            if l == 0:\n                if a[0] == a[r + 1]:\n                    while r < n and a[r] == a[0]:\n                        r += 1\n                    l -= 1\n                    continue\n                else:\n                    break\n            if r == n - 1:\n                if a[n - 1] == a[l - 1]:\n                    while l >= 0 and a[l] == a[n - 1]:\n                        l -= 1\n                    r += 1\n                    continue\n                else:\n                    break\n            if a[l] == a[r + 1] or a[l - 1] == a[r]:\n                t = a[l]\n                print(\"t: \", str(t))\n                while l >= 0 and a[l] == t:\n                    l -= 1\n                while r < n and a[r] == t:\n                    r += 1\n            else:\n                break\n        ans = max(ans, r - l - 1)\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 129, "result": 0, "generated": "<ans>\nn, k = map(int, input().split())\nprint(\"n: \", str(n), \"k: \", str(k))\nXY = [list(map(int, input().split())) for _ in range(n)]\nprint(\"XY: \", str(XY))\nXY.sort(key=lambda x: x[0])\nXY = [xy + [x] for x, xy in enumerate(XY)]\nprint(\"XY: \", str(XY))\nXY.sort(key=lambda x: x[1])\nXY = [xy + [y] for y, xy in enumerate(XY)]\nprint(\"XY: \", str(XY))\n\ngr = [[0] * n for _ in range(n)]\nprint(\"gr: \", str(gr))\nfor _, _, i, j in XY:\n  gr[i][j] = 1\nprint(\"gr: \", str(gr))\n\nrui = [[0] * (n + 1) for _ in range(n + 1)]\nprint(\"rui: \", str(rui))\nfor i in range(n):\n  for j in range(n):\n    rui[i + 1][j + 1] = rui[i + 1][j] + rui[i][j + 1] - rui[i][j] + gr[i][j]\nprint(\"rui: \", str(rui))\n\n# XY\u306e2\u70b9,3\u70b9,4\u70b9\u3092\u7dcf\u5f53\u305f\u308a\nans = 10 ** 21\nfor i in range(n - 1):\n  for j in range(i + 1, n):\n    x = [XY[m][0] for m in [i, j]]\n    y = [XY[m][1] for m in [i, j]]\n    ii = [XY[m][2] for m in [i, j]]\n    jj = [XY[m][3] for m in [i, j]]\n    innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                + rui[min(ii)][min(jj)] \\\n                - rui[min(ii)][max(jj) + 1] \\\n                - rui[max(ii) + 1][min(jj)]\n    if innerPoints >= k:\n      area = (max(x) - min(x)) * (max(y) - min(y))\n      if area < ans:\n        ans = area\n\nif n > 2:\n  for i in range(n - 2):\n    for j in range(i + 1, n - 1):\n      for l in range(j + 1, n):\n        x = [XY[m][0] for m in [i, j, l]]\n        y = [XY[m][1] for m in [i, j, l]]\n        ii = [XY[m][2] for m in [i, j, l]]\n        jj = [XY[m][3] for m in [i, j, l]]\n        innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                    + rui[min(ii)][min(jj)] \\\n                    - rui[min(ii)][max(jj) + 1] \\\n                    - rui[max(ii) + 1][min(jj)]\n        if innerPoints >= k:\n          area = (max(x) - min(x)) * (max(y) - min(y))\n          if area < ans:\n            ans = area\n\nif n > 3:\n  for i in range(n - 3):\n    for j in range(i + 1, n - 2):\n      for l in range(j + 1, n - 1):\n        for o in range(l + 1, n):\n          x = [XY[m][0] for m in [i, j, o, l]]\n          y = [XY[m][1] for m in [i, j, o, l]]\n          ii = [XY[m][2] for m in [i, j, o, l]]\n          jj = [XY[m][3] for m in [i, j, o, l]]\n          innerPoints = rui[max(ii) + 1][max(jj) + 1] \\\n                      + rui[min(ii)][min(jj)] \\\n                      - rui[min(ii)][max(jj) + 1] \\\n                      - rui[max(ii) + 1][min(jj)]\n          if innerPoints >= k:\n            area = (max(x) - min(x)) * (max(y) - min(y))\n            if area < ans:\n              ans = area\n\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 140, "result": 0, "generated": "<ans>\n```\nimport sys\nsys.setrecursionlimit(4100000)\nimport math\nimport fractions\n\n'''\n1\u884c\u306eint\nN, K = map(int, input().split())\n\n1\u884c\u306estring\nS, T = input().split()\n\n1\u884c\u306e\u6574\u6570\u914d\u5217\nP = list(map(int,input().split()))\n\n\u8907\u6570\u884c2\u6570\u5024\nx = []\ny = []\nfor i in range(5):\n    x1,y1=[int(i) for i in input().split()]\n    x.append(x1)\n    y.append(y1)\n\n'''\n\nprint(\"S: \", str(S))\ncheck = len(S)-1\nprint(\"check: \", str(check))\n\nwhile(check >= 0):\n\n    if S[check] == \"r\":\n        print(\"S[check]: \", str(S[check]))\n        if S[check-2] == \"m\":\n            print(\"S[check-2]: \", str(S[check-2]))\n            remove = S[check-6: check+1]\n            print(\"remove: \", str(remove))\n            if remove == \"dreamer\":\n                check -= 7\n                print(\"check: \", str(check))\n            else:\n                print(\"NO\")\n                return\n\n        elif S[check-2] == \"s\":\n            print(\"S[check-2]: \", str(S[check-2]))\n            remove = S[check-5: check+1]\n            print(\"remove: \", str(remove))\n            if remove == \"eraser\":\n                check -= 6\n                print(\"check: \", str(check))\n            else:\n                print(\"NO\")\n                return\n\n        else:\n            print(\"NO\")\n            return\n\n    elif S[check] == \"e\":\n        print(\"S[check]: \", str(S[check]))\n        remove = S[check-4: check+1]\n        print(\"remove: \", str(remove))\n        if remove == \"erase\":\n            check -= 5\n            print(\"check: \", str(check))\n        else:\n            print(\"NO\")\n            return\n\n    elif S[check] == \"m\":\n        print(\"S[check]: \", str(S[check]))\n        remove = S[check-4: check+1]\n        print(\"remove: \", str(remove))\n        if remove == \"dream\":\n            check -= 5\n            print(\"check: \", str(check))\n        else:\n            print(\"NO\")\n            return\n\n    else:\n        print(\"NO\")\n        return\n\nprint(\"YES\")\n```", "format_properties": {}}
{"idx": 139, "result": 0, "generated": "<ans>\nka, kb = 0, 0\nprint(\"ka: \", str(ka), \"kb: \", str(kb))\n\ndef g(a, b):\n    nonlocal ka, kb\n    if a == b:\n        return\n    if abs(a - b) == 2:\n        if a == 1:\n            ka += 1\n        else:\n            kb += 1\n    else:\n        if a > b:\n            ka += 1\n        else:\n            kb += 1\n\ndef main():\n    nonlocal ka, kb\n    k, a, b = list(map(int, input().split()))\n    print(\"k: \", str(k), \"a: \", str(a), \"b: \", str(b))\n    aa = [[] for i in [1, 1, 1]]\n    bb = [[] for i in [1, 1, 1]]\n    print(\"aa: \", str(aa), \"bb: \", str(bb))\n    aa[0] = list(map(int, input().split()))\n    aa[1] = list(map(int, input().split()))\n    aa[2] = list(map(int, input().split()))\n    bb[0] = list(map(int, input().split()))\n    bb[1] = list(map(int, input().split()))\n    bb[2] = list(map(int, input().split()))\n    print(\"aa: \", str(aa), \"bb: \", str(bb))\n    x = a\n    y = b\n    o = 1\n    c = [[x, y]]\n    d = [[0, 0]]\n    g(x, y)\n    if k == 1:\n        return\n    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n    print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n    while [x, y] not in c:\n        o += 1\n        c += [[x, y]]\n        d += [[ka, kb]]\n        g(x, y)\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n        if o == k:\n            return\n    ind = c.index([x, y])\n    dka = ka - d[ind][0]\n    dkb = kb - d[ind][1]\n    delta = o - ind\n    kk = (k - ind) // delta - 1\n    print(\"dka: \", str(dka), \"dkb: \", str(dkb), \"delta: \", str(delta))\n    ka += kk * dka\n    kb += kk * dkb\n    o += kk * delta\n    while o != k:\n        o += 1\n        g(x, y)\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        print(\"x: \", str(x), \"y: \", str(y), \"ka: \", str(ka), \"kb: \", str(kb))\n\nmain()\nprint(\"ka: \", str(ka), \"kb: \", str(kb))\n</ans>", "format_properties": {}}
{"idx": 141, "result": 0, "generated": "<ans>\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n + 1\n        self.parents = [-1] * self.n\n        print(\"self.n: \", str(self.n))\n        print(\"self.parents: \", str(self.parents))\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n        # TODO \u6839\u3092\u8fd4\u3059\n        return x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nfrom collections import defaultdict\ndef main():\n    N, M = list(map(int, input().split()))\n    print(\"N: \", str(N))\n    print(\"M: \", str(M))\n    A = list(map(int, input().split()))\n    print(\"A: \", str(A))\n    B = list(map(int, input().split()))\n    print(\"B: \", str(B))\n    A.append(0)\n    B.append(0)\n    uf = UnionFind(N+1)\n    for _ in range(M):\n        c, d = list(map(int,input().split()))\n        print(\"c: \", str(c))\n        print(\"d: \", str(d))\n        uf.union(c, d)\n    A_sums = defaultdict(int)\n    B_sums = defaultdict(int)\n    for i in range(1, N+1):\n        x = uf.find(i)\n        A_sums[x] += A[i-1]\n        B_sums[x] += B[i-1]\n    for a, b in zip(list(A_sums.values()), list(B_sums.values())):\n        if a != b:\n            print('No')\n            return\n    print('Yes')\n\n\nmain()\n\n</ans>", "format_properties": {}}
{"idx": 144, "result": 0, "generated": "<ans>\nfrom array import array\ninf = (1 << 30)\n\ndef main():\n    print(\"n, k: \", str([int(x) for x in input().split(' ')]))\n    n, k = [int(x) for x in input().split(' ')]\n    Matrix = []\n    for i in range(n):\n        Matrix.append(array('b',[ord(x) for x in input()]))\n    print(\"Matrix: \", str(Matrix))\n    dp = [array('l', [inf for j in range(n)]) for i in range(n)]\n    print(\"dp: \", str(dp))\n    direct = [[ord('d') for j in range(n)] for i in range(n)]\n    print(\"direct: \", str(direct))\n    opt = \"\"\n    for s in range (2 * n - 1):\n        opchar = chr(ord('z') + 1)\n        positions = []\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(i > 0 and j > 0):\n                    if(dp[i-1][j] < dp[i][j-1]):\n                        dp[i][j] = dp[i-1][j]\n                        direct[i][j] = 'l'\n                    else:\n                       dp[i][j] = dp[i][j-1]\n                       direct[i][j] = 'd'\n                elif i > 0:\n                    dp[i][j] = dp[i-1][j]\n                    direct[i][j] = 'l'\n                elif j > 0:\n                    dp[i][j] = dp[i][j-1]\n                    direct[i][j] = 'd'\n                else:\n                    dp[i][j] = 0\n                    direct[i][j] = 'e'\n                if(dp[i][j] < k and Matrix[i][j] is not ord('a')):\n                    dp[i][j]+=1\n                    Matrix[i][j] = ord('a')\n                if(Matrix[i][j] < ord(opchar) and dp[i][j] <= k):\n                     opchar = chr(Matrix[i][j])\n        for i in range(0, s+1):\n            j = s - i;\n            if j < n and i < n:\n                if(Matrix[i][j] is not ord(opchar)):\n                    dp[i][j] = inf\n    ans = \"\"\n    a,b = (n-1,n-1)\n    while(direct[a][b] is not 'e'):\n        ans += chr(Matrix[a][b])\n        if(direct[a][b] is 'l'):\n            a-=1\n        else:\n            b-=1\n    ans += chr(Matrix[0][0])\n    print(ans[::-1])\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 147, "result": 0, "generated": "<ans>\nimport sys\nfrom functools import lru_cache\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\ndef main():\n    N, K, *A = list(map(int, read().split()))\n    print(\"N: \", str(N), \"K: \", str(K), \"A: \", str(A))\n\n    K = list(map(int, f'{K:>040b}'))\n    print(\"K: \", str(K))\n\n    A2 = [list(map(int, f'{a:>040b}')) for a in A]\n    print(\"A2: \", str(A2))\n\n    B = [0] * 40\n    for a in A2:\n        for i, bit in enumerate(a):\n            B[i] += bit\n    print(\"B: \", str(B))\n\n    for i in range(40):\n        if B[i] == N - B[i]:\n            B[i] = 2\n        elif B[i] < N - B[i]:\n            B[i] = 1\n        else:\n            B[i] = 0\n    print(\"B: \", str(B))\n\n    @lru_cache(maxsize=None)\n    def rec(i, x, smaller):\n        if i == 40:\n            ans = 0\n            for a in A:\n                ans += x ^ a\n            return ans\n        elif smaller:\n            if B[i] == 2:\n                return rec(i + 1, (x << 1), True)\n            else:\n                return rec(i + 1, (x << 1) + B[i], True)\n        else:\n            if B[i] == 2:\n                if K[i] == 0:\n                    return rec(i + 1, (x << 1), False)\n                else:\n                    return rec(i + 1, (x << 1), True)\n            elif K[i] == B[i]:\n                return rec(i + 1, (x << 1) + K[i], False)\n            elif K[i] < B[i]:\n                return rec(i + 1, (x << 1) + K[i], False)\n            else:\n                return rec(i + 1, (x << 1) + B[i], True)\n\n    print((rec(0, 0, False)))\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 148, "result": 0, "generated": "<ans>\n#\n# abc069 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3\n1 10 100\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"4\n1 2 3 4\"\"\"\n        output = \"\"\"No\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"3\n1 4 1\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_4(self):\n        input = \"\"\"2\n1 1\"\"\"\n        output = \"\"\"No\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_5(self):\n        input = \"\"\"6\n2 7 1 8 2 8\"\"\"\n        output = \"\"\"Yes\"\"\"\n        self.assertIO(input, output)\n\ndef resolve():\n    N = int(input())\n    print(\"N: \", str(N))\n    A = list(map(int, input().split()))\n    print(\"A: \", str(A))\n\n    Q = 0\n    E = 0\n    O = 0\n    for a in A:\n        if a % 4 == 0:\n            Q += 1\n        elif a % 2 == 0:\n            E += 1\n        else:\n            O += 1\n    print(\"Q: \", str(Q), \"E: \", str(E), \"O: \", str(O))\n\n    if N-2*Q <= 0 or (N-2*Q) == 1 or N-2*Q == E:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 145, "result": 0, "generated": "<ans>\nimport sys\n\ncases = False\n\n# Pre-defined function\n# Begin\ndef fast_pow(a:int, b:int):\n    print(\"a: \", str(a), \"b: \", str(b))\n    res = 1\n    while b > 0:\n        if b & 1:\n            res *= a\n        a *= a\n        b >>= 1\n    return res\n\ndef c2(n):\n    print(\"n: \", str(n))\n    return n * (n-1) // 2\n\ndef get():\n    print(\"input: \", str(input()))\n    return list(map(int, input().split()))\n\ndef bits(n: int):\n    print(\"n: \", str(n))\n    return list(bin(n)).count('1')\n\ndef main(test_case = False):\n    print(\"test_case: \", str(test_case))\n    n = int(input()) if test_case else 1\n    for _ in range(n):\n        test()\n\ndef flush():\n    sys.stdout.flush()\n\ndef parr(arr):\n    print(\"arr: \", str(arr))\n    print(*arr, sep=' ')\n\ndef gcd(a, b):\n    print(\"a: \", str(a), \"b: \", str(b))\n    while b:\n        if b % a == 0:\n            break\n        tmp = a\n        a = b % a\n        b = tmp\n    return a\n\ndef ext_gcd(a: int, b: int):\n    print(\"a: \", str(a), \"b: \", str(b))\n    if (b == 0):\n        return [a, [1, 0]]\n\n    res = ext_gcd(b, a % b)\n    g = res[0]\n    x1 = res[1][0]\n    y1 = res[1][1]\n    x = y1\n    y = x1 - y1 * (a // b)\n\n    return [g, [x, y]]\n\n# End\n\nb = []\np = []\nn = m = a = 0\n\ndef check(cnt):\n    print(\"cnt: \", str(cnt))\n    if cnt == 0:\n        return True\n    x = b[-cnt:]\n    y = p[:cnt]\n    s = a\n    i = 0\n    while i < cnt and s >= 0:\n        s -= max(0, y[i]-x[i])\n        i += 1\n    return s >= 0\n\ndef test():\n    nonlocal n, m, a, b, p\n    n, m, a = get()\n    b = sorted(get())\n    p = sorted(get())\n\n    left = 0\n    right = min(n, m)\n\n    ans = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if check(mid):\n            ans = max(ans, mid)\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if ans == -1:\n        print(0, 0)\n        return\n\n    # print(ans)\n\n    t = 0\n    x = b[-ans:]\n    y = p[:ans]\n    i = 0\n    while i < ans:\n        t += min(x[i], y[i])\n        a -= max(0, y[i]-x[i])\n        i += 1\n    print(ans, max(0, t-a))\n\nmain(cases)\n</ans>", "format_properties": {}}
{"idx": 146, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nla=[]\nprint(\"la: \", str(la))\nle=[]\nprint(\"le: \", str(le))\nli=[]\nprint(\"li: \", str(li))\nlo=[]\nprint(\"lo: \", str(lo))\nlu=[]\nprint(\"lu: \", str(lu))\nans=[]\nprint(\"ans: \", str(ans))\nd1={}\nfor i in range(n):\n    s=input()\n    x=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')\n    print(\"x: \", str(x))\n    if x>0:\n        for c in s[::-1]:\n            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':\n                break\n        if (x,c) in d1:\n            d1[(x,c)].append(s)\n        else :\n            d1[(x,c)]=[s]\nd2={}\npairs1=[]\nprint(\"pairs1: \", str(pairs1))\npairs2=[]\nprint(\"pairs2: \", str(pairs2))\nfor k in d1:\n    if len(d1[k])%2==1:\n        if k[0] in d2:\n            d2[k[0]].append(d1[k][0])\n        else :\n            d2[k[0]]=[d1[k][0]]\n        for i in range(1,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\n    else :\n        for i in range(0,len(d1[k]),2):\n            pairs1.append((d1[k][i],d1[k][i+1]))\nfor k in d2:\n    if len(d2[k])>1:\n        if len(d2[k])%2==1:\n            d2[k].pop()\n        for i in range(0,len(d2[k]),2):\n            pairs2.append((d2[k][i],d2[k][i+1]))\nif len(pairs1)<len(pairs2):\n    print(\"len(pairs1): \", str(len(pairs1)))\n    for i in range(len(pairs1)):\n        print(\"pairs2[i][0]: \", str(pairs2[i][0]), \"pairs1[i][0]: \", str(pairs1[i][0]))\n        print(\"pairs2[i][1]: \", str(pairs2[i][1]), \"pairs1[i][1]: \", str(pairs1[i][1]))\nelse :\n    print(\"len(pairs2)+(len(pairs1)-len(pairs2))//2: \", str(len(pairs2)+(len(pairs1)-len(pairs2))//2))\n    for i in range(len(pairs2)):\n        print(\"pairs2[i][0]: \", str(pairs2[i][0]), \"pairs1[i][0]: \", str(pairs1[i][0]))\n        print(\"pairs2[i][1]: \", str(pairs2[i][1]), \"pairs1[i][1]: \", str(pairs1[i][1]))\n    for j in range(len(pairs2),len(pairs1),2):\n        if j==len(pairs1)-1:\n            break\n        else :\n            print(\"pairs1[j][0]: \", str(pairs1[j][0]), \"pairs1[j+1][0]: \", str(pairs1[j+1][0]))\n            print(\"pairs1[j][1]: \", str(pairs1[j][1]), \"pairs1[j+1][1]: \", str(pairs1[j+1][1]))\n</ans>", "format_properties": {}}
{"idx": 142, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout\n\nk = int(stdin.readline())\n\nprint(\"k: \", str(k))\n\nn, m = list(map(int, stdin.readline().split()))\n\nprint(\"n, m: \", str(n), \", \", str(m))\n\nleft, right, down, up = [], [], [], []\n\ncoordinates = []\n\nfor i in range(k):\n\n    x1, y1, x2, y2 = list(map(int, stdin.readline().split()))\n\n    if x1 == x2:\n\n        if y1 < y2:\n\n            coordinates.append((x1, y1, x2, y2, i))\n\n        else:\n\n            coordinates.append((x2, y2, x1, y1, i))\n\n    else:\n\n        if x1 < x2:\n\n            coordinates.append((x1, y1, x2, y2, i))\n\n        else:\n\n            coordinates.append((x2, y2, x1, y1, i))\n\n    left.append(coordinates[-1])\n\n    right.append(coordinates[-1])\n\n    up.append(coordinates[-1])\n\n    down.append(coordinates[-1])\n\nleft.sort(key = lambda x: (x[0], x[2]))\n\ndown.sort(key = lambda x: (x[1], x[3]))\n\nchallengers = [[], [], [], []]\n\ncntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))\n\nlabel = 1\n\nif cntl or not cntl:\n\n    for i in range(cntl, -1, -1):\n\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n\n            challengers[0].append(left[i][-1])\n\n        else:\n\n            break\n\n    for i in range(cntl + 1, k):\n\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:\n\n            label = 0\n\n        if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):\n\n            challengers[0].append(left[i][-1])\n\n        else:\n\n            break\n\nif cntr or not cntr:\n\n    for i in range(k - 1 - cntr, k):\n\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n\n            challengers[1].append(left[i][-1])\n\n        else:\n\n            break\n\n    for i in range(k - 2 - cntr, -1, -1):\n\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:\n\n            label = 0\n\n        if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):\n\n            challengers[1].append(left[i][-1])\n\n        else:\n\n            break\n\n#!!!!!!!!!!\n\nif cntd or not cntd:\n\n    for i in range(cntd, -1, -1):\n\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n\n            challengers[2].append(down[i][-1])\n\n        else:\n\n            break\n\n    for i in range(cntd + 1, k):\n\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:\n\n            label = 0\n\n        if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):\n\n            challengers[2].append(down[i][-1])\n\n        else:\n\n            break\n\nif cntu or not cntu:\n\n    for i in range(k - 1 - cntu, k):\n\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n\n            challengers[3].append(down[i][-1])\n\n        else:\n\n            break\n\n    for i in range(k - 2 - cntu, -1, -1):\n\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:\n\n            label = 0\n\n        if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):\n\n            challengers[3].append(down[i][-1])\n\n        else:\n\n            break\n\nans = set(challengers[0]) & set(challengers[1]) & set(challengers[2]) & set(challengers[3])\n\nif not len(ans) or not label:\n\n    stdout.write('-1')\n\nelse:\n\n    stdout.write(str(list(ans)[0] + 1))\n\n# Made By Mostafa_Khaled\n</ans>", "format_properties": {}}
{"idx": 149, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\nenum = enumerate\ninf = 1001001001\n\nprint(\"inf: \", str(inf))\n\nimport collections\nimport random\n\nprint(\"collections: \", str(collections))\nprint(\"random: \", str(random))\n\ndef linput(ty=int, cvt=list):\n\treturn cvt(list(map(ty,input().split())))\n\nprint(\"linput: \", str(linput))\n\ndef vinput(rep=1, ty=int, cvt=list):\n\treturn cvt(ty(input().rstrip()) for _ in \"*\"*rep)\n\nprint(\"vinput: \", str(vinput))\n\ndef gcd(a: int, b: int):\n\twhile b: a, b = b, a%b\n\treturn a\n\nprint(\"gcd: \", str(gcd))\n\ndef lcm(a: int, b: int):\n\treturn a * b // gcd(a, b)\n\nprint(\"lcm: \", str(lcm))\n\ndef dist(x1,y1,x2,y2):\n\treturn abs(x1-x2)+abs(y1-y2)\n\nprint(\"dist: \", str(dist))\n\n#vD = [chr(ord(\"a\")+i) for i in range(26)]\n\nprint(\"vD: \", str(vD))\n\ndef ran():\n\tvRan = [random.randint(1, 10),\n\t        random.randint(0, 10),\n\t        random.randint(1, 100)]\n\treturn vRan\n\nprint(\"ran: \", str(ran))\n\ndef bye(res):\n\tsT = \"No Yes\".split()\n\tprint((sT[res]))\n\t#return\n\nprint(\"bye: \", str(bye))\n\ndef sol_n(a,b,c):\n\tres = 0\n\tcnt = 0\n\twhile cnt<c:\n\t\tres += 1\n\t\tcnt += a\n\t\tif res%7==0:\n\t\t\tcnt += b\n\treturn res\n\nprint(\"sol_n: \", str(sol_n))\n\ndef sol(a,b,c):\n\t#a,b,c = linput()\n\t### 3 6 9 12 15\n\t### 1 2 3 4  5\n\n\tres = 0\n\tL = -(-a//c)\n\tR = (b//c)\n\tres = R-L+1\n\n\treturn res\n\nprint(\"sol: \", str(sol))\n\ndef deb():\n\t#vI = linput()\n\tvI = ran()\n\t#print(vI)\n\tI = sol_n(*vI)\n\tJ = sol(*vI)\n\tif 1:#I!=J:\n\t\tprint((vI, I, J))\n\nprint(\"deb: \", str(deb))\n\ndef main():\n\tvI = linput()\n\tprint((sol(*vI)))\n\nprint(\"main: \", str(main))\n\ndef __starting_point():\n\t#for _ in \"*\"*1000:\n\t#\tdeb()\n\tmain()\n\nprint(\"__starting_point: \", str(__starting_point))\n</ans>", "format_properties": {}}
{"idx": 150, "result": 0, "generated": "<ans>\nfrom math import sqrt, pow, log, log2, log10, exp\nfrom copy import deepcopy\nfrom fractions import gcd\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_int():\n    print(\"read_int: \", str(read_int()))\n    return read_ints()[0]\n\ndef read_floats():\n    return list(map(float, input().split()))\n\ndef read_float():\n    print(\"read_float: \", str(read_float()))\n    return read_floats()[0]\n\ndef format_list(l):\n    print(\"format_list: \", str(format_list(l)))\n    return ' '.join(list(map(str, l)))\n\ndef one_dim_array(n, value=0):\n    print(\"one_dim_array: \", str(one_dim_array(n, value)))\n    return [deepcopy(value) for x in range(n)]\n\ndef two_dim_array(n, m, value=0):\n    print(\"two_dim_array: \", str(two_dim_array(n, m, value)))\n    return [[deepcopy(value) for x in range(m)] for x in range(n)]\n\ndef is_prime(n):\n    print(\"is_prime: \", str(is_prime(n)))\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, sqrt(n) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef max_len_sublist(l, f):\n    print(\"max_len_sublist: \", str(max_len_sublist(l, f)))\n    start, max_length, length = 0, 0, 0\n    for i in range(1, len(l)):\n        if f(l[i], l[i - 1]):\n            length += 1\n        else:\n            if max_length < length:\n                start = i - length\n                max_length = length\n            length = 0\n    return start, max_length\n\ndef tf_to_yn(b):\n    print(\"tf_to_yn: \", str(tf_to_yn(b)))\n    return 'YES' if b else 'NO'\n\ndef longest_non_descent_subsequence(s, restore_sequence=False):\n    print(\"longest_non_descent_subsequence: \", str(longest_non_descent_subsequence(s, restore_sequence)))\n    d = one_dim_array(len(s), 0)\n    for i in range(len(s)):\n        possible = [d[j] + 1 if s[j] <= s[i] else 1 for j in range(i)]\n        d[i] = 1 if len(possible) == 0 else max(possible)\n\n    if not restore_sequence:\n        return d[-1] if len(d) != 0 else 0\n\nl = read_int()\np = read_int()\nq = read_int()\nt = l / (p + q)\nprint(\"t: \", str(t))\nprint(t*p)\n\n</ans>", "format_properties": {}}
{"idx": 151, "result": 0, "generated": "<ans>\nz=[int(p) for p in input().split()]\nprint(\"z: \", str(z))\nm=z[2]\nprint(\"m: \", str(m))\nlst=[]\nprint(\"lst: \", str(lst))\nlst.append(z[0])\nprint(\"lst: \", str(lst))\nlst.append(z[1])\nprint(\"lst: \", str(lst))\ntempi=min(lst)\nprint(\"tempi: \", str(tempi))\ntempa=max(lst)\nprint(\"tempa: \", str(tempa))\n\ncount=0\nprint(\"count: \", str(count))\nfibo=[]\nprint(\"fibo: \", str(fibo))\n\nn=1000000000000000000\nprint(\"n: \", str(n))\n\ndef fib(n):\n        a, b = 0, 1\n        while b < n:\n                fibo.append(b)\n                a, b = b, a+b\n\ndef add(m):\n        n=10**18\n        print(\"n: \", str(n))\n        tempi=min(lst)\n        print(\"tempi: \", str(tempi))\n        tempa=max(lst)\n        print(\"tempa: \", str(tempa))\n        count=0\n        print(\"count: \", str(count))\n        if(tempi>0 and tempa>0 and m>tempa):\n                fib(n)\n                for p in range(1,len(fibo)+1):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n        elif(tempi==0 or tempa==0):\n                count=1\n                fib(n)\n                tempi=tempa+(tempi)\n                for p in range(1,len(fibo)):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n\n        elif(tempi<0 and tempa>0):\n                val=(-(tempi)//tempa)+1\n                count=val\n                tempi=tempi+(val*tempa)\n                fib(n)\n                for p in range(1,len(fibo)):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n\n</ans>", "format_properties": {}}
{"idx": 153, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\n\nINF = float(\"inf\")\n\ndef solve(N: int, X: int, D: int):\n    print(\"N: \", str(N), \"X: \", str(X), \"D: \", str(D))\n    if D == 0:\n        if X == 0:\n            print((1))\n        else:\n            print((N+1))\n        return\n\n    if D < 0:\n        X = X + (N-1)*D\n        D = abs(D)\n\n    segs = defaultdict(list)\n    print(\"segs: \", str(segs))\n    for k in range(N+1):\n        L = k*(k-1)//2\n        R = k*N - k*(k+1)//2\n        Ck = k*X + D*L\n        Rk = R-L\n        seg = (Ck//D, Ck//D+Rk+1)\n        s = Ck % D\n        segs[s].append(seg)\n\n    tot = 0\n    print(\"tot: \", str(tot))\n    for k in segs:\n        event = defaultdict(int)\n        print(\"event: \", str(event))\n        for l, r in segs[k]:\n            event[l] += 1\n            event[r] -= 1\n\n        curr = 0\n        pre = -1\n        for k in sorted(event.keys()):\n            if curr > 0:\n                tot += k - pre\n            curr += event[k]\n            pre = k\n    print(\"tot: \", str(tot))\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    X = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    solve(N, X, D)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 154, "result": 0, "generated": "<ans>\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nn = int(input())\nprint(\"n: \", str(n))\np = list(map(int, input().split()))\nprint(\"p: \", str(p))\nodd = (n+1)//2\nprint(\"odd: \", str(odd))\neven = n-odd\nprint(\"even: \", str(even))\nfor i in p:\n    if i:\n        if i%2 == 0:\n            even -= 1\n        else:\n            odd -= 1\n\nif even == 0:\n    p = [i if i else 1 for i in p]\n    print(\"p: \", str(p))\nif odd*even == 0:\n    ans = 0\n    prev = p[0]\n    for pi in p:\n        ans += (pi+prev)%2\n        prev = pi\n    print(\"ans: \", str(ans))\n    return\n\nDP = [[float(\"inf\")]*(even+1) for i in range(2)]\nprint(\"DP: \", str(DP))\nfor i in range(n):\n    nxt = [[float(\"inf\")]*(even+1) for i in range(2)]\n    if i == 0:\n        if p[i]:\n            if p[i]%2 == 0:\n                nxt[0][0] = 0\n            else:\n                nxt[1][0] = 0\n        else:\n            nxt[0][1] = 0\n            nxt[1][0] = 0\n    else:\n        if p[i]:\n            if p[i]%2 == 0:\n                for j in range(even+1):\n                    nxt[0][j] = min(DP[0][j], DP[1][j]+1)\n            else:\n                for j in range(even+1):\n                    nxt[1][j] = min(DP[0][j]+1, DP[1][j])\n        else:\n            for j in range(1, even+1):\n                nxt[0][j] = min(DP[0][j-1], DP[1][j-1]+1)\n            for j in range(even+1):\n                nxt[1][j] = min(DP[0][j]+1, DP[1][j])\n    DP = nxt\n    print(\"DP: \", str(DP))\nprint(min(DP[0][-1], DP[1][-1]))\n</ans>", "format_properties": {}}
{"idx": 143, "result": 0, "generated": "<ans>\nimport math\nimport sys\n##### graph implementation with adjacancy list#####\nclass Graph:\n    def __init__(self, Nodes, is_directed=False):\n        print(\"Nodes: \", str(Nodes))\n        print(\"is_directed: \", str(is_directed))\n        self.nodes = Nodes\n        self.adj_list = {}\n        self.is_directed = is_directed\n\n        for node in self.nodes:\n            self.adj_list[node] = []\n            print(\"adj_list[{}]: \".format(node), str(self.adj_list[node]))\n\n    def add_edge(self, u, v):\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        self.adj_list[u].append(v)\n        if self.is_directed == False:\n            self.adj_list[v].append(u)\n\n    def print_graph(self):\n        for node in self.nodes:\n            print((node, \"->\", self.adj_list[node]))\n\n    def degree_node(self, node):\n        print(\"node: \", str(node))\n        return len(self.adj_list[node])\n\n    def dfsUTIL(self, v, visited, parents=[]):\n        # print(v, end=\" \")\n        visited[v] = True\n        for i in self.adj_list[v]:\n            if visited[i] == False:\n                self.dfsUTIL(i, visited, parents)\n                parents.append(i)\n\n    def dfs(self, v):\n        visited = [False] * (max(self.adj_list) + 1)\n        parents = [v]\n        self.dfsUTIL(v, visited, parents)\n        return len(parents)\n\n##### sorting a dictionary by the values #####\ndef dict_sort(ans):\n    print(\"ans: \", str(ans))\n    ans = sorted(list(ans.items()), reverse=True, key=lambda kv: (kv[1]))\n\n##### naive method for testing prime or not O(n^.5) #####\ndef is_prime(n):\n    print(\"n: \", str(n))\n    if n == 1:\n        return 0\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n##### swap function #####\ndef swap(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    temp = a\n    a = b\n    b = temp\n    return a, b\n\n##### Primes till Nth O(n) #####\ndef seive_primes(n):\n    print(\"n: \", str(n))\n    flag = [0] * (n + 10)\n    flag[1] = flag[0] = 1\n    i = 2\n    while i * i <= n + 1:\n        if flag[i] == 0:\n            j = i * i\n            while j <= n + 1:\n                flag[j] = 1\n                j += i\n        i += 1\n    return flag\n\n##### all the prime factors of a number #####\ndef factors(n):\n    print(\"n: \", str(n))\n    d = {}\n    while n % 2 == 0:\n        if 2 in d:\n            d[2] += 1\n        else:\n            d[2] = 1\n        n /= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n            n /= i\n    n = int(n)\n    if n > 1:\n        d[n] = 1\n    return d\n\n##### greatest common divisor of two numbers #####\ndef gcd(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n##### least common multiplyer of two numbers #####\ndef lcm(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    return (a * b) // gcd(a, b)\n\n##### function that return all the letters #####\ndef alphabates():\n    return \"abcdefghijklmnopqrstuvwxyz\"\n\n##### binary search O(logN) #####\ndef binary_search(ls, n, flag):\n    print(\"ls: \", str(ls))\n    print(\"n: \", str(n))\n    print(\"flag: \", str(flag))\n    low = 0\n    hi = n - 1\n    while low <= hi:\n        mid = (low + hi) // 2\n        if ls[mid] == flag:\n            return mid\n        elif ls[mid] > flag:\n            hi = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\n##### quadratic roots #####\ndef qdrt(a, b, c):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    print(\"c: \", str(c))\n    chk = b * b - 4 * a * c\n    if chk >= 0:\n        ans1 = (-b + chk ** 0.5) / (2 * a)\n        ans2 = (-b - chk ** 0.5) / (2 * a)\n        return [int(ans1), int(ans2)]\n    return -1\n\n##### permutations #####\ndef permutation(n, r):\n    print(\"n: \", str(n))\n    print(\"r: \", str(r))\n    if n < r:\n        return 0\n    ans = 1\n    for i in range(n - r + 1, n + 1):\n        ans *= i\n    return ans\n\n##### combinations #####\ndef combination(n, r):\n    print(\"n: \", str(n))\n    print(\"r: \", str(r))\n    if n < r:\n        return 0\n    ans = 1\n    for i in range(r):\n        ans *= (n - i)\n    div = 1\n    for i in range(2, r + 1):\n        div *= i\n    return ans // div\n\n##### taking an array/list as input #####\ndef arinp():\n    ls = list(map(int, input().split()))\n    print(\"ls: \", str(ls))\n    return ls\n\n##### taking multiple inputs #####\ndef mult_inp():\n    return list(map(int, input().split()))\n\n##### Main function starts from here #####\ndef main():\n    s = input()\n    print(\"s: \", str(s))\n    n = len(s)\n    print(\"n: \", str(n))\n    if s == s[::-1] and s[:n // 2] == s[n // 2 + 1:]:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 152, "result": 0, "generated": "<ans>\n```python\n# NOT MY CODE\n# https://codeforces.com/contest/919/submission/80857331\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        to = f(*args, **kwargs)\n        if stack:\n            return to\n        else:\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        return to\n                    to = stack[-1].send(to)\n    return wrappedfunc\n\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\n\nn, m = list(map(int, input().split()))\ns = input()\nprint(\"n: \", str(n), \"m: \", str(m), \"s: \", str(s))\nd = dd(list)\nprint(\"d: \", str(d))\nlol = 0\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    print(\"u: \", str(u), \"v: \", str(v))\n    if(u == v):\n        lol = 1\n        print(-1)\n        return\n    d[u].append(v)\nprint(\"d: \", str(d))\n\nvis = [0] * (n + 1)\nrvis = [0] * (n + 1)\ncou = [0]\ndp = [dd(int) for i in range(n + 1)]\nprint(\"vis: \", str(vis), \"rvis: \", str(rvis), \"cou: \", str(cou), \"dp: \", str(dp))\nmx = [0]\nh = [0]\nprint(\"mx: \", str(mx), \"h: \", str(h))\n\n@bootstrap\ndef dfs(u):\n    if(h[0] == 1):\n        yield\n    vis[u] = 1\n    rvis[u] = 1\n    print(\"vis[u]: \", str(vis[u]), \"rvis[u]: \", str(rvis[u]))\n    for i in d[u]:\n        if(h[0] == 1):\n            yield\n        if(vis[i] == 0):\n            yield dfs(i)\n            if(h[0] == 1):\n                yield\n        elif(rvis[i] == True):\n            h[0] = 1\n            yield\n    rvis[u] = 0\n    print(\"rvis[u]: \", str(rvis[u]))\n    if(h[0] == 1):\n        yield\n    for i in d[u]:\n        for j in dp[i]:\n            dp[u][j] = max(dp[u][j], dp[i][j])\n            mx[0] = max(mx[0], dp[u][j])\n    print(\"dp[u]: \", str(dp[u]), \"mx[0]: \", str(mx[0]))\n    dp[u][s[u - 1]] += 1\n    print(\"dp[u][s[u - 1]]: \", str(dp[u][s[u - 1]]))\n    mx[0] = max(mx[0], dp[u][s[u - 1]])\n    print(\"mx[0]: \", str(mx[0]))\n    yield\n\nfor i in range(1, n + 1):\n    if(vis[i] == 0):\n        cou = [0]\n        dfs(i)\nif(h[0]):\n    print(-1)\nelse:\n    print(mx[0])\n```", "format_properties": {}}
{"idx": 155, "result": 0, "generated": "<ans>\n```\n# E\nN = int(input())\nprint(\"N: \", str(N))\nP_list = list(map(int, input().split()))\nprint(\"P_list: \", str(P_list))\nX_list = list(map(int, input().split()))\nprint(\"X_list: \", str(X_list))\n\n# graph\nchild_list = [[] for _ in range(N+1)]\nprint(\"child_list: \", str(child_list))\nfor i in range(2, N+1):\n    child_list[P_list[i-2]].append(i)\n\n# from root\n# minimize local total weight\n\ncolor1 = [0]+X_list\nprint(\"color1: \", str(color1))\ncolor2 = [0]*(N+1)\nprint(\"color2: \", str(color2))\n\n# solve knapsack\ndef solve_knapsack(L, M):\n    min_acc = sum([min(color1[j], color2[j]) for j in L])\n    print(\"min_acc: \", str(min_acc))\n    if min_acc > M:\n        return -1\n    else:\n        add_can = M - min_acc\n        add_set = set([0])\n        print(\"add_set: \", str(add_set))\n        for j in L:\n            add_j = max(color1[j], color2[j]) - min(color1[j], color2[j])\n            add_set_ = set(add_set)\n            for s in add_set:\n                if s + add_j <= add_can:\n                    add_set_.add(s + add_j)\n            add_set = add_set_\n        print(\"add_set: \", str(add_set))\n\n        total = sum([color1[j]+color2[j] for j in L])\n        print(\"total: \", str(total))\n        return total - max(add_set) - min_acc\n\nres = \"POSSIBLE\"\nprint(\"res: \", str(res))\n\nfor i in range(N, 0, -1):\n    if len(child_list[i]) == 0:\n        pass\n    elif len(child_list[i]) == 1:\n        j = child_list[i][0]\n        if min(color1[j], color2[j]) > X_list[i-1]:\n            res = \"IMPOSSIBLE\"\n            break\n        elif max(color1[j], color2[j]) > X_list[i-1]:\n            color2[i] = max(color1[j], color2[j])\n        else:\n            color2[i] = min(color1[j], color2[j])\n    else:\n        c2 = solve_knapsack(child_list[i], X_list[i-1])\n        if c2 < 0:\n            res = \"IMPOSSIBLE\"\n            break\n        else:\n            color2[i] = c2\n\nprint(res)\n</ans>", "format_properties": {}}
{"idx": 156, "result": 0, "generated": "<ans>\n```\ndef prime_factor(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            while n % i == 0:\n                n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    print(\"factors: \", str(factors))\n    return factors\n\ndef divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    print(\"divisors: \", str(divisors))\n    return divisors\n\ndef mebius(n):\n    res = {}\n    primes = prime_factor(n)\n    m = len(primes)\n    for i in range(1 << m):\n        mu = 1\n        d = 1\n        for j in range(m):\n            if i >> j & 1:\n                mu *= -1\n                d *= primes[j]\n        res[d] = mu\n    print(\"res: \", str(res))\n    return res\n\nmod = 10**9+7\nN, K = list(map(int, input().split()))\ndiv = divisors(N)\nprint(\"N: \", str(N), \"K: \", str(K), \"div: \", str(div))\n\nans = 0\n\nfor x in div:\n    div2 = divisors(x)\n    mu = mebius(x)\n    cnt = 0\n    for y in list(mu.keys()):\n        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]\n    if x % 2 == 0:\n        cnt *= pow(2, mod-2, mod)\n    ans += x*cnt\n    ans %= mod\n\nprint(\"ans: \", str(ans))\n```\n</ans>", "format_properties": {}}
{"idx": 134, "result": 0, "generated": "<ans>\n__author__ = 'zhan'\n\nimport time\n[a1, b1] = [int(i) for i in input().split()]\n[a2, b2] = [int(i) for i in input().split()]\n\nt0 = time.time()\nq1 = [[a1, b1, 0]]\nq2 = [[a2, b2, 0]]\ntested1 = []\ntested2 = []\ntested_total1 = []\ntested_total2 = []\n\nprint(\"a1: \", str(a1), \"b1: \", str(b1))\nprint(\"a2: \", str(a2), \"b2: \", str(b2))\nprint(\"q1: \", str(q1))\nprint(\"q2: \", str(q2))\nprint(\"tested1: \", str(tested1))\nprint(\"tested2: \", str(tested2))\nprint(\"tested_total1: \", str(tested_total1))\nprint(\"tested_total2: \", str(tested_total2))\n\ndef equal(t, q):\n    lo = 0\n    hi = len(q)\n    while True:\n        if lo >= hi:\n            return False\n        m = (lo + hi) // 2\n        p = q[m]\n        temp = p[0] * p[1]\n        if t == temp:\n            return [p[0], p[1], p[2]]\n        if t < temp:\n            lo = m + 1\n        elif t > temp:\n            hi = m\n\ndef found(key, a):\n    lo = 0\n    hi = len(a)\n    while True:\n        if lo >= hi:\n            return False\n        m = (lo + hi) // 2\n        p = a[m]\n        if key[0] == p[0] and key[1] == p[1]:\n            return True\n        if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:\n            lo = m + 1\n        if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:\n            hi = m\n\nwhile True:\n    if len(q1) > 0 and len(q2) > 0:\n        total1 = q1[0][0] * q1[0][1]\n        total2 = q2[0][0] * q2[0][1]\n        print(\"total1: \", str(total1), \"total2: \", str(total2))\n        if total1 > total2:\n            ans = equal(total1, q2)\n            if ans:\n                print(str(ans[2] + q1[0][2]) + \"\\n\" + str(q1[0][0]) + \" \" + str(q1[0][1]) + \"\\n\" + str(ans[0]) + \" \" + str(ans[1]))\n            else:\n                if not(q1[0][0] & 1):\n                    tt = [q1[0][0] // 2, q1[0][1], q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q1[0][0] % 3 == 0:\n                    tt = [q1[0][0] // 3 * 2, q1[0][1], q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if not(q1[0][1] & 1):\n                    tt = [q1[0][0], q1[0][1] // 2, q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q1[0][1] % 3 == 0:\n                    tt = [q1[0][0], q1[0][1] // 3 * 2, q1[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested1) and (not tt[0]*tt[1] in tested_total1):\n                        tested1.append([tt[0], tt[1]])\n                        q1.append(tt)\n                        tested_total1.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q2)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                q1.pop(0)\n                q1.sort(key=lambda x: x[0]*x[1], reverse=True)\n                print(\"q1: \", str(q1))\n\n        elif total1 < total2:\n            ans = equal(total2, q1)\n            if ans:\n                print(str(ans[2] + q2[0][2]) + \"\\n\" + str(ans[0]) + \" \" + str(ans[1]) + \"\\n\" + str(q2[0][0]) + \" \" + str(q2[0][1]))\n                break\n            else:\n                if not(q2[0][0] & 1):\n                    tt = [q2[0][0] // 2, q2[0][1], q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q2[0][0] % 3 == 0:\n                    tt = [q2[0][0] // 3 * 2, q2[0][1], q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if not(q2[0][1] & 1):\n                    tt = [q2[0][0], q2[0][1] // 2, q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                if q2[0][1] % 3 == 0:\n                    tt = [q2[0][0], q2[0][1] // 3 * 2, q2[0][2] + 1]\n                    print(\"tt: \", str(tt))\n                    if (not [tt[0], tt[1]] in tested2) and (not tt[0]*tt[1] in tested_total2):\n                        tested2.append([tt[0], tt[1]])\n                        q2.append(tt)\n                        tested_total2.append(tt[0]*tt[1])\n                        an = equal(tt[0]*tt[1], q1)\n                        if ans:\n                            print(str(an[2] + tt[2]) + \"\\n\" + str(tt[0]) + \" \" + str(tt[1]) + \"\\n\" + str(an[0]) + \" \" + str(an[1]))\n                q2.pop(0)\n                q2.sort(key=lambda x: x[0]*x[1], reverse=True)\n                print(\"q2: \", str(q2))\n\n        else:\n            print(str(q1[0][2] + q2[0][2]) + \"\\n\" + str(q1[0][0]) + \" \" + str(q1[0][1]) + \"\\n\" + str(q2[0][0]) + \" \" + str(q2[0][1]))\n            break\n    else:\n        print(-1)\n        break\n\nt1 = time.time()\n#print(t1-t0)\n\n</ans>", "format_properties": {}}
{"idx": 159, "result": 0, "generated": "<ans>\nimport sys\n\n#\u7e26k\u3001\u6a2ak\u306e\u30de\u30b9\u306b\u79fb\u52d5\u3055\u305b\u3066\u8003\u3048\u308b\nn, k = map(int, sys.stdin.readline().strip().split())\nprint(\"n: \", str(n), \"k: \", str(k))\nx = []\ny = []\nmx = []\nmy = []\nfor _ in range(n):\n    xx, yy, c = sys.stdin.readline().strip().split()\n    xx = int(xx)\n    yy = int(yy)\n    print(\"xx: \", str(xx), \"yy: \", str(yy), \"c: \", str(c))\n    if c == 'W':\n        xx += k\n    xx %= 2 * k\n    yy %= 2 * k\n    if xx >= k:\n        if yy >= k:\n            x.append(xx - k)\n            y.append(yy - k)\n        else:\n            mx.append(xx - k)\n            my.append(yy)\n    else:\n        if yy >= k:\n            mx.append(xx)\n            my.append(yy - k)\n        else:\n            x.append(xx)\n            y.append(yy)\n\ngraph = [[0 for _ in range(k)] for __ in range(k)]\nprint(\"graph: \", str(graph))\n\n#\u7d2f\u7a4d\u548c\n#lx + lmx = n\nlx = len(x)\nprint(\"lx: \", str(lx))\ngraph[0][0] += lx\nfor i in range(lx):\n    graph[x[i]][0] -= 1\n    graph[0][y[i]] -= 1\n    graph[x[i]][y[i]] += 2\n\nlmx = len(mx)\nprint(\"lmx: \", str(lmx))\ngraph[0][0] -= lmx\nfor i in range(lmx):\n    graph[mx[i]][0] += 1\n    graph[0][my[i]] += 1\n    graph[mx[i]][my[i]] -= 2\n\nfor i in graph:\n    for j in range(k-1):\n        i[j+1] += i[j]\n\nfor i in range(k):\n    for j in range(k-1):\n        graph[j+1][i] += graph[j][i]\n\n#\u6700\u5927\u5024\u3001\u6700\u5c0f\u5024\u3092\u53d6\u5f97\nbig = max([max(i) for i in graph]) + lmx\nprint(\"big: \", str(big))\nsmall = min([min(i) for i in graph]) - lx\nprint(\"small: \", str(small))\n\nif big + small >= 0:\n    print(big)\nelse:\n    print(-small)\n</ans>", "format_properties": {}}
{"idx": 160, "result": 0, "generated": "<ans>\n# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\nfrom itertools import product, accumulate, combinations, product\n#import bisect\n#import numpy as np\n#from copy import deepcopy\n#from collections import deque\n#from decimal import Decimal\n#from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\n\ndef run():\n    N = int(input())\n    print(\"N: \", str(N))\n    nines = [9 ** i for i in range(1, 10) if 9 ** i <= N]\n    print(\"nines: \", str(nines))\n    sixes = [6 ** i for i in range(1, 10) if 6 ** i <= N][::-1]\n    print(\"sixes: \", str(sixes))\n    L = len(nines)\n    print(\"L: \", str(L))\n    min_ans = INF\n    for K in product(list(range(9)), repeat = L):\n        print(\"K: \", str(K))\n        ans = 0\n        s = 0\n        for k, x in zip(K, nines):\n            if k:\n                ans += k\n                s += x * k\n        print(\"ans: \", str(ans), \"s: \", str(s))\n\n        if s > N:continue\n        resid = N - s\n        print(\"resid: \", str(resid))\n        for six in sixes:\n            print(\"six: \", str(six))\n            tmp = resid // six\n            if tmp:\n                ans += tmp\n                resid -= six * tmp\n        print(\"resid: \", str(resid), \"ans: \", str(ans))\n        #if resid >= 6:\n        #    print(resid)\n        ans += resid\n        min_ans = min(min_ans,ans)\n\n    print(min_ans)\n\ndef __starting_point():\n    run()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 158, "result": 0, "generated": "<ans>\ndef increasing(arr):\n    n = len(arr)\n    print(\"n: \", str(n))\n    for i in range(n-1):\n        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:\n            return False\n\n    return True\n\ndef getFacts(n,mod):\n    facts = [1]*n\n    print(\"facts: \", str(facts))\n    for i in range(1,n):\n        facts[i] = facts[i-1]*i\n        facts[i] %= mod\n\n    return facts\n\ndef solve(arr1,arr2,n,mod):\n    facts = getFacts(4*10**5+1,mod)\n    print(\"facts: \", str(facts))\n    total = facts[n]\n    dist1 = {}\n    print(\"dist1: \", str(dist1))\n    for i in arr1:\n        if i[0] not in list(dist1.keys()):\n            dist1[i[0]] = 1\n        else:\n            dist1[i[0]] += 1\n\n    dist2 = {}\n    print(\"dist2: \", str(dist2))\n    for i in arr2:\n        if i[0] not in list(dist2.keys()):\n            dist2[i[0]] = 1\n        else:\n            dist2[i[0]] += 1\n\n    count = 1\n    for i in dist1:\n        count *= facts[dist1[i]]\n        count = count%mod\n\n    total -= count\n    count = 1\n\n    for i in dist2:\n        count *= facts[dist2[i]]\n        count = count%mod\n\n    #print(count)\n    total -= count\n\n    arr1.sort()\n    if increasing(arr1):\n        count = 1\n    else:\n        count = 0\n    dist3 = {}\n    print(\"dist3: \", str(dist3))\n    for i in arr1:\n        if i not in list(dist3.keys()):\n            dist3[i] = 1\n        else:\n            dist3[i] += 1\n\n    for i in dist3:\n        count *= facts[dist3[i]]\n        count = count%mod\n\n    #print(count,total)\n    total += count\n    total = total%mod\n    print(total)\n\ndef main():\n    mod = 998244353\n    n = int(input())\n    first = []\n    second = []\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        first.append((a,b))\n        second.append((b,a))\n\n    solve(first,second,n,mod)\n\nmain()\n</ans>", "format_properties": {}}
{"idx": 162, "result": 0, "generated": "<ans>\n```python\nimport logging\nimport collections\n\nfmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'\nformatter = logging.Formatter(fmt)\n\nch = logging.StreamHandler()\nch.setLevel(logging.NOTSET)\nch.setFormatter(formatter)\n\nlogger = logging.getLogger('bus_of_characters')\nlogger.setLevel(logging.NOTSET)\nlogger.addHandler(ch)\n\ndef solve(w, s):\n    print(\"w: \", str(w))\n    free = collections.deque()\n    print(\"free: \", str(free))\n    used = collections.deque()\n    print(\"used: \", str(used))\n\n    for w in sorted(enumerate(w), key=lambda x: x[1]):\n        print(\"w: \", str(w))\n        free.append([w[0] + 1, w[1]])\n        print(\"free: \", str(free))\n\n    ids = [-1] * len(s)\n    print(\"ids: \", str(ids))\n\n    order = []\n    for pid, p in enumerate(s):\n        logger.debug('pid: %s', pid)\n        if p == '0':\n            taken = free.popleft()\n            print(\"taken: \", str(taken))\n            used.appendleft(taken)\n            print(\"used: \", str(used))\n            # order.append(pid, taken[0])\n        else:\n            logger.debug('used %s', used)\n            taken = used.popleft()\n            print(\"taken: \", str(taken))\n        #order.append([pid, taken[0]])\n        ids[pid] = taken[0]\n\n    print(\"ids: \", str(ids))\n    return [x for x, y in ids]\n\ndef main():\n    n = int(input().strip())\n    w = [int(x) for x in input().strip().split()]\n    s = input().strip()\n\n    result = solve(w, s)\n    print(' '.join(map(str, result)))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 167, "result": 0, "generated": "<ans>\nimport sys\nimport random\nfrom math import *\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    print(\"iinput: \", str(iinput))\n    return int(input())\n\ndef finput():\n    print(\"finput: \", str(finput))\n    return float(input())\n\ndef tinput():\n    print(\"tinput: \", str(tinput))\n    return input().split()\n\ndef linput():\n    print(\"linput: \", str(linput))\n    return list(input())\n\ndef rinput():\n    print(\"rinput: \", str(rinput))\n    return map(int, tinput())\n\ndef fiinput():\n    print(\"fiinput: \", str(fiinput))\n    return map(float, tinput())\n\ndef rlinput():\n    print(\"rlinput: \", str(rlinput))\n    return list(map(int, input().split()))\n\ndef trinput():\n    print(\"trinput: \", str(trinput))\n    return tuple(rinput())\n\ndef srlinput():\n    print(\"srlinput: \", str(srlinput))\n    return sorted(list(map(int, input().split())))\n\ndef NOYES(fl):\n    print(\"NOYES: \", str(NOYES), \"fl: \", str(fl))\n    if fl:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\ndef YESNO(fl):\n    print(\"YESNO: \", str(YESNO), \"fl: \", str(fl))\n    if fl:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ndef main():\n    x, y, n = rinput()\n    res = n - y\n    print(x * (res // x) + y)\n\nfor inytd in range(iinput()):\n    main()\n</ans>", "format_properties": {}}
{"idx": 164, "result": 0, "generated": "<ans>\nfrom sys  import stdin,stdout\n\nst=lambda:list(stdin.readline().strip())\nli=lambda:list(map(int,stdin.readline().split()))\nmp=lambda:list(map(int,stdin.readline().split()))\ninp=lambda:int(stdin.readline())\npr=lambda n: stdout.write(str(n)+\"\\n\")\n\ndef valid(x,y):\n    print(\"x: \", str(x), \"y: \", str(y))\n    if x>=n or y>=m or x<0 or y<0:\n        return False\n    if v[x][y] or l[x][y]=='*':\n        return False\n    return True\n\ndx=[-1,1,0,0]\ndy=[0,0,1,-1]\n\ndef DFS(i,j,val):\n    print(\"i: \", str(i), \"j: \", str(j), \"val: \", str(val))\n    ans=1\n    connected=[(i,j)]\n    stack=[(i,j)]\n    v[i][j]=True\n    while stack:\n        a,b=stack.pop()\n        for x in range(4):\n            newX,newY=a+dx[x], b+dy[x]\n            if valid(newX,newY):\n                stack.append((newX,newY))\n                v[newX][newY]=True\n                connected.append((newX,newY))\n                ans= (ans%10 + 1%10) % 10\n\n    for i in connected:\n        a,b=i\n        l[a][b]=(ans,val)\n\nn,m=mp()\nprint(\"n: \", str(n), \"m: \", str(m))\nl=[st() for i in range(n)]\nprint(\"l: \", str(l))\nval=0\nk=[list(i) for i in l]\nv=[[False for i in range(m)] for j in range(n)]\nprint(\"v: \", str(v))\nfor i in range(n):\n    for j in range(m):\n        if l[i][j]=='.' and not v[i][j]:\n            DFS(i,j,val)\n            val+=1\n\nfor  i in range(n):\n    for j in range(m):\n        if l[i][j]=='*':\n            k[i][j]=1\n            s=set()\n            for x in range(4):\n                newX,newY= i+dx[x], j+dy[x]\n                if newX>=0 and newY>=0 and newX<n and newY<m:\n                    if type(l[newX][newY])==tuple:\n                        A,B=l[newX][newY]\n                        if B not in s:\n                            k[i][j]+=A\n                            k[i][j]%=10\n                            s.add(B)\n\nprint('\\n'.join([''.join([str(i) for i in j]) for j in k]))\n</ans>", "format_properties": {}}
{"idx": 165, "result": 0, "generated": "<ans>\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nprint(\"M: \", str(M), \"mod: \", str(mod))\n\nfor _ in range(val()):\n    n,l,r = li()\n    print(\"n: \", str(n), \"l: \", str(l), \"r: \", str(r))\n    orig = r\n    l -= 1\n    r -= l\n\n    currleft = 0\n    curs = n - 1\n    print(\"currleft: \", str(currleft), \"curs: \", str(curs))\n    while curs and currleft + 2*curs <= l:\n        currleft += 2*curs\n        curs -= 1\n\n    start = n - curs\n    print(\"start: \", str(start))\n    ans = []\n    head = start\n    l -= currleft\n\n    last = head + 1\n    half = 0\n    print(\"last: \", str(last), \"half: \", str(half))\n    while l:\n        half = 1\n        start = last\n        last += 1\n        l -= 1\n        if not l:break\n        half = 0\n        start = head\n        l -= 1\n\n    if half:\n        ans.append(start)\n        if last == n + 1:\n            head += 1\n            last = head + 1\n        start = head\n        r -= 1\n\n    while r:\n        ans.append(start)\n        r -= 1\n        if not r:break\n        start = last\n        ans.append(start)\n        last += 1\n        if last == n + 1:\n            head += 1\n            last = head + 1\n        r -= 1\n        start = head\n\n    if orig == n*(n-1) + 1:\n        ans[-1] = 1\n\n    print(*ans)\n\n</ans>", "format_properties": {}}
{"idx": 163, "result": 0, "generated": "<ans>\n#!/usr/bin/env python3\nfrom sys import stdin\nfrom bisect import bisect_left, bisect_right\n\nINF = int(1e9)\n\ndef find(par, a):\n    print(\"par: \", str(par))\n    print(\"a: \", str(a))\n    if par[a] == a:\n        return a\n    par[a] = find(par, par[a])\n    return par[a]\n\ndef union(par, rnk, a, b):\n    a = find(par,a)\n    b = find(par,b)\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    if a==b:\n        return\n\n    if rnk[a]<rnk[b]:\n        par[a] = b\n    else:\n        par[b] = a\n        if rnk[a]==rnk[b]:\n            rnk[a] += 1\n\ndef solve():\n    n, m, k = map(int, stdin.readline().split())\n    print(\"n: \", str(n))\n    print(\"m: \", str(m))\n    print(\"k: \", str(k))\n    cnts = list(map(int, stdin.readline().split()))\n    print(\"cnts: \", str(cnts))\n    for i in range(1,k):\n        cnts[i] += cnts[i-1]\n\n    group = list(range(n))\n    print(\"group: \", str(group))\n    rnk = [0 for i in range(n)]\n    print(\"rnk: \", str(rnk))\n    adj = [[INF for j in range(k)] for i in range(k)]\n    print(\"adj: \", str(adj))\n    for i in range(m):\n        u, v, x = map(int, stdin.readline().split())\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        print(\"x: \", str(x))\n        if x==0:\n            union(group, rnk, u-1, v-1)\n        tu = bisect_left(cnts, u)\n        tv = bisect_left(cnts, v)\n        adj[tu][tv] = min(adj[tu][tv], x)\n        adj[tv][tu] = min(adj[tv][tu], x)\n\n    p = 0\n    for i in range(k):\n        cur = group[p]\n        while p<cnts[i]:\n            if group[p]!=cur:\n                print(\"No\")\n                return\n            p += 1\n    print(\"Yes\")\n\n    for p in range(k):\n        for i in range(k):\n            for j in range(k):\n                adj[i][j] = min(adj[i][j], adj[i][p]+adj[p][j])\n\n    for i in range(k):\n        adj[i][i] = 0\n        for j in range(k):\n            if adj[i][j] == INF:\n                adj[i][j] = -1\n\n    for i in range(k):\n        print(' '.join(map(lambda x: str(x), adj[i])))\n\nsolve()\n</ans>", "format_properties": {}}
{"idx": 169, "result": 1, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nif (n == 1) :\n print (\"Washington\")\nelif (n == 2):\n print (\"Adams\")\nelif (n == 3):\n print (\"Jefferson\")\nelif (n == 4):\n print (\"Madison\")\nelif (n == 5):\n print (\"Monroe\")\nelif (n == 6):\n print (\"Adams\")\nelif (n == 7):\n print (\"Jackson\")\nelif (n == 8):\n print (\"Van Buren\")\nelif (n == 9):\n print(\"Harrison\")\nelif (n == 10):\n print(\"Tyler\")\nelif (n == 11):\n print(\"Polk\")\nelif (n == 12):\n print(\"Taylor\")\nelif (n == 13):\n print(\"Fillmore\")\nelif (n == 14):\n print(\"Pierce\")\nelif (n == 15):\n print(\"Buchanan\")\nelif (n == 16):\n print (\"Lincoln\")\nelif (n == 17):\n print (\"Johnson\")\nelif (n == 18):\n print (\"Grant\")\nelif (n == 19):\n print (\"Hayes\")\nelif (n == 20):\n print (\"Garfield\")\nelif (n == 21):\n print (\"Arthur\")\nelif (n == 22):\n print (\"Cleveland\")\nelif (n == 23):\n print (\"Harrison\")\nelif (n == 24):\n print (\"Cleveland\")\nelif (n == 25):\n print (\"McKinley\")\nelif (n == 26):\n print (\"Roosevelt\")\nelif (n == 27):\n print (\"Taft\")\nelif (n == 28):\n print (\"Wilson\")\nelif (n == 29):\n print ('Harding')\nelif (n == 30):\n print (\"Coolidge\")\nelif (n == 31):\n print (\"Hoover\")\nelif (n == 32):\n print (\"Roosevelt\")\nelif (n == 33):\n print (\"Truman\")\nelif (n == 34):\n print (\"Eisenhower\")\nelif (n == 35):\n print (\"Kennedy\")\nelif (n == 36):\n print (\"Johnson\")\nelif (n == 37):\n print (\"Nixon\")\nelif n == 38:\n print (\"Ford\")\nelif n == 39:\n print (\"Carter\")\nelif n == 40:\n print (\"Reagan\")\n</ans>", "format_properties": {}}
{"idx": 157, "result": 0, "generated": "<ans>\nimport sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\nn = int(minp())\nprint(\"n: \", str(n))\nm = [None]*n\nprint(\"m: \", str(m))\nk = [None]*3\nprint(\"k: \", str(k))\ndp = [None]*3\nprint(\"dp: \", str(dp))\ndp[0] = [None]*(n*n)\nprint(\"dp[0]: \", str(dp[0]))\ndp[1] = [None]*(n*n)\nprint(\"dp[1]: \", str(dp[1]))\ndp[2] = [None]*(n*n)\nprint(\"dp[2]: \", str(dp[2]))\npath = [None]*(n*n)\nprint(\"path: \", str(path))\nfor i in range(n):\n\tm[i] = list(map(int, minp().split()))\n\tfor j in range(n):\n\t\tpath[m[i][j]-1] = (i,j)\nfor z in range(3):\n\tk_ = [None]*n\n\tprint(\"k_: \", str(k_))\n\tfor i in range(n):\n\t\tkk = [None]*n\n\t\tfor j in range(n):\n\t\t\tkkk_ = [None]*3\n\t\t\tfor zz in range(3):\n\t\t\t\tkkk = [None]*n\n\t\t\t\tfor w in range(n):\n\t\t\t\t\tkkk[w] = [(1000000,0)]*n\n\t\t\t\tkkk_[zz] = kkk\n\t\t\tkk[j] = kkk_\n\t\tk_[i] = kk\n\tk[z] = k_\n\nq = [0]*(10*n*n)\nprint(\"q: \", str(q))\nqr = 0\nkm = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]\nprint(\"km: \", str(km))\nsm = [(1,1),(1,-1),(-1,1),(-1,-1)]\nprint(\"sm: \", str(sm))\nlm = [(0,1),(0,-1),(-1,0),(1,0)]\nprint(\"lm: \", str(lm))\nmm = [km,sm,lm]\nprint(\"mm: \", str(mm))\nfor z in range(3):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tql = 0\n\t\t\tqr = 1\n\t\t\tq[0] = (z, i, j, (0,0))\n\t\t\tkc = k[z][i][j]\n\t\t\tkc[z][i][j] = (0, 0)\n\t\t\twhile ql < qr:\n\t\t\t\tt, x, y, dd = q[ql]\n\t\t\t\td = kc[t][x][y]\n\t\t\t\tql += 1\n\t\t\t\tif d != dd:\n\t\t\t\t\tcontinue\n\t\t\t\tdd = (d[0]+1, d[1]+1)\n\t\t\t\tfor tt in range(3):\n\t\t\t\t\tif t != tt and kc[tt][x][y] > dd:\n\t\t\t\t\t\tkc[tt][x][y] = dd\n\t\t\t\t\t\tq[qr] = (tt,x,y,dd)\n\t\t\t\t\t\tqr += 1\n\t\t\t\tdd = (d[0]+1,d[1])\n\t\t\t\tif t == 0:\n\t\t\t\t\tfor w in mm[t]:\n\t\t\t\t\t\txx,yy = w[0]+x,w[1]+y\n\t\t\t\t\t\tif xx >= 0 and xx < n and yy >= 0 and yy < n:\n\t\t\t\t\t\t\tif kc[t][xx][yy] > dd:\n\t\t\t\t\t\t\t\tkc[t][xx][yy] = dd\n\t\t\t\t\t\t\t\tq[qr] = (t,xx,yy,dd)\n\t\t\t\t\t\t\t\tqr += 1\n\t\t\t\telse:\n\t\t\t\t\tfor w in mm[t]:\n\t\t\t\t\t\tfor hm in range(n*2):\n\t\t\t\t\t\t\txx,yy = w[0]*hm+x,w[1]*hm+y\n\t\t\t\t\t\t\tif xx >= 0 and xx < n and yy >= 0 and yy < n:\n\t\t\t\t\t\t\t\tif kc[t][xx][yy] > dd:\n\t\t\t\t\t\t\t\t\tkc[t][xx][yy] = dd\n\t\t\t\t\t\t\t\t\tq[qr] = (t,xx,yy,dd)\n\t\t\t\t\t\t\t\t\tqr += 1\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tbreak\ndp[0][0] = (0,0)\ndp[1][0] = (0,0)\ndp[2][0] = (0,0)\nfor i in range(0,n*n-1):\n\tx,y = path[i]\n\txx,yy = path[i+1]\n\tfor z in range(3):\n\t\tfor j in range(3):\n\t\t\tdist = k[j][x][y][z][xx][yy]\n\t\t\tif dp[j][i] != None:\n\t\t\t\tnd = (dp[j][i][0]+dist[0],dp[j][i][1]+dist[1])\n\t\t\t\tif dp[z][i+1] == None:\n\t\t\t\t\tdp[z][i+1] = nd\n\t\t\t\telse:\n\t\t\t\t\tdp[z][i+1] = min(dp[z][i+1],nd)\nfor j in range(n*n-1,n*n):\n\tqq = [dp[i][j] if dp[i][j] != None else (1000000,0) for i in range(3)]\n\tqm = min(qq)\n\tprint(\"qm: \", str(qm[0]), \" \", str(qm[1]))\n</ans>", "format_properties": {}}
{"idx": 161, "result": 0, "generated": "<ans>\n# -*- coding: utf-8 -*-\nimport sys\n# from operator import itemgetter\n# from fractions import gcd\n# from math import ceil, floor\n# from copy import deepcopy\n# from itertools import accumulate\nfrom collections import deque\n# import math\n# from functools import reduce\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().rstrip().split()))\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\n# template\n\n# BEGIN CUT HERE\n\n\nclass BIT:\n    def __init__(self, x, d=0):\n        print(\"x: \", str(x), \"d: \", str(d))\n        if isinstance(x, int):\n            self.size = x\n            print(\"self.size: \", str(self.size))\n            self.tree = [d for _ in range(self.size + 1)]\n            print(\"self.tree: \", str(self.tree))\n        elif isinstance(x, list):\n            self.size = len(x)\n            print(\"self.size: \", str(self.size))\n            self.tree = [d for _ in range(self.size + 1)]\n            print(\"self.tree: \", str(self.tree))\n            self.build(x)\n        else:\n            raise TypeError\n\n    def build(self, arr):\n        print(\"arr: \", str(arr))\n        if not isinstance(arr, list):\n            raise TypeError\n        for num, x in enumerate(arr):\n            print(\"num: \", str(num), \"x: \", str(x))\n            self.add0(num, x)\n\n    def sum(self, i):\n        print(\"i: \", str(i))\n        s = self.tree[0]\n        while i > 0:\n            s += self.tree[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, a):\n        print(\"i: \", str(i), \"a: \", str(a))\n        if(i == 0):\n            return\n        while (i <= self.size):\n            self.tree[i] += a\n            i += (i & -i)\n\n    def bisect_left(self, w):\n        print(\"w: \", str(w))\n        if w <= 0:\n            return 0\n        x = 0\n        r = 1\n        while (r < self.size):\n            r <<= 1\n        k = r\n        while (k > 0):\n            if x + k <= self.size and self.tree[x + k] < w:\n                w -= self.tree[x + k]\n                x += k\n            k >>= 1\n        return x + 1\n\n    def query(self, l, r):\n        print(\"l: \", str(l), \"r: \", str(r))\n        return self.sum(r - 1) - self.sum(l - 1)\n\n    def sum0(self, i):\n        print(\"i: \", str(i))\n        return self.sum(i + 1)\n\n    def add0(self, i, a):\n        print(\"i: \", str(i), \"a: \", str(a))\n        self.add(i + 1, a)\n\n    def query0(self, l, r):\n        print(\"l: \", str(l), \"r: \", str(r))\n        return self.sum(r) - self.sum(l)\n\n    def __getitem__(self, item):\n        _tmp = item.indices(self.size + 1)\n        print(\"item: \", str(item), \"_tmp: \", str(_tmp))\n        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]\n\n    def __str__(self):\n        return str(self[1:self.size + 1])\n\n# END CUT\n\n\ndef main():\n    n = ii()\n    print(\"n: \", str(n))\n    a = lmi()\n    print(\"a: \", str(a))\n    q = ii()\n    print(\"q: \", str(q))\n    bit = BIT(a)\n    print(\"bit: \", str(bit))\n    for i in range(q):\n        l, r = mi()\n        print(\"l: \", str(l), \"r: \", str(r))\n        a = bit.query(l, r+1)\n        print(\"a: \", str(a))\n        print((a-a % 10)//10)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 168, "result": 0, "generated": "<ans>\n```\ndef bitmake(digit):#bit\u6587\u5b57\u5217\u751f\u6210\uff08\u53d6\u308a\u6271\u3044\u6ce8\u610f\uff09\n    print(\"digit: \", str(digit))\n    bit_list =list()\n\n    for i in range(2 ** digit):\n        bit = []\n        for j in range(digit):  # \u3053\u306e\u30eb\u30fc\u30d7\u304c\u4e00\u756a\u306e\u30dd\u30a4\u30f3\u30c8\n            if ((i >> j) & 1):  # \u9806\u306b\u53f3\u306b\u30b7\u30d5\u30c8\u3055\u305b\u6700\u4e0b\u4f4dbit\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\n                bit.append(j)\n        bit_list.append(bit)\n    print(\"bit_list: \", str(bit_list))\n    return bit_list\nh,w,k = list(map(int,input().split()))\nprint(\"h: \", str(h), \"w: \", str(w), \"k: \", str(k))\ngrid = [\"\"]*h\nfor i in range(h):\n    grid[i] = list(map(str,input()))\n# print(grid)\n\nbit_list = bitmake(h+w)\n# print(bit_list)\nblackh = [0]*h#\u6a2a\nblackw = [0]*w#\u7e26\nblacksum = 0\nfor i in range(h):\n    for j in range(w):\n        if(grid[i][j] == \"#\"):\n            blackh[i]+=1\n            blackw[j]+=1\n            grid[i][j] = 1\n            blacksum += 1\n        else:\n            grid[i][j] = 0\nprint(\"blackh: \", str(blackh), \"blackw: \", str(blackw), \"blacksum: \", str(blacksum))\nans = 0\nfor i in range(2**(h+w)):\n    bit = bit_list[i]#h:0~(h-1),w:h~(h+w)-1\n    remove = 0\n    hight = []\n    width = []\n    for j in range(len(bit)):\n        l = bit[j]\n        if(l <= h-1):\n            remove += blackh[l]\n            hight.append(l)\n        else:\n            ind = l - h\n            remove += blackw[ind]\n            width.append(ind)\n    print(\"hight: \", str(hight), \"width: \", str(width))\n    rid = 0\n    for j in range(len(hight)):\n        for l in range(len(width)):\n            if(grid[hight[j]][width[l]] == 1):\n                rid += 1\n\n    if((blacksum - remove) + rid == k):\n        # print(blacksum,remove,rid,\"___\",blacksum-remove+rid)\n        ans += 1\nprint(\"ans: \", str(ans))\n\n# 2 3 2\n# ..#\n# ###\n```\n</ans>", "format_properties": {}}
{"idx": 170, "result": 0, "generated": "<ans>\nimport math\nfrom decimal import Decimal\nimport heapq\ndef na():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\treturn n,b\n\ndef nab():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tc = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\tprint(\"c: \", str(c))\n\treturn n,b,c\n\ndef dv():\n\tn, m = list(map(int, input().split()))\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\treturn n,m\n\ndef dva():\n\tn, m = list(map(int, input().split()))\n\ta = [int(x) for x in input().split()]\n\tb = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\tprint(\"a: \", str(a))\n\tprint(\"b: \", str(b))\n\treturn n,m,b\n\ndef eratosthenes(n):\n\tsieve = list(range(n + 1))\n\tprint(\"sieve: \", str(sieve))\n\tfor i in sieve:\n\t\tif i > 1:\n\t\t\tfor j in range(i + i, len(sieve), i):\n\t\t\t\tsieve[j] = 0\n\treturn sorted(set(sieve))\n\ndef lol(lst,k):\n\tk=k%len(lst)\n\tret=[0]*len(lst)\n\tprint(\"lst: \", str(lst))\n\tprint(\"k: \", str(k))\n\tprint(\"ret: \", str(ret))\n\tfor i in range(len(lst)):\n\t\tif i+k<len(lst) and i+k>=0:\n\t\t\tret[i]=lst[i+k]\n\t\tif i+k>=len(lst):\n\t\t\tret[i]=lst[i+k-len(lst)]\n\t\tif i+k<0:\n\t\t\tret[i]=lst[i+k+len(lst)]\n\treturn(ret)\n\ndef nm():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tm = int(input())\n\tc = [int(x) for x in input().split()]\n\tprint(\"n: \", str(n))\n\tprint(\"b: \", str(b))\n\tprint(\"m: \", str(m))\n\tprint(\"c: \", str(c))\n\treturn n,b,m,c\n\ndef dvs():\n\tn = int(input())\n\tm = int(input())\n\tprint(\"n: \", str(n))\n\tprint(\"m: \", str(m))\n\treturn n, m\n\ndef Factor(n):\n\tAns = []\n\td = 2\n\twhile d * d <= n:\n\t\tif n % d == 0:\n\t\t\tAns.append(d)\n\t\t\tn //= d\n\t\telse:\n\t\t\td += 1\n\tif n > 1:\n\t\tAns.append(n)\n\tprint(\"Ans: \", str(Ans))\n\treturn Ans\n\ns = input()\na1 = 'Mike'\na2 = 'Ann'\nif len(s) == 1:\n\tprint(a1)\n\treturn\nprint(a1)\ntc = s[0]\npre = []\nn = len(s)\nfor i in range(1, n):\n\td = min(s[i], tc)\n\tpre.append(d)\n\ttc = d\nprint(\"pre: \", str(pre))\nfor i in range(1, n):\n\tif pre[i - 1] < s[i]:\n\t\tprint(a2)\n\telse:\n\t\tprint(a1)\n\n</ans>", "format_properties": {}}
{"idx": 173, "result": 0, "generated": "<ans>\nimport math as ma\nimport sys\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\ndef li():\n\treturn list(map(int , input().split()))\nprint(\"li: \", str(li))\n\ndef modInverse(a , m):\n\tm0 = m\n\ty = 0\n\tx = 1\n\tif (m == 1):\n\t\treturn 0\n\twhile (a > 1):\n\t\tq = a // m\n\t\tt = m\n\t\tm = a % m\n\t\ta = t\n\t\tt = y\n\t\ty = x - q * y\n\t\tx = t\n\tif (x < 0):\n\t\tx = x + m0\n\treturn x\nprint(\"modInverse: \", str(modInverse))\n\ndef num():\n\treturn map(int , input().split())\nprint(\"num: \", str(num))\n\ndef nu():\n\treturn int(input())\nprint(\"nu: \", str(nu))\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\nprint(\"find_gcd: \", str(find_gcd))\n\nn,k=num()\nprint(\"n: \", str(n), \"k: \", str(k))\nh=li()\nprint(\"h: \", str(h))\na=[0]*(max(h)+5)\nprint(\"a: \", str(a))\nmx=max(h)\nprint(\"mx: \", str(mx))\nmn=min(h)\nprint(\"mn: \", str(mn))\nfo=True\nprint(\"fo: \", str(fo))\nfor i in range(1,n):\n\tif(h[i]!=h[i-1]):\n\t\tfo=False\n\t\tbreak\nfor i in range(n):\n\ta[0]+=1\n\ta[h[i]+1]-=1\nfor i in range(1,len(a)):\n\ta[i]=a[i]+a[i-1]\ns=a[mx]\nprint(\"s: \", str(s))\ncc=0\nfl=False\nfor i in range(mx-1,mn,-1):\n\tif(s+a[i]>k):\n\t\tfl=True\n\t\ts=a[i]\n\t\tcc+=1\n\telse:\n\t\tfl=False\n\t\ts+=a[i]\nif(s<=k and fo==False):\n\tcc+=1\nprint(\"cc: \", str(cc))\nprint(cc)\n</ans>", "format_properties": {}}
{"idx": 174, "result": 0, "generated": "<ans>\nMOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\nprint(\"MOVS: \", str(MOVS))\ndef check(a):\n    return 0<=a<8\nprint(\"check: \", str(check))\nset1 = set()\nprint(\"set1: \", str(set1))\nset2 = set()\nprint(\"set2: \", str(set2))\ndic1 = dict()\nprint(\"dic1: \", str(dic1))\ndic2 = dict()\nprint(\"dic2: \", str(dic2))\ndef cango1(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check (nx) or not check(ny):\n            continue\n        if (nx,ny) in set1:\n            continue\n        dic1[(nx,ny)]=lap%2\n        set1.add((nx,ny))\n        cango1(matrix,(nx,ny),lap+1)\ndef cango2(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check(nx) or not check(ny):\n            continue\n        if (nx,ny) in set2:\n            continue\n        dic2[(nx,ny)]=lap%2\n        set2.add((nx,ny))\n        cango2(matrix,(nx,ny),lap+1)\nq = int(input())\nfor ww in range(q):\n    matrix = [input().strip() for i in range(8)]\n    pos = []\n    bad = set()\n    for i in range(8):\n        for j in range(8):\n            if matrix[i][j] == 'K':\n                pos.append((i,j))\n            if matrix[i][j]=='#':\n                bad.add((i,j))\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\n    cango1(matrix, pos[0],0)\n    cango2(matrix,pos[1],0)\n    if ww!=q-1:\n        input()\n    sec = (set1&set2) - bad\n    for x,y in sec:\n        if dic1[(x,y)]==dic2[(x,y)]:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n</ans>", "format_properties": {}}
{"idx": 166, "result": 0, "generated": "<ans>\narray2=input(\"\").split(' ')\nprint(\"array2: \", str(array2))\nsumm=0\nprint(\"summ: \", str(summ))\narray=list()\nprint(\"array: \", str(array))\nfor t in range (0,int(array2[0])):\n    g=input(\"\")\n    array.append(g)\nif (int(array2[1])==0):\n    for b in range (0,int(array2[0])):\n        if '0' in array[b]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==1):\n    for c in range (0,int(array2[0])):\n        if '0' in array[c] and '1' in array[c]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==2):\n    for d in range (0,int(array2[0])):\n        if '0' in array[d] and '1' in array[d] and '2' in array[d]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==3):\n    for e in range (0,int(array2[0])):\n        if '0' in array[e] and '1' in array[e] and '2' in array[e] and '3' in array[e]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==4):\n    for f in range (0,int(array2[0])):\n        if '0' in array[f] and '1' in array[f] and '2' in array[f] and '3' in array[f] and '4' in array[f]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==5):\n    for g in range (0,int(array2[0])):\n        if '0' in array[g] and '1' in array[g] and '2' in array[g] and '3' in array[g] and '4' in array[g] and '5' in array[g]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==6):\n    for h in range (0,int(array2[0])):\n        if '0' in array[h] and '1' in array[h] and '2' in array[h] and '3' in array[h] and '4' in array[h] and '5' in array[h] and '6' in array[h]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==7):\n     for i in range (0,int(array2[0])):\n                if '0' in array[i] and '1' in array[i] and '2' in array[i] and '3' in array[i] and '4' in array[i] and '5' in array[i] and '6' in array[i] and '7' in array[i]:\n                    summ=summ+1\n     print(\"summ: \", str(summ))\nif (int(array2[1])==8):\n    for j in range (0,int(array2[0])):\n        if '0' in array[j] and '1' in array[j] and '2' in array[j] and '3' in array[j] and '4' in array[j] and '5' in array[j] and '6' in array[j] and '7' in array[j] and '8' in array[j]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\nif (int(array2[1])==9):\n    for k in range (0,int(array2[0])):\n        if '0' in array[k] and '1' in array[k] and '2' in array[k] and '3' in array[k] and '4' in array[k] and '5' in array[k] and '6' in array[k] and '7' in array[k] and '8' in array[k] and '9' in array[k]:\n            summ=summ+1\n    print(\"summ: \", str(summ))\n</ans>", "format_properties": {}}
{"idx": 179, "result": 0, "generated": "<ans>\nA, B, C, X, Y = map(int, input().split())\nprint(\"A: \", str(A), \"B: \", str(B), \"C: \", str(C), \"X: \", str(X), \"Y: \", str(Y))\n\nif 2 * C > A + B:\n    print(A * X + B * Y)\nelse:\n    if X > Y:\n        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))\n    else:\n        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))\n</ans>", "format_properties": {}}
{"idx": 178, "result": 0, "generated": "<ans>\nimport sys\n\ndef Min(x, y):\n    if x > y:\n        return y\n    else:\n        return x\n\ndef Gcd(x, y):\n    if x == 0:\n        return y\n    else:\n        return Gcd(y % x, x)\n\ndef Lcm(x, y):\n    return x * y // Gcd(x, y)\n\nn = int(input())\nprint(\"n: \", str(n))\na = [int(i) for i in input().split()]\nprint(\"a: \", str(a))\nd = [int(0) for i in range(0, n)]\nprint(\"d: \", str(d))\n\nok = 0\n\ncur = 0\n\nlen = Lcm(7, n)\nprint(\"len: \", str(len))\n\nfor i in range(0, 7 * n):\n    if a[i % n] == 0 :\n        print(i % n + 1)\n        ok = 1\n        break\n    if cur != 6:\n        a[i % n] -= 1\n        d[i % n] += 1\n    cur = (cur + 1) % 7\n\nif ok == 0:\n    k = 10**20\n\n    for i in range(0, n):\n        a[i] += d[i]\n        if d[i] == 0: continue\n        if a[i] % d[i] > 0:\n            k = Min(k, a[i] // d[i])\n        else:\n            k = Min(k, a[i] // d[i] - 1)\n\n    if k == 10**20:\n        k = 0\n\n    for i in range(0, n):\n        a[i] -= k * d[i]\n\n    iter = 0\n    cur = 0\n\n    while True:\n        if a[iter] == 0:\n            print(iter % n + 1)\n            break\n        else:\n            if cur != 6:\n                a[iter] -= 1\n            cur = (cur + 1) % 7\n            iter = (iter + 1) % n\n\n</ans>", "format_properties": {}}
{"idx": 171, "result": 1, "generated": "<ans>\nt,sx,sy,ex,ey=map(int,input().split())\nprint(\"t: \", str(t), \"sx: \", str(sx), \"sy: \", str(sy), \"ex: \", str(ex), \"ey: \", str(ey))\nw=input()\nprint(\"w: \", str(w))\nn=len(w)\nprint(\"n: \", str(n))\nw+=\" \"\nprint(\"w: \", str(w))\nans=-1\nprint(\"ans: \", str(ans))\ni=0\nprint(\"i: \", str(i))\ndx=ex-sx\nprint(\"dx: \", str(dx))\ndy=ey-sy\nprint(\"dy: \", str(dy))\nif abs(dx)+abs(dy)>t:\n    pass\nelse:\n    while i<=t and i<n:\n        if dx==0 and dy==0:\n            ans=i\n            break\n        if dx>=0 and dy>=0:\n            if ((w[i]!=\"E\" and w[i]!=\"N\") or (dx==0 and w[i]==\"E\") or (dy==0 and w[i]==\"N\")) and i<n:\n                i+=1\n            if dx>0 and w[i]==\"E\" and i<n:\n                i+=1\n                dx-=1\n            if dy>0 and w[i]==\"N\"and i<n:\n                i+=1\n                dy-=1\n        elif dx>=0 and dy<=0:\n            if ((w[i]!=\"E\" and w[i]!=\"S\") or (dx==0 and w[i]==\"E\") or (dy==0 and w[i]==\"S\")) and i<n:\n                i+=1\n            if dx>0 and w[i]==\"E\" and i<n:\n                i+=1\n                dx-=1\n            if dy<0 and w[i]==\"S\" and i<n:\n                i+=1\n                dy+=1\n        elif dx<=0 and dy>=0:\n            if ((w[i]!=\"W\" and w[i]!=\"N\") or (dx==0 and w[i]==\"W\") or (dy==0 and w[i]==\"N\")) and i<n:\n                i+=1\n            if dx<0 and w[i]==\"W\" and i<n:\n                i+=1\n                dx+=1\n            if dy>0 and w[i]==\"N\" and i<n:\n                i+=1\n                dy-=1\n        elif dx<=0 and dy<=0:\n            if ((w[i]!=\"W\" and w[i]!=\"S\") or (dx==0 and w[i]==\"W\") or (dy==0 and w[i]==\"S\")) and i<n:\n                i+=1\n            if dx<0 and w[i]==\"W\" and i<n:\n                i+=1\n                dx+=1\n            if dy<0 and w[i]==\"S\" and i<n:\n                i+=1\n                dy+=1\nif dx==0 and dy==0:\n            ans=i\nprint(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 172, "result": 0, "generated": "<ans>\ndef __starting_point():\n    inp = input()\n    arr = inp.split(' ')\n    print(\"inp: \", str(inp))\n    print(\"arr: \", str(arr))\n    L = [int(x) for x in arr]\n    print(\"L: \", str(L))\n    ans = [0,0,0]\n    print(\"ans: \", str(ans))\n    s = 0\n    for l in L:\n        s+=l\n    print(\"s: \", str(s))\n    imp = False\n    for l in L:\n        if l>s/2:\n            imp = True\n    if imp:\n        print('Impossible')\n    else:\n##        m = min(L)//2\n##        for i in (0,1,2):\n##            ans[i]+=m\n##            L[i]-=m*2\n####        print(ans)\n        imp = False\n        if L[0]==min(L):\n            if L[1]>L[2]:\n                bonds = L[1]-L[2]\n                ans[0] += bonds\n                L[0]-= bonds\n                L[1] -=bonds\n            else:\n                bonds = L[2]-L[1]\n                ans[2] += bonds\n                L[0] -= bonds\n                L[2] -= bonds\n            if L[0]%2==1:\n                imp = True\n            else:\n                bonds = L[0]//2\n                ans[0] += bonds\n                ans[2] += bonds\n                ans[1] += (L[1]+L[2])//2 - bonds\n        elif L[1]==min(L):\n            if L[0]>L[2]:\n                bonds = L[0]-L[2]\n                ans[0] += bonds\n                L[1]-= bonds\n                L[0] -= bonds\n            else:\n                bonds = L[2]-L[0]\n                ans[1] += bonds\n                L[1] -= bonds\n                L[2] -= bonds\n            if L[1]%2==1:\n                imp = True\n            else:\n                bonds = L[1]//2\n                ans[0] += bonds\n                ans[1] += bonds\n                ans[2] += (L[0]+L[2])//2 - bonds\n\n        else:\n            if L[0]>L[1]:\n                bonds = L[0]-L[1]\n                ans[2] += bonds\n                L[2]-= bonds\n                L[0]-=bonds\n            else:\n                bonds = L[1]-L[0]\n                ans[1] += bonds\n                L[2] -= bonds\n                L[1] -= bonds\n            if L[2]%2==1:\n                imp = True\n            else:\n                bonds = L[2]//2\n                ans[2] += bonds\n                ans[1] += bonds\n                ans[0] += (L[0]+L[1])//2 - bonds\n\n        for i in ans:\n            if i<0:\n                imp = True\n        if imp:\n            print('Impossible')\n        else:\n            for i in range(3):\n                print(ans[i],end=' ')\n            print()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 184, "result": 0, "generated": "<ans>\n# alpha = \"abcdefghijklmnopqrstuvwxyz\"\nprime = 998244353\nt = 1#int(input())\nfrom heapq import heappop, heappush\nfor test in range(t):\n    n = int(input())\n    print(\"n: \", str(n))\n    s = input()\n    print(\"s: \", str(s))\n    grp = []\n    cnt = []\n    tmp = 0\n    cur = s[0]\n    for i in s:\n        if i==cur:\n            tmp+=1\n        else:\n            grp.append(cur)\n            cnt.append(tmp)\n            cur = i\n            tmp = 1\n    grp.append(cur)\n    cnt.append(tmp)\n    print(\"grp: \", str(grp))\n    print(\"cnt: \", str(cnt))\n    if len(grp)==1:\n        ans = ((n*(n+1))//2)%prime\n        print(\"ans: \", str(ans))\n    else:\n        if grp[0]==grp[-1]:\n            ans = ((cnt[0]+1)*(cnt[-1]+1))%prime\n            print(\"ans: \", str(ans))\n        else:\n            ans = cnt[0]+1+cnt[-1]\n            ans = ans%prime\n            print(\"ans: \", str(ans))\n</ans>", "format_properties": {}}
{"idx": 175, "result": 0, "generated": "<ans>\n```python\n'''input\n3\n0 2 0\n1 0 3\n'''\nfrom sys import stdin\nfrom copy import deepcopy\nfrom collections import deque\n\ndef find_start(pile):\n    start = 1\n    index = -1\n    print(\"start: \", str(start))\n    print(\"index: \", str(index))\n    for i in range(len(pile)):\n        if pile[i] == start:\n            index = i\n            break\n    latest = start\n    print(\"latest: \", str(latest))\n    if index != -1:\n        flag = True\n        print(\"flag: \", str(flag))\n        for i in range(index, len(pile)):\n            if pile[i] == latest:\n                latest += 1\n            else:\n                flag = False\n                break\n        print(\"latest: \", str(latest))\n        print(\"flag: \", str(flag))\n        if flag:\n            start = latest\n    print(\"start: \", str(start))\n    return start\n\ndef check_start(num, op):\n    op[0] = 0\n    nonlocal arr\n    nonlocal barr\n    print(\"op[0]: \", str(op[0]))\n    mydict = [0] * (n + 1)\n    print(\"mydict: \", str(mydict))\n    for i in range(len(arr)):\n        mydict[arr[i]] += 1\n    print(\"mydict: \", str(mydict))\n    zeroes = mydict[0]\n    print(\"zeroes: \", str(zeroes))\n    pile = deque(barr[:])\n    print(\"pile: \", str(pile))\n    for i in range(num):\n        if zeroes > 0:\n            op[0] += 1\n            print(\"op[0]: \", str(op[0]))\n            pile.append(0)\n            zeroes -= 1\n            mydict[0] -= 1\n        else:\n            return False\n        element = pile.popleft()\n        print(\"element: \", str(element))\n        mydict[element] += 1\n        print(\"mydict: \", str(mydict))\n        if element == 0:\n            zeroes += 1\n    print(\"zeroes: \", str(zeroes))\n    start = find_start(barr)\n    print(\"start: \", str(start))\n    for i in range(start, n + 1):\n        if mydict[i] > 0:\n            op[0] += 1\n            print(\"op[0]: \", str(op[0]))\n            pile.append(i)\n            mydict[i] -= 1\n            element = pile.popleft()\n            mydict[element] += 1\n        else:\n            return False\n    return True\n\nn = int(stdin.readline().strip())\narr = list(map(int, stdin.readline().split()))\nbarr = list(map(int, stdin.readline().split()))\nstart = 0\nend = 2 * n\nop = [0]\nprint(\"n: \", str(n))\nprint(\"arr: \", str(arr))\nprint(\"barr: \", str(barr))\nprint(\"start: \", str(start))\nprint(\"end: \", str(end))\nprint(\"op: \", str(op))\nif check_start(0, op):\n    print(op[0])\n    return\npos = [0] * (n + 1)\nprint(\"pos: \", str(pos))\nfor i in range(n):\n    pos[barr[i]] = i + 1\nprint(\"pos: \", str(pos))\nans = -float('inf')\nprint(\"ans: \", str(ans))\nfor i in range(1, n + 1):\n    ans = max(pos[i] - i  + 1 + n, ans)\nprint(\"ans: \", str(ans))\n```", "format_properties": {}}
{"idx": 177, "result": 0, "generated": "<ans>\nimport sys\nimport math\n\ndef ii():\n    return sys.stdin.readline().strip()\n\ndef idata():\n    print(\"idata: \", str(idata))\n    return [int(x) for x in ii().split()]\n\ndef bfs(graph1, root1):\n    visited1 = set()\n    print(\"visited1: \", str(visited1))\n    queue1 = [[root1, 0]]\n    print(\"queue1: \", str(queue1))\n    visited1.add(root1)\n    qw, ver = 0, 1\n    while queue1:\n        vertex1 = queue1[0]\n        queue1 = queue1[1:]\n        for neig1 in graph1[vertex1[0]]:\n            if neig1 not in visited1:\n                visited1.add(neig1)\n                queue1 += [[neig1, vertex1[1] + 1]]\n                if qw < vertex1[1] + 1:\n                    ver, qw = neig1, vertex1[1] + 1\n    return ver, qw\n\ndef dfs(graph, ver):\n    used_v = set()\n    print(\"used_v: \", str(used_v))\n    depth = [0] * (len(graph) + 1)\n    print(\"depth: \", str(depth))\n    level = [ver]\n    print(\"level: \", str(level))\n    num_of_level = 0\n    while level:\n        new_level = []\n        for v in level:\n            depth[v] = num_of_level\n            used_v.add(v)\n            for v1 in graph[v]:\n                if v1 not in used_v:\n                    new_level += [v1]\n        level = new_level\n        num_of_level += 1\n    return depth\n\ndef binary_search(array, x):\n    left, right = -1, len(array)\n    print(\"left: \", str(left), \"right: \", str(right))\n    while left + 1 != right:\n        middle = (left + right) // 2\n        print(\"middle: \", str(middle))\n        if array[middle] >= x:\n            right = middle\n        elif array[middle] < x:\n            left = middle\n    return right\n\ndef c_mod(n1, k1, mod1):\n    num = den = 1\n    print(\"num: \", str(num), \"den: \", str(den))\n    for i in range(n1 - k1):\n        num = (num * (n1 - i)) % mod1\n        den = (den * (i + 1)) % mod1\n    return (num * pow(den, mod1 - 2, mod1)) % mod1\n\ndef c(n1, k1):\n    num = den = 1\n    print(\"num: \", str(num), \"den: \", str(den))\n    for i in range(n1 - k1):\n        num = num * (n1 - i)\n        den = den * (i + 1)\n    return num // den\n\ndef v_sistemu(x, k):\n    x = int(x)\n    print(\"x: \", str(x))\n    z = ''\n    while x:\n        z += str(x % k)\n        x //= k\n    return z[::-1]\n\ndef iz_sistemi(x, k):\n    x = str(x)[::-1]\n    print(\"x: \", str(x))\n    ans = 0\n    for i in range(len(x)):\n        ans += int(x[i]) * pow(k, i)\n    return ans\n\ndef solve_of_problem():\n    n = int(ii())\n    print(\"n: \", str(n))\n    ans = 2\n    for i in range(n):\n        ans *= 2\n        if n % (ans - 1) == 0:\n            print(n // (ans - 1))\n            return\n    return\n\nfor ______ in range(int(ii())):\n    solve_of_problem()\n\n</ans>", "format_properties": {}}
{"idx": 183, "result": 0, "generated": "<ans>\n#\n# abc147 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3\n1\n2 1\n1\n1 1\n1\n2 0\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"3\n2\n2 1\n3 0\n2\n3 1\n1 0\n2\n1 1\n2 0\"\"\"\n        output = \"\"\"0\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"2\n1\n2 0\n1\n1 0\"\"\"\n        output = \"\"\"1\"\"\"\n        self.assertIO(input, output)\n\ndef resolve():\n    N = int(input())\n    print(\"N: \", str(N))\n    C = []\n    for i in range(N):\n        a = int(input())\n        print(\"a: \", str(a))\n        C.append([list(map(int, input().split())) for j in range(a)])\n    print(\"C: \", str(C))\n\n    ans = 0\n    for bit in range(1 << N):\n        f = True\n        for i in range(N):\n            if bit & (1 << i):\n                for c in C[i]:\n                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:\n                        f = False\n                        break\n        if f == True:\n            ans = max(ans, bin(bit).count(\"1\"))\n    print(\"ans: \", str(ans))\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 176, "result": 0, "generated": "<ans>\ndef xmax(x, y):\n    print(\"x: \", str(x), \"y: \", str(y))\n    if x[1] > y[1]:\n        return x\n    return y\n\nclass SegTree:\n    def __init__(self, init_val, n, ide_ele, seg_func):\n        self.segfunc = seg_func\n        print(\"segfunc: \", str(seg_func))\n        self.num = 2**(n-1).bit_length()\n        print(\"num: \", str(self.num))\n        self.ide_ele = ide_ele\n        print(\"ide_ele: \", str(self.ide_ele))\n        self.seg=[self.ide_ele]*2*self.num\n        print(\"seg: \", str(self.seg))\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]\n        print(\"init_val: \", str(init_val))\n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2])\n\n    def update(self, k, x):\n        ll = k\n        k += self.num-1\n        self.seg[k] = (ll, self.seg[k][1] + x)\n        print(\"k: \", str(k), \"x: \", str(x), \"self.seg[k]: \", str(self.seg[k]))\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def update2(self, k, x):\n        k += self.num-1\n        self.seg[k] = x\n        print(\"k: \", str(k), \"x: \", str(x))\n        while k+1:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\n\nimport sys;input=sys.stdin.readline\nN, M = map(int, input().split())\nprint(\"N: \", str(N), \"M: \", str(M))\nX = list(map(int, input().split()))\nprint(\"X: \", str(X))\nsts = [[] for _ in range(N)]\nfor i in range(1, M+1):\n    a, b = map(int, input().split())\n    print(\"a: \", str(a), \"b: \", str(b))\n    sts[a-1].append((i, b-1))\n    sts[b-1].append((i, a-1))\n    X[a-1] -= 1\n    X[b-1] -= 1\nminf = -(10 ** 18)-1\nss = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)\nf = False\nR = []\nvs = set()\nwhile True:\n    j, mx = ss.query(0, N)\n    print(\"j: \", str(j), \"mx: \", str(mx))\n    if mx<0:\n        f=True\n        break\n    while sts[j]:\n        i, co = sts[j].pop()\n        print(\"i: \", str(i), \"co: \", str(co))\n        if i in vs:\n            continue\n        vs.add(i)\n        ss.update(co, 1)\n        R.append(i)\n    if len(R) == M:break\n    ss.update2(j, (j, minf))\n\nif f or len(R) != M:print(\"DEAD\")\nelse:print(\"ALIVE\");print(*R[::-1])\n</ans>", "format_properties": {}}
{"idx": 182, "result": 0, "generated": "<ans>\n```\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport collections\nimport math\n\ndef isSubSequence(str1,str2):\n    m = len(str1)\n    n = len(str2)\n    j = 0    # Index of str1\n    i = 0    # Index of str2\n    print(\"m: \", str(m), \"n: \", str(n), \"j: \", str(j), \"i: \", str(i))\n    while j<m and i<n:\n        if str1[j] == str2[i]:\n            j = j+1\n        i = i + 1\n    print(\"j: \", str(j), \"m: \", str(m))\n    return j==m\n\nT = int(input())\nprint(\"T: \", str(T))\n\nfor t in range(T):\n    #N,M = [int(x) for x in stdin.readline().split()]\n    s = input()\n    t = input()\n    p = input()\n    print(\"s: \", str(s), \"t: \", str(t), \"p: \", str(p))\n\n    freq_s = {}\n    freq_t = {}\n    freq_p = {}\n    for i in range(26):\n        freq_s[chr(97+i)] = 0\n        freq_t[chr(97+i)] = 0\n        freq_p[chr(97+i)] = 0\n    print(\"freq_s: \", str(freq_s), \"freq_t: \", str(freq_t), \"freq_p: \", str(freq_p))\n\n    for letter in s:\n        freq_s[letter] += 1\n    for letter in t:\n        freq_t[letter] += 1\n    for letter in p:\n        freq_p[letter] += 1\n    print(\"freq_s: \", str(freq_s), \"freq_t: \", str(freq_t), \"freq_p: \", str(freq_p))\n\n    # check s is subsequence of t, if not, print no\n    sub = isSubSequence(s,t)\n    print(\"sub: \", str(sub))\n    if sub==0:\n        print('NO')\n    else:\n        flag = 0\n        for i in range(26):\n            d = freq_t[chr(97+i)] - freq_s[chr(97+i)]\n            print(\"chr(97+i): \", str(chr(97+i)), \"d: \", str(d))\n            if d>0:\n                #print(chr(97+i))\n                if freq_p[chr(97+i)]<d and flag==0:\n                    print('NO')\n                    flag = 1\n\n        if flag==0:\n            print('YES')\n</ans>", "format_properties": {}}
{"idx": 180, "result": 0, "generated": "<ans>\nimport sys\nsys.setrecursionlimit(10**9)\nN, M = map(int, input().split())\nprint(\"N: \", str(N), \"M: \", str(M))\n\ndef find_negative_loop(n, w, es):\n  dist = [float(\"inf\")] * n\n  print(\"dist: \", str(dist))\n  # \u3053\u306e\u59cb\u70b9\u306f\u3069\u3053\u3067\u3082\u3088\u3044\n  dist[1] = 0\n\n  for i in range(n):\n    for j in range(w):\n      e = es[j]\n      if dist[e[1]] > dist[e[0]] + e[2]:\n        dist[e[1]] = dist[e[0]] + e[2]\n        print(\"dist[{}]: {}\".format(e[1], dist[e[1]]))\n        if i == n - 1:\n          return True\n  return False\n\ndef shortest_path(s, n, w, es):\n  # s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  # s: \u59cb\u70b9, n: \u9802\u70b9\u6570, w: \u8fba\u306e\u6570, es[i]: [\u8fba\u306e\u59cb\u70b9, \u8fba\u306e\u7d42\u70b9, \u8fba\u306e\u30b3\u30b9\u30c8]\n  dist = [float(\"inf\")] * n\n  print(\"dist: \", str(dist))\n  # d[i]: s\u2192i\u306e\u6700\u77ed\u8ddd\u96e2\n  dist[s] = 0\n\n  while True:\n    update = False\n    for p, q, r in es:\n      # e: \u8fbai\u306b\u3064\u3044\u3066 [from, to, cost]\n      if dist[p] != float(\"inf\") and dist[q] > dist[p] + r:\n        dist[q] = dist[p] + r\n        print(\"dist[{}]: {}\".format(q, dist[q]))\n        update = True\n    if not update:\n      break\n\n  return dist\n\ngraph = [[] for _ in range(N + 1)]\nelist = []\nfor _ in range(M):\n  a, b, c = map(int, input().split())\n  graph[a].append(b)\n  elist.append((a, b, -c))\n  print(\"graph[{}]: {}\".format(a, graph[a]))\n\n# remove unnecessary vertex and edge\nvisited = [None] * (N + 1)\ndef check_reachable(u):\n  visited[u] = True\n  if u == N:\n    reachable[u] = True\n    return True\n  elif reachable[u] != None:\n    return reachable[u]\n\n  cnt = 0\n  for v in graph[u]:\n    if not visited[v]:\n      ret = check_reachable(v)\n      if ret:\n        cnt += 1\n\n  if cnt > 0:\n    reachable[u] = True\n    return True\n  else:\n    reachable[u] = False\n    return False\n\nreachable = [None] * (N + 1)\nfor i in range(1, N + 1):\n  if reachable[i] == None:\n    visited = [False] * (N + 1)\n    check_reachable(i)\n#print(reachable)\n\nelist2 = []\nfor a, b, nc in elist:\n  if reachable[b]:\n    elist2.append((a, b, nc))\n    print(\"elist2: \", str(elist2))\n\nM2 = len(elist2)\nres1 = find_negative_loop(N + 1, M2, elist2)\n\nif res1:\n  print(\"inf\")\nelse:\n  res2 = shortest_path(1, N + 1, M2, elist2)\n  print(\"-res2[N]: \", -res2[N])\n</ans>", "format_properties": {}}
{"idx": 181, "result": 0, "generated": "<ans>\nimport sys\nimport os\nimport time\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\nimport random\nimport string\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    print(\"prime: \", str(prime))\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    print(\"r: \", str(r))\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    print(\"r: \", str(r))\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    print(\"divisors: \", str(divisors))\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    print(\"divisors: \", str(divisors))\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    print(\"divs_number: \", str(divs_number))\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n    print(\"divs_number: \", str(divs_number))\n    return divs_number\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    print(\"left: \", str(left), \"right: \", str(right))\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    print(\"left: \", str(left), \"right: \", str(right))\n    if left == -1:\n        return default, default\n    else:\n        return left, right\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n########################################################################################################################\n# input = sys.stdin.readline\n\nfor _ in range(ii()):\n    n, k = mi()\n    even = n - 2*(k - 1)\n    print(\"even: \", str(even))\n    odd = n - (k - 1)\n    print(\"odd: \", str(odd))\n    if odd > 0 and odd % 2:\n        res = [1]*(k - 1) + [odd]\n        print(\"res: \", str(res))\n        print('YES')\n        prr(res, ' ')\n    elif even > 0 and even % 2 == 0:\n        res = [2] * (k - 1) + [even]\n        print(\"res: \", str(res))\n        print('YES')\n        prr(res, ' ')\n    else:\n        print('NO')\n\n</ans>", "format_properties": {}}
{"idx": 188, "result": 0, "generated": "<ans>\nr1=input()\nr2=input()\nprint(\"r1: \", str(r1))\nprint(\"r2: \", str(r2))\nn=len(r1)\nprint(\"n: \", str(n))\nl=[0]\nprint(\"l: \", str(l))\nfor i in range(n):\n\tif r1[i]=='0':\n\t\tif r2[i]=='0':\n\t\t\tl.append(2)\n\t\telse:\n\t\t\tl.append(1)\n\telse:\n\t\tif r2[i]=='X':\n\t\t\tl.append(0)\n\t\telse:\n\t\t\tl.append(-1)\nprint(\"l: \", str(l))\nl.append(0)\nprint(\"l: \", str(l))\ns=len(l)\nprint(\"s: \", str(s))\ncount=0\nprint(\"count: \", str(count))\nu=1\nprint(\"u: \", str(u))\ne=1\nprint(\"e: \", str(e))\nwhile(u<s-1):\n\tif l[u]==2 and e==1:\n\t\tif l[u+1]==2:\n\t\t\te=2\n\t\t\tu=u+1\n\t\t\tcontinue\n\t\telif (l[u+1]==1 or l[u+1]==-1):\n\t\t\tcount=count+1\n\t\t\tu=u+2\n\t\t\tcontinue\n\t\telse:\n\t\t\tu=u+2\n\t\t\tcontinue\n\tif l[u]==2 and e==2:\n\t\tif l[u+1]==2:\n\t\t\tcount=count+2\n\t\t\tu=u+2\n\t\t\te=1\n\t\t\tcontinue\n\t\telse:\n\t\t\tcount=count+1\n\t\t\tu=u+1\n\t\t\te=1\n\t\t\tcontinue\n\tif l[u]==1 or l[u]==-1:\n\t\tif l[u+1]==2:\n\t\t\tcount=count+1\n\t\t\tu=u+2\n\t\t\tcontinue\n\t\telse:\n\t\t\tu=u+1\n\t\t\tcontinue\n\tif l[u]==0:\n\t\tu=u+1\nprint (count)\n</ans>", "format_properties": {}}
{"idx": 187, "result": 0, "generated": "<ans>\nfrom sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    print(\"sep: \", str(sep))\n    if sep == '' :\n        return input().split()\n    else: return input().split(sep)\ndef rip(sep = ''):\n    print(\"sep: \", str(sep))\n    if sep == '' :\n        return list(map(int, input().split()))\n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''):\n    print(\"sep: \", str(sep))\n    return list(rip(sep))\ndef ri():\n    print(\"No separator\")\n    return int(input())\ndef rd():\n    print(\"No separator\")\n    return float(input())\ndef rs():\n    print(\"No separator\")\n    return input()\n##\nclass mint:\n    mod = int(1e9 + 7)\n    def __init__(self, v = 0):\n        print(\"v: \", str(v))\n        if not ((v >= 0) and (v < mint.mod)):\n            v %= mint.mod\n            if v < 0: v += mint.mod\n        self.V = v\n    # ... rest of the class remains the same ...\n\ndef main():\n    N = ri()\n    print(\"N: \", str(N))\n    A = ria()\n    print(\"A: \", str(A))\n    A = sorted(A)\n    print(\"A (sorted): \", str(A))\n    A = list(reversed(A))\n    print(\"A (reversed): \", str(A))\n    Pow2 = [mint(0)] * (N + 1)\n    print(\"Pow2: \", str(Pow2))\n    Pow2[0] = mint(1)\n    print(\"Pow2[0]: \", str(Pow2[0]))\n    for i in range(1,N+1): Pow2[i] = Pow2[i-1] * 2\n\n    tot = mint(0)\n    print(\"tot: \", str(tot))\n    for i in range(N):\n        tot += mint(A[i]) * Pow2[N-1]\n        if i > 0: tot += mint(A[i]) * i * Pow2[N-2]\n    tot *= Pow2[N]\n    print(\"tot: \", str(tot))\n\ndef __starting_point():\n    main()\n\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 189, "result": 0, "generated": "<ans>\nfrom random import seed, randint\nimport sys\nsys.setrecursionlimit(10000)\n\nprint(\"opr: \", str(opr))\nprint(\"namespace: \", str(namespace))\nprint(\"rules: \", str(rules))\nprint(\"lookup: \", str(lookup))\nprint(\"cnt: \", str(cnt))\n\nN = int(input())\nfor _ in range(N):\n    lval, rval = input().split('=')\n    print(\"lval: \", str(lval))\n    print(\"rval: \", str(rval))\n    for c in opr:\n        if c in rval:\n            arg1, arg2 = list(map(get_tag, rval.split(c)))\n            print(\"arg1: \", str(arg1))\n            print(\"arg2: \", str(arg2))\n            rule = (arg1, arg2, c)\n            print(\"rule: \", str(rule))\n            if rule in rules:\n                namespace[lval] = (True, rules[rule])\n            else:\n                cnt += 1\n                namespace[lval] = (True, cnt)\n                rules[rule] = cnt\n                lookup[cnt] = rule\n            break\n    else:\n        if rval in namespace:\n            namespace[lval] = namespace[rval]\n        else:\n            namespace[lval] = (False, rval)\n\nprint(\"namespace: \", str(namespace))\n\nif namespace[\"res\"] == (False, \"res\"):\n    print(\"0\")\n    return\n\nprogram = []\nprint(\"program: \", str(program))\nmyvars = dict()\nprint(\"myvars: \", str(myvars))\n\ndef reserve():\n    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4))\n\ndef implement(rule, final):\n    if type(rule) == str:\n        return rule\n    elif rule in myvars:\n        return myvars[rule]\n    else:\n        if final:\n            name = \"res\"\n        else:\n            name = reserve()\n        myvars[rule] = name\n        arg1, arg2, op = lookup[rule]\n        var1, var2 = implement(arg1, False), implement(arg2, False)\n        program.append(name + \"=\" + var1 + op + var2)\n        return name\n\nseed(123)\nif namespace[\"res\"][0]:\n    implement(namespace[\"res\"][1], True)\nelse:\n    program.append(\"res=\" + namespace[\"res\"][1])\nprint(\"program: \", str(program))\nprint(\"len(program): \", str(len(program)))\nprint(\"\\n\".join(program))\n\n#print(namespace)\n#print(rules)\n\n</ans>", "format_properties": {}}
{"idx": 185, "result": 0, "generated": "<ans>\nn, l, r = [int(i) for i in input().split()]\nprint(\"n: \", str(n), \"l: \", str(l), \"r: \", str(r))\n\nnumber_of_zeros = 0\nnumber_of_ones = 0\nnumber_of_twos = 0\n\nif l%3 == 0:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\nelif l%3 == 1:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3 + 1\nelif l%3 == 2:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    elif r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\n\nprint(\"number_of_zeros: \", str(number_of_zeros), \"number_of_ones: \", str(number_of_ones), \"number_of_twos: \", str(number_of_twos))\n\ndp = [[-1 for i in range(3)] for j in range(n+1)]\nprint(\"dp: \", str(dp))\n\nMOD = 10**9 + 7\ndp[1][0] = number_of_zeros%MOD\ndp[1][1] = number_of_ones%MOD\ndp[1][2] = number_of_twos%MOD\n\nfor i in range(2,n+1):\n    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD\n    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD\n    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD\n\nprint(\"dp: \", str(dp))\n\nif dp[n][0]!=-1:\n    print(dp[n][0]%MOD)\nelse:\n    print(0)\n</ans>", "format_properties": {}}
{"idx": 186, "result": 0, "generated": "<ans>\nfrom sys import stdin, stdout\nfrom bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nimport math\nfrom fractions import Fraction as frac\nfrom random import random\ncin = stdin.readline\ndef cout(x):\n\tstdout.write(str(x)+'\\n')\ndef var(type = int):\n    print(\"type: \", str(type))\n    return type(stdin.readline())\ndef readline(type = int):\n    print(\"type: \", str(type))\n    return list(map(type,stdin.readline().split()))\ndef readlist(type = int):\n    print(\"type: \", str(type))\n    return list(map(type,stdin.readline().split()))\ndef sorted_indexes(arr):\n    print(\"arr: \", str(arr))\n    return sorted(list(range(len(arr))),key=arr.__getitem__)\ndef printr(arr):\n    print(\"arr: \", str(arr))\n    [stdout.write(str(x)+' ')   for x in arr]\n    cout('')\ndef find_lt(a, x):#'Find rightmost value less than x'\n    print(\"a: \", str(a), \"x: \", str(x))\n    i = bisect_left(a, x)\n    if i:\n        return a[i-1]\n    raise ValueError\ndef find_gt(a, x):#'Find leftmost value greater than x'\n    print(\"a: \", str(a), \"x: \", str(x))\n    i = bisect_right(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\ndef dist(x,y):\n    print(\"x: \", str(x), \"y: \", str(y))\n    return math.sqrt(x*x + y*y)\ndef binary_search(arr, x):\n    print(\"arr: \", str(arr), \"x: \", str(x))\n    i = bisect_left(arr, x)\n    if i == len(arr) or arr[i] != x:\n        return -1\n    return i\n\n# mp = [0]*201\n# ops = [0]*201\n# def go(arr,i,j ,dp):\n#     print(\"arr: \", str(arr), \"i: \", str(i), \"j: \", str(j), \"dp: \", str(dp))\n#     if i==j and ops[i] is None:\n#         return [mp[i],mp[i]]\n#     if i>j:\n#         return [0,0]\n#     if dp[i][j]:\n#         return dp[i][j]\n#     mx = -1000000000\n#     mn = 1000000000\n#     for k in range(i+1,j,2):\n#         if ops[k]:\n#             left = go(arr,i,k-1,dp)\n#             right = go(arr,k+1,j,dp)\n#             mx = max(mx,left[0] + right[0])\n#             mn = min(mn,left[1] + right[1])\n#         else:\n#             left = go(arr,i,k-1,dp)\n#             right = go(arr,k+1,j,dp)\n#             mx = max(mx,left[0] - right[1])\n#             mn = min(mn,left[1] - right[0])\n#     dp[i][j] = [mx,mn]\n#     return [mx,mn]\n\nn , a , b = readline(int)\nprint(\"n: \", str(n), \"a: \", str(a), \"b: \", str(b))\nprice = [a,b]\nprint(\"price: \", str(price))\narr = readlist(int)\nprint(\"arr: \", str(arr))\nhalf = n//2\nprint(\"half: \", str(half))\ncost = 0\nprint(\"cost: \", str(cost))\nflg = True\nprint(\"flg: \", str(flg))\nfor i in range(half):\n    if arr[i] == arr[n-1-i] == 2:\n        cost += 2*min(a,b)\n    elif arr[i] ==2 and arr[n-1-i] <= 1:\n        cost += price[arr[n-1-i]]\n    elif arr[i] <= 1 and arr[n-1-i] == 2:\n        cost += price[arr[i]]\n    elif arr[i] != arr[n-1-i]:\n        flg = False\n        break\nif n%2 == 1:\n    if arr[half] == 2:\n        cost += min(a,b)\nif not flg:\n    print(-1)\nelse:\n    print(cost)\n</ans>", "format_properties": {}}
{"idx": 191, "result": 0, "generated": "<ans>\nimport sys\ninput = sys.stdin.readline\n\n# def find(a):\n#     if par[a] == a:\n#         return a\n#     par[a] = find(par[a])\n#     return par[a]\n\ndef find(a):\n    print(\"a: \", str(a))\n    upd = []\n    print(\"upd: \", str(upd))\n    cur = a\n    while par[cur] != cur:\n        upd.append(cur)\n        print(\"upd: \", str(upd))\n        cur = par[cur]\n    for x in upd:\n        par[x] = cur\n    print(\"par: \", str(par))\n    return cur\n\ndef union(a, b):\n    print(\"a: \", str(a))\n    print(\"b: \", str(b))\n    a = find(a)\n    print(\"a: \", str(a))\n    b = find(b)\n    print(\"b: \", str(b))\n    if a == b:\n        return\n    par[a] = b\n    print(\"par: \", str(par))\n\ndef mst():\n    print(\"edges: \", str(edges))\n    ret = []\n    for edge in edges:\n        u, v, w = edge\n        print(\"u: \", str(u))\n        print(\"v: \", str(v))\n        print(\"w: \", str(w))\n        u = find(u)\n        print(\"u: \", str(u))\n        v = find(v)\n        print(\"v: \", str(v))\n        if u != v:\n            union(u, v)\n            ret.append(edge)\n    print(\"ret: \", str(ret))\n    return ret\n\ndef dfs(u, par):\n    print(\"u: \", str(u))\n    print(\"par: \", str(par))\n    for v, w in adj[u]:\n        print(\"v: \", str(v))\n        print(\"w: \", str(w))\n        if v != par:\n            dist[v] = max(dist[u], w)\n            print(\"dist: \", str(dist))\n            dfs(v, u)\n\ndef bfs(u):\n    print(\"u: \", str(u))\n    visit = [False] * (n+1)\n    print(\"visit: \", str(visit))\n    from collections import deque\n\n    dq = deque()\n    dq.append(u)\n    visit[u] = True\n    while dq:\n        u = dq.popleft()\n        print(\"u: \", str(u))\n        for v, w in adj[u]:\n            print(\"v: \", str(v))\n            print(\"w: \", str(w))\n            if not visit[v]:\n                dist[v] = max(dist[u], w)\n                print(\"dist: \", str(dist))\n                dq.append(v)\n                visit[v] = True\n\nn, m, k = list(map(int, input().split()))\nprint(\"n: \", str(n))\nprint(\"m: \", str(m))\nprint(\"k: \", str(k))\na = list(map(int, input().split()))\nprint(\"a: \", str(a))\n# n = 50000\n# m = 2 * n\n# k = n\n# a = [i for i in range(1, n+1)]\n# import random\n\npar = [0] * (n+1)\nprint(\"par: \", str(par))\nfor i in range(1, n+1):\n    par[i] = i\nedges = []\n# for i in range(1, n+1):\n#     edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))\n#     edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))\n#     edges.append(edge)\nfor i in range(m):\n    edge = tuple(map(int, input().split()))\n    print(\"edge: \", str(edge))\n    edges.append(edge)\nedges.sort(key=lambda x: x[2])\nprint(\"edges: \", str(edges))\nedges = mst()\nadj = [list() for i in range(n+1)]\nprint(\"adj: \", str(adj))\nfor edge in edges:\n    u, v, w = edge\n    print(\"u: \", str(u))\n    print(\"v: \", str(v))\n    print(\"w: \", str(w))\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\ndist = [0] * (n+1)\nprint(\"dist: \", str(dist))\n# dfs(a[0], -1)\nbfs(a[0])\nans = 0\nfor x in a:\n    print(\"x: \", str(x))\n    ans = max(ans, dist[x])\nprint(\"ans: \", str(ans))\nans = [ans] * k\nprint(\"ans: \", str(ans))\nprint(*ans)\n\n</ans>", "format_properties": {}}
{"idx": 190, "result": 0, "generated": "<ans>\n''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n        print(\"self.parent: \", str(self.parent))\n        print(\"self.size: \", str(self.size))\n        print(\"self.num_sets: \", str(self.num_sets))\n        print(\"self.lista: \", str(self.lista))\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n        print(\"self.parent: \", str(self.parent))\n        print(\"self.size: \", str(self.size))\n        print(\"self.num_sets: \", str(self.num_sets))\n        print(\"self.lista: \", str(self.lista))\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    a, b, c, d, k = get_tuple()\n    x = (a+c-1)//c\n    y = (b+d-1)//d\n    print(\"x: \", str(x))\n    print(\"y: \", str(y))\n    if x+y<=k:\n        print(x, y)\n    else: print(-1)\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n\n</ans>", "format_properties": {}}
{"idx": 192, "result": 0, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\ns1=[int(x) for x in input().split()]\nprint(\"s1: \", str(s1))\ns2=[int(x) for x in input().split()]\nprint(\"s2: \", str(s2))\nS1=sorted(s1)\nprint(\"S1: \", str(S1))\nS2=sorted(s2)\nprint(\"S2: \", str(S2))\nS1=[0]+S1\nprint(\"S1: \", str(S1))\nS2=[0]+S2\nprint(\"S2: \", str(S2))\nS1=S1[::-1]\nprint(\"S1: \", str(S1))\nS2=S2[::-1]\nprint(\"S2: \", str(S2))\npta=0\nprint(\"pta: \", str(pta))\nptb=0\nprint(\"ptb: \", str(ptb))\nsm1=0\nprint(\"sm1: \", str(sm1))\nsm2=0\nprint(\"sm2: \", str(sm2))\nfor j in range(0,(2*n)+1):\n    if(j%2==0):\n        if(S2[ptb]>S1[pta]):\n            ptb=ptb+1\n        else:\n            sm1=sm1+S1[pta]\n            pta=pta+1\n    else:\n        if(S1[pta]>S2[ptb]):\n            pta=pta+1\n        else:\n            sm2=sm2+S2[ptb]\n            ptb=ptb+1\n    if(pta==n+1 and ptb==n+1):\n        break\nprint(\"sm1: \", str(sm1))\nprint(\"sm2: \", str(sm2))\nprint(sm1-sm2)\n</ans>", "format_properties": {}}
{"idx": 198, "result": 0, "generated": "<ans>\nfrom math import gcd\n\nm,a,b = list(map(int,input().split()))\nprint(\"m: \", str(m), \"a: \", str(a), \"b: \", str(b))\n\ng = gcd(a,b)\nprint(\"g: \", str(g))\n\nvis = [0]*(a+b+1)\nprint(\"vis: \", str(vis))\nvis[0] = 1\n\nnvis = 1\nprint(\"nvis: \", str(nvis))\n\ncount = 0\nprint(\"count: \", str(count))\nlast = 0\nprint(\"last: \", str(last))\nt = 0\nprint(\"t: \", str(t))\n\nwhile True:\n    #print(t, vis)\n    if t >= b:\n        #print('back')\n        t -= b\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n        print(\"nvis: \", str(nvis))\n    else:\n        t += a\n        if t > m:\n            break\n        if t > last:\n            #print('forward', t - last, 'with', nvis)\n            count += (t - last)*nvis\n            print(\"count: \", str(count))\n            last = t\n            print(\"last: \", str(last))\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n        print(\"nvis: \", str(nvis))\n    #print(nvis,count)\n    #print('---')\n\nif t > m:\n    # we're done\n    count += (m - last + 1)*nvis\n    print(\"count: \", str(count))\nelse:\n    def sumto(n):\n        whole = n//g + 1\n        r = whole*(whole+1)//2 * g\n        corr = whole * (g-1 - (n%g))\n        r -= corr\n        return r\n\n    #S = 0\n    #for i in range(last, m+1):\n    #    S += i//g + 1\n    #count += S\n    #assert S == sumto(m) - sumto(last-1)\n\n    count += sumto(m) - sumto(last-1)\n    print(\"count: \", str(count))\n\n#print(vis)\nprint(count)\n\n</ans>", "format_properties": {}}
{"idx": 194, "result": 0, "generated": "<ans>\nfrom bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nfrom math import *\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nprint(\"getcontext().prec: \", str(getcontext().prec))\nMAX = sys.maxsize\nprint(\"MAX: \", str(MAX))\nMAXN = 10**5+10\nprint(\"MAXN: \", str(MAXN))\nMOD = 10**9+7\nprint(\"MOD: \", str(MOD))\ndef isprime(n):\n    n = abs(int(n))\n    print(\"n: \", str(n))\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    print(\"g: \", str(g))\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    print(\"msf: \", str(msf))\n    meh = 0\n    print(\"meh: \", str(meh))\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    n,k = arrIN()\n    ans = 0\n    while 1:\n        if n%k==0:\n            n//=k\n            ans+=1\n        else:\n            x = n%k\n            ans+=x\n            n-=x\n        if n==0:\n            print(ans)\n            break\n</ans>", "format_properties": {}}
{"idx": 193, "result": 0, "generated": "<ans>\nimport sys\n# from collections import deque\ninput=sys.stdin.readline\ndef binary_search(org,arr,l,r,n,L,value):\n\tmid=(l+r)//2\n\t# print(mid,\"ppppp\")\n\tif(mid>0 and arr[mid]-value>=org and arr[mid-1]-value<org):\n\t\treturn mid\n\telif(mid==0 and arr[mid]-value>=org ):\n\t\treturn mid\n\telif(mid==L and arr[mid]-value>=org ):\n\t\treturn mid\n\n\telif(mid==n):\n\t\treturn mid\n\n\telif(mid>0 and arr[mid]-value>org and arr[mid-1]-value>=org):\n\t\treturn binary_search(org,arr,l,mid,n,L,value)\n\n\telif(arr[mid]-value<org):\n\t\t# print(\"dddddd\")\n\t\treturn binary_search(org,arr,mid+1,r,n,L,value)\n\treturn mid\n\nn=int(input())\nprint(\"n: \", str(n))\nl= list(map(int,input().split()))\nprint(\"l: \", str(l))\nu= list(map(int,input().split()))\nprint(\"u: \", str(u))\nextra=[0]*n\nprint(\"extra: \", str(extra))\npre=[0]*n\nprint(\"pre: \", str(pre))\nt=[0]*n\nprint(\"t: \", str(t))\nt[0]=u[0]\nfor i in range(1,n):\n\tt[i]+=t[i-1]+u[i]\n# print(t)\nfor i in range(n):\n\tif(i>0):\n\t\tv=t[i-1]\n\telse:\n\t\tv=0\n\tindex=binary_search(l[i],t,i,n-1,n-1,i,v)\n\t# print(i,index)\n\tif(index>0 and index!=i):\n\t\tvalue=t[index]-t[index-1]\n\t\tremain=l[i]-(t[index-1]-v)\n\telif(index>0 and index==i):\n\t\tvalue=t[index]-t[index-1]\n\t\tremain=l[i]\n\n\n\telse:\n\t\tvalue=t[index]\n\t\tremain=l[i]\n\tif(value>=remain):\n\t\textra[index]+=remain\n\t\t# print(extra[index],\"ooooo\")\n\telif(remain>value):\n\n\t\textra[index]+=value\n\t\t# print(extra[index],\"oooooopp\")\n\tif(i>0 and index>0):\n\t\tpre[i-1]-=1\n\t\tpre[index-1]+=1\n\telif(i==0 and index>0):\n\t\tpre[index-1]+=1\n\telif(i==0 and index==0):\n\t\tcontinue\n\t# print(extra,pre)\n# print(extra,pre)\nfor i in range(n-2,-1,-1):\n\tpre[i]+=pre[i+1]\n# print(extra,pre)\nr=[0]*n\nprint(\"r: \", str(r))\nfor i in range(n):\n\tr[i]=(u[i]*pre[i])+extra[i]\n\nfor i in r:\n\tprint (i,end=\" \")\n</ans>", "format_properties": {}}
{"idx": 197, "result": 1, "generated": "<ans>\nn=int(input())\nprint(\"n: \", str(n))\nl=list(map(int,input().split()))\nprint(\"l: \", str(l))\ns=input()\nprint(\"s: \", str(s))\nwater=0\nprint(\"water: \", str(water))\ngrass=0\nprint(\"grass: \", str(grass))\ncgrass=0\nprint(\"cgrass: \", str(cgrass))\ntime=0\nprint(\"time: \", str(time))\nseen=False\nprint(\"seen: \", str(seen))\nfor i in range(n):\n    if s[i]==\"G\":\n        dist=l[i]\n        print(\"dist: \", str(dist))\n        if water>=dist:\n            water-=dist\n            print(\"water: \", str(water))\n            time+=2*dist\n            print(\"time: \", str(time))\n            cgrass+=dist\n            print(\"cgrass: \", str(cgrass))\n        else:\n            dist-=water\n            print(\"dist: \", str(dist))\n            time+=2*water\n            print(\"time: \", str(time))\n            cgrass+=water\n            print(\"cgrass: \", str(cgrass))\n            water=0\n            print(\"water: \", str(water))\n            time+=3*dist\n            print(\"time: \", str(time))\n            grass+=dist\n            print(\"grass: \", str(grass))\n    elif s[i]==\"W\":\n        water+=l[i]\n        print(\"water: \", str(water))\n        time+=2*l[i]\n        print(\"time: \", str(time))\n        seen=True\n        print(\"seen: \", str(seen))\n    else:\n        dist=l[i]\n        print(\"dist: \", str(dist))\n        if water>=dist:\n            water-=dist\n            print(\"water: \", str(water))\n            time+=2*dist\n            print(\"time: \", str(time))\n        else:\n            dist-=water\n            print(\"dist: \", str(dist))\n            time+=2*water\n            print(\"time: \", str(time))\n            water=0\n            print(\"water: \", str(water))\n            if cgrass>=dist:\n                cgrass-=dist\n                print(\"cgrass: \", str(cgrass))\n                grass+=dist\n                print(\"grass: \", str(grass))\n                time+=3*dist\n                print(\"time: \", str(time))\n            else:\n                dist-=cgrass\n                print(\"dist: \", str(dist))\n                grass+=cgrass\n                print(\"grass: \", str(grass))\n                time+=3*cgrass\n                print(\"time: \", str(time))\n                cgrass=0\n                print(\"cgrass: \", str(cgrass))\n                if grass>=dist:\n                    grass-=dist\n                    print(\"grass: \", str(grass))\n                    time+=3*dist\n                    print(\"time: \", str(time))\n                else:\n                    dist-=grass\n                    print(\"dist: \", str(dist))\n                    time+=3*grass\n                    print(\"time: \", str(time))\n                    grass=0\n                    print(\"grass: \", str(grass))\n                    if seen:\n                        time+=4*dist\n                        print(\"time: \", str(time))\n                    else:\n                        time+=6*dist\n                        print(\"time: \", str(time))\nprint(time)\n</ans>", "format_properties": {}}
{"idx": 195, "result": 0, "generated": "<ans>\nMOD = 1000000007\n\ndef isSubset(a, b):\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a & b) == a\n\ndef isIntersect(a, b):\n\tprint(\"a: \", str(a), \"b: \", str(b))\n\treturn (a & b) != 0\n\n# Solve for each weakly connected component (WCC)\ndef cntOrder(s, t):\n\tprint(\"s: \", str(s), \"t: \", str(t))\n\tp = len(s)\n\tm = len(t)\n\n\tinMask = [0 for i in range(m)]\n\n\tfor x in range(p):\n\t\tfor i in range(m):\n\t\t\tif t[i] % s[x] == 0:\n\t\t\t\tinMask[i] |= 1 << x\n\n\tprint(\"inMask: \", str(inMask))\n\n\tcnt = [0 for mask in range(1<<p)]\n\tfor mask in range(1<<p):\n\t\tfor i in range(m):\n\t\t\tif isSubset(inMask[i], mask):\n\t\t\t\tcnt[mask] += 1\n\n\tprint(\"cnt: \", str(cnt))\n\n\tdp = [[0 for mask in range(1<<p)] for k in range(m+1)]\n\tfor i in range(m):\n\t\tdp[1][inMask[i]] += 1\n\tfor k in range(m):\n\t\tfor mask in range(1<<p):\n\t\t\tfor i in range(m):\n\t\t\t\tif not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):\n\t\t\t\t\tdp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD\n\t\t\tdp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD\n\n\tprint(\"dp: \", str(dp))\n\n\treturn dp[m][(1<<p)-1]\n\ndef dfs(u):\n\tnonlocal a, graph, degIn, visited, s, t\n\n\tvisited[u] = True\n\tif degIn[u] == 0:\n\t\ts.append(a[u])\n\telse:\n\t\tt.append(a[u])\n\n\tprint(\"u: \", str(u), \"s: \", str(s), \"t: \", str(t))\n\n\tfor v in graph[u]:\n\t\tif not visited[v]:\n\t\t\tdfs(v)\n\ndef main():\n\tnonlocal a, graph, degIn, visited, s, t\n\n\t# Reading input\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\n\tprint(\"n: \", str(n), \"a: \", str(a))\n\n\t# Pre-calculate C(n, k)\n\tc = [[0 for j in range(n)] for i in range(n)]\n\tfor i in range(n):\n\t\tc[i][0] = 1\n\t\tfor j in range(1, i+1):\n\t\t\tc[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD\n\n\tprint(\"c: \", str(c))\n\n\t# Building divisibility graph\n\tdegIn = [0 for u in range(n)]\n\tgraph = [[] for u in range(n)]\n\tfor u in range(n):\n\t\tfor v in range(n):\n\t\t\tif u != v and a[v] % a[u] == 0:\n\t\t\t\tgraph[u].append(v)\n\t\t\t\tgraph[v].append(u)\n\t\t\t\tdegIn[v] += 1\n\n\tprint(\"degIn: \", str(degIn), \"graph: \", str(graph))\n\n\t# Solve for each WCC of divisibility graph and combine result\n\tans = 1\n\tcurLen = 0\n\tvisited = [False for u in range(n)]\n\tfor u in range(n):\n\t\tif not visited[u]:\n\t\t\ts = []\n\t\t\tt = []\n\t\t\tdfs(u)\n\n\t\t\tif len(t) > 0:\n\t\t\t\tsz = len(t) - 1\n\t\t\t\tcnt = cntOrder(s, t)\n\n\t\t\t\t# Number of orders for current WCC\n\t\t\t\tans = (ans * cnt) % MOD\n\t\t\t\t# Number of ways to insert <sz> number to array of <curLen> elements\n\t\t\t\tans = (ans * c[curLen + sz][sz]) % MOD\n\t\t\t\tcurLen += sz\n\n\tprint(\"ans: \", str(ans))\n\ndef __starting_point():\n\tmain()\n__starting_point()\n</ans>", "format_properties": {}}
{"idx": 196, "result": 0, "generated": "<ans>\nN=int(input())\nprint(\"N: \", str(N))\nS=input()\nprint(\"S: \", str(S))\nS=[1 if S[i]=='o' else -1 for i in range(N)]\nprint(\"S: \", str(S))\n\n#0\u756a\u76ee\u306f\u7f8a\u306e\u30d1\u30bf\u30fc\u30f3\ntmp=[0]*N\nprint(\"tmp: \", str(tmp))\ntmp[0]=1\nif S[0]==1: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u540c\u7a2e\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7f8a\n  tmp[1]=1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u72fc\n  tmp[1]=-1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\nelse: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7570\u7a2e\n  #1\u756a\u76ee\u304c\u7f8a, N-1\u756a\u76ee\u304c\u72fc\n  tmp[1]=1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\n  #1\u756a\u76ee\u304c\u72fc, N-1\u756a\u76ee\u304c\u7f8a\n  tmp[1]=-1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\n#0\u756a\u76ee\u306f\u72fc\u306e\u30d1\u30bf\u30fc\u30f3\ntmp=[0]*N\nprint(\"tmp: \", str(tmp))\ntmp[0]=-1\nif S[0]==-1: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u540c\u7a2e\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7f8a\n  tmp[1]=1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\n  #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u72fc\n  tmp[1]=-1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\nelse: #0\u756a\u76ee\u306e\u4e21\u96a3\u306f\u7570\u7a2e\n  #1\u756a\u76ee\u304c\u7f8a, N-1\u756a\u76ee\u304c\u72fc\n  tmp[1]=1\n  tmp[N-1]=-1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\n  #1\u756a\u76ee\u304c\u72fc, N-1\u756a\u76ee\u304c\u7f8a\n  tmp[1]=-1\n  tmp[N-1]=1\n  print(\"tmp: \", str(tmp))\n\n  for i in range(2, N-1):\n    tmp[i]=tmp[i-1]*tmp[i-2]*S[i-1]\n  print(\"tmp: \", str(tmp))\n\n  if tmp[N-1]==tmp[N-2]*tmp[N-3]*S[N-2] and tmp[0]==tmp[N-1]*tmp[N-2]*S[N-1]:\n    ans=['S' if tmp[i]==1 else 'W' for i in range(N)]\n    print(''.join(ans))\n    return\n\nprint(-1)\n</ans>", "format_properties": {}}
