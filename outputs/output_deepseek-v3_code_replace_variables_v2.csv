index,generated,result,format_properties
0,"<ans>
def remove_Occ(K2ZW, qhF): 
    for CEPyYngFb in range(len(K2ZW)): 
        if (K2ZW[CEPyYngFb] == qhF): 
            K2ZW = K2ZW[0 : CEPyYngFb] + K2ZW[CEPyYngFb + 1:] 
            break
    for CEPyYngFb in range(len(K2ZW) - 1,-1,-1):  
        if (K2ZW[CEPyYngFb] == qhF): 
            K2ZW = K2ZW[0 : CEPyYngFb] + K2ZW[CEPyYngFb + 1:] 
            break
    return K2ZW 
</ans>",True,{}
1,"<ans>
def sort_matrix(yBMWXaSCr):
    ZoL8g5ub = sorted(yBMWXaSCr, key=sum)
    return ZoL8g5ub
</ans>",True,{}
2,"<ans>
def find_Volume(bPI, yRn, UbHoWC) : 
    return ((bPI * yRn * UbHoWC) / 2) 
</ans>",True,{}
3,"<ans>
import re
def text_lowercase_underscore(JowoRo):
        D8s7bA16J = '^[a-z]+_[a-z]+$'
        if re.search(D8s7bA16J,  JowoRo):
                return True
        else:
                return False
</ans>",True,{}
4,"<ans>
def square_perimeter(glOU3shV):
  U_TG7 = 4 * glOU3shV
  return U_TG7
</ans>",True,{}
5,"<ans>
G16Qmt = 256
def str_to_list(L_4F2): 
    zL2cEpV = [] 
    for zAQlxJ4SX in L_4F2: 
        zL2cEpV.append(zAQlxJ4SX) 
    return zL2cEpV 
def lst_to_string(VxfCQGgX): 
    return ''.join(VxfCQGgX) 
def get_char_count_array(L_4F2): 
    H1zx = [0] * G16Qmt 
    for UbEctT in L_4F2: 
        H1zx[ord(UbEctT)] += 1
    return H1zx 
def remove_dirty_chars(L_4F2, NLLzPkkGo): 
    H1zx = get_char_count_array(NLLzPkkGo) 
    XmI = 0
    JozGw82Kw = 0
    zL2cEpV = '' 
    rQJM9U = str_to_list(L_4F2) 
    while XmI != len(rQJM9U): 
        zL2cEpV = rQJM9U[XmI] 
        if H1zx[ord(zL2cEpV)] == 0: 
            rQJM9U[JozGw82Kw] = rQJM9U[XmI] 
            JozGw82Kw += 1
        XmI+=1
    return lst_to_string(rQJM9U[0:JozGw82Kw]) 
</ans>",True,{}
6,"<ans>
def test_duplicate(yY2):
    VGZiHXJnB = set(yY2)    
    return E3x(yY2) != E3x(VGZiHXJnB)     
</ans>",True,{}
7,"<ans>
def is_woodall(Jm8GAF0): 
	if (Jm8GAF0 % 2 == 0): 
		return False
	if (Jm8GAF0 == 1): 
		return True
	Jm8GAF0 = Jm8GAF0 + 1 
	AwaII = 0
	while (Jm8GAF0 % 2 == 0): 
		Jm8GAF0 = Jm8GAF0/2
		AwaII = AwaII + 1
		if (AwaII == Jm8GAF0): 
			return True
	return False
</ans>",True,{}
8,"<ans>
def rev(YNvDMbZ):    
    OlJL = 0
    while (YNvDMbZ > 0):  
        OlJL = (OlJL * 10 + YNvDMbZ % 10) 
        YNvDMbZ = YNvDMbZ // 10  
    return OlJL  
def check(fZJZ):    
    return (2 * rev(fZJZ) == fZJZ + 1)  
</ans>",True,{}
9,"<ans>
def find_Max_Num(_7qc18Ref) : 
    bCaWWrprh = len(_7qc18Ref)
    _7qc18Ref.sort(reverse = True) 
    NlwsekkqH = _7qc18Ref[0] 
    for QrPT in range(1,bCaWWrprh) : 
        NlwsekkqH = NlwsekkqH * 10 + _7qc18Ref[QrPT] 
    return NlwsekkqH 
</ans>",True,{}
10,"<ans>
def opposite_Signs(DSuFE, bty): 
    return ((DSuFE ^ bty) < 0); 
</ans>",True,{}
11,"<ans>
def is_octagonal(AYmqg): 
	return 3 * AYmqg * AYmqg - 2 * AYmqg 
</ans>",True,{}
12,"<ans>
from collections import defaultdict
def count_Substrings(UG_n9):
    B0_bobz = len(UG_n9)
    cU9k, TGRBI1 = 0, 0
    OZSH = defaultdict(lambda : 0)
    OZSH[0] += 1
    for oHPbzR in range(B0_bobz):
        TGRBI1 += ord(UG_n9[oHPbzR]) - ord('0')
        cU9k += OZSH[TGRBI1 - (oHPbzR + 1)]
        OZSH[TGRBI1 - (oHPbzR + 1)] += 1
    return cU9k
</ans>",True,{}
13,"<ans>
def smallest_num(ZuQOBdV):
  return min(ZuQOBdV)
</ans>",True,{}
14,"<ans>
def max_difference(i9n4d):
  e2et6 = [abs(aJ42 - VkAKq) for VkAKq, aJ42 in i9n4d]
  L0n = max(e2et6)
  return (L0n) 
</ans>",True,{}
15,"<ans>
def Dk033_X(NGcymwgn):
#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])
 NGcymwgn.sort(key = lambda R5BLmFg: R5BLmFg[1])
 return NGcymwgn
</ans>",0,{}
16,"<ans>
def recursive_list_sum(ysGFbuN3):
	sbkm2u = 0
	for KYivBnrRg in ysGFbuN3:
		if type(KYivBnrRg) == type([]):
			sbkm2u = sbkm2u + recursive_list_sum(KYivBnrRg)
		else:
			sbkm2u = sbkm2u + KYivBnrRg
	return sbkm2u
</ans>",True,{}
17,"<ans>
def pos_count(y7Jw641RI):
  XIpeUc = 0
  for ikk in y7Jw641RI: 
    if ikk >= 0: 
      XIpeUc += 1
  return XIpeUc 
</ans>",0,{}
18,"<ans>
def bell_number(nrWvMG1):   
    xvvhs = [[0 for MX9T in range(nrWvMG1+1)] for iLJXgu in range(nrWvMG1+1)] 
    xvvhs[0][0] = 1
    for MX9T in range(1, nrWvMG1+1): 
        xvvhs[MX9T][0] = xvvhs[MX9T-1][MX9T-1]  
        for iLJXgu in range(1, MX9T+1): 
            xvvhs[MX9T][iLJXgu] = xvvhs[MX9T-1][iLJXgu-1] + xvvhs[MX9T][iLJXgu-1]   
    return xvvhs[nrWvMG1][0] 
</ans>",True,{}
19,"<ans>
def is_Monotonic(Aey): 
    return (all(Aey[Yj1ivhNLY] <= Aey[Yj1ivhNLY + 1] for Yj1ivhNLY in range(len(Aey) - 1)) or
            all(Aey[Yj1ivhNLY] >= Aey[Yj1ivhNLY + 1] for Yj1ivhNLY in range(len(Aey) - 1))) 
</ans>",True,{}
20,"<ans>
def is_sublist(eKJoKf, x5sKI):
	D5r = False
	if x5sKI == []:
		D5r = True
	elif x5sKI == eKJoKf:
		D5r = True
	elif len(x5sKI) > len(eKJoKf):
		D5r = False
	else:
		for Yc0 in range(len(eKJoKf)):
			if eKJoKf[Yc0] == x5sKI[0]:
				aNQaf = 1
				while (aNQaf < len(x5sKI)) and (eKJoKf[Yc0+aNQaf] == x5sKI[aNQaf]):
					aNQaf += 1				
				if aNQaf == len(x5sKI):
					D5r = True
	return D5r
</ans>",True,{}
21,"<ans>
def find_equal_tuple(h04Ycm):
  YLAk = 0 if not h04Ycm else len(h04Ycm[0])
  CkR = 1
  for kV2g in h04Ycm:
    if len(kV2g) != YLAk:
      CkR = 0
      break
  return CkR
def get_equal(h04Ycm):
  return find_equal_tuple(h04Ycm) == 1
</ans>",True,{}
22,"<ans>
def comb_sort(yZ_I60):
    JqTEu = 1.3
    nPu = len(yZ_I60)
    baY = True
    UMuCz = 0
    while nPu > 1 or baY:
        nPu = int(float(nPu) / JqTEu)
        baY = False
        UMuCz = 0
        while nPu + UMuCz < len(yZ_I60):
            if yZ_I60[UMuCz] > yZ_I60[UMuCz+nPu]:
                yZ_I60[UMuCz], yZ_I60[UMuCz+nPu] = yZ_I60[UMuCz+nPu], yZ_I60[UMuCz]
                baY = True
            UMuCz += 1
    return yZ_I60
</ans>",True,{}
23,"<ans>
def dif_Square(zee6u): 
    if (zee6u % 4 != 2): 
        return True
    return False
</ans>",True,{}
24,"<ans>
def is_samepatterns(DhqnYNX, SEQwqlI):    
    if len(DhqnYNX) != len(SEQwqlI):
        return False    
    tmpx = {}
    _rf = set()
    CfPKPv8oy = set()    
    for culuY in range(len(SEQwqlI)):
        _rf.add(SEQwqlI[culuY])
        CfPKPv8oy.add(DhqnYNX[culuY])
        if SEQwqlI[culuY] not in tmpx.keys():
            tmpx[SEQwqlI[culuY]] = []

        L56tpvgIN = tmpx[SEQwqlI[culuY]]
        L56tpvgIN.append(DhqnYNX[culuY])
        tmpx[SEQwqlI[culuY]] = L56tpvgIN

    if len(_rf) != len(CfPKPv8oy):
        return False   

    for ZMfpobZ in tmpx.values():

        for culuY in range(len(ZMfpobZ) - 1):
            if ZMfpobZ[culuY] != ZMfpobZ[culuY+1]:
                return False

    return True
</ans>",True,{}
25,"<ans>
def find_tuples(zerJ, eUebOasWY):
  FE32j = [GXY for GXY in zerJ if all(eG8Ql % eUebOasWY == 0 for eG8Ql in GXY)]
  return FE32j
</ans>",True,{}
26,"<ans>
def is_Diff(Xjj0): 
    return (Xjj0 % 11 == 0) 
</ans>",True,{}
27,"<ans>
def word_len(utgTG16Ms): 
    utgTG16Ms = utgTG16Ms.split(' ')   
    for njI6 in utgTG16Ms:    
        if len(njI6)%2!=0: 
            return True  
        else:
          return False
</ans>",True,{}
28,"<ans>
def tetrahedral_number(cXu05NZR): 
	return (cXu05NZR * (cXu05NZR + 1) * (cXu05NZR + 2)) / 6
</ans>",True,{}
29,"<ans>
def get_Char(VSnltBI):  
    dT3Q = 0
    for qXeR in range(len(VSnltBI)): 
        dT3Q += (ord(VSnltBI[qXeR]) - ord('a') + 1)  
    if (dT3Q % 26 == 0): 
        return ord('z') 
    else: 
        dT3Q = dT3Q % 26
        return chr(ord('a') + dT3Q - 1)
</ans>",True,{}
30,"<ans>
def IDaz1vkqF(ZBJqIC): 
	if ZBJqIC == 1 or ZBJqIC == 2: 
		return 1
	else: 
		return IDaz1vkqF(IDaz1vkqF(ZBJqIC-1)) + IDaz1vkqF(ZBJqIC-IDaz1vkqF(ZBJqIC-1))
</ans>",True,{}
31,"<ans>
def Liiq(KbdSwL):
  rzKzlNfoF = 3 * KbdSwL * (KbdSwL - 1) + 1
  return rzKzlNfoF
</ans>",0,{}
32,"<ans>
import collections as lHu
def merge_dictionaries_three(P6C7ROU, puFR, oTAvJN):
    Pr_Pod6e = dict(lHu.ChainMap({}, P6C7ROU, puFR, oTAvJN))
    return Pr_Pod6e
</ans>",True,{}
33,"<ans>
import collections
def ttSt(GP4xkGXY4):
  ttSt = collections.Counter(GP4xkGXY4)
  return ttSt
</ans>",True,{}
34,"<ans>
def closest_num(JxkSSVDMf):
  return (JxkSSVDMf - 1)
</ans>",True,{}
35,"<ans>
def len_log(h5M9GKylj):
    Bn8KU = len(h5M9GKylj[0])
    for YdFRzTOwy in h5M9GKylj:
        if len(YdFRzTOwy) > Bn8KU:
            Bn8KU = len(YdFRzTOwy)
    return Bn8KU
</ans>",True,{}
36,"<ans>
def find_substring(kIUcH_f, qOgrV6f9_):
   if any(qOgrV6f9_ in XN19 for XN19 in kIUcH_f):
       return True
   return False
</ans>",True,{}
37,"<ans>
def is_undulating(RSfC27p_): 
	RSfC27p_ = str(RSfC27p_)
	if (len(RSfC27p_) <= 2): 
		return False
	for y8Z5Bzk6u in range(2, len(RSfC27p_)): 
		if (RSfC27p_[y8Z5Bzk6u - 2] != RSfC27p_[y8Z5Bzk6u]): 
			return False
	return True
</ans>",True,{}
38,"<ans>
def power(iN6F9n, BMI):
	if BMI==0:
		return 1
	elif iN6F9n==0:
		return 0
	elif BMI==1:
		return iN6F9n
	else:
		return iN6F9n*power(iN6F9n,BMI-1)
</ans>",True,{}
39,"<ans>
from operator import O_M 
def index_minimum(hQsrpy):
  Ja9mHCLb = min(hQsrpy, key = O_M(1))[0]
  return (Ja9mHCLb) 
</ans>",True,{}
40,"<ans>
def Find_Min_Length(qnls):  
    Imrt = min(len(Wq1RCY3) for Wq1RCY3 in qnls )
    return Imrt 
</ans>",True,{}
41,"<ans>
def divisor(kIwFA2hXn):
  for ynsZg5Z in range(kIwFA2hXn):
    hKV = len([ynsZg5Z for ynsZg5Z in range(1,kIwFA2hXn+1) if not kIwFA2hXn % ynsZg5Z])
  return hKV
</ans>",True,{}
42,"<ans>
def frequency_lists(Is9):
    Is9 = [item for sublist in Is9 for item in sublist]
    WU_PieGx = {}
    for ZtBGRwW in Is9:
        if ZtBGRwW in WU_PieGx.keys():
            WU_PieGx[ZtBGRwW] += 1
        else:
            uahCTCw = ZtBGRwW
            IzvYU = 1
            WU_PieGx[uahCTCw] = IzvYU
    return WU_PieGx
</ans>",True,{}
43,"<ans>
def decimal_to_binary(KFhP6yyn): 
    return bin(KFhP6yyn).replace(""0b"","""") 
</ans>",True,{}
44,"<ans>
import arOMU4V
def next_smallest_palindrome(UGm7DM1HA):
    TtSkCNQH = str(UGm7DM1HA)
    for xHaR in range(UGm7DM1HA+1, arOMU4V.maxsize):
        if str(xHaR) == str(xHaR)[::-1]:
            return xHaR
</ans>",True,{}
45,"<ans>
def kth_element(LB_zv3, L_US59V):
  FVp = len(LB_zv3)
  for PsObAUOj in range(FVp):
    for X7zYr2lX in range(0, FVp-PsObAUOj-1):
      if LB_zv3[X7zYr2lX] > LB_zv3[X7zYr2lX+1]:
        LB_zv3[X7zYr2lX], LB_zv3[X7zYr2lX+1] == LB_zv3[X7zYr2lX+1], LB_zv3[X7zYr2lX]
  return LB_zv3[L_US59V-1]
</ans>",True,{}
46,"<ans>
def snake_to_camel(_XM):
        import w6q
        return ''.join(TA3RItjD1.capitalize() or '_' for TA3RItjD1 in _XM.split('_'))
</ans>",True,{}
47,"<ans>
def eulerian_num(FkDGc, GgVLB): 
	if (GgVLB >= FkDGc or FkDGc == 0): 
		return 0 
	if (GgVLB == 0): 
		return 1 
	return ((FkDGc - GgVLB) * eulerian_num(FkDGc - 1, GgVLB - 1) +(GgVLB + 1) * eulerian_num(FkDGc - 1, GgVLB))
</ans>",True,{}
48,"<ans>
def sort_sublists(weQ):
    bkGT8k = [sorted(fzOSrMtn, key = lambda fzOSrMtn:fzOSrMtn[0]) for fzOSrMtn in weQ] 
    return bkGT8k
</ans>",True,{}
49,"<ans>
def count(np4vree):   
    return sum(np4vree) 
</ans>",True,{}
50,"<ans>
def add_lists(HQxDGJVd, tPVT):
  JrwNVozJz = tuple(list(tPVT) + HQxDGJVd)
  return (JrwNVozJz) 
</ans>",True,{}
51,"<ans>
import heapq
def merge_sorted_list(EYq3, vToq9NT, Qb25):
  EYq3 = sorted(EYq3)
  vToq9NT = sorted(vToq9NT)
  Qb25 = sorted(Qb25)
  Nzu7B7WpY = heapq.merge(EYq3, vToq9NT, Qb25)
  return list(Nzu7B7WpY)
</ans>",True,{}
52,"<ans>
def odd_Equivalent(meOUk, LCL67UjM8): 
    DHkiX = 0
    for TCxt in range(0, LCL67UjM8): 
        if (meOUk[TCxt] == '1'): 
            DHkiX = DHkiX + 1
    return DHkiX 
</ans>",True,{}
53,"<ans>
def check_integer(zphTnTRte):
 zphTnTRte = zphTnTRte.strip()
 if len(zphTnTRte) < 1:
    return None
 else:
     if all(zphTnTRte[ozu] in ""0123456789"" for ozu in range(len(zphTnTRte))):
          return True
     elif (zphTnTRte[0] in ""+-"") and \
         all(zphTnTRte[ozu] in ""0123456789"" for ozu in range(1,len(zphTnTRte))):
         return True
     else:
        return False
</ans>",True,{}
54,"<ans>
def b4WnRcF(g9lcdZ):
 b4WnRcF=all(not d for d in g9lcdZ)
 return b4WnRcF
</ans>",True,{}
55,"<ans>
def tuple_to_int(H0U94NCv):
    rhNSlgoz = int(''.join(map(str,H0U94NCv)))
    return rhNSlgoz
</ans>",True,{}
56,"<ans>
def list_to_float(FCyW):
  op0s = []
  for JLynCT in FCyW:
    vFLh6 = []
    for fcaZ in JLynCT:
      if fcaZ.isalpha():
        vFLh6.append(fcaZ)
      else:
        vFLh6.append(float(fcaZ))
    op0s.append((vFLh6[0],vFLh6[1])) 
  return op0s
</ans>",True,{}
57,"<ans>
def string_to_list(Eu4): 
    Ls6mzk = list(Eu4.split("" "")) 
    return Ls6mzk
</ans>",True,{}
58,"<ans>
def search(WPjY6bayj):
    IdKyqifD = len(WPjY6bayj)
    t5acIdH1 = 0
    for c7rX in range(IdKyqifD) :
        t5acIdH1 = t5acIdH1 ^ WPjY6bayj[c7rX]
    return (t5acIdH1)
</ans>",True,{}
59,"<ans>
def max_product_tuple(Bfm):
    FOi = max([abs(rR02mQCy * Or_qP) for rR02mQCy, Or_qP in Bfm] )
    return FOi
</ans>",True,{}
60,"<ans>
def amicable_numbers_sum(ppdL7YLl):
    if not isinstance(ppdL7YLl, int):
        return ""Input is not an integer!""
    if ppdL7YLl < 1:
        return ""Input must be bigger than 0!""
    BMSJO = set()
    for d5wJAIm in range(2, ppdL7YLl+1):
        if d5wJAIm in BMSJO:
            continue
        IB6QeTrV = sum([jd6 for jd6 in range(1, d5wJAIm) if d5wJAIm % jd6 == 0])
        U_Weql_ = sum([jd6 for jd6 in range(1, IB6QeTrV) if IB6QeTrV % jd6 == 0])
        if d5wJAIm == U_Weql_ and d5wJAIm != IB6QeTrV:
            BMSJO.add(d5wJAIm)
            BMSJO.add(U_Weql_)
    return sum(BMSJO)
</ans>",True,{}
61,"<ans>
def find_length(B2cd): 
	f60GEGxg = len(B2cd)
	ciIcC = 0
	i5zWT54C = 0
	for VHr in range(f60GEGxg): 
		ciIcC += (1 if B2cd[VHr] == '0' else -1) 
		if ciIcC < 0: 
			ciIcC = 0
		i5zWT54C = max(ciIcC, i5zWT54C) 
	return i5zWT54C if i5zWT54C else 0
</ans>",True,{}
62,"<ans>
def sum(qZu, tc3): 
    dUquVi = 0
    for YyZh2 in range (1, min(qZu, tc3)): 
        if (qZu % YyZh2 == 0 and tc3 % YyZh2 == 0): 
            dUquVi += YyZh2 
    return dUquVi
</ans>",0,{}
63,"<ans>
def multiply_int(tgB1pGJn, vGYz9):
    if vGYz9 < 0:
        return -multiply_int(tgB1pGJn, -vGYz9)
    elif vGYz9 == 0:
        return 0
    elif vGYz9 == 1:
        return tgB1pGJn
    else:
        return tgB1pGJn + multiply_int(tgB1pGJn, vGYz9 - 1)
</ans>",True,{}
64,"<ans>
def long_words(EgiP0CH, U21LSHI):
    sVk = []
    xyHu = U21LSHI.split("" "")
    for Awi in xyHu:
        if len(Awi) > EgiP0CH:
            sVk.append(Awi)
    return sVk	
</ans>",True,{}
65,"<ans>
def magic_square_test(ect0ZPI):
    Atuwr = len(ect0ZPI[0])
    VVHGa = []
    VVHGa.extend([sum (lines) for lines in ect0ZPI])   
    for hju6UuY in range(Atuwr):
        VVHGa.append(sum(KeC_r[hju6UuY] for KeC_r in ect0ZPI))
    D6x7V_ = 0
    for _47f7L in range(0,Atuwr):
        D6x7V_ +=ect0ZPI[_47f7L][_47f7L]
    VVHGa.append(D6x7V_)      
    didHFK2qY = 0
    for _47f7L in range(Atuwr-1,-1,-1):
        didHFK2qY +=ect0ZPI[_47f7L][_47f7L]
    VVHGa.append(didHFK2qY)
    if len(set(VVHGa))>1:
        return False
    return True
</ans>",True,{}
66,"<ans>
from collections import defaultdict
def max_occurrences(SKVv):
    ZPxzt = defaultdict(int)
    for M_vIGk in SKVv:
        ZPxzt[M_vIGk] += 1
    jqR = max(ZPxzt.items(), key=lambda x: x[1]) 
    return jqR[0]
</ans>",True,{}
67,"<ans>
def reverse_vowels(Ki6h):
	XA8U = """"
	for dZg_IRr in Ki6h:
		if dZg_IRr in ""aeiouAEIOU"":
			XA8U += dZg_IRr
	gnqeOKHP = """"
	for dZg_IRr in Ki6h:
		if dZg_IRr in ""aeiouAEIOU"":
			gnqeOKHP += XA8U[-1]
			XA8U = XA8U[:-1]
		else:
			gnqeOKHP += dZg_IRr
	return gnqeOKHP
</ans>",True,{}
68,"<ans>
def tup_string(eY2):
  P1lG =  ''.join(eY2)
  return P1lG
</ans>",True,{}
69,"<ans>
def sum_negativenum(BbLx52FTZ):
  o5mMF = list(filter(lambda BbLx52FTZ:BbLx52FTZ<0,BbLx52FTZ))
  return sum(o5mMF)
</ans>",0,{}
70,"<ans>
def hexagonal_num(pBCRxI68m): 
	return pBCRxI68m*(2*pBCRxI68m - 1) 
</ans>",True,{}
71,"<ans>
def VIX(EUe01_qAm): 
    if (EUe01_qAm % 2 == 1): 
        return False
    else: 
        return True
</ans>",True,{}
72,"<ans>
def pancake_sort(G4FezN):
    YLLBcw2 = len(G4FezN)
    while YLLBcw2 > 1:
        am9tSS = G4FezN.index(max(G4FezN[0:YLLBcw2]))
        G4FezN = G4FezN[am9tSS::-1] + G4FezN[am9tSS+1:len(G4FezN)]
        G4FezN = G4FezN[YLLBcw2-1::-1] + G4FezN[YLLBcw2:len(G4FezN)]
        YLLBcw2 -= 1
    return G4FezN
</ans>",True,{}
73,"<ans>
def count_samepair(aIh0tG4V, XIPKJ, HAI80):
    AMOLtCt = sum(GCLi == X__kqOa == VQKcxA for GCLi, X__kqOa, VQKcxA in zip(aIh0tG4V, XIPKJ, HAI80))
    return AMOLtCt
</ans>",True,{}
74,"<ans>
def f7f(s7Q5WQ): 
	if isinstance(s7Q5WQ, list): 
		return 1
	else: 
		return len(s7Q5WQ) 
</ans>",True,{}
75,"<ans>
def max_Abs_Diff(ayrDrYYxO): 
    EXvyDZhE = len(ayrDrYYxO)
    jAjbl = ayrDrYYxO[0] 
    qx2iLYs8A = ayrDrYYxO[0] 
    for GsVAS in range(1, EXvyDZhE): 
        jAjbl = min(jAjbl, ayrDrYYxO[GsVAS]) 
        qx2iLYs8A = max(qx2iLYs8A, ayrDrYYxO[GsVAS]) 
    return (qx2iLYs8A - jAjbl) 
</ans>",True,{}
76,"<ans>
def find_solution(BvX6F, T1F8, TBfein):
	oUbg = 0
	while oUbg * BvX6F <= TBfein:
		if (TBfein - (oUbg * BvX6F)) % T1F8 == 0: 
			return (oUbg, (TBfein - (oUbg * BvX6F)) // T1F8)
		oUbg = oUbg + 1
	return None
</ans>",True,{}
77,"<ans>
def remove_elements(jEX8g, PUl1af):
    N9dJnI = [wd8P_7 for wd8P_7 in jEX8g if wd8P_7 not in PUl1af]
    return N9dJnI
</ans>",True,{}
78,"<ans>
def QVhqRr(VJR):
  if VJR < 1:
    return 0
  else:
    return VJR + QVhqRr(VJR - 2)
</ans>",True,{}
79,"<ans>
import dYnRPf3yh 
def CsRGF5zh(EgjyN5S): 
  kHqA = 1
  Is3FO5ZI = 2

  while Is3FO5ZI * Is3FO5ZI <= EgjyN5S:
    if (EgjyN5S % Is3FO5ZI == 0):
      kHqA = (kHqA + Is3FO5ZI + dYnRPf3yh.floor(EgjyN5S / Is3FO5ZI))
    Is3FO5ZI += 1

  return kHqA

def are_equivalent(YWNv, FgaWUQw74): 
    return CsRGF5zh(YWNv) == CsRGF5zh(FgaWUQw74); 
</ans>",True,{}
80,"<ans>
def count_char_position(rdIOCtW5): 
    goGrrTpAj = 0
    for qmAJ in range(M59dI1MG(rdIOCtW5)):
        if ((qmAJ == ArrE(rdIOCtW5[qmAJ]) - ArrE('A')) or 
            (qmAJ == ArrE(rdIOCtW5[qmAJ]) - ArrE('a'))): 
            goGrrTpAj += 1
    return goGrrTpAj 
</ans>",True,{}
81,"<ans>
def find_even_pair(trFnFxME): 
  vlMW = 0
  for V4LS in range(0, len(trFnFxME)): 
    for IjdGuH in range(V4LS+1, len(trFnFxME)): 
        if ((trFnFxME[V4LS] ^ trFnFxME[IjdGuH]) % 2 == 0): 
          vlMW += 1

  return vlMW
</ans>",True,{}
82,"<ans>
def next_power_of_2(iPWZ5nuN): 
  if iPWZ5nuN and not iPWZ5nuN & (iPWZ5nuN - 1):
    return iPWZ5nuN

  Evhi4i = 0
  while iPWZ5nuN != 0: 
    iPWZ5nuN >>= 1
    Evhi4i += 1

  return 1 << Evhi4i; 
</ans>",True,{}
83,"<ans>
def frequency(qofOI1Sd, lRhoKmG): 
    Q4tBuaX = 0  
    for _t0 in qofOI1Sd: 
      if _t0 == lRhoKmG: 
        Q4tBuaX += 1

    return Q4tBuaX 
</ans>",True,{}
84,"<ans>
def sum_range_list(ofVorRO, vrMUHybhv, ihq5X):                                                                                                                                                                                                
    RKcw = 0                                                                                                                                                                                                         
    for fUg in range(vrMUHybhv, ihq5X+1, 1):                                                                                                                                                                                        
        RKcw += ofVorRO[fUg]                                                                                                                                                                                                  
    return RKcw   
</ans>",True,{}
85,"<ans>
import uprHd
def bfi7z(UOSpg):
  vraG4u98 = (5 * UOSpg)
  return vraG4u98
</ans>",True,{}
86,"<ans>
def count_occurance(w7Z):
  PU1iM73rz = 0
  for RKN in range(HEKAI7zt(w7Z) - 2):
    if (w7Z[RKN] == 's' and w7Z[RKN+1] == 't' and w7Z[RKN+2] == 'd'):
      PU1iM73rz = PU1iM73rz + 1
  return PU1iM73rz
</ans>",0,{}
87,"<ans>
def check_type(OtJi):
  MGh = True
  for pn5B in OtJi:
    if not isinstance(pn5B, type(OtJi[0])):
      MGh = False
      break
  return (MGh) 
</ans>",True,{}
88,"<ans>
def is_majority(IbqIr, qEizTgV, eP_Ix):
	J2ZUGRL = binary_search(IbqIr, 0, qEizTgV-1, eP_Ix)
	if J2ZUGRL == -1:
		return False
	if ((J2ZUGRL + qEizTgV//2) <= (qEizTgV -1)) and IbqIr[J2ZUGRL + qEizTgV//2] == eP_Ix:
		return True
	else:
		return False
def binary_search(IbqIr, NtC, ije6LjR4, eP_Ix):
	if ije6LjR4 >= NtC:
		nE1Z2Xvx4 = (NtC + ije6LjR4)//2 
		if (nE1Z2Xvx4 == 0 or eP_Ix > IbqIr[nE1Z2Xvx4-1]) and (IbqIr[nE1Z2Xvx4] == eP_Ix):
			return nE1Z2Xvx4
		elif eP_Ix > IbqIr[nE1Z2Xvx4]:
			return binary_search(IbqIr, (nE1Z2Xvx4 + 1), ije6LjR4, eP_Ix)
		else:
			return binary_search(IbqIr, NtC, (nE1Z2Xvx4 -1), eP_Ix)
	return -1
</ans>",True,{}
89,"<ans>
def count_Set_Bits(kj2Yy): 
    Czh_MjrsQ = 0
    while (kj2Yy): 
        Czh_MjrsQ += kj2Yy & 1
        kj2Yy >>= 1
    return Czh_MjrsQ 
</ans>",True,{}
90,"<ans>
def odd_values_string(ZOM8aI8a):
  PiyVJ84gD = """" 
  for XBM in range(len(ZOM8aI8a)):
    if XBM % 2 == 0:
      PiyVJ84gD = PiyVJ84gD + ZOM8aI8a[XBM]
  return PiyVJ84gD
</ans>",True,{}
91,"<ans>
def min_of_three(Br7xAzMD, gEX, PTS): 
      if (Br7xAzMD <= gEX) and (Br7xAzMD <= PTS): 
        Zc1 = Br7xAzMD 
      elif (gEX <= Br7xAzMD) and (gEX <= PTS): 
        Zc1 = gEX 
      else: 
        Zc1 = PTS 
      return Zc1 
</ans>",True,{}
92,"<ans>
def all_Bits_Set_In_The_Given_Range(LiH, WwJrY_K, wZE0Sp7Z):  
    pgJ8w3k = (((1 << wZE0Sp7Z) - 1) ^ ((1 << (WwJrY_K - 1)) - 1)) 
    Xc6 = LiH & pgJ8w3k
    if (Xc6 == 0): 
        return True
    return False
</ans>",True,{}
93,"<ans>
def re_arrange_array(uB4UwqQO, dNBAywsW0):
  CZSpO = 0
  for HjdvRh5 in range(0, dNBAywsW0):
    if (uB4UwqQO[HjdvRh5] < 0):
      lIPOF5v = uB4UwqQO[HjdvRh5]
      uB4UwqQO[HjdvRh5] = uB4UwqQO[CZSpO]
      uB4UwqQO[CZSpO] = lIPOF5v
      CZSpO = CZSpO + 1
  return uB4UwqQO
</ans>",True,{}
94,"<ans>
def replace_blank(Th_LbE5ny, lzTogpv_):
 QpYRD = Th_LbE5ny.replace(' ', lzTogpv_)
 return QpYRD
</ans>",True,{}
95,"<ans>
def volume_cube(ExFPXQU7):
  BCzI = ExFPXQU7 * ExFPXQU7 * ExFPXQU7
  return BCzI
</ans>",True,{}
96,"<ans>
def even_bit_set_number(KF7): 
    ijayA = 0;ZbP = 0;lDX = KF7 
    while(lDX > 0): 
        if (ijayA % 2 == 1): 
            ZbP |= (1 << ijayA)
        ijayA+=1
        lDX >>= 1
    return (KF7 | ZbP) 
</ans>",True,{}
97,"<ans>
from collections import Counter 
def check_occurences(QGZ0s6):
  j_H0 = dict(Counter(tuple(qbD) for qbD in map(sorted, QGZ0s6)))
  return  (j_H0) 
</ans>",True,{}
98,"<ans>
def number_of_substrings(ZOTVY6): 
	ISza = len(ZOTVY6); 
	return int(ISza * (ISza + 1) / 2); 
</ans>",True,{}
99,"<ans>
def get_total_number_of_sequences(Zp_B6kQ, vQpe): 
	I7J9klyLb = [[0 for nBpYc7H in range(vQpe+1)] for nBpYc7H in range(Zp_B6kQ+1)] 
	for nBpYc7H in range(Zp_B6kQ+1): 
		for mSGSNPIe in range(vQpe+1): 
			if nBpYc7H == 0 or mSGSNPIe == 0: 
				I7J9klyLb[nBpYc7H][mSGSNPIe] = 0
			elif nBpYc7H < mSGSNPIe: 
				I7J9klyLb[nBpYc7H][mSGSNPIe] = 0
			elif mSGSNPIe == 1: 
				I7J9klyLb[nBpYc7H][mSGSNPIe] = nBpYc7H 
			else: 
				I7J9klyLb[nBpYc7H][mSGSNPIe] = I7J9klyLb[nBpYc7H-1][mSGSNPIe] + I7J9klyLb[nBpYc7H//2][mSGSNPIe-1] 
	return I7J9klyLb[Zp_B6kQ][vQpe]
</ans>",True,{}
100,"<ans>
def replace_list(zXDh, PdyfJgP):
 zXDh[-1:] = PdyfJgP
 Ec_HpXab9 = zXDh
 return Ec_HpXab9
</ans>",0,{}
101,"<ans>
def count_charac(tDrUAkMiJ):
 _uXIOCGZ = 0
 for JkSzSy in tDrUAkMiJ:
    _uXIOCGZ = _uXIOCGZ + 1
 return _uXIOCGZ
</ans>",True,{}
102,"<ans>
import mF0rx7jqK  
def lXUNf(xv7jqqqw): 
    rKDaj9 = mF0rx7jqK.floor(mF0rx7jqK.sqrt(xv7jqqqw)) + 1
    return rKDaj9 * rKDaj9 
</ans>",True,{}
103,"<ans>
def max_sum(qome): 
	LINmIBT3p = qome[:] 
	for iJDzTmf in range(len(qome)): 
		for ejYQdbVz in range(0, iJDzTmf): 
			if qome[iJDzTmf] > qome[ejYQdbVz] and LINmIBT3p[iJDzTmf] < LINmIBT3p[ejYQdbVz] + qome[iJDzTmf]: 
				LINmIBT3p[iJDzTmf] = LINmIBT3p[ejYQdbVz] + qome[iJDzTmf] 
	ARiLMi = qome[:] 
	for iJDzTmf in range(1, len(qome) + 1): 
		for ejYQdbVz in range(1, iJDzTmf): 
			if qome[-iJDzTmf] > qome[-ejYQdbVz] and ARiLMi[-iJDzTmf] < ARiLMi[-ejYQdbVz] + qome[-iJDzTmf]: 
				ARiLMi[-iJDzTmf] = ARiLMi[-ejYQdbVz] + qome[-iJDzTmf] 
	IIe7p2yi = float(""-Inf"") 
	for iJDzTmf, ejYQdbVz, mQUzw in zip(LINmIBT3p, ARiLMi, qome): 
		IIe7p2yi = max(IIe7p2yi, iJDzTmf + ejYQdbVz - mQUzw) 
	return IIe7p2yi
</ans>",0,{}
104,"<ans>
def lps(lotTjwFI): 
	fG0tn = len(lotTjwFI) 
	DbsZZNLg = [[0 for xWCqNdd in range(fG0tn)] for xWCqNdd in range(fG0tn)] 
	for YukZi97O0 in range(fG0tn): 
		DbsZZNLg[YukZi97O0][YukZi97O0] = 1
	for h2B in range(2, fG0tn+1): 
		for YukZi97O0 in range(fG0tn-h2B+1): 
			LpVnGGzh = YukZi97O0+h2B-1
			if lotTjwFI[YukZi97O0] == lotTjwFI[LpVnGGzh] and h2B == 2: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = 2
			elif lotTjwFI[YukZi97O0] == lotTjwFI[LpVnGGzh]: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = DbsZZNLg[YukZi97O0+1][LpVnGGzh-1] + 2
			else: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = max(DbsZZNLg[YukZi97O0][LpVnGGzh-1], DbsZZNLg[YukZi97O0+1][LpVnGGzh]); 
	return DbsZZNLg[0][fG0tn-1]
</ans>",True,{}
105,"<ans>
def intersection_array(n08yQ7Hi, TLqUaThZm):
    KyQEINorc = list(filter(lambda x: x in n08yQ7Hi, TLqUaThZm)) 
    return KyQEINorc
</ans>",True,{}
106,"<ans>
def count_X(kQQ6JGo2, rXQAzr): 
    gQ11il = 0
    for bDWcFnz in kQQ6JGo2: 
        if (bDWcFnz == rXQAzr): 
            gQ11il = gQ11il + 1
    return gQ11il 
</ans>",True,{}
107,"<ans>
def insert_element(UI07v6pge, Vc2B1Cm9):
 UI07v6pge = [MGm2 for yHxmoxQ in UI07v6pge for MGm2 in (Vc2B1Cm9, yHxmoxQ)]
 return UI07v6pge
</ans>",True,{}
108,"<ans>
import cmath  
def convert(WXev5dD):    
  Nl5 = cmath.polar(WXev5dD)  
  return (Nl5) 
</ans>",True,{}
109,"<ans>
def count_integer(sEcL):
    e31Kzfz = 0
    for G1KPtzr5w in sEcL:
        if isinstance(G1KPtzr5w, int):
            e31Kzfz = e31Kzfz + 1
    return e31Kzfz
</ans>",True,{}
110,"<ans>
from itertools import combinations_with_replacement 
def combinations_colors(dJ863E, BtL):
    return list(combinations_with_replacement(dJ863E, BtL))
</ans>",True,{}
111,"<ans>
def count_Primes_nums(uYjMLJ2r):
    MYY = 0
    for xAzHYbKLh in range(uYjMLJ2r):
        if xAzHYbKLh <= 1:
            continue
        for KHa in range(2, xAzHYbKLh):
            if (xAzHYbKLh % KHa) == 0:
                break
        else:
            MYY += 1
    return MYY
</ans>",True,{}
112,"<ans>
def swap_numbers(vv7, WJcOx):
 eF5Of2I = vv7
 vv7 = WJcOx
 WJcOx = eF5Of2I
 return (vv7, WJcOx)
</ans>",True,{}
113,"<ans>
def maximize_elements(vG6ZIa, uxnj):
  jLgzu3G = tuple(tuple(max(_xv2qM, cTeXO) for _xv2qM, cTeXO in zip(_YqW, JsKYNf))
   for _YqW, JsKYNf in zip(vG6ZIa, uxnj))
  return (jLgzu3G) 
</ans>",True,{}
114,"<ans>
def AfisJ(Tk5): 
	if Tk5 == 0 or Tk5 == 1: 
		return 1
	return 2 * AfisJ(Tk5 - 1) + AfisJ(Tk5 - 2)
</ans>",True,{}
115,"<ans>
def division_elements(PqpngrUE, VGt):
  Z_n0IeJuv = tuple(HicC0 // ZVcbu for HicC0, ZVcbu in zip(PqpngrUE, VGt))
  return (Z_n0IeJuv) 
</ans>",True,{}
116,"<ans>
def split_two_parts(Vk4JcT, SQO3HBl):
    return Vk4JcT[:SQO3HBl], Vk4JcT[SQO3HBl:]
</ans>",True,{}
117,"<ans>
def dog_age(ohLi):
 if ohLi < 0:
 	exit()
 elif ohLi <= 2:
	 GhUrDmY = ohLi * 10.5
 else:
	 GhUrDmY = 21 + (ohLi - 2)*4
 return GhUrDmY
</ans>",True,{}
118,"<ans>
def list_split(x9D, NUwo7):
    return [x9D[aa_Fckq5::NUwo7] for aa_Fckq5 in range(NUwo7)]
</ans>",True,{}
119,"<ans>
def lateralsurface_cube(caoW4fH):
  lc8HmnCsp = 4 * (caoW4fH * caoW4fH)
  return lc8HmnCsp
</ans>",True,{}
120,"<ans>
def mMl(Gxuz8P):  
    return int(Gxuz8P*(4*Gxuz8P*Gxuz8P-1)/3) 
</ans>",True,{}
121,"<ans>
def BNExbFb(RNt9): 
	return (6 * RNt9 * (RNt9 - 1) + 1) 
</ans>",True,{}
122,"<ans>
def ascii_value(QOK):
  N82B0TLv = QOK
  return ord(N82B0TLv)
</ans>",True,{}
123,"<ans>
def sum_even_and_even_index(ePAmS):  
    ZF811MK = 0
    J8G2EMRV = 0
    for ZF811MK in range(0, XCMEk1r(ePAmS), 2): 
        if (ePAmS[ZF811MK] % 2 == 0) : 
            J8G2EMRV += ePAmS[ZF811MK]  
    return J8G2EMRV
</ans>",True,{}
124,"<ans>
def even_Power_Sum(_HtKWZzM): 
    qqtaMWc = 0; 
    for DD5woGCnS in range(1,_HtKWZzM+1): 
        vSOjy3 = 2*DD5woGCnS; 
        qqtaMWc = qqtaMWc + (vSOjy3*vSOjy3*vSOjy3*vSOjy3*vSOjy3); 
    return qqtaMWc; 
</ans>",True,{}
125,"<ans>
def rear_extract(dPhw3Y):
  qWI = [dtyauvtL[-1] for dtyauvtL in dPhw3Y]
  return (qWI) 
</ans>",True,{}
126,"<ans>
def substract_elements(_3dnTfvhQ, PeiXSs9AM):
  ob9PS = tuple(map(lambda lWXWGVKP, tsyA7: lWXWGVKP - tsyA7, _3dnTfvhQ, PeiXSs9AM))
  return (ob9PS) 
</ans>",True,{}
127,"<ans>
import DZ32e8m  
def pTzy( oMcNpO): 
    return (1 << (oMcNpO - 1)) 
</ans>",True,{}
128,"<ans>
def dict_filter(NjUt, U4xaTTRt):
    FkRjbx = {Jv3ZGF:MhLPs for (Jv3ZGF, MhLPs) in NjUt.items() if MhLPs >= U4xaTTRt}
    return FkRjbx
</ans>",True,{}
129,"<ans>
def count_first_elements(JQrBa1tWf):
  for FhGo3MVP, qBxYodgM in enumerate(JQrBa1tWf):
    if isinstance(qBxYodgM, tuple):
      break
  return (FhGo3MVP) 
</ans>",True,{}
130,"<ans>
def is_num_decagonal(GGkis7d): 
	return 4 * GGkis7d * GGkis7d - 3 * GGkis7d 
</ans>",True,{}
131,"<ans>
def sequential_search(naR, BUT):
    bedacIvvY = 0
    NaJ = False
    while bedacIvvY < len(naR) and not NaJ:
        if naR[bedacIvvY] == BUT:
            NaJ = True
        else:
            bedacIvvY = bedacIvvY + 1
    return NaJ, bedacIvvY
</ans>",True,{}
132,"<ans>
def all_unique(Emrs):
    if JHq4oln(Emrs) > JHq4oln(dp_JSC(Emrs)):
        return False
    return True
</ans>",True,{}
133,"<ans>
def sub_list(vuA, bKl):
  OfWlnol = map(lambda x, y: x - y, vuA, bKl)
  return list(OfWlnol)
</ans>",True,{}
134,"<ans>
def validate(ZgdYu): 
    for je1CjocV in range(10): 
        wdLfC = ZgdYu;  
        YoQl = 0; 
        while (wdLfC): 
            if (wdLfC % 10 == je1CjocV): 
                YoQl+=1;  
            if (YoQl > je1CjocV): 
                return False
            wdLfC //= 10; 
    return True
</ans>",True,{}
135,"<ans>
def check_element(dmd, Uhf8YZVo):
  TqHB3 = all(UcUq == Uhf8YZVo for UcUq in dmd)
  return TqHB3
</ans>",0,{}
136,"<ans>
import F4v6lMPhp
def text_match_two_three(muwwDW37Q):
        Ny3RyfB7p = 'ab{2,3}'
        if F4v6lMPhp.search(Ny3RyfB7p,  muwwDW37Q):
                return True
        else:
                return False
</ans>",True,{}
137,"<ans>
def max_sub_array_sum_repeated(XZB, It6_7, W1xAD): 
	wuz9E = -2147483648
	bxitktK = 0
	for JTUj in range(It6_7*W1xAD): 
		bxitktK = bxitktK + XZB[JTUj%It6_7] 
		if (wuz9E < bxitktK): 
			wuz9E = bxitktK 
		if (bxitktK < 0): 
			bxitktK = 0
	return wuz9E
</ans>",True,{}
138,"<ans>
def kf0N(DPOj):  
    return int(2*DPOj*(DPOj+1)*(2*DPOj+1)/3)
</ans>",True,{}
139,"<ans>
def max_length(pwPuk):
    EteBj = max(len(w4C6g2j) for w4C6g2j in pwPuk)  
    ueRlEIcc = max((w4C6g2j) for w4C6g2j in pwPuk)
    return(EteBj, ueRlEIcc)
</ans>",0,{}
140,"<ans>
def count_no_of_ways(mPwV9xG7, w22YGOZQx): 
	Phl8y = [0] * (mPwV9xG7 + 1) 
	r4N = w22YGOZQx 
	Zndp12tu = 1000000007
	Phl8y[1] = w22YGOZQx 
	Phl8y[2] = w22YGOZQx * w22YGOZQx	 
	for zpxXdo8 in range(3, mPwV9xG7 + 1): 
		Phl8y[zpxXdo8] = ((w22YGOZQx - 1) * (Phl8y[zpxXdo8 - 1] + Phl8y[zpxXdo8 - 2])) % Zndp12tu 
	return Phl8y[mPwV9xG7]
</ans>",True,{}
141,"<ans>
def find(SKamg, oxG4):  
    jkoet = SKamg // oxG4 
    return (jkoet)
</ans>",True,{}
142,"<ans>
import GG54IM5
def IYB33CLGE(G3wm, ZernoW):
  iXnb = GG54IM5.sqrt((G3wm * G3wm) + (ZernoW * ZernoW))
  return iXnb
</ans>",True,{}
143,"<ans>
def max_val(Fxld):
     xfNpRS3nf = max(PPmMvk for PPmMvk in Fxld if isinstance(PPmMvk, int)) 
     return(xfNpRS3nf)
</ans>",0,{}
144,"<ans>
def sum_div(S11QT7b):
    u4EJ = [1]
    for d2x in range(2, S11QT7b):
        if (S11QT7b % d2x)==0:
            u4EJ.append(d2x)
    return sum(u4EJ)
</ans>",True,{}
145,"<ans>
def get_Inv_Count(JwiFeG): 
    QV7KQ = 0
    for Mu4YK in range(len(JwiFeG)): 
        for EvA in range(Mu4YK + 1, len(JwiFeG)): 
            if (JwiFeG[Mu4YK] > JwiFeG[EvA]): 
                QV7KQ += 1
    return QV7KQ 
</ans>",True,{}
146,"<ans>
def flatten_list(eqeQP2ubl):
    ouq10 = []
    if not eqeQP2ubl: return ouq10
    t8FA8 = [list(eqeQP2ubl)]
    while t8FA8:
        skO = t8FA8.pop()
        dhBB7 = skO.pop()
        if skO: t8FA8.append(skO)
        if isinstance(dhBB7, list):
            if dhBB7: t8FA8.append(list(dhBB7))
        else: ouq10.append(dhBB7)
    ouq10.reverse()
    return ouq10
</ans>",True,{}
147,"<ans>
from collections import defaultdict
def KsMqRl(jwgzw):
    VKS3mz_ = nrwXPUK(int)
    for j1E_Sp, UOp in jwgzw:
        VKS3mz_[j1E_Sp] += UOp
    return max(VKS3mz_.items(), key=lambda Vec: Vec[1])
</ans>",0,{}
148,"<ans>
def YkKTFza(GEKESu6):
    if isinstance(GEKESu6, dict):
        return 1 + (max(JUJ1VC(YkKTFza, GEKESu6.LLxd)) if GEKESu6 else 0)
    return 0
</ans>",0,{}
149,"<ans>
def find_Element(Ux0wCpSPQ, t2fCW3w, kiC7, c9xKv_ZlK) :  
    for EaKo44 in range(kiC7 - 1,-1,-1 ) : 
        dCPkGnz = t2fCW3w[EaKo44][0] 
        huqikv = t2fCW3w[EaKo44][1] 
        if (dCPkGnz <= c9xKv_ZlK and huqikv >= c9xKv_ZlK) : 
            if (c9xKv_ZlK == dCPkGnz) : 
                c9xKv_ZlK = huqikv 
            else : 
                c9xKv_ZlK = c9xKv_ZlK - 1 
    return Ux0wCpSPQ[c9xKv_ZlK] 
</ans>",True,{}
150,"<ans>
import lZ6V
def HtoJTBD(GJtkHN):
 for tL1YnsR in GJtkHN:
        Ra0_ = lZ6V.match(""(P\w+)\W(P\w+)"", tL1YnsR)
        if Ra0_:
            return Ra0_.groups()
</ans>",0,{}
151,"<ans>
def max_sum_increasing_subseq(hByTP, VlN4CC0, Cx1ndfU, gIy):
	CzlE = [[0 for H2LcLm in range(VlN4CC0)] 
			for H2LcLm in range(VlN4CC0)]
	for H2LcLm in range(VlN4CC0):
		if hByTP[H2LcLm] > hByTP[0]:
			CzlE[0][H2LcLm] = hByTP[H2LcLm] + hByTP[0]
		else:
			CzlE[0][H2LcLm] = hByTP[H2LcLm]
	for H2LcLm in range(1, VlN4CC0):
		for CFys6wX in range(VlN4CC0):
			if hByTP[CFys6wX] > hByTP[H2LcLm] and CFys6wX > H2LcLm:
				if CzlE[H2LcLm - 1][H2LcLm] + hByTP[CFys6wX] > CzlE[H2LcLm - 1][CFys6wX]:
					CzlE[H2LcLm][CFys6wX] = CzlE[H2LcLm - 1][H2LcLm] + hByTP[CFys6wX]
				else:
					CzlE[H2LcLm][CFys6wX] = CzlE[H2LcLm - 1][CFys6wX]
			else:
				CzlE[H2LcLm][CFys6wX] = CzlE[H2LcLm - 1][CFys6wX]
	return CzlE[Cx1ndfU][gIy]
</ans>",True,{}
152,"<ans>
from copy import deepcopy
def colon_tuplex(ZQe, oC2uCv4, gydVDr7A):
  vGgkzI = l1Mrl4XbJ(ZQe)
  vGgkzI[oC2uCv4].append(gydVDr7A)
  return vGgkzI
</ans>",0,{}
153,"<ans>
def large_product(B44NV2EGj, jw_iN, oYZ_):
    DP4j = sorted([x*y for x in B44NV2EGj for y in jw_iN], reverse=True)[:oYZ_]
    return DP4j
</ans>",True,{}
154,"<ans>
def maximum(SgB, Djx):   
    if SgB >= Djx: 
        return SgB 
    else: 
        return Djx 
</ans>",True,{}
155,"<ans>
def string_to_tuple(u8rzayF):
    CtVTtPLy = tuple(WslgF for WslgF in u8rzayF if not WslgF.isspace()) 
    return CtVTtPLy
</ans>",True,{}
156,"<ans>
def set_left_most_unset_bit(CjDg): 
    if not (CjDg & (CjDg + 1)): 
        return CjDg 
    hIuu0F8, J7OvULuJ, ZDuFSz0 = 0, CjDg, 0 
    while J7OvULuJ: 
        if not (J7OvULuJ & 1): 
            hIuu0F8 = ZDuFSz0      
        ZDuFSz0 += 1; J7OvULuJ>>=1
    return (CjDg | (1 << (hIuu0F8))) 
</ans>",True,{}
157,"<ans>
def highest_Power_of_2(nkpIm2M): 
    dXu5 = 0 
    for WdvA8bw in range(nkpIm2M, 0, -1): 
        if ((WdvA8bw & (WdvA8bw - 1)) == 0): 
            dXu5 = WdvA8bw 
            break 
    return dXu5 
</ans>",True,{}
158,"<ans>
def AnY52s6ou(xMM4Q): 
	if (xMM4Q == 0): 
		return 2
	if (xMM4Q == 1): 
		return 1
	return AnY52s6ou(xMM4Q - 1) + AnY52s6ou(xMM4Q - 2) 
</ans>",True,{}
159,"<ans>
def add_string(SyQXla, P599wM):
 XN15ooe0N=[P599wM.format(ynT3s) for ynT3s in  SyQXla]
 return XN15ooe0N
</ans>",0,{}
160,"<ans>
def convert_list_dictionary(BaZ, fZA8j, IYU):
     lWvjyBuI3 = [{SH_r88nm: {k_Ik: hCLH}} for (SH_r88nm, k_Ik, hCLH) in zip(BaZ, fZA8j, IYU)]
     return lWvjyBuI3
</ans>",True,{}
161,"<ans>
def get_max_sum (Bi2v):
	YUSRuMi = list()
	YUSRuMi.append(0)
	YUSRuMi.append(1)
	wXl = 2
	while wXl < Bi2v + 1:
		YUSRuMi.append(max(wXl, (YUSRuMi[int(wXl / 2)] 
						+ YUSRuMi[int(wXl / 3)] +
							YUSRuMi[int(wXl / 4)]
						+ YUSRuMi[int(wXl / 5)])))
		wXl = wXl + 1
	return YUSRuMi[Bi2v]
</ans>",True,{}
162,"<ans>
def max_length_list(pSFL):
    c7PfiI = max(len(KjnxTi) for KjnxTi in pSFL )   
    Vw_ey = max(pSFL, key = lambda bHD4mU: len(bHD4mU))    
    return(c7PfiI, Vw_ey)
</ans>",True,{}
163,"<ans>
def check_distinct(nS6Z):
  USt = True
  r0H = set()
  for eZg0 in nS6Z:
    if eZg0 in r0H:
      USt = False
      break
    r0H.add(eZg0)
  return USt 
</ans>",True,{}
164,"<ans>
def first_non_repeating_character(X2h3zvgCT):
  HTPEQrj = []
  xPw7Wy = {}
  for Bx9J7n in X2h3zvgCT:
    if Bx9J7n in xPw7Wy:
      xPw7Wy[Bx9J7n] += 1
    else:
      xPw7Wy[Bx9J7n] = 1 
      HTPEQrj.append(Bx9J7n)
  for Bx9J7n in HTPEQrj:
    if xPw7Wy[Bx9J7n] == 1:
      return Bx9J7n
  return None
</ans>",True,{}
165,"<ans>
import re  
pQz = r'^[a-z]$|^([a-z]).*\1$'
def check_char(YNCKgd): 
	if(ejpp.search(pQz, YNCKgd)): 
		return ""Valid"" 
	else: 
		return ""Invalid"" 
</ans>",0,{}
166,"<ans>
def median_numbers(_00H, cB2, rAi3pSXQx):
 if _00H > cB2:
    if _00H < rAi3pSXQx:
        XvLVdG = _00H
    elif cB2 > rAi3pSXQx:
        XvLVdG = cB2
    else:
        XvLVdG = rAi3pSXQx
 else:
    if _00H > rAi3pSXQx:
        XvLVdG = _00H
    elif cB2 < rAi3pSXQx:
        XvLVdG = cB2
    else:
        XvLVdG = rAi3pSXQx
 return XvLVdG
</ans>",True,{}
167,"<ans>
def sum_of_digits(iS6HxL):
    return sum(int(wh1) for pOOhB8jZb in iS6HxL for wh1 in str(pOOhB8jZb) if wh1.isdigit())
</ans>",True,{}
168,"<ans>
def bitwise_xor(ijsbE, bEeWY__L):
  fEIMGg = tuple(I2RT ^ PMI8Ap for I2RT, PMI8Ap in zip(ijsbE, bEeWY__L))
  return (fEIMGg) 
</ans>",True,{}
169,"<ans>
def extract_freq(yE1UuCh):
  nLN = len(list(set(tuple(sorted(Sxggwg46m)) for Sxggwg46m in yE1UuCh)))
  return (nLN)
</ans>",True,{}
170,"<ans>
def add_nested_tuples(SPL, aGB):
  ftFN = tuple(tuple(KBJ + zOcQM for KBJ, zOcQM in zip(r6N, Cor63u))
   for r6N, Cor63u in zip(SPL, aGB))
  return (ftFN) 
</ans>",True,{}
171,"<ans>
def minimum(ECIdrGlVT, DsLLlu):   
    if ECIdrGlVT <= DsLLlu: 
        return ECIdrGlVT 
    else: 
        return DsLLlu 
</ans>",True,{}
172,"<ans>
def check_tuplex(QzW9QSA, JMzEWOot): 
  if JMzEWOot in QzW9QSA:
    return True
  else:
     return False
</ans>",True,{}
173,"<ans>
def find_Parity(h0xq21tY_): 
    tigGiD2 = h0xq21tY_ ^ (h0xq21tY_ >> 1); 
    tigGiD2 = tigGiD2 ^ (tigGiD2 >> 2); 
    tigGiD2 = tigGiD2 ^ (tigGiD2 >> 4); 
    tigGiD2 = tigGiD2 ^ (tigGiD2 >> 8); 
    tigGiD2 = tigGiD2 ^ (tigGiD2 >> 16); 
    if (tigGiD2 & 1): 
        return True
    return False
</ans>",True,{}
174,"<ans>
def rearrange_bigger(CEU):
    uIxiT_a = list(str(CEU))
    for mXrNZeY in range(len(uIxiT_a)-2,-1,-1):
        if uIxiT_a[mXrNZeY] < uIxiT_a[mXrNZeY+1]:
            saPrU9 = uIxiT_a[mXrNZeY:]
            SbKzhgR = min(filter(lambda x: x > saPrU9[0], saPrU9))
            saPrU9.remove(SbKzhgR)
            saPrU9.sort()
            uIxiT_a[mXrNZeY:] = [SbKzhgR] + saPrU9
            return int("""".join(uIxiT_a))
    return False
</ans>",True,{}
175,"<ans>
import heapq as MNOSS
def CfNFHvL(RcmkdNhZc, JHt, YmkIjo3nf):
   w5S1KBr = []
   def isKZpe2(qd7bBN9, EBB1Z):
       if qd7bBN9 < len(RcmkdNhZc) and EBB1Z < len(JHt):
           MNOSS.heappush(w5S1KBr, [RcmkdNhZc[qd7bBN9] + JHt[EBB1Z], qd7bBN9, EBB1Z])
   isKZpe2(0, 0)
   lnX = []
   while w5S1KBr and len(lnX) < YmkIjo3nf:
       c7O_0WB9, qd7bBN9, EBB1Z = MNOSS.heappop(w5S1KBr)
       lnX.append([RcmkdNhZc[qd7bBN9], JHt[EBB1Z]])
       isKZpe2(qd7bBN9, EBB1Z + 1)
       if EBB1Z == 0:
           isKZpe2(qd7bBN9 + 1, 0)
   return lnX
</ans>",0,{}
176,"<ans>
def min_product_tuple(Aw8wG6jlY):
    oZ8d = min([abs(e3Cu0 * oqjS) for e3Cu0, oqjS in Aw8wG6jlY] )
    return oZ8d
</ans>",True,{}
177,"<ans>
def min_val(HygERU57):
     NaEtqXYSs = min(ZiSO for ZiSO in HygERU57 if isinstance(ZiSO, int))
     return NaEtqXYSs
</ans>",0,{}
178,"<ans>
import QcYXyD
def snake_to_camel(bio2FPg):
  return ''.join(SNBmH.capitalize() or '_' for SNBmH in gppFK)
</ans>",0,{}
179,"<ans>
def remove_odd(lFw):
    for P8MO5NBz in lFw:
        if P8MO5NBz % 2 != 0:
            lFw.remove(P8MO5NBz)
    return lFw
</ans>",True,{}
180,"<ans>
def extract_nth_element(A1WbOz8, jBidsyNBO):
    mMr = [MBqG1X[jBidsyNBO] for MBqG1X in A1WbOz8]
    return mMr
</ans>",True,{}
181,"<ans>
def overlapping(uY8, JTIY):  
    for R5RbJ in range(len(uY8)): 
        for U6gXxDqW in range(len(JTIY)): 
            if(uY8[R5RbJ] == JTIY[U6gXxDqW]): 
                return True
    return False
</ans>",True,{}
182,"<ans>
def max_Product(siZ): 
    AT_ = len(siZ) 
    if (AT_ < 2): 
        return (""No pairs exists"")           
    bELUiX = siZ[0]; J_zFZ1XoG = siZ[1]      
    for yZd in range(0,AT_): 
        for MfpRc5 in range(yZd + 1,AT_): 
            if (siZ[yZd] * siZ[MfpRc5] > bELUiX * J_zFZ1XoG): 
                bELUiX = siZ[yZd]; J_zFZ1XoG = siZ[MfpRc5] 
    return bELUiX,J_zFZ1XoG    
</ans>",True,{}
183,"<ans>
def group_tuples(fsNcwX): 
	ee0 = {} 
	for Ltw in fsNcwX: 
		try: 
			ee0[Ltw[0]].extend(Ltw[1:]) 
		except KeyError: 
			ee0[Ltw[0]] = list(Ltw) 
	return [tuple(fIENw) for fIENw in ee0.values()] 
</ans>",True,{}
184,"<ans>
def Find_Max(u2Xk4Ow4H): 
    uMop = max((XSnt9t1I) for XSnt9t1I in u2Xk4Ow4H) 
    return uMop
</ans>",True,{}
185,"<ans>
def round_and_sum(TtLaQ):
  q3QYoj = len(TtLaQ)
  kfqz = sum(list(map(round, TtLaQ)) * q3QYoj)
  return kfqz
</ans>",0,{}
186,"<ans>
def cube_Sum(ik0J): 
    Neuy6Tnkc = 0
    for nzYhS5 in range(1, ik0J + 1): 
        Neuy6Tnkc += (2*nzYhS5)*(2*nzYhS5)*(2*nzYhS5) 
    return Neuy6Tnkc
</ans>",True,{}
187,"<ans>
def concatenate_tuple(XoUOs):
    YPCvfee = ""-""
    ohHDT0JDa = ''.join([str(kDBIhma) + YPCvfee for kDBIhma in XoUOs])
    ohHDT0JDa = ohHDT0JDa[ : len(ohHDT0JDa) - len(YPCvfee)]
    return (str(ohHDT0JDa)) 
</ans>",True,{}
188,"<ans>
def find_Average_Of_Cube(tnHM):  
    tq6wr = 0
    for db3aO in range(1, tnHM + 1): 
        tq6wr += db3aO * db3aO * db3aO  
    return round(tq6wr / tnHM, 6) 
</ans>",True,{}
189,"<ans>
def extract_rear(CcneuCQth):
  R3hm = list(mO5[len(mO5) - 1] for mO5 in CcneuCQth)
  return (R3hm) 
</ans>",True,{}
190,"<ans>
def count_element_in_list(NMR4, bC_UbJo1): 
    l1I86a = 0
    for ieb3 in range(len(NMR4)): 
        if bC_UbJo1 in NMR4[ieb3]: 
            l1I86a += 1          
    return l1I86a
</ans>",True,{}
191,"<ans>
def filter_oddnumbers(u6Kf):
 IqmzaIr = list(filter(lambda qIy3z: qIy3z%2 != 0, u6Kf))
 return IqmzaIr
</ans>",True,{}
192,"<ans>
import re as HIDrflW
def change_date_format(Kzi5Nn):
        return HIDrflW.sub(r'(\d{4})-(\d{1,2})-(\d{1,2})', '\\3-\\2-\\1', Kzi5Nn)
</ans>",0,{}
193,"<ans>
def shell_sort(bHd2ujo):
    zc4AU = len(bHd2ujo) // 2
    while zc4AU > 0:
        for LE1G4YeZS in range(zc4AU, len(bHd2ujo)):
            iJA = bHd2ujo[LE1G4YeZS]
            yIrLcnm = LE1G4YeZS
            while yIrLcnm >= zc4AU and bHd2ujo[yIrLcnm - zc4AU] > iJA:
                bHd2ujo[yIrLcnm] = bHd2ujo[yIrLcnm - zc4AU]
                yIrLcnm -= zc4AU
            bHd2ujo[yIrLcnm] = iJA
        zc4AU //= 2

    return bHd2ujo
</ans>",True,{}
194,"<ans>
def and_tuples(Ty9t6, b7KrmIH):
  I4kofnEk = tuple(Q1z & ajZg1 for Q1z, ajZg1 in zip(Ty9t6, b7KrmIH))
  return (I4kofnEk) 
</ans>",True,{}
195,"<ans>
def parabola_directrix(TLB, l80nKD, Q7g_3Qz3o): 
  ivG=((int)(Q7g_3Qz3o - ((l80nKD * l80nKD) + 1) * 4 * TLB ))
  return ivG
</ans>",True,{}
196,"<ans>
def common_element(FGQxB0, Lp28Cq8zw):
     ZKoy5N = False
     for glR3MOZwe in FGQxB0:
         for A4L in Lp28Cq8zw:
             if glR3MOZwe == A4L:
                 ZKoy5N = True
                 return ZKoy5N
</ans>",True,{}
197,"<ans>
def median_trapezium(d_WD5h, PW88oDwG, vRc):
    LHXN2 = 0.5 * (d_WD5h + PW88oDwG)
    return LHXN2
</ans>",True,{}
198,"<ans>
def check_greater(iKkBR, TCUpF):
  iKkBR.sort()
  return TCUpF > iKkBR[-1]
</ans>",True,{}
199,"<ans>
import re
def text_match_one(yb9Gqhsq):
        Kfu = 'ab+?'
        if re.search(Kfu,  yb9Gqhsq):
                return True
        else:
                return False
</ans>",True,{}
200,"<ans>
def last_Digit(GQlosVfk) :
    return (GQlosVfk % 10) 
</ans>",True,{}
201,"<ans>
def neg_nos(xzO0X9):
  ZREQQ2 = []
  for gKFKf7Qcd in xzO0X9: 
    if gKFKf7Qcd < 0: 
      ZREQQ2.append(gKFKf7Qcd)
  return ZREQQ2 
</ans>",True,{}
202,"<ans>
def remove_odd(rcr):
 lIENT = ''
 for vbD3vp29 in range(1, len(rcr) + 1):
    if(vbD3vp29 % 2 == 0):
        lIENT = lIENT + rcr[vbD3vp29 - 1]
 return lIENT
</ans>",True,{}
203,"<ans>
def count_bidirectional(wV26):
  dbCGmzjl = 0
  for fzcl in range(0, len(wV26)):
    for aDI0N in range(fzcl + 1, len(wV26)):
      if wV26[aDI0N][0] == wV26[fzcl][1] and wV26[fzcl][1] == wV26[aDI0N][0]:
        dbCGmzjl += 1
  return dbCGmzjl
</ans>",True,{}
204,"<ans>
def multiple_to_single(kc1Bo07):
  RH_9C = int("""".join(map(str, kc1Bo07)))
  return RH_9C
</ans>",True,{}
205,"<ans>
import cM1T
def find_adverb_position(AzGBrC):
 for K7bfE in cM1T.finditer(r""\w+ly"", AzGBrC):
    return (K7bfE.start(), K7bfE.end(), K7bfE.group(0))
</ans>",True,{}
206,"<ans>
def VEs9w7(UVAk5Bk1I):
  XGUGNlr = 6 * UVAk5Bk1I * UVAk5Bk1I
  return XGUGNlr
</ans>",True,{}
207,"<ans>
```
from array import D3zJyspw
def IZ4TTHo(b2Qeq):
    ykqXZLqF = len(b2Qeq)
    k0E = 0
    for ojh in b2Qeq:
        if ojh > 0:
            k0E += 1
        else:
          None
    return round(k0E/ykqXZLqF,2)
```
</ans>",0,{}
208,"<ans>
def largest_neg(dlegDJ): 
    PDYbdrdH = dlegDJ[0] 
    for VPnwMC in dlegDJ: 
        if VPnwMC < PDYbdrdH : 
             PDYbdrdH = VPnwMC  
    return PDYbdrdH
</ans>",True,{}
209,"<ans>
def trim_tuple(v5u, y7Pysfo0U):
  JwBBT5 = []
  for VBLrlj2d in v5u:
    w9yeO = len(VBLrlj2d)
    JwBBT5.append(tuple(list(VBLrlj2d)[y7Pysfo0U: w9yeO - y7Pysfo0U]))
  return (str(JwBBT5)) 
</ans>",True,{}
210,"<ans>
def index_multiplication(Y_uK5_l, WU61):
  hInE8Tow = tuple(tuple(H6OTkXn * k2ViP for H6OTkXn, k2ViP in zip(BFwTXc, ebxpjn6))
   for BFwTXc, ebxpjn6 in zip(Y_uK5_l, WU61))
  return (hInE8Tow) 
</ans>",True,{}
211,"<ans>
from collections import Counter 
def count_Occurrence(CGLrBM, v7E5vfLNd): 
    i62JVE8lf = 0
    for ebl in CGLrBM: 
        if ebl in v7E5vfLNd: 
            i62JVE8lf += 1 
    return i62JVE8lf  
</ans>",True,{}
212,"<ans>
def cube_nums(mUDzT):
 GrS_36R = list(map(lambda Jy3gT: Jy3gT ** 3, mUDzT))
 return GrS_36R
</ans>",0,{}
213,"<ans>
def cal_sum(DpeUUu): 
	RMbO = 3
	yOdswXQ3 = 0
	SNC = 2
	if (DpeUUu == 0): 
		return 3
	if (DpeUUu == 1): 
		return 3
	if (DpeUUu == 2): 
		return 5
	YzS8WUdL = 5
	while (DpeUUu > 2): 
		LaWIu = RMbO + yOdswXQ3 
		YzS8WUdL = YzS8WUdL + LaWIu 
		RMbO = yOdswXQ3 
		yOdswXQ3 = SNC 
		SNC = LaWIu 
		DpeUUu = DpeUUu-1
	return YzS8WUdL
</ans>",True,{}
214,"<ans>
def extract_string(RC2RSPgBz, h2K4ba67):
    JMAW_wlzV = [j78 for j78 in RC2RSPgBz if len(j78) == h2K4ba67] 
    return JMAW_wlzV
</ans>",True,{}
215,"<ans>
import sHSNA0PkY
def remove_whitespaces(EUsLZ_M):
  return (sHSNA0PkY.sub(r'\s+', '',EUsLZ_M))
</ans>",True,{}
216,"<ans>
def loss_amount(VRcX4, I8LA6j): 
  if(I8LA6j > VRcX4):
    kDzK7 = I8LA6j - VRcX4
    return kDzK7
  else:
    return 0
</ans>",True,{}
217,"<ans>
import math 
def sumofFactors(QiG5PfM) : 
    if (QiG5PfM % 2 != 0) : 
        return 0
    NzqzFUc = 1
    for OVsk1O7ry in range(2, (int)(math.sqrt(QiG5PfM)) + 1) :    
        hq9a_ = 0
        Q7Y = 1
        gD8jDpYpc = 1
        while (QiG5PfM % OVsk1O7ry == 0) : 
            hq9a_= hq9a_ + 1
            QiG5PfM = QiG5PfM // OVsk1O7ry 
            if (OVsk1O7ry == 2 and hq9a_ == 1) : 
                Q7Y = 0
            gD8jDpYpc = gD8jDpYpc * OVsk1O7ry 
            Q7Y = Q7Y + gD8jDpYpc 
        NzqzFUc = NzqzFUc * Q7Y  
    if (QiG5PfM >= 2) : 
        NzqzFUc = NzqzFUc * (1 + QiG5PfM) 
    return NzqzFUc
</ans>",True,{}
218,"<ans>
def check_monthnumb_number(fg07):
  if(fg07==1 or fg07==3 or fg07==5 or fg07==7 or fg07==8 or fg07==10 or fg07==12):
    return UcL
  else:
    return hcqAj0wh
</ans>",True,{}
219,"<ans>
def reverse_string_list(Z6y):
    NN0okIKF4 = [kw1Mz0GYZ[::-1] for kw1Mz0GYZ in Z6y]
    return NN0okIKF4
</ans>",True,{}
220,"<ans>
def Find_Min(QkuH2e7): 
    return ZWd9aZKt(QkuH2e7, key=Cfa) 
</ans>",True,{}
221,"<ans>
def rectangle_area(QdVrJtL7N, YqDyhZ9Po):
  PQXiG = QdVrJtL7N * YqDyhZ9Po
  return PQXiG
</ans>",True,{}
222,"<ans>
import V8bx3TC
def remove_uppercase(BZR):
  return V8bx3TC.sub('[A-Z]', '', BZR)
</ans>",True,{}
223,"<ans>
def Extract(rhxq): 
    return [_nv7NjJo8[0] for _nv7NjJo8 in rhxq] 
</ans>",True,{}
224,"<ans>
def upper_ctr(aoT1EwP):
    AQvB = 0
    for ChqdHsT in range(len(aoT1EwP)):
          if aoT1EwP[ChqdHsT] >= 'A' and aoT1EwP[ChqdHsT] <= 'Z': AQvB += 1
          return AQvB
</ans>",0,{}
225,"<ans>
def combinations_list(um_no1V):
    if len(um_no1V) == 0:
        return [[]]
    ywq3 = []
    for FXG in combinations_list(um_no1V[1:]):
        ywq3 += [FXG, FXG+[um_no1V[0]]]
    return ywq3
</ans>",True,{}
226,"<ans>
def max_subarray_product(BWEf):
	Z1rgogB = len(BWEf)
	jhQC0H = 1
	Znknrx1T = 1
	wVqKW = 0
	boq7 = 0
	for XMIbvb in range(0, Z1rgogB):
		if BWEf[XMIbvb] > 0:
			jhQC0H = jhQC0H * BWEf[XMIbvb]
			Znknrx1T = min (Znknrx1T * BWEf[XMIbvb], 1)
			boq7 = 1
		elif BWEf[XMIbvb] == 0:
			jhQC0H = 1
			Znknrx1T = 1
		else:
			ZlSmqP6oe = jhQC0H
			jhQC0H = max (Znknrx1T * BWEf[XMIbvb], 1)
			Znknrx1T = ZlSmqP6oe * BWEf[XMIbvb]
		if (wVqKW < jhQC0H):
			wVqKW = jhQC0H
	if boq7 == 0 and wVqKW == 0:
		return 0
	return wVqKW
</ans>",True,{}
227,"<ans>
def check_value(SxSxW0, mg9a7zvKv):
    YAvLYSq8 = all(WNrXwN == mg9a7zvKv for WNrXwN in SxSxW0.values()) 
    return YAvLYSq8
</ans>",True,{}
228,"<ans>
def drop_empty(Z72):
  Z72 = {oNE4wX:TbgMH for (oNE4wX, TbgMH) in Z72.items() if TbgMH is not None}
  return Z72
</ans>",True,{}
229,"<ans>
def max_product(kNW):   
  X4IC = len(kNW)
  sBzNaezjU = kNW[:]
  for n16EQ7z in range(X4IC): 
    gA6YP6 = kNW[n16EQ7z]
    TQFn = n16EQ7z + 1
    while TQFn < X4IC:
      if kNW[TQFn-1] > kNW[TQFn]: 
        break
      gA6YP6 *= kNW[TQFn]
      if gA6YP6 > sBzNaezjU[TQFn]:
        sBzNaezjU[TQFn] = gA6YP6 
      TQFn = TQFn + 1
  return max(sBzNaezjU)
</ans>",True,{}
230,"<ans>
def add_pairwise(t9JXc3ts):
  iq0PGtEiB = tuple(Hunrc + G63Ks for Hunrc, G63Ks in zip(t9JXc3ts, t9JXc3ts[1:]))
  return (iq0PGtEiB) 
</ans>",True,{}
231,"<ans>
def find_remainder(tqksqZ, jqy4R): 
    Q14FUk = 1
    for cfLn_7 in range(len(tqksqZ)):  
        Q14FUk = (Q14FUk * (tqksqZ[cfLn_7] % jqy4R)) % jqy4R 
    return Q14FUk % jqy4R 
</ans>",True,{}
232,"<ans>
def check_Consecutive(dHVtc): 
    return Yg9NOS(dHVmc) == list(range(i6awp(dHVmc), wHB8TpH(dHVmc)+1)) 
</ans>",0,{}
233,"<ans>
def tuple_intersection(cvb, Cbk5Z4Vr):
  QN1n2YBsO = set([tuple(sorted(ccFy)) for ccFy in cvb]) & set([tuple(sorted(ccFy)) for ccFy in Cbk5Z4Vr])
  return (QN1n2YBsO)
</ans>",True,{}
234,"<ans>
def replace_char(IR6QhysB6, ovA, KFMnLGR):
 vYO = IR6QhysB6.replace(ovA, KFMnLGR)
 return vYO
</ans>",True,{}
235,"<ans>
from collections import PlX8pH
def sort_counter(F3eZOARzn):
 Xascq = PlX8pH(F3eZOARzn)
 flNqWCSBt = Xascq.most_common()
 return flNqWCSBt
</ans>",0,{}
236,"<ans>
def big_sum(tYd):
      l0qJni = RzJ(tYd) + KGt(tYd)
      return l0qJni
</ans>",True,{}
237,"<ans>
def is_lower(Uyv):
  return (Uyv.lower())
</ans>",True,{}
238,"<ans>
import re as qkM
def remove_lowercase(melXSRKP):
 return qkM.sub('[a-z]', '', melXSRKP)
</ans>",0,{}
239,"<ans>
def RbQaHA(HKUbo6) :  
    while HKUbo6 >= 10:  
        HKUbo6 = HKUbo6 / 10 
    return int(HKUbo6) 
</ans>",True,{}
240,"<ans>
'''input
9 4 8
6 8 5 1 8 1 1 2 1
9 2
8 4
5 3
9 7
'''
from sys import stdin
import math
from copy import deepcopy
from collections import defaultdict


def process_offer(ZpYlHW4Aq):
	hReKe4E7RE = []
	for i in ZpYlHW4Aq:
		CqUgTxe3 = ZpYlHW4Aq[i]
		CqUgTxe3.sort()
		hReKe4E7RE.append([i, CqUgTxe3[-1]])

	hReKe4E7RE = sorted(hReKe4E7RE, key = lambda x: x[0])
	return hReKe4E7RE


def make(first, second):
	return str(first) + ' ' + str(second)


def brute(Gl8Q, pMHyZZnX5, ZpYlHW4Aq, index, remain):
	#print(index, remain)
	# base case:
	if remain == 0:
		return 0

	if make(index, remain) in pMHyZZnX5:
		return pMHyZZnX5[make(index, remain)]

	Vz9nE = Gl8Q[index] + brute(Gl8Q, pMHyZZnX5, ZpYlHW4Aq, index + 1, remain - 1)
	#print(Vz9nE)
	for i in range(len(ZpYlHW4Aq)):
		uTiL7mgaz = 0
		if ZpYlHW4Aq[i][0] <= remain:
			QKgB = ZpYlHW4Aq[i][1]
			for  j in range(index + QKgB, index + ZpYlHW4Aq[i][0]):
				uTiL7mgaz += Gl8Q[j]
			uTiL7mgaz += brute(Gl8Q, pMHyZZnX5, ZpYlHW4Aq, index + ZpYlHW4Aq[i][0], remain - ZpYlHW4Aq[i][0])
			Vz9nE = min(Vz9nE, uTiL7mgaz)
		else:
			break
	pMHyZZnX5[make(index, remain)] = Vz9nE
	return Vz9nE",0,{}
241,"<ans>
def PrimeDecomp(N,ConcFlag):
    if ConcFlag:
        if N<=1:
            return [1],1
        else:
            Hxci4z = 2
            Jwi3HDHmUB = []
            y7cSNFQ = 1
            while Hxci4z*Hxci4z<=N:
                CrrU = 0
                while N%Hxci4z==0:
                    N //= Hxci4z
                    Jwi3HDHmUB.append(Hxci4z)
                y7cSNFQ *= (CrrU+1)
                Hxci4z += 1
            if N>=2:
                Jwi3HDHmUB.append(N)
                y7cSNFQ *= 2
            return Jwi3HDHmUB,y7cSNFQ        
    else:
        if N<=1:
            return [1],[1],1
        else:
            Hxci4z = 2
            Jwi3HDHmUB = []
            EDlf = []
            y7cSNFQ = 1
            while Hxci4z*Hxci4z<=N:
                CrrU = 0
                while N%Hxci4z==0:
                    N //= Hxci4z
                    CrrU += 1
                if CrrU>=1:
                    Jwi3HDHmUB.append(Hxci4z)
                    EDlf.append(CrrU)
                    y7cSNFQ *= (CrrU+1)
                Hxci4z += 1
            if N>=2:
                Jwi3HDHmUB.append(N)
                EDlf.append(1)
                y7cSNFQ *= 2
            return Jwi3HDHmUB,EDlf,y7cSNFQ

def DivisorFactorial(N,FactDec,FactCnt,MemoFlag,Mod,ModFlag):
    if MemoFlag:
        if N<=1:
            upXIm = 1
            return FactDec,FactCnt,upXIm
        else:
            Jwi3HDHmUB,EDlf,_ = PrimeDecomp(N,False)
            for TP in range(0,len(Jwi3HDHmUB)):
                if Jwi3HDHmUB[TP] in set(FactDec):
                    FactCnt[FactDec.index(Jwi3HDHmUB[TP])] += EDlf[TP]
                else:
                    FactDec.append(Jwi3HDHmUB[TP])
                    FactCnt.append(EDlf[TP])
            upXIm = 1
            for TF in FactCnt:
                upXIm = [upXIm*(TF+1),(upXIm*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,upXIm
    else:
        if N<=1:
            upXIm = 1
            return FactDec,FactCnt,upXIm
        else:
            for TN in range(2,N+1): 
                Jwi3HDHmUB,EDlf,_ = PrimeDecomp(TN,False)
                for TP in range(0,len(Jwi3HDHmUB)):
                    if Jwi3HDHmUB[TP] in set(FactDec):
                        FactCnt[FactDec.index(Jwi3HDHmUB[TP])] += EDlf[TP]
                    else:
                        FactDec.append(Jwi3HDHmUB[TP])
                        FactCnt.append(EDlf[TP])
            upXIm = 1
            for TF in FactCnt:
                upXIm = [upXIm*(TF+1),(upXIm*(TF+1))%Mod][ModFlag]
            return FactDec,FactCnt,upXIm
FactDec,FactCnt,upXIm = DivisorFactorial(int(input()),[],[],False,10**9+7,True)
print(upXIm)
</ans>",True,{}
242,"<ans>
from math import sqrt,gcd


def gen_primes():
    """""" Generate an infinite sequence of prime numbers.
    """"""
    #
    lTPiuhg2Ok = {}

    # The running integer that's checked for primeness
    QkotpGl77Z = 2

    while True:
        if QkotpGl77Z not in lTPiuhg2Ok:
            # QkotpGl77Z is a new prime.
            # Yield it and mark its first multiple that isn't
            # already marked in previous iterations
            #
            yield QkotpGl77Z
            lTPiuhg2Ok[QkotpGl77Z * QkotpGl77Z] = [QkotpGl77Z]
        else:
            # QkotpGl77Z is composite. lTPiuhg2Ok[QkotpGl77Z] is the list of primes that
            # divide it. Since we've reached QkotpGl77Z, we no longer
            # need it in the map, but we'll mark the next
            # multiples of its witnesses to prepare for larger
            # numbers
            #
            for p in lTPiuhg2Ok[QkotpGl77Z]:
                lTPiuhg2Ok.setdefault(p + QkotpGl77Z, []).append(p)
            del lTPiuhg2Ok[QkotpGl77Z]

        QkotpGl77Z += 1


def is_prime(j4sh4QLO):
    if j4sh4QLO<=1:
        return False
    if j4sh4QLO == 2:
        return True
    if j4sh4QLO % 2 ==0:
        return False
    return all(j4sh4QLO%i for i in range(3,int(sqrt(j4sh4QLO))+1))


def calculate_colors(j4sh4QLO):
    LGRM4 = gen_primes()
    Zz_ = int(sqrt(j4sh4QLO)) + 1
    if j4sh4QLO == 1:
        return 1
    for p in LGRM4:
        if j4sh4QLO % p == 0:
            while j4sh4QLO % p == 0:
                esjMvtg= gcd(p,j4sh4QLO)
                j4sh4QLO = int(j4sh4QLO//esjMvtg)
            if j4sh4QLO > 1:
                return 1
            else:
                return p
        if p > Zz_:
            return j4sh4QLO",0,{}
243,"<ans>
```python
import numpy as np
YPxATBMpdj = 998244353

def poly_mul(f, g):
    # 参考: https://judge.yosupo.jp/submission/2380
    Mli = len(f); H5BECT5 = len(g); V7c5 = Mli + H5BECT5 - 1
    if Mli <= 16 or H5BECT5 <= 16:
        if Mli == 0 or H5BECT5 == 0:
            return np.zeros((0,), dtype=np.int64)
        return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % YPxATBMpdj).astype(np.int64)
    Ic3 = np.fft.rfft; NU52 = np.fft.irfft
    ajtECEB = 1 << V7c5.bit_length()
    IM4Jupn5 = f & (1 << 15) - 1; Sk7wMb20sI = f >> 15
    hmyYu49Gh = g & (1 << 15) - 1; PHG = g >> 15
    llBIKfKF = (NU52(Ic3(IM4Jupn5, ajtECEB) * Ic3(hmyYu49Gh, ajtECEB))[:V7c5] + 0.5).astype(np.int64) % YPxATBMpdj
    ioga = (NU52(Ic3(IM4Jupn5+Sk7wMb20sI, ajtECEB) * Ic3(hmyYu49Gh+PHG, ajtECEB))[:V7c5] + 0.5).astype(np.int64) % YPxATBMpdj
    P7sD = (NU52(Ic3(Sk7wMb20sI, ajtECEB) * Ic3(PHG, ajtECEB))[:V7c5] + 0.5).astype(np.int64) % YPxATBMpdj
    return (llBIKfKF + ((ioga - llBIKfKF - P7sD) << 15) + (P7sD << 30)) % YPxATBMpdj

def poly_inv(fps, sjE0jx=None):
    assert fps[0] != 0
    if sjE0jx is None:
        sjE0jx = len(fps)
    WIXmbD8D = np.zeros(1<<(sjE0jx-1).bit_length(), dtype=np.int64)
    WIXmbD8D[0] = pow(int(fps[0]), YPxATBMpdj-2, YPxATBMpdj)
    mHvNr00fNr = 1
    while mHvNr00fNr < sjE0jx:
        mHvNr00fNr <<= 1
        WIXmbD8D[:mHvNr00fNr] = ((WIXmbD8D[:mHvNr00fNr]<<1) - poly_mul(poly_mul(WIXmbD8D[:mHvNr00fNr>>1], WIXmbD8D[:mHvNr00fNr>>1]), fps[:mHvNr00fNr])[:mHvNr00fNr]) % YPxATBMpdj
    return WIXmbD8D[:sjE0jx]

def poly_div(fps1, fps2):
    sjE0jx1, sjE0jx2 = len(fps1), len(fps2)
    if sjE0jx1 < sjE0jx2:
        return np.zeros((0,), dtype=np.int64)
    sjE0jx = sjE0jx1 - sjE0jx2 + 1
    WIXmbD8D = poly_mul(fps1[-1:-sjE0jx-1:-1], poly_inv(fps2[::-1], sjE0jx))[sjE0jx-1::-1]
    return WIXmbD8D

def poly_mod(fps1, fps2):
    sjE0jx1, sjE0jx2 = len(fps1), len(fps2)
    if sjE0jx1 < sjE0jx2:
        return fps1
    WIXmbD8D = fps1[:sjE0jx2-1] - poly_mul(poly_div(fps1, fps2), fps2)[:sjE0jx2-1]
    return WIXmbD8D % YPxATBMpdj

def multipoint_evaluation(fps, z_U):
    IwZG = 8
    zS8aU2Ekbl = len(z_U)
    jP_l_N3td = (zS8aU2Ekbl-1).bit_length()
    if jP_l_N3td <= IwZG:
        WIXmbD8D = np.zeros_like(z_U)
        bSSPGNud7t = np.ones_like(z_U)
        for coef in fps:
            WIXmbD8D += bSSPGNud7t * coef
            bSSPGNud7t *= z_U
            bSSPGNud7t %= YPxATBMpdj
        return WIXmbD8D
    mKzx = 1<<jP_l_N3td
    Nyfmcwfb = np.zeros((jP_l_N3td+1, mKzx+1), dtype=fps.dtype)
    Nyfmcwfb[0, :zS8aU2Ekbl] = -z_U % YPxATBMpdj
    Nyfmcwfb[1, :mKzx:2] = Nyfmcwfb[0, :mKzx:2] * Nyfmcwfb[0, 1::2] % YPxATBMpdj
    Nyfmcwfb[1, 1::2] = (Nyfmcwfb[0, :mKzx:2] + Nyfmcwfb[0, 1::2]) % YPxATBMpdj
    for mHvNr00fNr in range(1, jP_l_N3td):
        FEDU2NG = 2<<mHvNr00fNr
        mdRtZZW = FEDU2NG>>1
        for j in range(0, mKzx, FEDU2NG):
            zGXV = Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW+1].copy()
            YoMtv = Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:j+FEDU2NG+1].copy()
            zGXV[-1] = YoMtv[-1] = 1
            KUna5AYV1n = poly_mul(zGXV, YoMtv)
            Nyfmcwfb[mHvNr00fNr+1, j:j+FEDU2NG] = KUna5AYV1n[:-1]
    KUna5AYV1n = poly_mod(fps, KUna5AYV1n)
    Nyfmcwfb[-1, :len(KUna5AYV1n)] = KUna5AYV1n
    Nyfmcwfb[-1, len(KUna5AYV1n):] = 0
    for mHvNr00fNr in range(jP_l_N3td-1, IwZG-1, -1):
        FEDU2NG = 2<<mHvNr00fNr
        mdRtZZW = FEDU2NG>>1
        for j in range(0, mKzx, FEDU2NG):
            KUna5AYV1n = Nyfmcwfb[mHvNr00fNr+1, j:j+FEDU2NG]
            zGXV = Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW+1].copy()
            YoMtv = Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:j+FEDU2NG+1].copy()
            zGXV[-1] = YoMtv[-1] = 1
            Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW] = poly_mod(KUna5AYV1n, zGXV)
            Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:j+FEDU2NG] = poly_mod(KUna5AYV1n, YoMtv)
    z_U = (-Nyfmcwfb[0, :mKzx] % YPxATBMpdj).reshape(-1, 1<<IwZG)
    bSSPGNud7t = np.ones_like(z_U)
    WIXmbD8D = np.zeros_like(z_U)
    for mHvNr00fNr in range(1<<IwZG):
        WIXmbD8D += Nyfmcwfb[IwZG, mHvNr00fNr:mKzx:1<<IwZG, None] * bSSPGNud7t % YPxATBMpdj
        bSSPGNud7t *= z_U
        bSSPGNud7t %= YPxATBMpdj
    return WIXmbD8D.reshape(-1)[:zS8aU2Ekbl] % YPxATBMpdj

def poly_differential(fps):
    return fps[1:] * np.arange(1, len(fps)) % YPxATBMpdj

def lagrange_interpolation(WRLV4VeK, Y, YPxATBMpdj):
    # old
    sjE0jx = len(WRLV4VeK)
    wC2oN9CJc2 = [0]*(sjE0jx+1)
    wC2oN9CJc2[0] = 1
    for mHvNr00fNr, x in enumerate(WRLV4VeK):
        for j in range(mHvNr00fNr, -1, -1):
            wC2oN9CJc2[j+1] += wC2oN9CJc2[j] * (-x) % YPxATBMpdj
    WIXmbD8D = [0]*sjE0jx
    for x, y in zip(WRLV4VeK, Y):
        KUna5AYV1n = wC2oN9CJc2[:]
        Lo1aJt_3 = 0
        FkzNb = 1
        Udv_f3d = [1]  # x の idx 乗
        for _ in range(sjE0jx-1):
            FkzNb = FkzNb * x % YPxATBMpdj
            Udv_f3d.append(FkzNb)
        Udv_f3d.reverse()  # n-1 乗 ~ 0 乗
        for mHvNr00fNr, po in enumerate(Udv_f3d):
            MUVEHZ7X = KUna5AYV1n[mHvNr00fNr]
            KUna5AYV1n[mHvNr00fNr+1] += MUVEHZ7X * x % YPxATBMpdj  # f = g / (x - x_i) を組立除法で求める
            Lo1aJt_3 = (Lo1aJt_3 + MUVEHZ7X * po) % YPxATBMpdj
        F0urA = pow(Lo1aJt_3, YPxATBMpdj-2, YPxATBMpdj)
        for mHvNr00fNr, MUVEHZ7X in enumerate(KUna5AYV1n[:sjE0jx]):
            WIXmbD8D[mHvNr00fNr] += (MUVEHZ7X * y * F0urA)# % YPxATBMpdj  # mod が大きいと 64bit に収まらなくなるのでひとつずつ mod 取った方がいいか？
    return [v % YPxATBMpdj for v in WIXmbD8D]

def polynomial_interpolation(z_U, ys):
    # 参考: https://rsk0315.hatenablog.com/entry/2020/04/05/203210
    assert len(z_U) == len(ys)
    IwZG = 8
    xtCkkue = np.lib.stride_tricks.as_strided
    sjE0jx = len(z_U)
    if sjE0jx==1:
        return ys.copy()
    jP_l_N3td = (sjE0jx-1).bit_length()
    if jP_l_N3td <= IwZG:
        WIXmbD8D = lagrange_interpolation(z_U.tolist(), ys.tolist(), YPxATBMpdj)
        return np.array(WIXmbD8D[::-1], dtype=np.int64)
    mKzx = 1<<jP_l_N3td
    Nyfmcwfb = np.zeros((jP_l_N3td+1, sjE0jx+1), dtype=np.int64)
    Nyfmcwfb[0, :sjE0jx] = -z_U % YPxATBMpdj
    for mHvNr00fNr in range(jP_l_N3td):
        FEDU2NG = 2 << mHvNr00fNr
        mdRtZZW = FEDU2NG >> 1
        for j in range(0, sjE0jx, FEDU2NG):
            if j+mdRtZZW >= sjE0jx:
                Nyfmcwfb[mHvNr00fNr+1, j:sjE0jx] = Nyfmcwfb[mHvNr00fNr, j:sjE0jx]
                continue
            zGXV = Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW+1].copy()
            YoMtv = Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:j+FEDU2NG+1].copy()
            zGXV[-1] = YoMtv[-1] = 1
            KUna5AYV1n = poly_mul(zGXV, YoMtv)
            Nyfmcwfb[mHvNr00fNr+1, j:j+len(KUna5AYV1n)-1] = KUna5AYV1n[:-1]
    AH6 = np.zeros((jP_l_N3td+1, mKzx+1), dtype=np.int64)
    AH6[jP_l_N3td, :sjE0jx] = poly_differential(KUna5AYV1n)
    for mHvNr00fNr in range(jP_l_N3td-1, IwZG-1, -1):
        FEDU2NG = 2<<mHvNr00fNr
        mdRtZZW = FEDU2NG>>1
        for j in range(0, sjE0jx, FEDU2NG):
            if j+mdRtZZW >= sjE0jx:
                AH6[mHvNr00fNr, j:sjE0jx] = AH6[mHvNr00fNr+1, j:sjE0jx]
                continue
            KUna5AYV1n = AH6[mHvNr00fNr+1, j:min(j+FEDU2NG, sjE0jx)]
            zGXV = Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW+1].copy()
            YoMtv = Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:min(j+FEDU2NG, sjE0jx)+1].copy()
            zGXV[-1] = YoMtv[-1] = 1
            AH6[mHvNr00fNr, j:j+mdRtZZW] = poly_mod(KUna5AYV1n, zGXV)
            AH6[mHvNr00fNr, j+mdRtZZW:min(j+FEDU2NG, sjE0jx)] = poly_mod(KUna5AYV1n, YoMtv)
    z_U = xtCkkue(z_U, (mKzx>>IwZG, 1<<IwZG), (8<<IwZG, 8))
    bSSPGNud7t = np.ones_like(z_U)
    KUna5AYV1n = np.zeros_like(z_U)
    for mHvNr00fNr in range(1<<IwZG):
        KUna5AYV1n += AH6[IwZG, mHvNr00fNr:mKzx:1<<IwZG, None] * bSSPGNud7t % YPxATBMpdj
        bSSPGNud7t *= z_U
        bSSPGNud7t %= YPxATBMpdj
    KUna5AYV1n = KUna5AYV1n.ravel()
    for j in range(sjE0jx):
        AH6[0, j] = ys[j] * pow(int(KUna5AYV1n[j]), YPxATBMpdj-2, YPxATBMpdj) % YPxATBMpdj
    for mHvNr00fNr in range(jP_l_N3td):
        FEDU2NG = 2 << mHvNr00fNr
        mdRtZZW = FEDU2NG >> 1
        for j in range(0, mKzx, FEDU2NG):
            if j+mdRtZZW >= sjE0jx:
                AH6[mHvNr00fNr+1, j:sjE0jx] = AH6[mHvNr00fNr, j:sjE0jx]
                continue
            zGXV = Nyfmcwfb[mHvNr00fNr, j:j+mdRtZZW+1].copy()
            YoMtv = Nyfmcwfb[mHvNr00fNr, j+mdRtZZW:j+FEDU2NG+1",0,{}
244,"<ans>
import math
from collections import defaultdict
import sys
#input = sys.stdin.readline


def main():
    n, m = list(map(int, input().split()))
    hVk7f = list(map(int, input().split()))
    tjpN = [(0, 0)] * m
    for i in range(m):
        a, b = list(map(int, input().split()))
        tjpN[i] = (b, a)

    def check(days):
        Hjnxj = {}
        for sale in tjpN:
            if sale[1] <= days:
                if sale[0] not in Hjnxj or sale[1] > Hjnxj[sale[0]]:
                    Hjnxj[sale[0]] = sale[1]

        bjbnsxe = {}
        for t, d in list(Hjnxj.items()):
            if d not in bjbnsxe:
                bjbnsxe[d] = [t]
            else:
                bjbnsxe[d].append(t)

        gSLJ = 0
        L6a9LD2j6 = [0] + hVk7f.copy()

        EkfjK = 0
        for d in range(1, days+1):
            gSLJ += 1
            if d in bjbnsxe:
                for t in bjbnsxe[d]:
                    if L6a9LD2j6[t] > 0:
                        if L6a9LD2j6[t] > gSLJ:
                            EkfjK += L6a9LD2j6[t] - gSLJ
                        gSLJ -= min(L6a9LD2j6[t], gSLJ)
                        L6a9LD2j6[t] = 0
            if d == days:  # last day
                for r in L6a9LD2j6:
                    if r > 0:
                        EkfjK += r

        return 2*EkfjK <= gSLJ

    LP5 = sum(hVk7f)
    yfyMP4AMA = 2*LP5
    oai = 1

    while oai + 1 < yfyMP4AMA:
        WvPwI1 = (oai + yfyMP4AMA) // 2
        if check(WvPwI1):
            yfyMP4AMA = WvPwI1
        else:
            oai = WvPwI1

    if check(oai):
        print(oai)
    else:
        print(yfyMP4AMA)


def __starting_point():
    main()

__starting_point()
</ans>",True,{}
245,"<ans>
import sys
from collections import deque
import heapq
BiLk = sys.stdin.readline

e1j7=int(BiLk())
q31JKUtX=[list(map(int,BiLk().split())) for l6ln in range(e1j7-1)]

ouoj=[[] for l6ln in range(e1j7+1)]

for l6ln,j in q31JKUtX:
    ouoj[l6ln].append(j)
    ouoj[j].append(l6ln)

#EDGES=[[] for i in range(N+1)]
QeHW=[None for l6ln in range(e1j7+1)]
ldQuOCeFQf=deque([1])
L5I=[0]*(e1j7+1)
UkA=[None]*(e1j7+1)
l6ln=0
while ldQuOCeFQf:
    aoQ2H=deque()
    l6ln+=1
    
    while ldQuOCeFQf:
        NttcgYd=ldQuOCeFQf.pop()
        UkA[NttcgYd]=l6ln
        L5I[NttcgYd]=1
        for to in ouoj[NttcgYd]:
            if L5I[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                QeHW[to]=NttcgYd
                aoQ2H.append(to)
    ldQuOCeFQf=aoQ2H


L5I=[0]*(e1j7+1)
L5I[1]=1
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


L5gqjRs=[]
for l6ln in range(2,e1j7+1):
    if len(ouoj[l6ln])==1:
        L5gqjRs.append((-UkA[l6ln],l6ln))

ldQuOCeFQf=L5gqjRs
heapq.heapify(ldQuOCeFQf)
Wbr=0

#print(check,QUE)

while ldQuOCeFQf:
    dep,NttcgYd=heapq.heappop(ldQuOCeFQf)
    if L5I[NttcgYd]!=0 or dep>=-3:
        continue

    if L5I[QeHW[NttcgYd]]==2:
        continue

    if L5I[NttcgYd]==0:
        L5I[NttcgYd]=1
    if L5I[QeHW[QeHW[NttcgYd]]]==0:
        L5I[QeHW[QeHW[NttcgYd]]]=1
    L5I[QeHW[NttcgYd]]=2   
    heapq.heappush(ldQuOCeFQf,(-UkA[QeHW[QeHW[QeHW[NttcgYd]]]],QeHW[QeHW[QeHW[NttcgYd]]]))
    Wbr+=1

    #print(x,QUE,check)

print(Wbr)
</ans>",0,{}
246,"<ans>
class UnionFindVerSize():
    def __init__(self, ZoCcy8YP):
        self._parent = [n for n in range(0, ZoCcy8YP)]
        self._size = [1] * ZoCcy8YP

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        return self._parent[x]

    def unite(self, x, y):
        j9f9kd_9 = self.find_root(x)
        EMSzSWJ1M6 = self.find_root(y)
        if j9f9kd_9 == EMSzSWJ1M6: return

        if self._size[j9f9kd_9] < self._size[EMSzSWJ1M6]:
            self._parent[j9f9kd_9] = EMSzSWJ1M6
            self._size[EMSzSWJ1M6] += self._size[j9f9kd_9]
        else:
            self._parent[EMSzSWJ1M6] = j9f9kd_9
            self._size[j9f9kd_9] += self._size[EMSzSWJ1M6]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

    def calc_group_num(self):
        ZoCcy8YP = len(self._parent)
        eRdsboT = 0
        for i in range(ZoCcy8YP):
            if self.find_root(i) == i:
                eRdsboT += 1
        return eRdsboT

import sys

i0O=sys.stdin.readline

n,m=list(map(int,i0O().split()))
VXf6Nizl5n=list(map(int,i0O().split()))
VXf6Nizl5n=[VXf6Nizl5n[i]-1 for i in range(n)]
GgELiNUIIO=[]
for i in range(m-1):
    a,b=list(map(int,i0O().split()))
    GgELiNUIIO.append((a-1,b-1))

H2ySvkD=[[] for i in range(m)]
for i in range(n):
    LTbRrbXjG=VXf6Nizl5n[i]
    if not H2ySvkD[LTbRrbXjG]:
        H2ySvkD[LTbRrbXjG].append((i+1,i+1))
    else:
        x0XgI_Us,OM970k=H2ySvkD[LTbRrbXjG].pop()
        if OM970k+1==i+1:
            H2ySvkD[LTbRrbXjG].append((x0XgI_Us,i+1))
        else:
            H2ySvkD[LTbRrbXjG].append((x0XgI_Us,OM970k))
            H2ySvkD[LTbRrbXjG].append((i+1,i+1))

#print(H2ySvkD)
R7PHJE=[]
for i in range(m):
    for x0XgI_Us,OM970k in H2ySvkD[i]:
        if OM970k!=n:
            R7PHJE.append((VXf6Nizl5n[x0XgI_Us-1],VXf6Nizl5n[OM970k]))

#print(R7PHJE)
x0XgI_Us=[-1]*len(R7PHJE)
OM970k=[m-1]*len(R7PHJE)
XnFgr44yi=[[] for i in range(m)]
for i in range(len(R7PHJE)):
    fPmnYa=(OM970k[i]+x0XgI_Us[i])//2
    XnFgr44yi[fPmnYa].append(i)


def parabisect():
    JCnAT=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=GgELiNUIIO[i]
        JCnAT.unite(a,b)
        while XnFgr44yi[i]:
            qj0sU=XnFgr44yi[i].pop()
            LTbRrbXjG1,LTbRrbXjG2=R7PHJE[qj0sU]
            if JCnAT.is_same_group(LTbRrbXjG1,LTbRrbXjG2):
                OM970k[qj0sU]=i
            else:
                x0XgI_Us[qj0sU]=i
            if OM970k[qj0sU]-x0XgI_Us[qj0sU]>1:
                fPmnYa=(OM970k[qj0sU]+x0XgI_Us[qj0sU])//2
                XnFgr44yi[fPmnYa].append(qj0sU)

for i in range(20):
    parabisect()

a9kY=[0]*m
for i in range(len(R7PHJE)):
    a9kY[OM970k[i]+1]-=1

for i in range(1,m):
    a9kY[i]+=a9kY[i-1]

for i in range(m):
    print(len(R7PHJE)+a9kY[i])
</ans>",0,{}
247,"<ans>
# from collections import deque
import io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # 神奇快读，无法运行调试
import os
import sys
from io import BytesIO, IOBase

qsDLCxk = 8192


class FastIO(IOBase):
    jBq4QwFU = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            F63w = os.read(self._fd, max(os.fstat(self._fd).st_size, qsDLCxk))
            if not F63w:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(F63w), self.buffer.seek(ptr)
        self.jBq4QwFU = 0
        return self.buffer.read()

    def readline(self):
        while self.jBq4QwFU == 0:
            F63w = os.read(self._fd, max(os.fstat(self._fd).st_size, qsDLCxk))
            self.jBq4QwFU = F63w.count(b""\n"") + (not F63w)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(F63w), self.buffer.seek(ptr)
        self.jBq4QwFU -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")


n, m = map(int, input().split())
# ddk = {}
YtUGM = {
    # chr(97+i):0 for i in range(26)

}
OcBOnsqto = [None for i in range(n*m)]

for i in range(n):
    dEcWiepMw = int(input())
    # tmp = []
    for j in range(m):
        # tmp.append(input())
        BJwP8sG = input()
        OcBOnsqto[dEcWiepMw*m+j] = BJwP8sG
        if len(YtUGM)==26:continue
        for q in BJwP8sG:
            YtUGM.setdefault(q, 0)
    # ddk[dEcWiepMw] = tmp
# OcBOnsqto = []
# for i in range(n):
#     for j in ddk[i]:
#         OcBOnsqto.append(j)

ddk = {}


# f = OcBOnsqto[0][0]

def ae(u, v):
    dEcWiepMw = ddk.setdefault(u, set())
    if v not in dEcWiepMw:
        dEcWiepMw.add(v)
        YtUGM[v] = YtUGM.get(v, 0) + 1


for p, i in enumerate(OcBOnsqto[1:]):
    for j in range(min(len(OcBOnsqto[p]), len(i))):
        if OcBOnsqto[p][j] != i[j]:
            # if len(OcBOnsqto[p])-1 != j:
                # ae(OcBOnsqto[p][j],i[j])
            ae(i[j], OcBOnsqto[p][j])
            break
        if len(i)-1==j and len(OcBOnsqto[p])-1 > j:
            print(""IMPOSSIBLE"")
            return


KjiPHHbDo9 = []
Zohtc = []
# Zohtc = deque()
B9qae5S = 0


DRnPH = {}

for k, v in YtUGM.items():
    if v == 0:
        Zohtc.append(k)
    else:
        DRnPH[k] = v


# if ctr>1:
    # print(""IMPOSSIBLE"")
    # return

YtUGM = DRnPH


while B9qae5S != len(Zohtc):
    f_6Do = Zohtc[B9qae5S]
    KjiPHHbDo9.append(f_6Do)

    for i in ddk.get(f_6Do, []):
        YtUGM[i] -= 1
        if YtUGM[i] == 0:
            Zohtc.append(i)
            YtUGM.pop(i)

    # if ctr>1:
        # print(""IMPOSSIBLE"")
        # return
    B9qae5S += 1

if len(YtUGM):
    print(""IMPOSSIBLE"")
    return

print(*reversed(KjiPHHbDo9), sep='')
</ans>",0,{}
248,"<ans>
import sys
import math
import itertools
import functools
import collections


def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    M5hAjuvdC = [True for _ in range(n + 1)]
    qmjZu6DYj = 3
    while qmjZu6DYj * qmjZu6DYj <= n:
        if M5hAjuvdC[qmjZu6DYj]:
            for i in range(qmjZu6DYj * 2, n + 1, qmjZu6DYj):
                M5hAjuvdC[i] = False
        qmjZu6DYj += 2
    pHLc_ = [2]
    for qmjZu6DYj in range(3, n + 1, 2):
        if M5hAjuvdC[qmjZu6DYj]:
            pHLc_.append(qmjZu6DYj)
    return pHLc_
def divs(n, start=1):
    pHLc_ = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                pHLc_.append(i)
            else:
                pHLc_.extend([i, n // i])
    return pHLc_
def divn(n, primes):
    bvlgqEHkXF = 1
    for i in primes:
        if n == 1:
            return bvlgqEHkXF
        Ed3FjCNlu = 1
        while n % i == 0:
            Ed3FjCNlu += 1
            n //= i
        bvlgqEHkXF *= Ed3FjCNlu
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    mxre3 = int(math.sqrt(n)) + 1
    for d in range(3, mxre3, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    e2RwAX0 = 0
    while number > 0:
        e2RwAX0 += number % base
        number //= base
    return e2RwAX0
def cdiv(n, k): return n // k + (n % k != 0)


Ed3FjCNlu = ii()
for _ in range(Ed3FjCNlu):
    pHLc_, g, b = sorted(mi())
    if b > pHLc_ + g + 1:
        print('No')
    else:
        print('Yes')
</ans>",0,{}
249,"<ans>
#!/usr/bin/env python
# 560B_art.py - Codeforces.com 560B Art program
#
# Copyright (C) 2015 Sergey

""""""
Gerald asks whether it is possible to place the paintings on the board,
or is the board he bought not large enough?
Input

The first line contains two space-separated numbers a1 and b1 the sides
of the board. Next two lines contain numbers a2 b2 a3 and b3 the sides
of the paintings. All numbers ai,?bi in the input are integers and fit into
the range from 1 to 1000.

Output

If the paintings can be placed on the wall, print ""YES"" (without the quotes),
and if they cannot, print ""NO"" (without the quotes).
""""""

# Standard modules
import unittest
import sys

# Additional modules


###############################################################################
# Art Class
###############################################################################


class Art:
    """""" Art representation """"""

    def __init__(self, jkbEiH):
        """""" Default constructor """"""

        self.vmHE8, self.yQg0Zx = jkbEiH

        self.r = self.rect(self.vmHE8[0], self.yQg0Zx[0])
        self.rmax = self.rect(self.vmHE8[1], self.yQg0Zx[1])
        self.rmin = self.rect(self.vmHE8[2], self.yQg0Zx[2])
        if self.rmax[0] < self.rmax[1]:
            self.rmax, self.rmin = self.rmin, self.rmax

        self.remain = []
        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))
        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))

        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))
        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))

    def rect(self, a, b):
        if a > b:
            return (a, b)
        else:
            return (b, a)

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        for rec in self.remain:
            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:
                return ""YES""
            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:
                return ""YES""
        return ""NO""


###############################################################################
# Helping classes
###############################################################################


###############################################################################
# Art Class testing wrapper code
###############################################################################


def get_inputs(xSW=None):

    hb0Ja = iter(xSW.split(""\n"")) if xSW else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if hb0Ja:
            return next(hb0Ja)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    yZfMHStk = 3
    nyWWFS26bU = list(map(int, "" "".join(uinput() for i in range(yZfMHStk)).split()))

    # Splitting nyWWFS26bU into n arrays
    vmHE8 = []
    yQg0Zx = []
    for i in range(0, 2*yZfMHStk, 2):
        vmHE8.append(nyWWFS26bU[i])
        yQg0Zx.append(nyWWFS26bU[i+1])

    # Decoding inputs into a list
    return [vmHE8, yQg0Zx]


def calculate(xSW=None):
    """""" Base class calculate method wrapper """"""
    return Art(get_inputs(xSW)).calculate()


###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_Art_class__basic_functions(self):
        """""" Art class basic functions testing """"""

        # Constructor test
        KV1 = Art([[3, 1, 2], [2, 3, 1]])
        self.assertEqual(KV1.vmHE8[0], 3)

        self.assertEqual(KV1.r, (3, 2))
        self.assertEqual(KV1.rmax, (3, 1))
        self.assertEqual(KV1.rmin, (2, 1))

        self.assertEqual(KV1.remain, [(3, 1)])

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        xSW = ""3 2\n1 3\n2 1""
        self.assertEqual(calculate(xSW), ""YES"")
        self.assertEqual(list(get_inputs(xSW)[0]), [3, 1, 2])
        self.assertEqual(list(get_inputs(xSW)[1]), [2, 3, 1])

        # Sample test 2
        xSW = ""5 5\n3 3\n3 3""
        self.assertEqual(calculate(xSW), ""NO"")

        # Sample test 3
        xSW = ""4 2\n2 3\n1 2""
        self.assertEqual(calculate(xSW), ""YES"")

        # My test 4
        xSW = ""5 5\n1 5\n1 5""
        self.assertEqual(calculate(xSW), ""YES"")

    def test_time_limit_test(self):
        """""" Quiz time limit test """"""

        import random

        # Time limit test
        xSW = ""1000 1000""
        xSW += ""\n900 900""
        xSW += ""\n50 50""

        import timeit

        lw0pSEA0 = timeit.default_timer()
        jkbEiH = get_inputs(xSW)

        vhLXv6Kop = timeit.default_timer()
        KV1 = Art(jkbEiH)

        tAkUIdme = timeit.default_timer()
        KV1.calculate()

        iWzNdkFR25 = timeit.default_timer()
        print((
            ""\nTime Test: "" +
            ""{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)"".
            format(iWzNdkFR25-lw0pSEA0, vhLXv6Kop-lw0pSEA0, tAkUIdme-vhLXv6Kop, iWzNdkFR25-tAkUIdme)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(calculate())

__starting_point()
</ans>",0,{}
250,"<ans>
import sys
from collections import defaultdict
 
class BIT():
    def __init__(self, IOAO6VSk):
        self.IOAO6VSk = IOAO6VSk
        self.tree = [0] * IOAO6VSk
    
    def _get_sum(self, r):
        '''
        sum on interval [0, r)
        '''
        gcj6u = 0
        while r > 0:
            gcj6u += self.tree[r-1]
            r &= (r - 1)
        return gcj6u
    
    def get_sum(self, l, r):
        '''
        sum on interval [l, r)
        '''
        return self._get_sum(r) - self._get_sum(l)
    
    def add(self, i, value=1):
        while i < self.IOAO6VSk:
            self.tree[i] += value
            i |= (i + 1)

VtKxSjUzr = (line.rstrip() for line in sys.stdin)
sZGh6ILJtl = VtKxSjUzr.__next__

IOAO6VSk = int(sZGh6ILJtl())
uPL = []
for _ in range(IOAO6VSk):
    i, j = list(map(int, sZGh6ILJtl().split()))
    uPL.append(i)
    uPL.append(j)

bzax = defaultdict(list)
for i, val in enumerate(uPL):
    bzax[val].append(i)

sG7Ux8 = 0
IAF7ssh = -1
iRsbU = [0] * (2*IOAO6VSk)
KP75EX = {}
for val in sorted(uPL):
    if IAF7ssh == val: continue
    for j in bzax[val]:
        iRsbU[j] = sG7Ux8
    KP75EX[sG7Ux8] = val
    sG7Ux8 += 1
    IAF7ssh = val

FDLKkz = list(range(sG7Ux8))
for t in range(IOAO6VSk):
    i, j = iRsbU[t<<1], iRsbU[t<<1|1]
    FDLKkz[i], FDLKkz[j] = FDLKkz[j], FDLKkz[i]

mVRH = BIT(sG7Ux8)
N2bGG = 0
for i, val in enumerate(FDLKkz):
    N2bGG += mVRH.get_sum(val+1, sG7Ux8)
    if i != val:
        N2bGG += abs(KP75EX[val] - KP75EX[i]) - abs(val - i)
    mVRH.add(val)
print(N2bGG)
</ans>",0,{}
251,"<ans>
from math import sqrt

ivoV81wjq = 1e-9

def mysqrt(x):
    if x <= 0:
        return 0
    return sqrt(x)

def good(rjaW1ziKQQ):
    nonlocal puWJdA9r
    nonlocal Lsl
    nonlocal DECEeudv
    
    VSK6fm = -10**20
    LzWA = 10**20
    
    for i in range(DECEeudv):
        # (x - wsa1k7)**2 + (y - ei7K6zgZ3)**2 = rjaW1ziKQQ**2
        # y = rjaW1ziKQQ
        wsa1k7 = puWJdA9r[i]
        ei7K6zgZ3 = abs(Lsl[i])
        
        a1J97 = 2 * rjaW1ziKQQ * ei7K6zgZ3 - ei7K6zgZ3**2
        
        if a1J97 + ivoV81wjq < 0:
            return False
        
        eKwbyNea = mysqrt(a1J97)
        
        agK = wsa1k7 - eKwbyNea
        GWc = wsa1k7 + eKwbyNea
        
        VSK6fm = max(VSK6fm, agK)
        LzWA = min(LzWA, GWc)
        
        if VSK6fm + ivoV81wjq > LzWA:
            return False
    
    return True
        

def solve(wUgqTaA0d, HE61uxI, md):
    rjaW1ziKQQ = 0
    for _ in range(150):
        rjaW1ziKQQ = md(wUgqTaA0d, HE61uxI)
        
        if good(rjaW1ziKQQ):
            HE61uxI = rjaW1ziKQQ
        else:
            wUgqTaA0d = rjaW1ziKQQ
        
    return rjaW1ziKQQ

DECEeudv = int(input())

puWJdA9r = [0.0 for _ in range(DECEeudv)]
Lsl = [0.0 for _ in range(DECEeudv)]

for i in range(DECEeudv):
    puWJdA9r[i], Lsl[i] = list(map(float, input().split()))
    if i > 0:
        if Lsl[i] * Lsl[0] < 0:
            print(-1)
            return

rjaW1ziKQQ = None
if good(1):
    rjaW1ziKQQ = solve(0, 1, lambda x, y: (x + y) / 2)
else:
    rjaW1ziKQQ = solve(1, 1e16, lambda x, y: sqrt(x * y))

print('{:.16}'.format(rjaW1ziKQQ))
</ans>",True,{}
252,"<ans>
def bin_pow(Za4WcVZK, LtZRSHskm , bvwhb):
    if LtZRSHskm == 0:
        return 1
    if LtZRSHskm == 1:
        return Za4WcVZK % bvwhb

    if LtZRSHskm % 2 == 0:
        w5je_ = bin_pow(Za4WcVZK, LtZRSHskm // 2, bvwhb)
        return (w5je_ * w5je_) % bvwhb
    
    return (Za4WcVZK * bin_pow(Za4WcVZK , LtZRSHskm - 1, bvwhb)) % bvwhb",0,{}
253,"<ans>
import bisect


class BTreeNode:
    def __init__(self):
        self.key = []
        self.child = []


class BTree:
    def __init__(self):
        self.root = BTreeNode()

    def search_higher(self, key):
        Uu3k5W_I5K = self.root
        DR7Gm9Qi = None
        while Uu3k5W_I5K.child:
            W2m7r3W8p = bisect.bisect_right(Uu3k5W_I5K.key, key)
            if W2m7r3W8p != len(Uu3k5W_I5K.key):
                DR7Gm9Qi = Uu3k5W_I5K.key[W2m7r3W8p]
            Uu3k5W_I5K = Uu3k5W_I5K.child[W2m7r3W8p]
        W2m7r3W8p = bisect.bisect_right(Uu3k5W_I5K.key, key)
        if W2m7r3W8p != len(Uu3k5W_I5K.key):
            DR7Gm9Qi = Uu3k5W_I5K.key[W2m7r3W8p]
        return DR7Gm9Qi

    def search_lower(self, key):
        Uu3k5W_I5K = self.root
        DR7Gm9Qi = None
        while Uu3k5W_I5K.child:
            W2m7r3W8p = bisect.bisect_left(Uu3k5W_I5K.key, key)
            if W2m7r3W8p != 0:
                DR7Gm9Qi = Uu3k5W_I5K.key[W2m7r3W8p - 1]
            Uu3k5W_I5K = Uu3k5W_I5K.child[W2m7r3W8p]
        W2m7r3W8p = bisect.bisect_left(Uu3k5W_I5K.key, key)
        if W2m7r3W8p != 0:
            DR7Gm9Qi = Uu3k5W_I5K.key[W2m7r3W8p - 1]
        return DR7Gm9Qi

    def insert(self, key):
        def insert_rec(Uu3k5W_I5K):
            mQIQrK = 10
            if not Uu3k5W_I5K.child:
                bisect.insort(Uu3k5W_I5K.key, key)
                if len(Uu3k5W_I5K.key) == mQIQrK * 2 - 1:
                        DR7Gm9Qi = BTreeNode()
                        DR7Gm9Qi.key = Uu3k5W_I5K.key[:mQIQrK]
                        Uu3k5W_I5K.key = Uu3k5W_I5K.key[mQIQrK:]
                        return DR7Gm9Qi
            else:
                W2m7r3W8p = bisect.bisect(Uu3k5W_I5K.key, key)
                VFjbO_z = insert_rec(Uu3k5W_I5K.child[W2m7r3W8p])
                if VFjbO_z is not None:
                    Uu3k5W_I5K.key.insert(W2m7r3W8p, VFjbO_z.key.pop(-1))
                    Uu3k5W_I5K.child.insert(W2m7r3W8p, VFjbO_z)
                    if len(Uu3k5W_I5K.child) == mQIQrK * 2:
                        DR7Gm9Qi = BTreeNode()
                        DR7Gm9Qi.child = Uu3k5W_I5K.child[:mQIQrK]
                        Uu3k5W_I5K.child = Uu3k5W_I5K.child[mQIQrK:]
                        DR7Gm9Qi.key = Uu3k5W_I5K.key[:mQIQrK]
                        Uu3k5W_I5K.key = Uu3k5W_I5K.key[mQIQrK:]
                        return DR7Gm9Qi
            return None
        VFjbO_z = insert_rec(self.root)
        if VFjbO_z is not None:
            A4Mxo_S = BTreeNode()
            A4Mxo_S.key = [VFjbO_z.key.pop(-1)]
            A4Mxo_S.child = [VFjbO_z, self.root]
            self.root = A4Mxo_S

    def dump(self):
        def dump_rec(Uu3k5W_I5K, dep):
            for _ in range(0, dep):
                print(""  "", end="""")
            print(Uu3k5W_I5K.key)
            for c in Uu3k5W_I5K.child:
                dump_rec(c, dep + 1)
        dump_rec(self.root, 0)
        print("""")


def main():
    n14LUxJn = int(input())
    W_GFk9Urj = list(map(int, input().split()))
    WkgWCPxHXC = [0] * n14LUxJn
    for W2m7r3W8p in range(0, n14LUxJn):
        WkgWCPxHXC[W2m7r3W8p] = W2m7r3W8p
    WkgWCPxHXC.sort(key=lambda W2m7r3W8p: - W_GFk9Urj[W2m7r3W8p])
    yLFgaQB = BTree()
    yLFgaQB.insert(-1)
    yLFgaQB.insert(n14LUxJn)
    WnpceoB = 0
    for W2m7r3W8p in WkgWCPxHXC:
        peV0 = yLFgaQB.search_higher(W2m7r3W8p)
        _ne8V = yLFgaQB.search_higher(peV0)
        E_wrexY = yLFgaQB.search_lower(W2m7r3W8p)
        SuQLVhk = yLFgaQB.search_lower(E_wrexY)
        if SuQLVhk != None:
            WnpceoB += W_GFk9Urj[W2m7r3W8p] * (E_wrexY - SuQLVhk) * (peV0 - W2m7r3W8p)
        if _ne8V != None:
            WnpceoB += W_GFk9Urj[W2m7r3W8p] * (W2m7r3W8p - E_wrexY) * (_ne8V - peV0)
        yLFgaQB.insert(W2m7r3W8p)
    print(WnpceoB)


main()
</ans>",True,{}
254,"<ans>
FkQbmkCkb = 72
lVU = 1<<FkQbmkCkb
smvX5D = lambda L: int("""".join([bin(lVU+nc95W2V)[-FkQbmkCkb:] for nc95W2V in L[::-1]]), 2)
egm = lambda n: bin(n)[2:] + ""0""
dCZ3Ue = lambda s, l: [int(nc95W2V, 2) if len(nc95W2V) else 0 for nc95W2V in [s[-(i+1)*FkQbmkCkb-1:-i*FkQbmkCkb-1] for i in range(l)]]

def grow(d, v, h):
    h += [0] * d
    Ep6Da = [(-1 if (i+d) % 2 else 1) * pW3Mg[i] * pW3Mg[d-i] % jM0lTQ * h[i] % jM0lTQ for i in range(d+1)]
    
    for idx, nc95W2V in enumerate([d+1, d * mhx2wZ1Jv[v-1] * pW3Mg[v] % jM0lTQ, (d * mhx2wZ1Jv[v-1] * pW3Mg[v] + d + 1) % jM0lTQ]):
        Uj9f = [1] * (2*d+2)
        for i in range(1, 2*d+2): Uj9f[i] = Uj9f[i-1] * (nc95W2V - d + i - 1) % jM0lTQ
        A8Uul = [1] * (2*d+2)
        A8Uul[-1] = pow(Uj9f[-1], jM0lTQ-2, jM0lTQ)
        for i in range(1, 2*d+2)[::-1]: A8Uul[i-1] = A8Uul[i] * (nc95W2V - d + i - 1) % jM0lTQ
        
        MnKjTmjqZ = [A8Uul[i+1] * Uj9f[i] % jM0lTQ for i in range(2*d+1)]
        liyD = dCZ3Ue(egm(smvX5D(Ep6Da) * smvX5D(MnKjTmjqZ)), d * 2 + 2)
            
        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (liyD[d+i] * Uj9f[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ) % jM0lTQ
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = liyD[d+i] * Uj9f[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (liyD[d+i] * Uj9f[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ) % jM0lTQ
    return h

# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]
def create_table(v):
    RymCr = 1
    t06inl4fa9 = [1, v+1]
    while RymCr < v:
        t06inl4fa9 = grow(RymCr, v, t06inl4fa9)
        RymCr *= 2
    uTs = [1]
    for x in t06inl4fa9:
        uTs.append(uTs[-1] * x % jM0lTQ)
    return uTs

def fact(i, uTs):
    nc95W2V = uTs[i//aoH_]
    for j in range(i//aoH_*aoH_+1, i+1):
        nc95W2V = nc95W2V * j % jM0lTQ
    return nc95W2V

jM0lTQ = 10**9+7
aoH_ = 1 << 11
mhx2wZ1Jv = [1] * (2*aoH_+2)
pW3Mg = [1] * (2*aoH_+2)
for i in range(2*aoH_+1):
    mhx2wZ1Jv[i+1] = mhx2wZ1Jv[i] * (i+1) % jM0lTQ
pW3Mg[-1] = pow(mhx2wZ1Jv[-1], jM0lTQ-2, jM0lTQ)
for i in range(2*aoH_+1)[::-1]:
    pW3Mg[i] = pW3Mg[i+1] * (i+1) % jM0lTQ

G_c3 = create_table(aoH_)

Ep6Da = lambda nc95W2V, b: fact(nc95W2V+b+2, G_c3) * pow(fact(nc95W2V+1, G_c3) * fact(b+1, G_c3), jM0lTQ-2, jM0lTQ) % jM0lTQ
r1, c1, r2, c2 = list(map(int, input().split()))
print(((Ep6Da(r2, c2) - Ep6Da(r2, c1-1) - Ep6Da(r1-1, c2) + Ep6Da(r1-1, c1-1)) % jM0lTQ))
</ans>",0,{}
255,"<ans>
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n

    def find(self, XD34cifB):
        bYEWKo = []

        while XD34cifB != self.parent[XD34cifB]:
            bYEWKo.append(XD34cifB)
            XD34cifB = self.parent[XD34cifB]

        for mtpC in bYEWKo:
            self.parent[mtpC] = XD34cifB

        return self.parent[XD34cifB]

    def merge(self, XD34cifB, mtpC):
        XD34cifB = self.find(XD34cifB)
        mtpC = self.find(mtpC)

        if XD34cifB == mtpC:
            return

        if self.size[XD34cifB] < self.size[mtpC]:
            XD34cifB, mtpC = mtpC, XD34cifB

        self.num_sets -= 1
        self.parent[mtpC] = XD34cifB
        self.size[XD34cifB] += self.size[mtpC]

    def set_size(self, XD34cifB):
        return self.size[self.find(XD34cifB)]


def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(LOZUbv=None, maxsplit=-1):
        return read().split(LOZUbv, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(LOZUbv=None, maxsplit=-1):
        return [int(XD34cifB) for XD34cifB in read_array(LOZUbv, maxsplit)]

    def write(*args, **kwargs):
        LOZUbv = kwargs.get('sep', ' ')
        hJtjv = kwargs.get('end', '\n')
        stdout.write(LOZUbv.join(str(XD34cifB) for XD34cifB in args) + hJtjv)

    def write_array(array, **kwargs):
        LOZUbv = kwargs.get('sep', ' ')
        hJtjv = kwargs.get('end', '\n')
        stdout.write(LOZUbv.join(str(XD34cifB) for XD34cifB in array) + hJtjv)

    n, m = read_int_array()
    REJ2V = UnionFind(n)
    for _ in range(m):
        VSx = read_int_array()
        SJH = VSx[0]
        bVrix = None
        for i in range(SJH):
            mPIb_jge = VSx[1 + i] - 1
            if bVrix is None:
                bVrix = mPIb_jge
            else:
                REJ2V.merge(mPIb_jge, bVrix)

    lOoBX = [REJ2V.set_size(i) for i in range(n)]
    write(*lOoBX)

main()
</ans>",0,{}
256,"<ans>
#!/usr/bin/env python3
# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015

import unittest
import sys

###############################################################################
# Sponge Class (Main Program)
###############################################################################


class Sponge:
    """""" Sponge representation """"""

    def __init__(self, XnAR4a=None):
        """""" Default constructor """"""

        Q4WO8 = iter(XnAR4a.split(""\n"")) if XnAR4a else None

        def uinput():
            return next(Q4WO8) if Q4WO8 else sys.stdin.readline().rstrip()

        # Reading single elements
        [self.n, self.m] = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        self.numf = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        self.numb = list(map(int, uinput().split()))

        self.fd = {}
        self.fdn = {}
        for (i, n) in enumerate(self.numf):
            self.fd[n] = self.fd.setdefault(n, 0) + 1
            self.fdn[n] = i + 1

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        rImz = []
        for n in self.numb:
            if n not in self.fd:
                return ""Impossible""
            rImz.append(self.fdn[n])
        for n in self.numb:
            if self.fd[n] > 1:
                return ""Ambiguity""

        return ""Possible\n"" + "" "".join(map(str, rImz))

###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_single_test(self):
        """""" Sponge class testing """"""

        # Constructor test
        XnAR4a = ""3 3\n3 2 1\n1 2 3""
        lCxuXhp = Sponge(XnAR4a)
        self.assertEqual(lCxuXhp.n, 3)
        self.assertEqual(lCxuXhp.m, 3)
        self.assertEqual(lCxuXhp.numf, [3, 2, 1])
        self.assertEqual(lCxuXhp.numb, [1, 2, 3])

        # Sample test
        self.assertEqual(Sponge(XnAR4a).calculate(), ""Possible\n3 2 1"")

        # Sample test
        XnAR4a = ""3 3\n1 1 3\n1 2""
        self.assertEqual(Sponge(XnAR4a).calculate(), ""Impossible"")

        # Sample test
        XnAR4a = ""3 3\n1 1 1\n1 1 1""
        self.assertEqual(Sponge(XnAR4a).calculate(), ""Ambiguity"")

        # My tests
        XnAR4a = """"
        # self.assertEqual(Sponge(XnAR4a).calculate(), ""0"")

        # Time limit test
        # self.time_limit_test(5000)

    def time_limit_test(self, nmax):
        """""" Timelimit testing """"""
        import random
        import timeit

        # Random inputs
        XnAR4a = str(nmax) + "" "" + str(nmax) + ""\n""
        PvpTr = [str(i) + "" "" + str(i+1) for i in range(nmax)]
        XnAR4a += ""\n"".join(PvpTr) + ""\n""
        wE5LG0CTaE = [random.randint(1, 10000) for i in range(nmax)]
        XnAR4a += "" "".join(map(str, wE5LG0CTaE)) + ""\n""

        # Run the test
        AJ1 = timeit.default_timer()
        lCxuXhp = Sponge(XnAR4a)
        y0y = timeit.default_timer()
        lCxuXhp.calculate()
        WXXz_b4Tp7 = timeit.default_timer()
        print((""\nTimelimit Test: "" +
              ""{0:.3f}s (init {1:.3f}s calc {2:.3f}s)"".
              format(WXXz_b4Tp7-AJ1, y0y-AJ1, WXXz_b4Tp7-y0y)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(Sponge().calculate())

__starting_point()
</ans>",0,{}
257,"<ans>
NPM0n0Q1y=input().split()
_IbYO=int(NPM0n0Q1y[0])
lnDP=int(NPM0n0Q1y[1])
HQj=[]
for i in range(_IbYO):
    xGa348r=input()
    HQj.append(xGa348r)
Fr9Qg=[]
for i in range(_IbYO):
    BcOtKzy5M=[]
    for Nmz in range(_IbYO):
        BcOtKzy5M.append(0)
    Fr9Qg.append(BcOtKzy5M)
for i in range(_IbYO):
    for Nmz in range(len(HQj[i])):
        IZYsI0=0
        yGx1=0
        if Nmz+lnDP<=_IbYO:
            for q in range(lnDP):
                if HQj[i][Nmz+q:Nmz+q+1]=='.':
                    continue
                else:
                    IZYsI0=1
                    break
            if IZYsI0==0:
                for q in range(lnDP):
                    Fr9Qg[i][Nmz+q]=Fr9Qg[i][Nmz+q]+1
            if IZYsI0==1:
                Nmz=q+1
for i in range(_IbYO):
    for Nmz in range(_IbYO):
        IZYsI0=0
        yGx1=0
        if Nmz+lnDP<=_IbYO:
            for q in range(lnDP):
                if HQj[Nmz+q][i:i+1]=='.':
                    continue
                else:
                    IZYsI0=1
                    break
            if IZYsI0==0:
                for q in range(lnDP):
                    Fr9Qg[Nmz+q][i]=Fr9Qg[Nmz+q][i]+1
            if IZYsI0==1:
                Nmz=q+1
FJgmPF7j=0
XS2ew7ol=0
yUL7Se=0
for i in range(_IbYO):
    for Nmz in range(_IbYO):
        if Fr9Qg[i][Nmz]>yUL7Se:
            yUL7Se=Fr9Qg[i][Nmz]
            FJgmPF7j=i
            XS2ew7ol=Nmz
print(FJgmPF7j+1,XS2ew7ol+1)
</ans>",True,{}
258,"<ans>
"""""" ATSTNG's ejudge Python3 solution template """"""
import sys, queue

try:
    import dev_act_ffc429465ab634
    cry3KjH = True
except:
    cry3KjH = False

def log(*s):
    if cry3KjH: print('L',list(s),sep='')

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        WHUo = [[[5]*100000 for _ in range(1000)]]
        while True: WHUo.append([[5]*100000 for _ in range(1000)])

    def get_re(self):
        vQrHT = (0,)[8]

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        return

class IntReader:
    def __init__(self):
        self.ost = queue.Queue()

    def get(self):
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        return self.ost.get()

    def release(self):
        y35z0aw = []
        while not self.ost.empty():
            y35z0aw.append(self.ost.get())
        return y35z0aw

###############################################################################
RmQC = EJudge(  )
Gw8idueYk = IntReader()
XAyj1Hg6 = lambda f,l: list(map(f,l))
cKRjsT = lambda: XAyj1Hg6(int, input().split())
RsH5apY = lambda x: (x>0)-(x<0)

# input
n,x = cKRjsT()
fG0N = [0]*100500
vi1o = [0]*100500
for _ in range(n): fG0N[Gw8idueYk.get()] += 1
for idx in range(100500):
    tJZt = idx^x
    if tJZt < 100500:
        vi1o[tJZt] = fG0N[idx]

SagQqR = 0
for idx in range(100500):
    SagQqR += fG0N[idx]*vi1o[idx]

if x == 0: SagQqR -= n

print(SagQqR//2)
</ans>",0,{}
259,"<ans>
import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

# Guide:
#   1. construct complex data types while reading (e.g. graph adj list)
#   2. avoid any non-necessary time/memory usage
#   3. avoid templates and write more from scratch
#   4. switch to ""flat"" implementations

def VI(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(SO3Owig,m=None): return [0]*SO3Owig if m is None else [[0]*m for i in range(SO3Owig)]
def ELIST(SO3Owig): return [[] for i in range(SO3Owig)]
def MI(SO3Owig=None,m=None): # input matrix of integers
    if SO3Owig is None: SO3Owig,m = VI()
    RaTfI = LIST(SO3Owig)
    for i in range(SO3Owig): RaTfI[i] = VI()
    return RaTfI
def MS(SO3Owig=None,m=None): # input matrix of strings
    if SO3Owig is None: SO3Owig,m = VI()
    RaTfI = LIST(SO3Owig)
    for i in range(SO3Owig): RaTfI[i] = input()
    return RaTfI
def MIT(SO3Owig=None,m=None): # input transposed matrix/array of integers
    if SO3Owig is None: SO3Owig,m = VI()
    a = MI(SO3Owig,m)
    RaTfI = LIST(m,SO3Owig)
    for i,l in enumerate(a):
        for j,x in enumerate(l):
            RaTfI[j][i] = x
    return RaTfI


def run(SO3Owig,N6j):
    for i in range(SO3Owig+1):
        if N6j[0]==0:
            if sum([i==N6j[i] for i in range(SO3Owig)])==SO3Owig:
                print(""Yes"")
            else:
                print(""No"")
            return
        for j in range(SO3Owig):
            if j%2==0:
                N6j[j] = (N6j[j]+1)%SO3Owig
            else:
                N6j[j] = (N6j[j]-1)%SO3Owig


def main(info=0):
    SO3Owig = I()
    N6j = VI()

    run(SO3Owig,N6j)",0,{}
260,"<ans>
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass",0,{}
261,"<ans>
import math
import bisect
import itertools
import sys
vR80YSP_6e=lambda : sys.stdin.readline()
MyyP=10**9 +7
'''fact=[1]*100001
ifact=[1]*100001
for oHQ7rg5 in range(1,100001):
    fact[oHQ7rg5]=((fact[oHQ7rg5-1])*oHQ7rg5)%MyyP
    ifact[oHQ7rg5]=((ifact[oHQ7rg5-1])*pow(oHQ7rg5,MyyP-2,MyyP))%MyyP
def ncr(n,r):
    return (((fact[n]*ifact[n-r])%MyyP)*ifact[r])%MyyP
def npr(n,r):
    return (((fact[n]*ifact[n-r])%MyyP))
    '''


def mindiff(uZr):
    YY4nm0=uZr[:]
    YY4nm0.sort()
    JxI=10000000000
    for oHQ7rg5 in range(len(YY4nm0)-1):
        if YY4nm0[oHQ7rg5+1]-YY4nm0[oHQ7rg5]<JxI:
            JxI=YY4nm0[oHQ7rg5+1]-YY4nm0[oHQ7rg5]
    return JxI
    
def lcm(uZr,YY4nm0):
    return uZr*YY4nm0//math.gcd(uZr,YY4nm0)

    
def merge(uZr,YY4nm0):
    oHQ7rg5=0;jBAy=0
    m1xA=0
    IEACFyWa0=[]
    while oHQ7rg5<len(uZr) and jBAy<len(YY4nm0):
        if uZr[oHQ7rg5]<YY4nm0[jBAy]:
            IEACFyWa0.append(uZr[oHQ7rg5])
            oHQ7rg5+=1
        else:
            IEACFyWa0.append(YY4nm0[jBAy])
            m1xA+=len(uZr)-oHQ7rg5
            jBAy+=1
    IEACFyWa0+=uZr[oHQ7rg5:]
    IEACFyWa0+=YY4nm0[jBAy:]
    return IEACFyWa0,m1xA
def mergesort(uZr):
    if len(uZr)==1:
        return uZr,0
    AXF1RLHPZn=len(uZr)//2   
    left,left_inversion=mergesort(uZr[:AXF1RLHPZn])
    right,right_inversion=mergesort(uZr[AXF1RLHPZn:])
    m1xA,m1xA=merge(left,right)
    m1xA+=(left_inversion+right_inversion)
    return m1xA,m1xA
    
def is_prime(num):
    if num == 1: return False
    if num == 2: return True
    if num == 3: return True
    if num%2 == 0: return False
    if num%3 == 0: return False
    Y3OetRWEX = 5
    uZr = 2
    while Y3OetRWEX <= int(math.sqrt(num)):
        if num%Y3OetRWEX == 0: return False
        Y3OetRWEX += uZr
        uZr = 6 - uZr
    return True
    
  
def ceil(uZr,YY4nm0):
    if uZr%YY4nm0==0:
        return uZr//YY4nm0
    else:
        return (uZr//YY4nm0 + 1)

def binsearch(arr,YY4nm0,low,high):
    if low==high:
        return low
    if arr[math.ceil((low+high)/2)]<YY4nm0:
        return binsearch(arr,YY4nm0,low,math.ceil((low+high)/2) -1 )
    else:
        return binsearch(arr,YY4nm0,math.ceil((low+high)/2),high)
def ncr1(n,r):
    Hi4q=1
    for oHQ7rg5 in range(min(n-r,r)):
        Hi4q*=(n-oHQ7rg5)
        Hi4q%=MyyP
        Hi4q*=pow(oHQ7rg5+1,MyyP-2,MyyP)
        Hi4q%=MyyP
    return Hi4q
    
def calc(n,m1xA,r):
    Hi4q=0
    for oHQ7rg5 in range(0,r+1,2):
        Hi4q+=ncr1(n,oHQ7rg5)*ncr1(m1xA,oHQ7rg5)
        Hi4q%=MyyP
    return Hi4q    
    
def modu(uZr,n):
    if uZr%n==0:
        return n
    return uZr%n

#/////////////////////////////////////////////////////////////////////////////////////////////////

for oHQ7rg5 in range(1):
    n,k=map(int,input().split())
    uZr=list(map(int,input().split()))
    Hi4q=input()
    m1xA=1;YY4nm0=[]
    for oHQ7rg5 in range(1,n):
        if Hi4q[oHQ7rg5-1]==Hi4q[oHQ7rg5]:
            m1xA+=1
            iFSsuZ=True
        else:
            YY4nm0.append(m1xA)
            m1xA=1
            iFSsuZ=False
    if True:
        YY4nm0.append(m1xA)
    #print(YY4nm0) 
    IEACFyWa0=0
    P2wKL=0
    for oHQ7rg5 in YY4nm0:
        m1xA=uZr[P2wKL:min(P2wKL+oHQ7rg5,10**9)]
        
        #print(m1xA)
        
        
        m1xA.sort(reverse=True)
        m1xA=m1xA[:min(oHQ7rg5,k)]
        P2wKL+=oHQ7rg5
        IEACFyWa0+=sum(m1xA)
        
    print(IEACFyWa0)
</ans>",0,{}
262,"<ans>
def solve(printing):

    F87mUE = int(input())
    LRIvawq = [int(st)-1 for st in input().split("" "")]
    xVR1MB = [0] * F87mUE
    ybd = []
    CAL578CFbq = {}
    S7nPLyiI = []

    if printing:
        print(""LRIvawq""); print(LRIvawq)

    for i in range(F87mUE):
        xVR1MB[LRIvawq[i]] += 1

    for i in range(F87mUE):
        if xVR1MB[i] == 0:
            S7nPLyiI.append(i)
            
        if xVR1MB[LRIvawq[i]] >= 2:
            ybd.append(i)
            if LRIvawq[i] in CAL578CFbq:
                CAL578CFbq[LRIvawq[i]][1].append(i)
            else:
                CAL578CFbq[LRIvawq[i]] = [0, [i], False]
                # left location, dupe indexs, if already located original

    for num in CAL578CFbq:
        CAL578CFbq[num][0] = len(CAL578CFbq[num][1])

    if printing:
        print(""S7nPLyiI""); print(S7nPLyiI)
        print(""CAL578CFbq""); print(CAL578CFbq)

    l7u4i = len(S7nPLyiI)
    mEXZqGUMir = 0
    #answer = 0
    for index in ybd:

        if l7u4i <= mEXZqGUMir:
            break

        elif CAL578CFbq[LRIvawq[index]][0] == 1 and not CAL578CFbq[LRIvawq[index]][2]:
            # one spot left but original not located yet.
            # locate original.
            CAL578CFbq[LRIvawq[index]][0] -= 1
            CAL578CFbq[LRIvawq[index]][2] = True
        
        elif CAL578CFbq[LRIvawq[index]][0] > 0:
            
            if CAL578CFbq[LRIvawq[index]][2] or S7nPLyiI[mEXZqGUMir] < LRIvawq[index]:
                # num is smaller or original is already located.
                # locate missing number.
                CAL578CFbq[LRIvawq[index]][0] -= 1
                LRIvawq[index] = S7nPLyiI[mEXZqGUMir]
                mEXZqGUMir += 1
                #answer += 1

            else: # locate original
                CAL578CFbq[LRIvawq[index]][0] -= 1
                CAL578CFbq[LRIvawq[index]][2] = True

    print(l7u4i)
    for num in LRIvawq:
        print(num+1, end = "" "")

solve(False)
</ans>",0,{}
263,"<ans>
from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
 #------------------Sublime--------------------------------------#
 sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
 def I():return (int(input()))
 def In():return(map(int,input().split()))
else:
 #------------------PYPY FAst I/o--------------------------------#
 def I():return (int(stdin.readline()))
 def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
 XZ5Z3C0J={} 
 for x in a:
  if XZ5Z3C0J.get(x,-1)!=-1:
   XZ5Z3C0J[x]+=1
  else:
   XZ5Z3C0J[x]=1
 return XZ5Z3C0J
def find_gt(a, x):
 'Find leftmost value greater than x'
 Bij122A = bi.bisect_right(a, x)
 if Bij122A != len(a):
  return Bij122A
 else:            
  return -1

def find_ge(a, x):
 'Find leftmost item greater than or equal to x'
 Bij122A = bi.bisect_left(a, x)
 if Bij122A != len(a):
  return Bij122A
 else:
  return -1
def main():
 try:
  n,Q=In()
  XFCT_yLktZ=list(In())
  XFCT_yLktZ.sort()
  BwkY5=[0]
  Msatslftm=0
  for x in range(n):
   Msatslftm+=XFCT_yLktZ[x]
   BwkY5.append(Msatslftm)
  #print(BwkY5)
  for x in range(Q):
   kW2GNC2dy=I()
   kW2GNC2dy*=2
   A9w97=find_ge(XFCT_yLktZ,kW2GNC2dy)
   #print(A9w97)
   if A9w97==-1:
    print(0)
   else:
    #print(A9w97)
    Sn9=BwkY5[-1]-BwkY5[A9w97]
    print(Sn9)
 except:
  pass
  
kTru = 998244353
aALt = 1000000007
 
def __starting_point():
 #for _ in range(I()):main()
 for _ in range(1):main()
__starting_point()
</ans>",True,{}
264,"<ans>
import sys

def gcd(csd2HpF):
	if len(csd2HpF)==0:
		return 0
	if len(csd2HpF)==1:
		return csd2HpF[0]
	if len(csd2HpF)==2:                                   
		if csd2HpF[1]==0:
			return csd2HpF[0]  
		return gcd([csd2HpF[1],csd2HpF[0]%csd2HpF[1]])
	return gcd([gcd(csd2HpF[:-1]),csd2HpF[-1]])
		
def brute_force(l1,l2,csd2HpF,UHJ0bVG4U):                   
	if len(csd2HpF)==0:
		T5cw=gcd(l1)
		vbViA6gY1=gcd(l2)
		return T5cw==1 and vbViA6gY1==1,UHJ0bVG4U
	
	ERF6YUJp6i,s=brute_force(l1+[csd2HpF[0]],l2,csd2HpF[1:],UHJ0bVG4U+[1])
	if ERF6YUJp6i:
		return True,s
	return brute_force(l1,l2+[csd2HpF[0]],csd2HpF[1:],UHJ0bVG4U+[2])

def factor(pe9iQxDYbm):
	ERF6YUJp6i=[]
	mw9=2
	while mw9*mw9<=pe9iQxDYbm:
		if pe9iQxDYbm%mw9==0:
			ERF6YUJp6i.append(mw9)
		while pe9iQxDYbm%mw9==0:
			pe9iQxDYbm=int(pe9iQxDYbm/mw9)
		mw9+=1

	if pe9iQxDYbm!=1:
		ERF6YUJp6i.append(pe9iQxDYbm)

	return ERF6YUJp6i

def dumpsol(UHJ0bVG4U):
	for LeFDd6o in UHJ0bVG4U:
		print(LeFDd6o,end=' ')

pe9iQxDYbm=int(sys.stdin.readline())
csd2HpF=sys.stdin.readline().strip().split("" "")[0:pe9iQxDYbm]
csd2HpF=[int(LeFDd6o) for LeFDd6o in csd2HpF]
if pe9iQxDYbm<12:
	ERF6YUJp6i,UHJ0bVG4U=brute_force([],[],csd2HpF,[])
	if ERF6YUJp6i:
		print(""YES"")
		dumpsol(UHJ0bVG4U)
	else:
		print(""NO"")
	return

xhKU1YMQSW={}
for mw9 in range(10):
	for key in factor(csd2HpF[mw9]):
		xhKU1YMQSW[key]=0

oYit0U={}
for LeFDd6o in xhKU1YMQSW:
	oYit0U[LeFDd6o]=[]
	TxefTlaKEU=0
	Whg5iQpdj=False
	for v in csd2HpF:
		if v%LeFDd6o!=0:
			Whg5iQpdj=True
			xhKU1YMQSW[LeFDd6o]+=1
			oYit0U[LeFDd6o].append(TxefTlaKEU)
			if (xhKU1YMQSW[LeFDd6o]>9):
				break
		TxefTlaKEU+=1
	if not Whg5iQpdj:
		print(""NO"")
		return

gWWdS=[]
Jhj705dYN={}
for LeFDd6o in xhKU1YMQSW:
	if xhKU1YMQSW[LeFDd6o]==0:
		print(""NO"")
		return

	if xhKU1YMQSW[LeFDd6o]<10:
		gWWdS.append(LeFDd6o)
		Jhj705dYN[LeFDd6o]=1

#print(gWWdS)

UHJ0bVG4U=[1 for mw9 in range(len(csd2HpF))]
m63m25vIa=csd2HpF[0]
UHJ0bVG4U[0]=2
cQWBbkGQW=factor(m63m25vIa)
#print(cQWBbkGQW)
aWyyzH=[]
UvWMGKClc=0
PWdPioM={}
for LeFDd6o in cQWBbkGQW:
	if LeFDd6o in Jhj705dYN:
		UvWMGKClc+=1
		PWdPioM[LeFDd6o]=1
		aWyyzH.append(LeFDd6o)
	else:
		UHJ0bVG4U[oYit0U[LeFDd6o][0]]=2

VGrSQ1=[]
for LeFDd6o in gWWdS:
	if not LeFDd6o in PWdPioM:
		VGrSQ1.append(LeFDd6o)

iH6ISAoXG={}
TxefTlaKEU=0

#print(aWyyzH)
#print(VGrSQ1)

for LeFDd6o in aWyyzH+VGrSQ1:
	for v in oYit0U[LeFDd6o]:
		if not v in iH6ISAoXG:	
			iH6ISAoXG[v]=0
		iH6ISAoXG[v]|=1<<TxefTlaKEU
	TxefTlaKEU+=1

DMy1=[{} for mw9 in range(len(iH6ISAoXG)+1)]
DMy1[0][0]=0
TxefTlaKEU=0
r0wJh=[]
for mask in iH6ISAoXG:
	r0wJh.append(mask)
	gZtwOqN=iH6ISAoXG[mask]
	sas5DxDAZD=gZtwOqN<<10
	#print(DMy1)
	for LeFDd6o in DMy1[TxefTlaKEU]:
		DMy1[TxefTlaKEU+1][LeFDd6o|gZtwOqN]=LeFDd6o
		# first number is always in group2
		if (mask!=0):
			DMy1[TxefTlaKEU+1][LeFDd6o|sas5DxDAZD]=LeFDd6o
	TxefTlaKEU+=1	

#print(DMy1)
#print(iH6ISAoXG)
#print(UHJ0bVG4U)

D4a8mbi=((1<<len(aWyyzH))-1)|(((1<<len(gWWdS))-1)<<10)
#print(D4a8mbi)
for LeFDd6o in DMy1[TxefTlaKEU]:
	if (LeFDd6o&D4a8mbi)==D4a8mbi:
		print(""YES"")

		#print(TxefTlaKEU)
		while (TxefTlaKEU!=0):
			#print(LeFDd6o)
			#print(DMy1[TxefTlaKEU])
			cbWTpB=DMy1[TxefTlaKEU][LeFDd6o]
			#print(cbWTpB)
			if (cbWTpB^LeFDd6o<1024 and cbWTpB^LeFDd6o!=0):
				UHJ0bVG4U[r0wJh[TxefTlaKEU-1]]=2
			LeFDd6o=cbWTpB
			TxefTlaKEU-=1

		dumpsol(UHJ0bVG4U)
		return

print(""NO"")

#print(gWWdS)
#print(iH6ISAoXG)
</ans>",0,{}
265,"<ans>
```
a, b, f, k = [int(i) for i in input().split()]

##pm3zyN9 = b
##usSzTCs = 0
##ekN = 0
##current = 0
##while(usSzTCs != k):
##    print(""current = %d, pm3zyN9 = %d, ekN = %d, usSzTCs = %d"" % (current, pm3zyN9, ekN, usSzTCs))
##    if (pm3zyN9 // a >= k):
##        print(ekN)
##        return
        
##    if current == 0:
##        if pm3zyN9 >= a + (a-f):
##            pm3zyN9 -= a
##        elif pm3zyN9 >= f and b >= a-f:
##            ekN += 1
##            pm3zyN9 = b-(a-f)
##        else:
##            break
##        
##        current = a
##        
##    elif current == a:
##        if pm3zyN9 >= a + f:
##            pm3zyN9 -= a
##        elif pm3zyN9 >= a-f and b >= f:
##            ekN += 1
##            pm3zyN9 = b-f
##        else:
##            break
##        
##        current = 0
##
##    usSzTCs += 1

if b < f:
    print(-1)
    return

usSzTCs = 0
wLM4a = 0
ekN = 0
pm3zyN9 = b-f
while(usSzTCs != k): ## necessary? while(True) ?
    if wLM4a == 0:
        if pm3zyN9 >= a-f + a*(k-usSzTCs-1):
            print(ekN)
            return
        if b >= a-f + a*(k-usSzTCs-1):
            print(ekN+1)
            return
        if pm3zyN9 >= 2*(a-f):
            pm3zyN9 -= 2*(a-f)
        elif b >= 2*(a-f):
            ekN += 1
            pm3zyN9 = b - 2*(a-f)
        else:
            print(-1)
            return
        
        usSzTCs += 1
        wLM4a = a
        
    if wLM4a == a:
        if pm3zyN9 >= f + a*(k-usSzTCs-1):
            print(ekN)
            return
        if b >= f + a*(k-usSzTCs-1):
            print(ekN+1)
            return
        if pm3zyN9 >= 2*f:
            pm3zyN9 -= 2*f
        elif b >= 2*f:
            ekN += 1
            pm3zyN9 = b-2*f
        else:
            print(-1)
            return
        
        usSzTCs += 1
        wLM4a = 0

if usSzTCs == k:
    print(ekN)
else:
    print(-1)

##usSzTCs = 0
##wLM4a = 0
##refuels2 = 1
##pm3zyN9 = b
##cant2 = False
##while(usSzTCs != k):
##    if wLM4a == 0:
##        if pm3zyN9 >= a-f + a*(k-usSzTCs-1):
##            break
##        if pm3zyN9 >= 2*(a-f):
##            pm3zyN9 -= 2*(a-f)
##        elif b >= 2*(a-f):
##            refuels2 += 1
##            pm3zyN9 = b - 2*(a-f)
##        else:
##            cant2 = True
##            break
##        
##        usSzTCs += 1
##        wLM4a = a
##        
##    if wLM4a == a:
##        if pm3zyN9 >= f + a*(k-usSzTCs-1):
##            break
##        if pm3zyN9 >= 2*f:
##            pm3zyN9 -= 2*f
##        elif b >= 2*f:
##            refuels2 += 1
##            pm3zyN9 = b-2*f
##        else:
##            cant2 = True
##            break
##        
##        usSzTCs += 1
##        wLM4a = 0
##
##if cant1 and not cant2:
##    print(refuels2)
##elif not cant1 and cant2:
##    print(ekN)
##elif cant1 and cant2:
##    print(-1)
##else:
##    print(min(ekN, refuels2))
```
</ans>",0,{}
266,"<ans>
import heapq
n,m,k = list(map(int,input().split()))
_J7 = []
for _ in range(n):
    _J7.append([])
GNbrc4 = []
for _ in range(m):
    x,y,w = list(map(int,input().split()))
    GNbrc4.append((x,y,w))
GNbrc4.sort(key = lambda x: x[2])
if k < m:
    av8HTM = GNbrc4[min(m,k) - 1][2]
else:
    av8HTM = sum([x[2] for x in GNbrc4])
eIOt = {}
WHdYp = []
for i in range(n):
    eIOt[i] = [i]
    WHdYp.append(i)

for i in range(min(m,k)):
    x,y,w = GNbrc4[i]
    _J7[x-1].append((y-1,w))
    _J7[y-1].append((x-1,w))
    if WHdYp[x-1] != WHdYp[y-1]:
        if len(eIOt[WHdYp[x-1]]) >= len(eIOt[WHdYp[y-1]]):
            oS__bxjvM7 = WHdYp[y-1]
            for elem in eIOt[WHdYp[y-1]]:
                WHdYp[elem] = WHdYp[x-1]
                eIOt[WHdYp[x-1]].append(elem)
            del eIOt[oS__bxjvM7]
        else:
            oS__bxjvM7 = WHdYp[x-1]
            for elem in eIOt[WHdYp[x-1]]:
                WHdYp[elem] = WHdYp[y-1]
                eIOt[WHdYp[y-1]].append(elem)
            del eIOt[oS__bxjvM7]

AWGr = []
for key in eIOt:
    w1guj = eIOt[key]
    for mainVertex in w1guj:
        S_wUa = []
        Q_zlk = {}
        OTidly = {}
        for elem in w1guj:
            Q_zlk[elem] = False
            OTidly[elem] = av8HTM
        Q_zlk[mainVertex] = True
        for elem in _J7[mainVertex]:
            heapq.heappush(S_wUa,(elem[1],elem[0]))
            OTidly[elem[0]] = elem[1]
        while S_wUa:
            distance, curVertex = heapq.heappop(S_wUa)
            if Q_zlk[curVertex]:
                continue
            elif distance >= av8HTM:
                break
            for elem in _J7[curVertex]:
                if distance + elem[1] < OTidly[elem[0]]:
                    heapq.heappush(S_wUa,(distance + elem[1],elem[0]))
                    OTidly[elem[0]] = distance + elem[1]
        for key in OTidly:
            if OTidly[key] <= av8HTM and key > mainVertex:
                AWGr.append(OTidly[key])
        if len(AWGr) > k:
            AWGr.sort()
            AWGr = AWGr[0:k]
            if AWGr[-1] < av8HTM:
                av8HTM = AWGr[-1]
AWGr.sort()
print(AWGr[k-1])
</ans>",True,{}
267,"<ans>
class Ddict:
    def __init__(self):
        self.dicts={}
    def add(self,key):
        K7b=self.dicts
        for i in key:
            if i not in K7b:
                K7b[i]={}
            K7b=K7b[i]
        K7b[' ']=''
    def find(self,key):
        if key=='':
            return '',''
        K7b=self.dicts
        H8NA4uOZ=[]
        CJGAsYTOK=[key[0]]
        for i in key:
            if i not in K7b:
                if ' ' in K7b and len(K7b)==1:
                    return ''.join(H8NA4uOZ),''.join(CJGAsYTOK)
                return '',''
            H8NA4uOZ.append(i)
            if len(K7b)!=1:
                CJGAsYTOK=H8NA4uOZ[:]
            K7b=K7b[i]
        if ' ' in K7b and len(K7b)==1:
            return ''.join(H8NA4uOZ),''.join(CJGAsYTOK)
        return '',''
ZUm67a = Ddict()
GzK1J=0
while True:
    try:
        G1EdwfOle=input()
        if not G1EdwfOle:
            break
    except:
        break
    GzK1J+=len(G1EdwfOle)+1
    XGSBlWGw=[[]]
    for i in G1EdwfOle:
        if i in '.,?!\'- ':
            if XGSBlWGw[-1]:
                XGSBlWGw.append([])
        else:
            XGSBlWGw[-1].append(i)
    XGSBlWGw=list([''.join(e) for e in XGSBlWGw])
    for w in XGSBlWGw:
        next_word,helped_word = ZUm67a.find(w)
        if next_word and next_word!=helped_word:
            GzK1J-=len(next_word)-len(helped_word)-1
        ZUm67a.add(w)
print(GzK1J)
</ans>",True,{}
268,"<ans>
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
YHTk = 10**9 + 7
# YHTk = 9982443453
# YHTk = 998244353
Nr7e = float('inf')
from sys import stdin
R00Dk6Fq = stdin.readline
def readInts():
  return list(map(int,R00Dk6Fq().split()))
def readTuples():
    return tuple(map(int,R00Dk6Fq().split()))
def I():
    return int(R00Dk6Fq())
usQ_t = I()
sjMwN = 0
def dfs(T_njHeQ2J):
    if len(T_njHeQ2J) != 0:
        if int(T_njHeQ2J) > usQ_t:
            return
    if T_njHeQ2J.count('3') and T_njHeQ2J.count('5') and T_njHeQ2J.count('7'):
        nonlocal sjMwN
        sjMwN += 1
    for s in ""357"":
        T_njHeQ2J += s
        dfs(T_njHeQ2J)
        T_njHeQ2J = T_njHeQ2J[:-1]
dfs("""")
print(sjMwN)
</ans>",True,{}
269,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
from itertools import accumulate

#T = int(input())
PWPdi = input()
#N,M,K,Q = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

def computeGCD(x, y):

   while(y):
       x, y = y, x % y

   return x

A9osAVAi = {}

for x in range(10):
    for y in range(10):
        for oxlQ7eMOd1 in range(10):
            g_sIYm = 9999
            if (x==0 or y==0) and oxlQ7eMOd1==0:
                A9osAVAi[(x,y,oxlQ7eMOd1)] = 0
            elif x==0 and y==0 and oxlQ7eMOd1!=0:
                A9osAVAi[(x,y,oxlQ7eMOd1)] = -1
            else:
                for k in range(10):
                    qnOo4 = oxlQ7eMOd1 + 10*k
                    if x==0:
                        if qnOo4%y==0:
                            A9osAVAi[(x,y,oxlQ7eMOd1)] = qnOo4//y - 1
                            break

                    elif y==0:
                        if qnOo4%x==0:
                            A9osAVAi[(x,y,oxlQ7eMOd1)] = qnOo4//x - 1
                            break

                    else:
                        for a in range((qnOo4//x)+1):
                            for b in range((qnOo4//y)+1):
                                if x*a+y*b==qnOo4 and qnOo4!=0:
                                    g_sIYm = min(g_sIYm,a+b-1)

                if (x,y,oxlQ7eMOd1) not in A9osAVAi:
                    if g_sIYm==9999:
                        g_sIYm = -1
                    A9osAVAi[(x,y,oxlQ7eMOd1)] = g_sIYm
            #print(x,y,oxlQ7eMOd1,A9osAVAi[(x,y,oxlQ7eMOd1)])

G715xTqTN5 = [[0]*10 for _ in range(10)]

Hyw = len(PWPdi)
PWPdi = list(PWPdi)
bax0B16 = [0]*10
for i in range(Hyw-1):
    Nsvdl5w = PWPdi[i]
    W0UxS = PWPdi[i+1]

    oxlQ7eMOd1 = ord(W0UxS)-ord(Nsvdl5w)
    if oxlQ7eMOd1<0:
        oxlQ7eMOd1 += 10

    bax0B16[oxlQ7eMOd1] += 1

for x in range(10):
    for y in range(10):
        for oxlQ7eMOd1 in range(10):
            if bax0B16[oxlQ7eMOd1]==0:
                G715xTqTN5[x][y] += 0
            elif A9osAVAi[(x,y,oxlQ7eMOd1)]==-1:
                G715xTqTN5[x][y] = -10000000
            else:
                G715xTqTN5[x][y] += bax0B16[oxlQ7eMOd1]*A9osAVAi[(x,y,oxlQ7eMOd1)]

for x in range(10):
    for y in range(10):
        if G715xTqTN5[x][y]<0:
            print(-1,end=' ')
        else:
            print(G715xTqTN5[x][y],end=' ')
    print('',end='\n')
</ans>",True,{}
270,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import math

#T = int(input())
#N = int(input())
#print(N)
N,r = [int(x) for x in stdin.readline().split()]
#zka3jxP = [int(x) for x in stdin.readline().split()]

NYrADy = [0]*N

ZCm = [0]*N
eZIrR = [0]*N

bZ3 = 0

for i in range(N):
    zka3jxP = [int(x) for x in stdin.readline().split()]
    ZCm[i] = zka3jxP[0]
    eZIrR[i] = zka3jxP[1]
    
    if eZIrR[i]>=0:
        bZ3 += 1

for i in range(bZ3):
    TJcfH = -1
    eqvcC = 0
    WuEQBojc = -50000
    for j in range(N):
        # find available and largest gain
        # if gain tie, find largest start r
        if NYrADy[j]==1 or eZIrR[j]<0:
            continue
            
        if eZIrR[j]>WuEQBojc and r>=ZCm[j]:
            WuEQBojc = eZIrR[j]
            TJcfH = j
            eqvcC = ZCm[j]
        elif eZIrR[j]==WuEQBojc and r>=ZCm[j]:
            if ZCm[j]>eqvcC:
                TJcfH = j
                eqvcC = ZCm[j]
                
    if TJcfH==-1:
        print('NO')
        quit()
    else:
        NYrADy[TJcfH] = 1
        r += eZIrR[TJcfH]
        #print(TJcfH,r)
        
        
rxAn = []
for i in range(N):
    if NYrADy[i]==1 or eZIrR[i]>=0:
        continue
    rxAn.append((ZCm[i],eZIrR[i],i))
    
rxAn.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)

for i in range(len(rxAn)):
    piUOrfyj4 = rxAn[i][0]
    wC5x = rxAn[i][1]
    
    if r>=piUOrfyj4:
        r += wC5x
    else:
        print('NO')
        quit()
        

if r<0:
    print('NO')
    quit()
        
print('YES')
</ans>",0,{}
271,"<ans>
from math import*
from random import*

VpJ3ze = int(input()) * 2
LMnHr = list(map(int, input().split()))
Y1G4NgZOI = [0] * 101

D_J = []
for i in range(VpJ3ze):
    if Y1G4NgZOI[LMnHr[i]] < 2:
        Y1G4NgZOI[LMnHr[i]] += 1
        D_J += [(LMnHr[i], i)]
D_J.sort()
x, y = [], []
for i in range(len(D_J)):
    if(i % 2 == 0):
        x.append(D_J[i][1])
    else:
        y.append(D_J[i][1])
f8TpJ4kO = 0
WPn7 = 0
# print(x)
# print(y)
print(len(x) * len(y))
for i in range(VpJ3ze):
    if i in x:
        f8TpJ4kO += 1
        WPn7 += 1
        print(1, end = ' ')
    elif i in y:
        print(2, end = ' ')
    else:
        if len(x) - f8TpJ4kO + WPn7 < VpJ3ze // 2:
            print(1, end = ' ')
            WPn7 += 1
        else:
            print(2, end = ' ')
print()

# D_J, C = [], []
# for i in range(VpJ3ze):


# S = list(set(LMnHr))
# where = [0] * 101
# am1, am2 = 0, 0
# for i in range(len(S)):
#     if(i % 2 == 0):
#         where[S[i]] = 1
#         am1 += 1
#     else:
#         where[S[i]] = 2
#         am2 += 1
# used = [0] * 201
# for i in range(VpJ3ze):
#     if not used[LMnHr[i]]:
#         print(where[LMnHr[i]])
#         used[LMnHr[i]] = True
#     else:
#         print(3 - where[LMnHr[i]])
</ans>",True,{}
272,"<ans>
def check(iLIuew9):
    xb0yIin = []
    BpbP = 0
    for c, count in GKpybgkDkY:
        CYZ = count // iLIuew9
        if (count % iLIuew9 != 0):
            CYZ += 1
        xb0yIin.append((c, CYZ))
        BpbP += CYZ
    return BpbP <= oyu8j3Tt, xb0yIin
        

AqVJ = input()
oyu8j3Tt = int(input())
GKpybgkDkY = dict()
y39X = 0
for i in AqVJ:
    if i not in GKpybgkDkY:
        GKpybgkDkY[i] = 1
        y39X += 1
    else: GKpybgkDkY[i] += 1
xb0yIin = []
BpbP = """"
for i in GKpybgkDkY:
    xb0yIin.append(i)
    BpbP = i
if oyu8j3Tt >= len(AqVJ):
    print(1)
    print(AqVJ, end = '')
    oyu8j3Tt -= len(AqVJ)
    for u in range(oyu8j3Tt):
        print(BpbP, end ='')
else:
    GKpybgkDkY = (sorted(GKpybgkDkY.items(), key = lambda GKpybgkDkY:(GKpybgkDkY[1], GKpybgkDkY[0])))
    Ag901TQFo = 1
    Vzj1TikTG = len(AqVJ)
    xb0yIin = []
    EAgB = 0
    while (Ag901TQFo <= Vzj1TikTG):
        iLIuew9 = (Ag901TQFo + Vzj1TikTG) // 2
        flag, CYZ = check(iLIuew9)
        if (flag):
            Vzj1TikTG = iLIuew9 - 1
            EAgB = iLIuew9
            xb0yIin = CYZ
        else:
            Ag901TQFo = iLIuew9 + 1
        #print(Ag901TQFo, Vzj1TikTG, CYZ)
    if (len(xb0yIin) == 0):
        print(-1)
    else:
        lG9YFUa = 0
        print(EAgB)
        for c, sl in xb0yIin:
            for j in range(sl):
                print(c, end = '')
                lG9YFUa += 1
        oyu8j3Tt -= lG9YFUa
        for i in range(oyu8j3Tt):
            print(AqVJ[0], end = '')
</ans>",0,{}
273,"<ans>
""""""
Codeforces Contest Good Bye 2014 Contest Problem B

Author  : chaotic_iak
Language: Python 3.4.2
""""""

################################################### SOLUTION

def main():
    n, = read()
    jVqBPGeh = read()
    z4OBr6 = DSU()
    for uRyB in range(n):
        UnthY = read(0)
        z4OBr6.make()
        for j in range(uRyB):
            if UnthY[j] == ""1"":
                z4OBr6.union(j, uRyB)
    Zwr = [0] * n
    oqGyCgcp = [0] * n
    for uRyB in range(n):
        if not Zwr[uRyB]:
            uIemELSEe = z4OBr6.find(uRyB)
            RGuzKjUIN = []
            SKL = []
            for j in range(n):
                if z4OBr6.find(j) == uIemELSEe:
                    Zwr[j] = 1
                    RGuzKjUIN.append(j)
                    SKL.append(jVqBPGeh[j])
            SKL.sort()
            for uRyB,e in zip(RGuzKjUIN, SKL):
                oqGyCgcp[uRyB] = e
    write(oqGyCgcp)

#################################################### HELPERS

class DSU(object):
    """"""
    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.

    Methods:
    make(): add a new element and returns its index
    find(x): return representative of x
    union(x, y): merge the sets containing x and y

    Not to be used publicly:
    _parent: a list of ints for the parent of each vertex, used internally; call find instead
    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case
    __init__(): called when initialization, initialize DSU to be empty
    __str__(): return a readable string description of the DSU; meant to be printed while debugging
    """"""

    def __init__(self):
        self._parent = []
        self._rank = []

    def make(self):
        uRyB = len(self._parent)
        self._parent.append(uRyB)
        self._rank.append(0)
        return uRyB

    def find(self, x):
        if self._parent[x] != x:
            self._parent[x] = self.find(self._parent[x])
        return self._parent[x]

    def union(self, x, y):
        ySzir65 = self.find(x)
        gMc3S0 = self.find(y)
        if ySzir65 == gMc3S0: return
        if self._rank[ySzir65] < self._rank[gMc3S0]:
            self._parent[ySzir65] = gMc3S0
        elif self._rank[gMc3S0] < self._rank[ySzir65]:
            self._parent[gMc3S0] = ySzir65
        else:
            self._parent[gMc3S0] = ySzir65
            self._rank[ySzir65] += 1

    def __str__(self):
        wg9O = ""DSU\n""
        for uRyB in range(len(self._parent)):
            wg9O += str(uRyB) + "" in set "" + str(self.find(uRyB)) + "" with rank "" + str(self._rank[self.find(uRyB)]) + ""\n""
        return wg9O

def read(mode=2):
    # 0: String
    # 1: List of strings
    # 2: List of integers
    _3FfQ = input().strip()
    if mode == 0: return _3FfQ
    if mode == 1: return _3FfQ.split()
    if mode == 2: return list(map(int, _3FfQ.split()))

def write(s=""\n""):
    if s is None: s = """"
    if isinstance(s, list): s = "" "".join(map(str, s))
    s = str(s)
    print(s, end="""")

write(main())
</ans>",0,{}
274,"<ans>
from math import log2, floor

def is_power2(num):
    return num != 0 and ((num & (num - 1)) == 0)


def next_two_pow(la0):
    eCbsE0Uo=0
    while 2**eCbsE0Uo <= la0:
        eCbsE0Uo=+1
    return eCbsE0Uo        

h2x = int(input())
htdEa=[int(x) for x in input().split()]


l4Cz =-1
Mrx3LYbu=[]

for i in range(1,h2x+1):
    la0 = htdEa[i-1]
    if l4Cz ==-1:
       if  la0 == -1: 
           l4Cz =i
    else:
         if is_power2(i):
             Mrx3LYbu.append(la0)
             Mrx3LYbu.sort()
         else:
             if len(Mrx3LYbu) > 0 and la0 < Mrx3LYbu[-1]:
                 Mrx3LYbu.pop()
                 Mrx3LYbu.append(la0)
                 Mrx3LYbu.sort()

print(sum(Mrx3LYbu))


# if htdEa[h2x-1] ==-1:
#     print(0)
# else:
#     l4Cz =-1
#     for i in range(0,h2x):
#         if htdEa[i] == -1:
#             l4Cz =i
#             break
# 
#     crt_pow=int(floor(log2(h2x)))
#     stop_pow=next_two_pow(l4Cz)
#     total=0
#     taken= set()
#     while crt_pow > stop_pow:
#         two_p = 2**crt_pow
#         mn = 10**9 + 1
#         mn_idx = -1
#         for i in range(two_p - 1, h2x):
#             if i!=l4Cz and i not in taken and  htdEa[i] < mn:
#                 mn =htdEa[i]
#                 mn_idx=i
#         crt_pow -=1        
#         taken.add(mn_idx)
#         total+=mn
#     print(total)    

</ans>",True,{}
275,"<ans>
import sys

bIOUOpX2TN = sys.stdin.read().splitlines()
Iefw = iter(bIOUOpX2TN).__next__


def go():
    _gqT0DG4YA = int(Iefw())
    # _gqT0DG4YA, h, l, r = map(int, Iefw().split())
    i2b_H = list(map(int, Iefw().split()))
    OwVG1 = {i: set() for i in range(_gqT0DG4YA)}
    for _ in range(_gqT0DG4YA - 1):
        u, v = list(map(int, Iefw().split()))
        u, v = u - 1, v - 1
        OwVG1[u].add(v)
        OwVG1[v].add(u)
    _W_bFWrodV = [len(OwVG1[i]) for i in range(_gqT0DG4YA)]
    y40c0WgL = [i for i in range(_gqT0DG4YA) if _W_bFWrodV[i] == 1]
    D2gyN4 = 0
    pvrGcKe2tW = {i: {} for i in range(_gqT0DG4YA)}
    RpKAmV = set()
    while D2gyN4 < len(y40c0WgL):
        CeAw = y40c0WgL[D2gyN4]
        _0RMTx = sum(pvrGcKe2tW[CeAw].values())

        if i2b_H[CeAw] == 0:
            _0RMTx -= 1
        else:
            _0RMTx += 1

        for i in OwVG1[CeAw] - RpKAmV:
            pvrGcKe2tW[i][CeAw] = max(_0RMTx, 0)
            _W_bFWrodV[i] -= 1
            if _W_bFWrodV[i] == 1:
                y40c0WgL.append(i)
        RpKAmV.add(CeAw)
        D2gyN4 += 1

    IzrNtz6R = [0] * _gqT0DG4YA
    N3XDQkF5Md = [_W_bFWrodV.index(0)]
    RpKAmV = set()
    D2gyN4 = 0
    while D2gyN4 < len(N3XDQkF5Md):
        CeAw = N3XDQkF5Md[D2gyN4]

        _0RMTx = sum(pvrGcKe2tW[CeAw].values())

        if i2b_H[CeAw] == 0:
            _0RMTx -= 1
        else:
            _0RMTx += 1

        IzrNtz6R[CeAw] = _0RMTx

        for i in OwVG1[CeAw] - RpKAmV:
            pvrGcKe2tW[i][CeAw] = max(_0RMTx - pvrGcKe2tW[CeAw][i], 0)
            N3XDQkF5Md.append(i)

        RpKAmV.add(CeAw)
        D2gyN4 += 1

    return ' '.join(map(str,IzrNtz6R))


# t = int(Iefw())
for _ in range(1):
    print(go())
</ans>",True,{}
276,"<ans>
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
cfoaZJVu9 = 10**9 + 7
#cfoaZJVu9 = 9982443453
#cfoaZJVu9 = 998244353
dWsib8UPUk = float('inf')
from sys import stdin
JfX8Wl2JEh = stdin.readline
def readInts():
  return list(map(int,JfX8Wl2JEh().split()))
def readTuples():
    return tuple(map(int,JfX8Wl2JEh().split()))
def I():
    return int(JfX8Wl2JEh())
noqoLHbB3 = I()
x1f = readInts()
uH2gsB4s6i = readInts()
Rk7 = 0
for i in range(noqoLHbB3):
    lGYerMHJH = uH2gsB4s6i[i]
    # kill = x1f[i] + x1f[i+1]
    tfiV = min(lGYerMHJH, x1f[i])
    x1f[i] -= tfiV
    lGYerMHJH -= tfiV
    Rk7 += tfiV
    tfiV = min(x1f[i+1], lGYerMHJH)
    Rk7 += tfiV
    x1f[i+1] -= tfiV
print(Rk7)
</ans>",True,{}
277,"<ans>
def solve(tw2DY80F5E,FnNe):
    pzm = [False] * 256
    r5Zsbx = [False] * 256
    SfYVpFRF = []
    QVzJKlmf = len(tw2DY80F5E)
    for c in tw2DY80F5E:
        pzm[ord(c)] = True
    for c in FnNe:
        r5Zsbx[ord(c)] = True
    for HCr1ORF_i in range(256):
        if not pzm[HCr1ORF_i] and r5Zsbx[HCr1ORF_i]:
            print(-1)
            return
    IzDdXnWyY = tw2DY80F5E[::-1]
    HCr1ORF_i,oaA_ = 0,0
    while HCr1ORF_i < len(FnNe):
        JWnVpA9L_ = True
        AfT = FnNe[HCr1ORF_i]
        oaA_ = HCr1ORF_i + 1
        while oaA_ < len(FnNe):
            AfT += FnNe[oaA_]
            if AfT not in tw2DY80F5E and AfT not in IzDdXnWyY:
                JWnVpA9L_ = False
                break
            oaA_ += 1
        if JWnVpA9L_:
            LqX = tw2DY80F5E.find(AfT)
            if LqX != -1:
                SfYVpFRF.append((LqX + 1,LqX + len(AfT)))
                # print('1',LqX + 1,LqX + len(AfT))
            else:
                pOsE = IzDdXnWyY.find(AfT)
                SfYVpFRF.append((QVzJKlmf - pOsE,QVzJKlmf - pOsE - len(AfT) + 1))
                # print('2',QVzJKlmf - pOsE,QVzJKlmf - pOsE - len(AfT) + 1)
        else:
            LqX = tw2DY80F5E.find(AfT[:-1])
            if LqX != -1:
                SfYVpFRF.append((LqX + 1,LqX + len(AfT) - 1))
                # print('3',LqX + 1,LqX + len(AfT) - 1)
            else:
                LqX = IzDdXnWyY.find(AfT[:-1])
                SfYVpFRF.append((QVzJKlmf - LqX,QVzJKlmf - LqX - len(AfT) + 2))
                # print('4',QVzJKlmf - LqX,QVzJKlmf - LqX - len(AfT) + 2)
        HCr1ORF_i = oaA_
    print(len(SfYVpFRF))
    for LqX,pOsE in SfYVpFRF:
        print(LqX,pOsE)

tw2DY80F5E = input()
FnNe = input()

solve(tw2DY80F5E,FnNe)
</ans>",True,{}
278,"<ans>
from itertools import chain
import sys

def main():
    QhYB9 = int(input())
    # TLEs were caused mostly by slow input (1s+)
    # S = list(input() for _ in range(N))
    awHqQ = sys.stdin.read().split('\n')
    print((solve(awHqQ)))

def get_count(args):
    s, result = args # messy input to work with map.
    xHW = 0
    for c in s:
        if c == ')':
            xHW -= 1
        else:
            xHW += 1
        result[0] = max(result[0], -xHW)
    result[1] = result[0] + xHW
    return result

# Made-up name, don't remember what to call this. Radix-ish
def silly_sort(array, value_min, value_max, get_value):
    if len(array) == 0:
        return
    Qr7 = [None for _ in range(value_max - value_min + 1)]
    for elem in array:
        # Assume elem[0] is the value
        iWRlvdZqZ = get_value(elem) - value_min
        if Qr7[iWRlvdZqZ] is None:
            Qr7[iWRlvdZqZ] = []
        Qr7[iWRlvdZqZ].append(elem)
    for values in Qr7:
        if values is None:
            continue
        for value in values:
            yield value

def solve(awHqQ):
    zqqCCc = [[0,0] for _ in range(len(awHqQ))]
    zqqCCc = list(map(get_count, list(zip(awHqQ,zqqCCc))))
    xOXhEWVO = []
    FwukPnF = []
    sKtQdZhIE0 = float('inf')
    jr4ZmSDM = 0
    NiGHBw = float('inf')
    A7BhKdx = 0

    for c in zqqCCc:
        if c[0] - c[1] <= 0:
            xOXhEWVO.append(c)
            jr4ZmSDM = max(jr4ZmSDM, c[0])
            sKtQdZhIE0 = min(sKtQdZhIE0, c[0])
        else:
            FwukPnF.append(c)
            A7BhKdx = max(A7BhKdx, c[1])
            NiGHBw = min(sKtQdZhIE0, c[1])
    xOXhEWVO = silly_sort(xOXhEWVO, sKtQdZhIE0, jr4ZmSDM, lambda c: c[0])
    FwukPnF = reversed(list(silly_sort(FwukPnF, NiGHBw, A7BhKdx, lambda c: c[1])))

    SgO1b = chain(xOXhEWVO, FwukPnF)

    xHW = 0
    for c in SgO1b:
        xHW -= c[0]
        if xHW < 0:
            return 'No'
        xHW += c[1]
    if xHW == 0:
        return 'Yes'
    return 'No'

def __starting_point():
    main()

__starting_point()
</ans>",0,{}
279,"<ans>
import math
from functools import reduce
class SegmentTree():
    def __init__(self, L, function = lambda x,y: x+y):
        self.function = function
        gcTbiLQ = self.size = len(L)
        BS_pgka7S9 = 1 << gcTbiLQ.bit_length()
        self.margin = 2*BS_pgka7S9 - gcTbiLQ
        self.L = [None for i in range(self.margin)] + L
        for i in range(BS_pgka7S9-1, 0, -1):
            x, y = self.L[i<<1], self.L[i<<1|1]
            self.L[i] = None if x is None or y is None else function(x, y)
    def modify(self, pos, value):
        NXbie = pos + self.margin
        self.L[NXbie] = value 
        while NXbie > 1:
            x, y = self.L[NXbie], self.L[NXbie^1]
            if NXbie&1: x, y = y, x
            self.L[NXbie>>1] = None if x is None or y is None else self.function(x, y)
            NXbie>>=1
    def query(self, left, right):
        l, r = left + self.margin, right + self.margin
        aXY = []
        YnbcjMmqr = True
        while l < r:
            if l&1:
                if YnbcjMmqr:
                    akr = self.L[l]
                    YnbcjMmqr = False
                else:
                    akr = self.function(akr, self.L[l])
                l+=1
            if r&1:
                r-=1
                aXY.append(self.L[r])
            l>>=1
            r>>=1
        yfTA2WHst = aXY.pop() if YnbcjMmqr else akr
        return reduce(self.function, reversed(aXY), yfTA2WHst)

RQ9y = int(input())
pies, index, first_equal = [0]*RQ9y, [0]*RQ9y, [0]*RQ9y
for i in range(RQ9y):
    r, h = [int(x) for x in input().split()]
    pies[i] = r*r*h
lBjiaQQnsu = list(sorted(enumerate(pies), key = lambda p: p[1]))
for i in range(RQ9y): index[lBjiaQQnsu[i][0]] = i
for i in range(1, RQ9y):
    first_equal[lBjiaQQnsu[i][0]] = i if lBjiaQQnsu[i][1] != lBjiaQQnsu[i-1][1] else first_equal[lBjiaQQnsu[i-1][0]]
MeZGXJvTYR = SegmentTree([0]*(RQ9y+1), max)
for j, pie in enumerate(pies):
    i, k = index[j], first_equal[j]
    lhSzis = MeZGXJvTYR.query(0, k+1)
    MeZGXJvTYR.modify(i+1, lhSzis + pie)
print(math.pi * MeZGXJvTYR.query(0, RQ9y+1))
</ans>",0,{}
280,"<ans>
# returns answer to the subproblem with interval range [start, Bf3],
# but with a total of ""extra"" additional stuff on the end
# that must be deleted last.
YfCNP = {}
def f(j3D87sQXN, I4kkgx, start, Bf3, extra):
    U6we = (start, Bf3, extra)
    if U6we in YfCNP:
        return YfCNP[U6we]
    
    if start > Bf3:
        return 0
    if start == Bf3:
        YfCNP[U6we] = I4kkgx[j3D87sQXN[start] + extra]
        return YfCNP[U6we]
    
    # test all possible ""cut points"".
    # ""cut"" is the earliest index to die in the same deletion as ""Bf3"".
    wOx1 = 0
    for cut in range(Bf3, start-1, -2):
        if cut == Bf3:
            # in this case, we're deleting the last interval right away.
            kvS3bQuOI = I4kkgx[j3D87sQXN[cut] + extra]
            kvS3bQuOI += f(j3D87sQXN, I4kkgx, start, cut-1, 0)
        else:
            # split into 2 pieces:
            # 1) slots [start, cut] plus [Bf3 + extra]
            # 2) slots [cut+1, Bf3-1] (with no extra, this needs to get deleted first).
            kvS3bQuOI = f(j3D87sQXN, I4kkgx, start, cut, extra + j3D87sQXN[Bf3])
            kvS3bQuOI += f(j3D87sQXN, I4kkgx, cut+1, Bf3-1, 0)
        
        wOx1 = max(wOx1, kvS3bQuOI)
    
    YfCNP[U6we] = wOx1
    return YfCNP[U6we]

def solve(Ve8hx98, I4kkgx_orig):
    # break into intervals.
    j3D87sQXN = []
    uxfxk = 0
    while uxfxk < len(Ve8hx98):
        Bf3 = uxfxk
        while Bf3 < len(Ve8hx98) and Ve8hx98[uxfxk] == Ve8hx98[Bf3]:
            Bf3 += 1

        j3D87sQXN.append(Bf3 - uxfxk)
        uxfxk = Bf3
    
    # compute the highest-value way to remove a run of size k.
    # (google translated from C++ thinking)
    I4kkgx = [0, I4kkgx_orig[0]]
    for k in range(2, len(I4kkgx_orig) + 1):
        # print(
        #     ""{}: {}"".format(
        #         k,
        #         [
        #             I4kkgx[k-j] + I4kkgx_orig[j-1]
        #             for j in range(1, k+1)
        #         ]
        #     )
        # )
        I4kkgx.append(
            max(
                I4kkgx[k-j] + I4kkgx_orig[j-1]
                for j in range(1, k+1)
            )
        )
    
    # print(""j3D87sQXN: {}"".format(j3D87sQXN))
    # print(""I4kkgx: {}"".format(I4kkgx))
    
    return f(j3D87sQXN, I4kkgx, 0, len(j3D87sQXN)-1, 0)

# get the integer
mmKyr = input()
# get the string
Ve8hx98 = input().strip()
# get the array
h5yNJ = input().strip().split()
yJaFijPlG = [int(x) for x in h5yNJ]

# print(Ve8hx98)
# print(yJaFijPlG)

print((
    solve(
        Ve8hx98,
        yJaFijPlG,
    )
))


# j3D87sQXN_test = ""10101""
# I4kkgx_test = [3, 10, 15, 15, 15]
# print(solve(j3D87sQXN_test, I4kkgx_test))
</ans>",0,{}
281,"<ans>
import sys
BQ6M0WrIc7 = (s.rstrip() for s in sys.stdin)
AVYL0p622 = BQ6M0WrIc7.__next__

class RAQ_RMQ():
    def __init__(self, n, inf=2**31-1):
        self.n0 = 1<<(n-1).bit_length()
        self.INF = inf
        self.data = [0]*(2*self.n0)
        self.lazy = [0]*(2*self.n0)

    def getIndex(self, x3Q, r):
        x3Q += self.n0; r += self.n0
        hvgJDD7u = (x3Q // (x3Q & -x3Q)) >> 1
        D0xV7 = (r // (r & -r)) >> 1
        while x3Q < r:
            if r <= D0xV7:
                yield r
            if x3Q <= hvgJDD7u:
                yield x3Q
            x3Q >>= 1; r >>= 1
        while x3Q:
            yield x3Q
            x3Q >>= 1

    def propagates(self, *ids):
        for i in reversed(ids):
            v = self.lazy[i-1]
            if not v:
                continue
            self.lazy[2*i-1] += v; self.lazy[2*i] += v
            self.data[2*i-1] += v; self.data[2*i] += v
            self.lazy[i-1] = 0

    def update(self, x3Q, r, x):
        *ids, = self.getIndex(x3Q, r)

        x3Q += self.n0; r += self.n0
        while x3Q < r:
            if r & 1:
                r -= 1
                self.lazy[r-1] += x; self.data[r-1] += x
            if x3Q & 1:
                self.lazy[x3Q-1] += x; self.data[x3Q-1] += x
                x3Q += 1
            x3Q >>= 1; r >>= 1
        for i in ids:
            self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]

    def query(self, x3Q, r):
        self.propagates(*self.getIndex(x3Q, r))
        x3Q += self.n0; r += self.n0

        iEjr = self.INF
        while x3Q < r:
            if r & 1:
                r -= 1
                iEjr = min(iEjr, self.data[r-1])
            if x3Q & 1:
                iEjr = min(iEjr, self.data[x3Q-1])
                x3Q += 1
            x3Q >>= 1; r >>= 1
        return iEjr

n,m,k = map(int, AVYL0p622().split())
x3Q = [0]*(n+1)
wcmlWPDo = k
x1ewSH = [0]*n
for i in range(n):
    a,b,c = map(int, AVYL0p622().split())
    x1ewSH[i] = c
    wcmlWPDo = wcmlWPDo-a
    x3Q[i] = wcmlWPDo
    wcmlWPDo += b+a
x3Q[n] = wcmlWPDo

E9b9 = RAQ_RMQ(n+1)
for i in range(n+1):
    E9b9.update(i,i+1,x3Q[i])

lpXj2Pu = list(range(n))
for i in range(m):
    u,FN8 = map(int, AVYL0p622().split())
    u,FN8 = u-1, FN8-1
    if lpXj2Pu[FN8]<u:
        lpXj2Pu[FN8] = u

if E9b9.query(0, n+1) < 0:
    print(-1)
    return

cF5S = [(-x1ewSH[i], -lpXj2Pu[i]) for i in range(n)]
from heapq import heapify, heappop
heapify(cF5S)

QZQp = 0
while cF5S:
    p,i = heappop(cF5S)
    p,i = -p,-i
    if E9b9.query(i+1, n+1)>0:
        QZQp += p
        E9b9.update(i+1, n+1, -1)

print(QZQp)
</ans>",0,{}
282,"<ans>
import sys
from collections import deque

vYG=1
for _ in range(int(input())):
    mFGpvFKHA=int(input())
    zh6=set([0,2*10**5+1])
    R0eRjdBY=[(0,2*10**5+1)]
    for i in range(mFGpvFKHA):
        l,r=map(int,input().split())
        zh6.add(l)
        zh6.add(r)
        R0eRjdBY.append((l,r))
    zh6=list(zh6)
    zh6.sort()
    X2MCt8bev={i:e+1 for e,i in enumerate(zh6)}
    for i in range(mFGpvFKHA+1):
        l,r=R0eRjdBY[i]
        R0eRjdBY[i]=(X2MCt8bev[l],X2MCt8bev[r])

    T_kZ=[0]*(mFGpvFKHA+1)
    sv1bfv=[[] for i in range(mFGpvFKHA+1)]
    for i in range(mFGpvFKHA+1):
        for j in range(i+1,mFGpvFKHA+1):
            l,r=R0eRjdBY[i]
            L,R=R0eRjdBY[j]
            if L<=l and r<=R:
                sv1bfv[j].append(i)
                T_kZ[i]+=1
            elif l<=L and R<=r:
                sv1bfv[i].append(j)
                T_kZ[j]+=1

    qw2=[0]
    ZsuI=deque(qw2)

    while ZsuI:
        iBobSVNDjM=ZsuI.popleft()
        for nv in sv1bfv[iBobSVNDjM]:
            T_kZ[nv]-=1
            if T_kZ[nv]==0:
                ZsuI.append(nv)
                qw2.append(nv)

    zAR1nX=[0]*(mFGpvFKHA+1)

    def solve(iBobSVNDjM):
        S1lUSfboT_=[[] for i in range(2*mFGpvFKHA+3)]
        for nv in sv1bfv[iBobSVNDjM]:l,r=R0eRjdBY[nv];S1lUSfboT_[r].append((l,zAR1nX[nv]))
        J9yg7P6m=[0]*(2*mFGpvFKHA+3)
        for i in range(1,2*mFGpvFKHA+3):
            GiywNJK=J9yg7P6m[i-1]
            for l,val in S1lUSfboT_[i]:gitcXX=J9yg7P6m[l-1]+val;GiywNJK=max(gitcXX,GiywNJK)
            J9yg7P6m[i]=GiywNJK

        zAR1nX[iBobSVNDjM]=J9yg7P6m[-1]+1

    for iBobSVNDjM in qw2[::-1]:solve(iBobSVNDjM)

    print(zAR1nX[0]-1)
</ans>",0,{}
283,"<ans>
WloQW1wEg=int(input())
xuXRXMrwL=list(map(int,input().split()))
g8zPRvXb1={}
for i in range(2*WloQW1wEg):
	try:
		g8zPRvXb1[xuXRXMrwL[i]].append(i+1)
		g8zPRvXb1[xuXRXMrwL[i]].sort()
	except:
		KeyError
		g8zPRvXb1[xuXRXMrwL[i]]=[i+1]
qUHu1J=0
rPfKh4Jav=1
QQOmIB=1
for i in range(1,WloQW1wEg+1):
	if(i==1):
		qUHu1J+=(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	elif(g8zPRvXb1[i][0]>rPfKh4Jav and g8zPRvXb1[i][0]>QQOmIB):
		qUHu1J+=(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	elif(g8zPRvXb1[i][1]<rPfKh4Jav<QQOmIB):
		qUHu1J+=abs(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=abs(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	elif(g8zPRvXb1[i][0]<rPfKh4Jav and rPfKh4Jav<g8zPRvXb1[i][1]<QQOmIB):
		qUHu1J+=abs(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=abs(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	elif(g8zPRvXb1[i][0]<rPfKh4Jav and g8zPRvXb1[i][1]<QQOmIB):
		qUHu1J+=abs(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=abs(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	elif(rPfKh4Jav<g8zPRvXb1[i][0]<g8zPRvXb1[i][1]<QQOmIB):
		qUHu1J+=abs(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=abs(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
	else:
		qUHu1J+=abs(g8zPRvXb1[i][0]-rPfKh4Jav)
		qUHu1J+=abs(g8zPRvXb1[i][1]-QQOmIB)
		rPfKh4Jav=g8zPRvXb1[i][0]
		QQOmIB=g8zPRvXb1[i][1]
print(qUHu1J)
</ans>",True,{}
284,"<ans>
def gcd(a,b):
    while b:
        a, b = b, a%b
    return a

Bpc5 = int(input())
hJqAY = [[int(x) for x in input().split()] for _ in range(Bpc5)]

DDPTUafDK = []
def addLine(x,y,dx,dy):
    if dx < 0:
        dx *= -1
        dy *= -1
    elif dx == 0:
        if dy < 0:
            dy *= -1
    xp1ENZeR = gcd(dx,dy)
    dx //= xp1ENZeR
    dy //= xp1ENZeR

    x += dx * (10**9)
    y += dy * (10**9)
    if dx:
        qFCka_J = x//dx
    else:
        qFCka_J = y//dy
    x -= qFCka_J*dx
    y -= qFCka_J*dy
    DDPTUafDK.append((x,y,dx,dy))


for i in range(Bpc5):
    for j in range(i+1,Bpc5):
        xi,yi = hJqAY[i]
        xj,yj = hJqAY[j]
        dx,dy = xi-xj,yi-yj
        addLine(xi,yi,dx,dy)

from collections import defaultdict as dd, deque

DDPTUafDK = list(set(DDPTUafDK))
NCPxWKCth = 0

DT_m = dd(int)
for x,y,dx,dy in DDPTUafDK:
    DT_m[dx,dy] += 1

qrxV = sum(DT_m.values())

for x in DT_m.values():
    NCPxWKCth += (qrxV-x)*x

#print(res//2)
print(NCPxWKCth//2)
</ans>",0,{}
285,"<ans>
import sys
r8fXDD = sys.stdin.readline

n,m=list(map(int,r8fXDD().split()))
pCBGRrahP=[list(map(int,r8fXDD().split())) for i in range(n)]

for i in range(m):
    #一行目をi-1まで0にする

    t8x=[0]*n
    lqG7Icze4K=[0]*m

    for j in range(i):
        if pCBGRrahP[0][j]==1:
            lqG7Icze4K[j]=1

    for j in range(i,m):
        if pCBGRrahP[0][j]==0:
            lqG7Icze4K[j]=1

    for r in range(1,n):
        c5DV=set()
        for c in range(m):
            if lqG7Icze4K[c]==0:
                c5DV.add(pCBGRrahP[r][c])
            else:
                c5DV.add(1-pCBGRrahP[r][c])

        if len(c5DV)>=2:
            break
        if max(c5DV)==0:
            t8x[r]=1

    else:
        print(""YES"")
        print("""".join(map(str,t8x)))
        print("""".join(map(str,lqG7Icze4K)))
        return

t8x=[0]*n
lqG7Icze4K=[0]*m

for j in range(m):
    if pCBGRrahP[0][j]==1:
        lqG7Icze4K[j]=1

tksxB4xwB=0
for r in range(1,n):
    if tksxB4xwB==0:
        c5DV=[]
        for c in range(m):
            if lqG7Icze4K[c]==0:
                c5DV.append(pCBGRrahP[r][c])
            else:
                c5DV.append(1-pCBGRrahP[r][c])

        if max(c5DV)==0:
            continue
        elif min(c5DV)==1:
            t8x[r]=1
            continue
        else:
            abH326shh2=c5DV.index(1)
            if min(c5DV[abH326shh2:])==1:
                tksxB4xwB=1
                continue

            svn5Zh3g=c5DV.index(0)
            if max(c5DV[svn5Zh3g:])==0:
                tksxB4xwB=1
                t8x[r]=1
                continue

            else:
                print(""NO"")
                return

    else:

        c5DV=set()
        for c in range(m):
            if lqG7Icze4K[c]==0:
                c5DV.add(pCBGRrahP[r][c])
            else:
                c5DV.add(1-pCBGRrahP[r][c])

        if len(c5DV)>=2:
            break
        if max(c5DV)==0:
            t8x[r]=1

else:
    print(""YES"")
    print("""".join(map(str,t8x)))
    print("""".join(map(str,lqG7Icze4K)))
    return

print(""NO"")
</ans>",True,{}
286,"<ans>
""""""Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I""""""
# from fractions import Fraction


# def convert_to_fractions(poly):
#     """"""convert polygon vertex to fractional type""""""
#     poly_frac = []
#     for x, y, z in poly:
#         vertex = (Fraction(x),
#                   Fraction(y),
#                   Fraction(z))
#         poly_frac.append(vertex)
#     return poly_frac


def convert_to_float(poly):
    """"""convert polygon vertex to float type""""""
    MLucwY = []
    for x, y, z in poly:
        M_KqsnHNs = (float(x),
                  float(y),
                  float(z))
        MLucwY.append(M_KqsnHNs)
    return MLucwY


def cross_product(a, b):
    """"""3-vector product""""""
    return (a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0])


def dot_product(a, b):
    """"""scalar product of 3-vectors""""""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def vect_diff(a, b):
    """"""vector difference""""""
    return a[0] - b[0], a[1] - b[1], a[2] - b[2]


def poly_normal(poly):
    """"""return normal vector for first three vertex""""""
    assert len(poly) >= 3
    x, y, z = poly[:3]
    u = vect_diff(y, x)
    v = vect_diff(z, y)
    return cross_product(u, v)


def intersect_list(poly, plain_norm, plain_point, proj_dir):
    """"""list of intersection points

    find points where the edges enter or leave upper half-space over the plain
    :return list of points projection on proj_dir
    """"""
    # vertex projection
    HN9e = [dot_product(vert, proj_dir) for vert in poly]

    # plain anchor
    tsumb = dot_product(plain_point, plain_norm)

    # polygon vertex
    rMgO98Sjp_ = [dot_product(vert, plain_norm) for vert in poly]

    wZNudME0 = []
    for i in range(len(poly)):
        if (rMgO98Sjp_[i-1] > tsumb) != (rMgO98Sjp_[i] > tsumb):
            aEl = ((tsumb - rMgO98Sjp_[i-1]) * HN9e[i] + (rMgO98Sjp_[i] - tsumb) * HN9e[i-1]) / (rMgO98Sjp_[i] - rMgO98Sjp_[i-1])
            wZNudME0.append(aEl)

    return wZNudME0


def points_to_str(a_points, b_points):
    """"""string representing the order of points 'a' and 'b'""""""
    xOO = [('a', val) for val in a_points]
    t1f = [('b', val) for val in b_points]
    HrNdRq = sorted(xOO + t1f, key=lambda pair: pair[1])
    abzR40 = [ch for ch, _ in HrNdRq]
    return ''.join(abzR40)


def recognize_str(s):
    """"""return True if string s belong to the grammar

    The context-free grammar is given
    S -> SS
    S -> a S a
    S -> b S b
    S -> e

    The recognising automaton is implemented
    """"""
    RLV = {'a':'b', 'b':'a'}
    NTP1hj0 = 0
    BmpGwT3 = None
    for ch in s:
        if not NTP1hj0:
            NTP1hj0 = 1
            BmpGwT3 = ch
            continue

        if ch == BmpGwT3:
            NTP1hj0 -= 1
        else:
            NTP1hj0 += 1

        if NTP1hj0:
            BmpGwT3 = RLV[BmpGwT3]
        else:
            BmpGwT3 = None
    return not NTP1hj0


def is_well_connected(a, b):
    """"""Two planar polygons are bind together in 3D

    Arguments:
        a_poly,
        b_poly -- lists of vertex triples
    """"""
    myaNpE9 = convert_to_float(a)
    boPE5J = convert_to_float(b)

    MvxubqK = poly_normal(myaNpE9)
    gMLSItr = poly_normal(boPE5J)

    szXOEZXUsn = cross_product(MvxubqK, gMLSItr)
    if not any(szXOEZXUsn):
        return False

    aUzNVLk = intersect_list(myaNpE9, gMLSItr, boPE5J[0], szXOEZXUsn)
    h7AAK = intersect_list(boPE5J, MvxubqK, myaNpE9[0], szXOEZXUsn)

    rlBeylCwW = points_to_str(aUzNVLk, h7AAK)
    return not recognize_str(rlBeylCwW)


def run_from_console():
    a_len, = [int(num) for num in input().split()]

    myaNpE9 = []
    for _ in range(a_len):
        M_KqsnHNs = tuple(int(num) for num in input().split())
        myaNpE9.append(M_KqsnHNs)

    b_len, = [int(num) for num in input().split()]

    boPE5J = []
    for _ in range(b_len):
        M_KqsnHNs = tuple(int(num) for num in input().split())
        boPE5J.append(M_KqsnHNs)

    if is_well_connected(myaNpE9, boPE5J):
        print('YES')
    else:
        print('NO')


def __starting_point():
    run_from_console()
__starting_point()
</ans>",0,{}
287,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


zwykg0L6M_ = 97
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(iUIcC):
    if iUIcC < 2: return list()
    gylEPX6Cg = [True for _ in range(iUIcC + 1)]
    kok = 3
    while kok * kok <= iUIcC:
        if gylEPX6Cg[kok]:
            for i in range(kok * 2, iUIcC + 1, kok):
                gylEPX6Cg[i] = False
        kok += 2
    e42Z5p1 = [2]
    for kok in range(3, iUIcC + 1, 2):
        if gylEPX6Cg[kok]:
            e42Z5p1.append(kok)
    return e42Z5p1
def divs(iUIcC, start=2):
    e42Z5p1 = []
    for i in range(start, int(math.sqrt(iUIcC) + 1)):
        if (iUIcC % i == 0):
            if (iUIcC / i == i):
                e42Z5p1.append(i)
            else:
                e42Z5p1.extend([i, iUIcC // i])
    return e42Z5p1
def divn(iUIcC, primes):
    uDK2p5T = 1
    for i in primes:
        if iUIcC == 1:
            return uDK2p5T
        INYcCeIc = 1
        while iUIcC % i == 0:
            INYcCeIc += 1
            iUIcC //= i
        uDK2p5T *= INYcCeIc
def gylEPX6Cg(iUIcC):
    if iUIcC == 2: return True
    if iUIcC % 2 == 0 or iUIcC <= 1: return False
    JJXu2_A = int(math.sqrt(iUIcC)) + 1
    for d in range(3, JJXu2_A, 2):
        if iUIcC % d == 0: return False
    return True
def convn(number, base):
    zOXedGg2VI = 0
    while number > 0:
        zOXedGg2VI += number % base
        number //= base
    return zOXedGg2VI
def cdiv(iUIcC, k): return iUIcC // k + (iUIcC % k != 0)


for _ in range(ii()):
    iUIcC = ii()
    pnJMcl = li()
    if iUIcC == 1 and pnJMcl[0] & 1:
        print(-1)
    else:
        for i in range(iUIcC):
            if pnJMcl[i] % 2 == 0:
                print(1)
                print(i + 1)
                break
        else:
            print(2)
            print(1, 2)
</ans>",0,{}
288,"<ans>
Bew5zISg, k = list(map(int, input().split()))
KHQrD  = {}
AaHmc = {}
YFyvoy    = []
OKbn0CFgw    = {}
fTVvLQ5   = {}

def push(d, s, v):
    if s not in d:
        d[s] = []
    d[s].append(v)

def is_pal(s):
    Bew5zISg = len(s)
    zyq=True
    for i in range(Bew5zISg//2):
        if s[i] != s[Bew5zISg-1-i]:
            zyq = False
            break
    return zyq        

def rev(s):
    return s[::-1]

for _ in range(Bew5zISg):
    s, g3Y = input().split()
    g3Y    = int(g3Y)
    
    if is_pal(s):
        push(KHQrD, s, g3Y)
    else:
        push(AaHmc, s, g3Y)
        
        if s not in fTVvLQ5:
            fTVvLQ5[s] = rev(s)

for k, v in list(KHQrD.items()):
    KHQrD[k] = sorted(v, reverse=True)
        
for k, v in list(AaHmc.items()):
    AaHmc[k] = sorted(v, reverse=True)
    
for s in AaHmc:
    if s not in OKbn0CFgw and fTVvLQ5[s] in AaHmc:
        YFyvoy.append([s, fTVvLQ5[s]])
        OKbn0CFgw[s] = True
        OKbn0CFgw[fTVvLQ5[s]] = True
        
I4B = 0
A5nmdo = 0
GeoNF = 0

for v_arr in list(KHQrD.values()):
    Bew5zISg = len(v_arr)
    for i in range(0, Bew5zISg, 2):
        if i+1==Bew5zISg:
            if v_arr[i] > 0:
                I4B = max(I4B, v_arr[i]) 
            
        else:
            if v_arr[i] + v_arr[i+1] >= 0:
                GeoNF += v_arr[i] + v_arr[i+1]
                
                if v_arr[i+1] < 0:
                    A5nmdo = min(A5nmdo, v_arr[i+1])
            else:
                if v_arr[i] > 0:
                    I4B = max(I4B, v_arr[i]) 

for [u, v] in YFyvoy:
    Bew5zISg = min(len(AaHmc[u]), len(AaHmc[v]))
        
    for x, y in  zip(AaHmc[u][:Bew5zISg], AaHmc[v][:Bew5zISg]):
        if x+y > 0:
            GeoNF += x+y
            
print(max(GeoNF+I4B, GeoNF-A5nmdo))            

#7 3
#abb 2
#aaa -3
#bba -1
#zyz -4
#abb 5
#aaa 7
#xyx 4
</ans>",True,{}
289,"<ans>
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    if a%k==0:
        return a//k
    tljz6bC4 = a//k
    #iDskFv2 = (a-tljz6bC4*k)//tljz6bC4 - (1 if (a-tljz6bC4*k)%tljz6bC4==0 else 0)
    return grundy(a-1-tljz6bC4,k)
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    tljz6bC4 = a//k
    I3oULM = (a-tljz6bC4*k)%(tljz6bC4+1)
    if I3oULM==0:
        return a//k
    iDskFv2 = (a-tljz6bC4*k)//(tljz6bC4+1) + 1
    #print(a,k,tljz6bC4,iDskFv2)
    return grundy(a-(tljz6bC4+1)*iDskFv2,k)


""""""
K = 10
N = 50
V = 5
for k in range(V,V+1):
    a = [0]*N
    for i in range(1,N):
        s = set()
        for j in range(1,1+i//k):
            s.add(a[i-j])
        for j in range(N):
            if j not in s:
                a[i] = j
                break
    
    #print(k,a)
    #for i in range(N//V):
    #    print(a[i*V:(i+1)*V])

    
    b = [grundy(i,k) for i in range(N)]
    print(a)
    print(b)
    assert a==b
""""""
# coding: utf-8
# Your code here!
import sys
bYDWRmNJrO = sys.stdin.readline
a5jEQ = sys.stdin.read
sys.setrecursionlimit(10**8)

n, = list(map(int,bYDWRmNJrO().split()))
fhdaEDs = 0
for _ in range(n):
    a,k = list(map(int,bYDWRmNJrO().split()))
    fhdaEDs ^= grundy(a,k)
if fhdaEDs:
    print(""Takahashi"")
else:
    print(""Aoki"")
</ans>",True,{}
290,"<ans>
mYP6P = input()
js7jHQm=[]
Zehlm=''
G0h =0
gpYDcfGiNI =0
sYQCzL9zeX =1 if mYP6P[0]=='""' else 0
for i in range(len(mYP6P)):
    xro53= mYP6P[i]
    if sYQCzL9zeX:
        if Zehlm=='':
            if xro53=='""':
                G0h+=1
                Zehlm = '<'
            elif xro53==' ':
                pass
            else:
                gpYDcfGiNI+=1
                Zehlm='<'+xro53
        elif G0h>0:
            if xro53 =='""':
                Zehlm+='>'
                G0h=0
                js7jHQm.append(Zehlm)
                Zehlm=''
                sYQCzL9zeX=0
            else:
                Zehlm+=xro53
        else:
            if xro53 ==' ':
                if Zehlm!='<':
                    Zehlm+='>'
                    js7jHQm.append(Zehlm)
                    Zehlm=''
                    sYQCzL9zeX=0
            else:
                Zehlm+=xro53
    else:
        if xro53==' ':
            sYQCzL9zeX=1
        elif xro53=='""':
            sYQCzL9zeX=1
            Zehlm='<'
            G0h=1
        else:
            Zehlm='<'+xro53
            sYQCzL9zeX=1
if Zehlm!='':
    Zehlm+='>'
    js7jHQm.append(Zehlm)
for xro53 in js7jHQm:
    print(xro53)
</ans>",True,{}
291,"<ans>
def main1():
    XBPON6 = input()
    nCy = XBPON6.split()
    Hng_rSXz = int(nCy[0])
    rJX = int(nCy[1])
    XBPON6 = input()
    nCy = XBPON6.split()
    qCyr6HJNO = list(map(int, nCy))
    DzYOT2qoxV = []
    CMzfuD = []
    for i in range(Hng_rSXz):
        IfDPz1g = 0
        b_2bqV7Xq = 0
        while b_2bqV7Xq < i:
            if IfDPz1g + DzYOT2qoxV[b_2bqV7Xq] <= rJX - qCyr6HJNO[i]:
                IfDPz1g += DzYOT2qoxV[b_2bqV7Xq]
                b_2bqV7Xq += 1
            else:
                break
        CMzfuD.append(i - b_2bqV7Xq)
        DzYOT2qoxV.append(qCyr6HJNO[i])
        DzYOT2qoxV.sort()
    print(' '.join(list(map(str, CMzfuD))))

def main2():
    XBPON6 = input()
    nCy = XBPON6.split()
    Hng_rSXz = int(nCy[0])
    rJX = int(nCy[1])
    XBPON6 = input()
    nCy = XBPON6.split()
    qCyr6HJNO = list(map(int, nCy))
    VDu = []
    for i in range(101):
        VDu.append(0)
    CMzfuD = []
    for i in range(Hng_rSXz):
        b9p = rJX - qCyr6HJNO[i]
        IfDPz1g = 0
        o_vYdZA = 0
        for j in range(1, 101):
            if o_vYdZA + VDu[j] * j > b9p:
                IfDPz1g += (b9p - o_vYdZA) // j
                break
            else:
                IfDPz1g += VDu[j]
                o_vYdZA += VDu[j] * j
        CMzfuD.append(i - IfDPz1g)
        VDu[qCyr6HJNO[i]] += 1
    print(' '.join(list(map(str, CMzfuD))))

def __starting_point():
    #main1() # for C1
    main2() # for C2

__starting_point()
</ans>",True,{}
292,"<ans>
import itertools
from collections import deque,defaultdict,Counter
from itertools import accumulate
import bisect
from heapq import heappop,heappush,heapify
import math
from copy import deepcopy
import queue
#import numpy as np
# sympy as syp(素因数分解とか)
mcoM = 1000000007
i_vGh = [1, 1]
CEdZQhg1 = [1, 1]
Bh3 = [0, 1] 
for i in range(2, 10**5 + 1):
    i_vGh.append((i_vGh[-1] * i) % mcoM)
    Bh3.append((-Bh3[mcoM % i] * (mcoM // i)) % mcoM)
    CEdZQhg1.append((CEdZQhg1[-1] * Bh3[-1]) % mcoM)
    
def cmb(RlxogMJIWK, oA9l1e5, p):
    if (oA9l1e5 < 0) or (RlxogMJIWK < oA9l1e5):
        return 0
    oA9l1e5 = min(oA9l1e5, RlxogMJIWK - oA9l1e5)
    return i_vGh[RlxogMJIWK] * CEdZQhg1[oA9l1e5] * CEdZQhg1[RlxogMJIWK - oA9l1e5] % p
    
def sieve_of_eratosthenes(RlxogMJIWK):
    if not isinstance(RlxogMJIWK,int):
        raise TypeError(""RlxogMJIWK is not int"")
    if RlxogMJIWK<2:
        raise ValueError(""RlxogMJIWK is not effective"")
    X7eoBBW = [1]*(RlxogMJIWK+1)
    for i in range(2,int(math.sqrt(RlxogMJIWK))+1):
        if X7eoBBW[i] == 1:
            for j in range(2*i,RlxogMJIWK+1):
                if j%i == 0:
                    X7eoBBW[j] = 0
    qBgZ = []
    for i in range(2,RlxogMJIWK+1):
        if X7eoBBW[i] == 1:
            qBgZ.append(i)
    return qBgZ

 
class UnionFind:
    def __init__(self,RlxogMJIWK):
        self.parent = [i for i in range(RlxogMJIWK+1)]
        self.rank = [0 for i in range(RlxogMJIWK+1)]
    
    def findroot(self,x):
        if x == self.parent[x]:
            return x
        else:
            lHoD = self.parent[x]
            lHoD = self.findroot(self.parent[x])
            return lHoD
    
    def union(self,x,lHoD):
        bZ8isMDI4n = self.findroot(x)
        Ktgf = self.findroot(lHoD)
        if bZ8isMDI4n < Ktgf:
            self.parent[lHoD] = bZ8isMDI4n
        else:
            self.parent[bZ8isMDI4n] = Ktgf
 
    def same_group_or_no(x,lHoD):
        return self.findroot(x) == self.findroot(lHoD)
def pow_k(x, RlxogMJIWK):

    if RlxogMJIWK == 0:
        return 1

    P2bg3X4 = 1
    while RlxogMJIWK > 1:
        if RlxogMJIWK % 2 != 0:
            P2bg3X4 *= x
        x *= x
        RlxogMJIWK //= 2

    return P2bg3X4 * x
def main():  #startline-------------------------------------------
    RlxogMJIWK = int(input())
    m6QxF = list(map(int, input().split()))
    LWuLFsa64 = defaultdict(int)
    jx9OKM = 0
    for i in range(RlxogMJIWK):
        C_8 = i - m6QxF[i]
        jx9OKM += LWuLFsa64[C_8]
        LWuLFsa64[m6QxF[i] + i] += 1
        
    print(jx9OKM)
def __starting_point():
    main() #endline===============================================
__starting_point()
</ans>",0,{}
293,"<ans>
#template
import sys
sys.setrecursionlimit(10**9)

BAYNYwF = sys.stdin.BAYNYwF
ADc = sys.stdin.ADc
p3YmiQPX = sys.stdin.p3YmiQPX

DVSv = lambda: int(ADc())
AIwrlx = lambda: map(int,ADc().split())
tXfpXyd95a = lambda: list(map(int,ADc().split()))
ByyRE = lambda h:list(list(map(int,ADc().split())) for _ in range(h))
SeJNq4 = lambda: list(map(str,ADc().rstrip().split()))
xwe25HYbuN = lambda h:list(list(map(str,ADc().rstrip().split())) for _ in range(h))

def read_allints_grid(w):
    NRuES = map(int,BAYNYwF().split())
    NRuES = list(map(list,zip(*(NRuES for _ in range(w)))))
    return NRuES

def read_allstrs_grid(w):
    NRuES = map(str,BAYNYwF().split())
    NRuES = list(map(list,zip(*(NRuES for _ in range(w)))))
    return NRuES

#import
# from copy import deepcopy
# from decimal import Decimal
# from math import ceil,floor
# from collections import deque,Counter
# from heapq import heapify,heappop,heappush
# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement
# from bisect import bisect_left,bisect_right

#solution
def sol():
    return None
def GCD(a:int,b:int)->int:
    '''
    ユークリッドの互除法による最大公約数/O(log min(a,b))
    '''
    if b==0:
        return a
    else:
        return GCD(b,a%b)

def GCD_multi(vec:list)->int:
    '''
    数列の要素の最大公約数を求める/O(N log(a'))
    '''
    EbT = vec[0]
    for i in range(len(vec)-1):
        EbT = GCD(EbT,vec[i+1])
    return EbT

def main():
    #input data
    jJThxeGp2a = DVSv()
    lBfgZCJ = tXfpXyd95a()

    #solve
    print(GCD_multi(lBfgZCJ))

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
294,"<ans>
__author__ = ""Ryabchun Vladimir""


class Stack:
    """"""
    This is a stack class. There is 5 Procedures we can do with stack:
    1. Push - we add one element at the end of the stack
    2. Pop - we remove last element from the stack and return it
    3. Last - We return last element but don't remove it
    4. len() - returns the length of stack(we don't use len() because it's too
    slow).
    5. Clear - remove all elements from stack
    """"""
    def __init__(self, element=None):
        """"""
        self.length - length of the stack. When we append an element we increase it(length) by 1
        __stack - this is our stack. Because we can't get any elements from the stack except the last one
        we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,
        but we mustn't do it).
        :param element: Can be any type
        """"""
        self.length = 0
        if element is None:
            self.__stack = []
        else:
            self.__stack = []
            for el in element:
                self.__stack.append(el)
                self.length += 1

    def push(self, element):
        """"""
        This function adds an element at the end of the stack.
        When we append an element we increase self.length by 1.
        :param element: Can be any type
        :return: NoneType
        """"""
        self.__stack.append(element)
        self.length += 1

    def pop(self):
        """"""
        This function removes an element from the end of the stack and
        returns it's value.
        When we append an element we decrease self.length by 1.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            self.length -= 1
            return self.__stack.pop()

    def last(self):
        """"""
        This function just returns an element from the end of the stack
        but it doesn't remove it.
        :return: Last element from the stack
        """"""
        if self.length == 0:
            raise IndexError(""Stack is empty"")
        else:
            return self.__stack[-1]

    def __len__(self):
        """"""
        This function returns the length of the stack.
        :return: self.length(int)
        """"""
        return self.length

    def clear(self):
        """"""
        Clears the stack.
        :return: NoneType
        """"""
        self.__stack = []

nJwyAC = int(input())
lm_ofA = Stack()
h9LG95 = set()
Bf2 = nJwyAC
VN2Nvqur = list(map(int, input().split()))
for i in VN2Nvqur:
    f5tTzc563s = []
    if i == Bf2:
        lm_ofA.push(i)
        f5tTzc563s.append(i)
        Bf2 -= 1
        while Bf2 in h9LG95:
            lm_ofA.push(Bf2)
            h9LG95.remove(Bf2)
            f5tTzc563s.append(Bf2)
            Bf2 -= 1
    else:
        h9LG95.add(i)
    print(*f5tTzc563s)
</ans>",0,{}
295,"<ans>
```
H,W=map(int,input().split())
Tuq6W = [list(input()) for i in range(H)]
hBymOz2VEO = ""Yes""
h4ts = True

def checkAround(Tuq6WX,i,j):
  if i == 0 and j ==0:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j !=0 and j != W-1:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j-1] == ""#"" or Tuq6W[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == 0 and j == W-1:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == 0:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j+1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == W-1:
    if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j !=0 and j != W-1:
    if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j+1] == ""#"" or Tuq6W[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i == H-1 and j == 0:
    if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
      return True
    else: 
      return False
  elif i != 0 and i != H-1 and j == W-1:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
      return True
    else: 
      return False
  else:
    if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"" or Tuq6W[i][j+1] == ""#"":
      return True
    else: 
      return False

for k in range(H):
  for l in range(W):
    if Tuq6W[k][l] == ""."":
      pass
    else:
      h4ts = checkAround(Tuq6W,k,l)
      if not h4ts:
        hBymOz2VEO = ""No""
        break
  if not h4ts:
    break
print(hBymOz2VEO)
```
</ans>",0,{}
296,"<ans>
import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity

    def bfs(self, s, t):
        xfS3Ig5_eI = [s]

        lgE = set()
        y7tF9Ljq = dict()
        while xfS3Ig5_eI:
            riTVl = []
            for node in xfS3Ig5_eI:
                for v, capacity in list(self.edges[node].items()):
                    if v not in lgE and capacity > 0:
                        riTVl.append(v)
                        y7tF9Ljq[v] = node
                        lgE.add(v)
                        if v == t:
                            VBmdjRM = []
                            JFCzC71b = v
                            ZTH = node
                            while ZTH != s:
                                VBmdjRM.append((ZTH, JFCzC71b))
                                JFCzC71b = ZTH
                                ZTH = y7tF9Ljq[ZTH]
                            VBmdjRM.append((ZTH, JFCzC71b))
                            return VBmdjRM

            xfS3Ig5_eI = riTVl

        return None

    def solve(self, s, t):
        NAw = 0
        QYB_ = self.bfs(s, t)
        while QYB_ is not None:
            Ur1 = float('inf')
            for _, (ZTH, JFCzC71b) in enumerate(QYB_):
                Ur1 = min(Ur1, self.edges[ZTH][JFCzC71b])
            for _, (ZTH, JFCzC71b) in enumerate(QYB_):
                self.edges[ZTH][JFCzC71b] -= Ur1
                self.edges[JFCzC71b][ZTH] += Ur1
            NAw += Ur1

            QYB_ = self.bfs(s, t)

        return NAw

    def __str__(self):
        VBmdjRM = ""{ ""
        for k, v in list(self.edges.items()):
            VBmdjRM += str(k) + "":"" + str(dict(v)) + "", ""
        VBmdjRM += ""}""
        return VBmdjRM


def main():
    (n, m) = tuple([int(x) for x in input().split()])
    nuRDGat = []
    QFhelinh = set()
    E3uW2gmm9U = set()
    for i in range(m):
        (B3cF, Z5P5Us, uyB93RX, L8Fk) = tuple(int(x) for x in input().split())
        nuRDGat.append((B3cF, Z5P5Us, uyB93RX, L8Fk))
        QFhelinh.add(B3cF)
        QFhelinh.add(uyB93RX + 1)
        E3uW2gmm9U.add(Z5P5Us)
        E3uW2gmm9U.add(L8Fk + 1)

    B4OahV = sorted(QFhelinh)
    Jxi = sorted(E3uW2gmm9U)
    FGzDDp = len(QFhelinh)
    yYOz = len(E3uW2gmm9U)
    UALmI1LSxq = []
    for i in range(yYOz):
        UALmI1LSxq.append([False] * FGzDDp)

    for rect in nuRDGat:
        B3cF = rect[0]
        Z5P5Us = rect[1]
        uyB93RX = rect[2]
        L8Fk = rect[3]
        for i, y in enumerate(Jxi):
            for j, x in enumerate(B4OahV):
                if B3cF <= x and Z5P5Us <= y and uyB93RX >= x and L8Fk >= y:
                    UALmI1LSxq[i][j] = True

    zF6apS = MaxFlow()
    for i in range(len(Jxi)):
        for j in range(len(B4OahV)):
            if UALmI1LSxq[i][j]:
                zF6apS.add_edge(1 + i, len(Jxi) + 1 + j, float('inf'))
    for i in range(len(Jxi) - 1):
        zF6apS.add_edge(0, i + 1, Jxi[i + 1] - Jxi[i])
    for i in range(len(B4OahV) - 1):
        zF6apS.add_edge(len(Jxi) + 1 + i, len(B4OahV) + len(Jxi) + 1, B4OahV[i + 1] - B4OahV[i])

    # print(B4OahV)
    # print(Jxi)
    # print(zF6apS)
    print(zF6apS.solve(0, len(B4OahV) + len(Jxi) + 1))


def __starting_point():
    main()

__starting_point()
</ans>",True,{}
297,"<ans>
```
""""""
#If FastIO not needed, used this and don't forget to strip
#import sys, math
#XNxmDYJruI = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right

from types import GeneratorType
Rp5LRc = 8192
class FastIO(IOBase):
    NltnSS = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            pEQze30 = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, Rp5LRc))
            if not pEQze30:
                break
            YbqcS = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(pEQze30), self.buffer.seek(YbqcS)
        self.NltnSS = 0
        return self.buffer.read()
 
    def readline(self):
        while self.NltnSS == 0:
            pEQze30 = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, Rp5LRc))
            self.NltnSS = pEQze30.count(b""\n"") + (not pEQze30)
            YbqcS = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(pEQze30), self.buffer.seek(YbqcS)
        self.NltnSS -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
XNxmDYJruI = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string


def getInts():
    return [int(s) for s in XNxmDYJruI().split()]

def getInt():
    return int(XNxmDYJruI())

def getStrs():
    return [s for s in XNxmDYJruI().split()]

def getStr():
    return XNxmDYJruI()

def listStr():
    return list(XNxmDYJruI())

def getMat(n):
    return [getInts() for _ in range(n)]

v1p0SuOO = 10**9+7


""""""
Each edge goes from parent U to child V
Edge appears on S_V * (N - S_V) paths

For each path of length L, (L + (-L)%K)/K


L%K 0, 1, 2, 3, 4
(K - L%K)%K K K-1 K-2 ...
0 K-1 K-2 ...

""""""
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            Qo60lQhwI = f(*args, **kwargs)
            while True:
                if type(Qo60lQhwI) is GeneratorType:
                    stack.append(Qo60lQhwI)
                    Qo60lQhwI = next(Qo60lQhwI)
                else:
                    stack.pop()
                    if not stack:
                        break
                    Qo60lQhwI = stack[-1].send(Qo60lQhwI)
            return Qo60lQhwI
    return wrappedfunc

def solve():
    N, K = getInts()
    C9Yvqtz = dd(set)
    for i in range(N-1):
        A, B = getInts()
        C9Yvqtz[A].add(B)
        C9Yvqtz[B].add(A)
    Yr7cLeF1 = [[0 for j in range(5)] for i in range(N+1)]
    ZHbnkTX_Ra = [0 for j in range(N+1)]
    nonlocal g1w
    g1w = 0
    @bootstrap
    def dfs(node,parent,depth):
        nonlocal g1w
        Yr7cLeF1[node][depth % K] = 1
        ZHbnkTX_Ra[node] = 1
        for neigh in C9Yvqtz[node]:
            if neigh != parent:
                yield dfs(neigh,node,depth+1)
                for i in range(K):
                    for j in range(K):
                        pDf = (i+j-2*depth)%K
                        V8bm = (-pDf)%K
                        g1w += V8bm * Yr7cLeF1[node][i] * Yr7cLeF1[neigh][j]
                for i in range(K):
                    Yr7cLeF1[node][i] += Yr7cLeF1[neigh][i]
                ZHbnkTX_Ra[node] += ZHbnkTX_Ra[neigh]
        g1w += ZHbnkTX_Ra[node] * (N - ZHbnkTX_Ra[node])
        yield
    dfs(1,-1,0)
    return g1w//K
    
    
print(solve())
</ans>",0,{}
298,"<ans>
import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy


class UnionFind:

    def __init__(self, n: int):
        self._n = n
        self._parents = [i for i in range(n)]
        self._size = [1 for _ in range(n)]

    def unite(self, x: int, y: int) -> None:
        RkgiuwNqdt = self.find(x)
        Nte = self.find(y)

        # 一致していないときはリンクをつける
        if RkgiuwNqdt != Nte:
            self._link(RkgiuwNqdt, Nte)

    def _link(self, x: int, y: int):
        if self._size[x] < self._size[y]:
            self._parents[x] = y
            self._size[y] += self._size[x]
        else:
            self._parents[y] = x
            self._size[x] += self._size[y]

    def same(self, x: int, y: int) -> bool:
        RkgiuwNqdt = self.find(x)
        Nte = self.find(y)
        return RkgiuwNqdt == Nte

    def find(self, x: int) -> int:
        if self._parents[x] == x:
            return x

        self._parents[x] = self.find(self._parents[x])
        return self._parents[x]

    def size(self, x: int):
        return self._size[self.find(self._parents[x])]

N, K, L = map(int, input().split())

kyAl = UnionFind(N + 1)
xDNaDcH0 = UnionFind(N + 1)
GIX53c = UnionFind(N + 1)

Drql = [list(map(int, input().split())) for _ in range(K)]
S98fjYg = [list(map(int, input().split())) for _ in range(L)]

for i in range(K):
    p, q = Drql[i]
    kyAl.unite(p, q)

for i in range(L):
    r, s = S98fjYg[i]
    xDNaDcH0.unite(r, s)

Belt_c = {}

for i in range(1, N + 1):
    B3ey = Belt_c.get((kyAl.find(i), xDNaDcH0.find(i)), 0)
    Belt_c[(kyAl.find(i), xDNaDcH0.find(i))] = B3ey + 1

HGWu40 = [0] * N
for i in range(N):
    HGWu40[i] = Belt_c[(kyAl.find(i + 1), xDNaDcH0.find(i + 1))]

print(*HGWu40)
</ans>",True,{}
299,"<ans>
import sys

UN61xrm72 = (int)(1e9+7)

def add(a, b):
	a += b
	if a >= UN61xrm72: a -= UN61xrm72
	return a
	
def mul(a, b):
	return (a * b) % UN61xrm72

class fenwickTree:
	def __init__(self, max_val):
		self.max_val = max_val + 5
		self.tree = [0] * self.max_val
	
	def update(self, idx, value):
		idx += 1
		while idx < self.max_val:
			self.tree[idx] = add(self.tree[idx], value)
			idx += (idx & (-idx))
	
	def read(self, idx):
		idx += 1
		r7RBC8HUBR = 0
		while idx > 0:
			r7RBC8HUBR = add(r7RBC8HUBR, self.tree[idx])
			idx -= (idx & (-idx))
		return r7RBC8HUBR

u9EkJA = [int(x) for x in sys.stdin.read().split()]

twzSMc = u9EkJA[0]
WvnBSVrvY = []
for i in range(1, twzSMc + 1):
	WvnBSVrvY.append(u9EkJA[i])
	
pj7ISspe = sorted(WvnBSVrvY)
Kjdyxjyed3 = {}
for i in range(twzSMc):
	Kjdyxjyed3[pj7ISspe[i]] = i
	
p30QwO = [0] * twzSMc
for i in range(0, twzSMc):
	p30QwO[i] = mul(i + 1, twzSMc - i)
	
tPIr_ = fenwickTree(twzSMc)
for i in range(0, twzSMc):
	ljf = Kjdyxjyed3[WvnBSVrvY[i]]
	p30QwO[i] = add(p30QwO[i], mul(twzSMc - i, tPIr_.read(ljf)))
	tPIr_.update(ljf, i + 1)
	
h2x54V5IB = fenwickTree(twzSMc)
for i in range(twzSMc - 1, -1, -1):
	ljf = Kjdyxjyed3[WvnBSVrvY[i]]
	p30QwO[i] = add(p30QwO[i], mul(i + 1, h2x54V5IB.read(ljf)))
	h2x54V5IB.update(ljf, twzSMc - i)

XK7fzw6 = 0
for i in range(twzSMc):
	XK7fzw6 = add(XK7fzw6, mul(WvnBSVrvY[i], p30QwO[i]))
print(XK7fzw6)
</ans>",0,{}
300,"<ans>
import sys 
wpk = lambda: sys.stdin.readline().strip()

def f(A, r, c, l):
  q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
  x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]

  #print(r, c, x,y,z,l, q,w,e)
  if x != y and y != z and e >= l and  w == q == l:
    return (l, z, y, x)
  else:
    return 0
  
  ",0,{}
301,"<ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)


class TreapNode:
    rYoc46AZpH = None
    HOw4 = None
    Pjzp = None
    j21rpg0r_P = None
    rEdQX7 = None

    def __init__(self, value):
        self.rYoc46AZpH = value
        self.HOw4 = random()
        self.Pjzp = 1


def treap_rotate_right(aW1):
    unlFt = aW1.j21rpg0r_P
    aW1.j21rpg0r_P = unlFt.rEdQX7
    unlFt.rEdQX7 = aW1
    return unlFt


def treap_rotate_left(aW1):
    mJBd5PXLM = aW1.rEdQX7
    aW1.rEdQX7 = mJBd5PXLM.j21rpg0r_P
    mJBd5PXLM.j21rpg0r_P = aW1
    return mJBd5PXLM


def treap_insert(aW1, v):
    if aW1 is None:
        return TreapNode(v)
    if aW1.rYoc46AZpH == v:
        aW1.Pjzp += 1
        return aW1
    if aW1.rYoc46AZpH > v:
        aW1.j21rpg0r_P = treap_insert(aW1.j21rpg0r_P, v)
        if aW1.HOw4 > aW1.j21rpg0r_P.HOw4:
            aW1 = treap_rotate_right(aW1)
    else:
        aW1.rEdQX7 = treap_insert(aW1.rEdQX7, v)
        if aW1.HOw4 > aW1.rEdQX7.HOw4:
            aW1 = treap_rotate_left(aW1)
    return aW1


def treap_delete(aW1, v):
    if aW1 is None:
        raise Exception('no nodes')
    if aW1.rYoc46AZpH > v:
        aW1.j21rpg0r_P = treap_delete(aW1.j21rpg0r_P, v)
        return aW1
    if aW1.rYoc46AZpH < v:
        aW1.rEdQX7 = treap_delete(aW1.rEdQX7, v)
        return aW1

    # aW1.rYoc46AZpH == v
    if aW1.Pjzp > 1:
        aW1.Pjzp -= 1
        return aW1

    if aW1.j21rpg0r_P is None and aW1.rEdQX7 is None:
        return None

    if aW1.j21rpg0r_P is None:
        aW1 = treap_rotate_left(aW1)
    elif aW1.rEdQX7 is None:
        aW1 = treap_rotate_right(aW1)
    else:
        # aW1.j21rpg0r_P is not None and aW1.rEdQX7 is not None
        if aW1.j21rpg0r_P.HOw4 < aW1.rEdQX7.HOw4:
            aW1 = treap_rotate_right(aW1)
        else:
            aW1 = treap_rotate_left(aW1)
    return treap_delete(aW1, v)


def treap_size(aW1):
    if aW1 is None:
        return 0
    return aW1.Pjzp + treap_size(aW1.j21rpg0r_P) + treap_size(aW1.rEdQX7)


def treap_str(aW1):
    if aW1 is None:
        return """"
    YPP1sx = []
    if aW1.j21rpg0r_P is not None:
        YPP1sx.append(treap_str(aW1.j21rpg0r_P))
    YPP1sx.append(""%d:%d"" % (aW1.rYoc46AZpH, aW1.Pjzp))
    if aW1.rEdQX7 is not None:
        YPP1sx.append(treap_str(aW1.rEdQX7))
    return ' '.join(YPP1sx)


def treap_search(aW1, v):
    # v 未満で最大のノードを検索する. v 未満のノードがなければ None を返す
    if aW1 is None:
        return None
    if aW1.rYoc46AZpH >= v:
        if aW1.j21rpg0r_P is None:
            return None
        return treap_search(aW1.j21rpg0r_P, v)
    # aW1.rYoc46AZpH < v
    if aW1.rEdQX7 is None:
        return aW1
    mJBd5PXLM = treap_search(aW1.rEdQX7, v)
    if mJBd5PXLM is None:
        return aW1
    return mJBd5PXLM


class Treap:
    XZIi = None
    UEV9D = 0

    def insert(self, v):
        self.XZIi = treap_insert(self.XZIi, v)
        self.UEV9D += 1

    def delete(self, v):
        self.XZIi = treap_delete(self.XZIi, v)
        self.UEV9D -= 1

    def __len__(self):
        return self.UEV9D

    def __str__(self):
        return treap_str(self.XZIi)

    def search(self, v):
        return treap_search(self.XZIi, v)


_QprCnF = int(input())
uJqpm1K2I = [int(input()) for _ in range(_QprCnF)]

KIB05ZlA = Treap()
for a in uJqpm1K2I:
    aW1 = KIB05ZlA.search(a)
    if aW1 is not None:
        KIB05ZlA.delete(aW1.rYoc46AZpH)
    KIB05ZlA.insert(a)
print((len(KIB05ZlA)))
</ans>",0,{}
302,"<ans>
def _3():
    from collections import defaultdict

    def can_pair(s1, s2):
        G7H4qILn2 = []
        for c1, c2 in zip(s1, s2):
            tgJ = sorted([c1, c2])
            if tgJ in G7H4qILn2:
                G7H4qILn2.remove(tgJ)
            else:
                G7H4qILn2.append(tgJ)

        if len(s1) % 2 == 0:
            return len(G7H4qILn2) == 0
        else:
            return len(G7H4qILn2) == 1 and G7H4qILn2[0][0] == G7H4qILn2[0][1]

    def pair_graph(s1, s2):
        nXi9a = len(s1)
        SQYsk = np.zeros([nXi9a, nXi9a])
        for i in range(nXi9a):
            for j in range(i+1, nXi9a):
                if s1[i] == s2[j] and s1[j] == s2[i]:
                    SQYsk[i, j] = 1
                    SQYsk[j, i] = 1
        return SQYsk

    import numpy as np
    H, W = list(map(int, input().split(' ')))
    dyW = []
    X7HErrcj = defaultdict(list)

    for h in range(H):
        nT7 = input()
        dyW.append(nT7)
        X7HErrcj[''.join(sorted(dyW))].append(h)

    MrXYjl1rVG = np.zeros(H)

    Sb7UWM6UX = []

    for i in range(H):
        if MrXYjl1rVG[i]:
            continue

        for j in range(i+1, H):
            if MrXYjl1rVG[j]:
                continue

            if can_pair(dyW[i], dyW[j]):
                MrXYjl1rVG[i] = 1
                MrXYjl1rVG[j] = 1
                SQYsk = pair_graph(dyW[i], dyW[j])
                Sb7UWM6UX.append(SQYsk)
                break

    if MrXYjl1rVG.sum() < H - 1:
        print('NO')
        return

    elif MrXYjl1rVG.sum() == H - 1:
        for i in range(H):
            if MrXYjl1rVG[i] == 0:
                SQYsk = pair_graph(dyW[i], dyW[i])
                Sb7UWM6UX.append(SQYsk)
                break

    SQYsk = np.array(Sb7UWM6UX).sum(axis=0) // len(Sb7UWM6UX)

    def is_perfect_matching(SQYsk):
        nXi9a = len(SQYsk)
        if nXi9a == 1:
            return True

        for i in range(nXi9a):
            for j in range(i+1, nXi9a):
                if SQYsk[i, j] == 1:
                    G7H4qILn2 = list(range(nXi9a))
                    G7H4qILn2.remove(i)
                    G7H4qILn2.remove(j)
                    if len(G7H4qILn2) == 0:
                        return True
                    if is_perfect_matching(SQYsk[G7H4qILn2][:, G7H4qILn2]):
                        return True
        return False

    if is_perfect_matching(SQYsk):
        print('YES')
    else:
        print('NO')

def __starting_point():
    _3()
__starting_point()
</ans>",True,{}
303,"<ans>
import sys
t38R = sys.stdin.readline

def accumulate2d(X):
    z77VN = len(X)
    GtucSvt9mP = len(X[0])
    
    for i in range(0, z77VN):
        for j in range(1, GtucSvt9mP):
            X[i][j] += X[i][j-1]
    
    for j in range(0, GtucSvt9mP):
        for i in range(1, z77VN):
            X[i][j] += X[i-1][j]
    
    return X

z77VN, GtucSvt9mP, Q = map(int, t38R().split())
b6QThiEe = [None]*100
b6QThiEe[ord('R')] = 0
b6QThiEe[ord('G')] = 1
b6QThiEe[ord('B')] = 2
b6QThiEe[ord('Y')] = 3

QO3oeuoS = 10**3
_aSL = [[b6QThiEe[ord(s)] for s in t38R().strip()] for _ in range(z77VN)]
vYZsfM = [[0]*GtucSvt9mP for _ in range(z77VN)]

H7a = 25
UATM4kubM = []
WQ7ZhV4TD = GtucSvt9mP
for i in range(z77VN-1):
    for j in range(GtucSvt9mP-1):
        if _aSL[i][j] == 0 and _aSL[i][j+1] == 1 and _aSL[i+1][j+1] == 2 and _aSL[i+1][j] == 3:
            vYZsfM[i][j] = 1
            nh, nw = i, j
            while True:
                Pur = vYZsfM[nh][nw]
                fh, fw = nh-Pur, nw-Pur
                XN_oVxK = 2*(Pur+1)
                JGW = Pur+1
                if fh < 0 or fw < 0 or z77VN < fh+XN_oVxK-1 or GtucSvt9mP < fw+XN_oVxK-1:
                    break
                if any(_aSL[fh][j] != 0 for j in range(fw, fw+JGW)) or\
                any(_aSL[j][fw] != 0 for j in range(fh, fh+JGW)) or\
                any(_aSL[fh][j] != 1 for j in range(fw+JGW, fw+XN_oVxK)) or\
                any(_aSL[j][fw+XN_oVxK-1] != 1 for j in range(fh, fh+JGW)) or\
                any(_aSL[j][fw+XN_oVxK-1] != 2 for j in range(fh+JGW, fh+XN_oVxK)) or\
                any(_aSL[fh+XN_oVxK-1][j] != 2 for j in range(fw+JGW, fw+XN_oVxK)) or\
                any(_aSL[fh+XN_oVxK-1][j] != 3 for j in range(fw, fw+JGW)) or\
                any(_aSL[j][fw] != 3 for j in range(fh+JGW, fh+XN_oVxK)):
                    break
                vYZsfM[nh][nw] += 1
            if vYZsfM[nh][nw] > H7a:
                UATM4kubM.append((nh, nw))

 
K_NcJa = [None] + [[[0]*GtucSvt9mP for _ in range(z77VN)] for _ in range(H7a)]
for h in range(z77VN):
    for w in range(GtucSvt9mP):
        if vYZsfM[h][w] > 0:
            for Pur in range(1, min(H7a, vYZsfM[h][w])+1):
                K_NcJa[Pur][h][w] = 1

K_NcJa = [None] + [accumulate2d(g) for g in K_NcJa[1:]]


EiD2rg = [None]*Q
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, t38R().split())
    nOU = 0
    for Pur in range(min(H7a, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+Pur-1, w1+Pur-1
        he, we = h2-Pur, w2-Pur
        if hs <= he and ws <= we:
            SISX = K_NcJa[Pur][he][we]
            if hs:
                SISX -= K_NcJa[Pur][hs-1][we]
            if ws:
                SISX -= K_NcJa[Pur][he][ws-1]
            if hs and ws:
                SISX += K_NcJa[Pur][hs-1][ws-1]
            if SISX:
                nOU = Pur
                break
    
    for nh, nw in UATM4kubM:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            nOU = max(nOU, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, vYZsfM[nh][nw]))
    EiD2rg[qu] = 4*nOU**2
print('\n'.join(map(str, EiD2rg)))
</ans>",0,{}
304,"<ans>
# problem http://codeforces.com/contest/1100/problem/E
import copy
import sys


def find_loop(Gw02Lv3x, BGZNz, k, n):
    jUcng = [False] * n
    ANugMJxF21 = [False] * n
    for i in range(n):
        if jUcng[i]:
            continue
        MqD2AF = [Gw02Lv3x[i][:]]
        H4ACx = [i]
        jUcng[i] = True
        ANugMJxF21[i] = True
        while MqD2AF:
            if not MqD2AF[-1]:
                MqD2AF.pop()
                ANugMJxF21[H4ACx[-1]] = False
                H4ACx.pop()
                continue
            UFDGuvxUQ = MqD2AF[-1][-1]
            MqD2AF[-1].pop()
            if BGZNz[(H4ACx[-1], UFDGuvxUQ)] <= k:
                continue
            if ANugMJxF21[UFDGuvxUQ]:
                return True
            if jUcng[UFDGuvxUQ]:
                continue
            jUcng[UFDGuvxUQ] = True
            ANugMJxF21[UFDGuvxUQ] = True
            MqD2AF.append(Gw02Lv3x[UFDGuvxUQ][:])
            H4ACx.append(UFDGuvxUQ)
    return False


def top_sort(Gw02Lv3x, BGZNz, k, n):
    jUcng = [False] * n
    MSWHqVB = [-1] * n
    fafKy_Y = 0
    for i in range(n):
        if jUcng[i]:
            continue
        MqD2AF = [Gw02Lv3x[i][:]]
        H4ACx = [i]
        jUcng[i] = True
        while MqD2AF:
            if not MqD2AF[-1]:
                MSWHqVB[H4ACx[-1]] = fafKy_Y
                H4ACx.pop()
                MqD2AF.pop()
                fafKy_Y += 1
                continue
            UFDGuvxUQ = MqD2AF[-1][-1]
            MqD2AF[-1].pop()
            if BGZNz[(H4ACx[-1], UFDGuvxUQ)] <= k:
                continue
            if jUcng[UFDGuvxUQ]:
                continue
            jUcng[UFDGuvxUQ] = True
            MqD2AF.append(Gw02Lv3x[UFDGuvxUQ][:])
            H4ACx.append(UFDGuvxUQ)

    HQfR3PD = []
    for a, b in list(BGZNz.items()):
        if b > k:
            continue
        if MSWHqVB[a[0]] < MSWHqVB[a[1]]:
            HQfR3PD.append(a)
    return HQfR3PD


def __starting_point():
    n, n4abUB31cJ = list(map(int, input().split()))
    BGZNz = {}
    Gw02Lv3x = [[] for _ in range(n)]
    mGv = {}
    u6EvaS = 0
    SNrrf = [0]
    Ql7rWYr = sys.stdin.readlines()
    for i, line in enumerate(Ql7rWYr): #range(1, m + 1):
        u, v, c = list(map(int, line.split()))
        Gw02Lv3x[u - 1].append(v - 1)
        if (u - 1, v - 1) in list(BGZNz.keys()):
            BGZNz[(u - 1, v - 1)] = max(BGZNz[(u - 1, v - 1)], c)
        else:
            BGZNz[(u - 1, v - 1)] = c
        if (u - 1, v - 1) in list(mGv.keys()):
            mGv[(u - 1, v - 1)].append(str(i + 1))
        else:
            mGv[(u - 1, v - 1)] = [str(i + 1)]
        SNrrf.append(c)
        # u6EvaS = max(c, u6EvaS)

    # print(find_loop(copy.deepcopy(Gw02Lv3x), copy.deepcopy(BGZNz), 0, n))

    SNrrf.sort()
    TOf_MKWB, nLx_ = 0, len(SNrrf)
    if not find_loop(Gw02Lv3x, BGZNz, SNrrf[TOf_MKWB], n):
        print(0, 0)
        return
    if find_loop(Gw02Lv3x, BGZNz, SNrrf[-1], n):
        jRokB0Dk7 = SNrrf[-1]
    else:
        while TOf_MKWB + 1 != nLx_:
            n4abUB31cJ = int((TOf_MKWB + nLx_) / 2)
            # if find_loop(copy.deepcopy(Gw02Lv3x), copy.deepcopy(BGZNz), SNrrf[n4abUB31cJ], n):
            if find_loop(Gw02Lv3x, BGZNz, SNrrf[n4abUB31cJ], n):
                TOf_MKWB = n4abUB31cJ
            else:
                nLx_ = n4abUB31cJ
        jRokB0Dk7 = SNrrf[TOf_MKWB+1]

    HQfR3PD = top_sort(Gw02Lv3x, BGZNz, jRokB0Dk7, n)
    PYdCgBfzU = 0
    sf26UJ = []
    for t in HQfR3PD:
        PYdCgBfzU += len(mGv[t])
        sf26UJ.extend(mGv[t])

    print(jRokB0Dk7, PYdCgBfzU)
    print("" "".join(sf26UJ))",0,{}
305,"<ans>
QknPR05 = list(map(int,input().split()))
IOYDe = [0,0,0,0,0];
AIDep = [0,0,0,0,0];
XPcj6xLerY = [];
MXXwlk = [];
pdc3AuE = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}

d2f4mZ = int(input())

for i in range(1,d2f4mZ+1) :
    NlAHoHfutL = input()
    XPcj6xLerY.append(NlAHoHfutL)
    MXXwlk.append(NlAHoHfutL)
    if NlAHoHfutL.find(',') == -1 :
        QknPR05[pdc3AuE[NlAHoHfutL]] -= 1
    else :
        IOYDe[pdc3AuE[NlAHoHfutL[0:NlAHoHfutL.find(',')]]] += 1

MXXwlk = False;

for i in range(0,6) :
    if (QknPR05[i] < 0) and MXXwlk == False:
        MXXwlk = True
    elif i < 5:
        if i==0 :
            if IOYDe[i] > QknPR05[i] :
                AIDep[i] = IOYDe[i] - QknPR05[i];
                IOYDe[i] -= QknPR05[i];
                QknPR05[i] = 0;
            else :
                AIDep[i] = 0;
                QknPR05[i] -= IOYDe[i];
                IOYDe[i] = 0;
                
        else :
            if IOYDe[i-1] > 0 :
                if IOYDe[i-1] > QknPR05[i] :
                    MXXwlk = True
                else :
                    QknPR05[i] -= IOYDe[i-1];
            if IOYDe[i] > QknPR05[i] :
                AIDep[i] = IOYDe[i] - QknPR05[i];
                IOYDe[i] -= QknPR05[i];
                QknPR05[i] = 0;
            else :
                AIDep[i] = 0;
                QknPR05[i] -= IOYDe[i];
                IOYDe[i] = 0;
    elif i==5 :
        if QknPR05[i] < IOYDe[i-1]:
            MXXwlk = True
                
if MXXwlk == True :
    print(""NO"");

else :
    print(""YES"")
    for i in XPcj6xLerY :
        if i.find(',') == -1 :
            print(i)
        else :
            pOLpb = i[0:i.find(',')];
            if (AIDep[pdc3AuE[pOLpb]] > 0) :
                print(i[i.find(',')+1:])
                AIDep[pdc3AuE[pOLpb]] -= 1
            else :
                print(pOLpb)
</ans>",True,{}
306,"<ans>
n, m = list(map(int, input().split()))
QIV2QQ3ALL = list(map(int, input().split()))
if n > 300:
    aRg5_ = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        aRg5_.append([a, b])
    kVVpVYbn = 0
    DHnXn = []
    i91X0it = [[-1, -10**6]]
    for i in range(max(0, m-1)):
        i91X0it.append([-1, -10**6])
    for u in range(n):
        if QIV2QQ3ALL[u] > min(i91X0it)[1]:
            i91X0it[i91X0it.index(min(i91X0it))] = [u, QIV2QQ3ALL[u]]
    for i, mi in i91X0it:
        i0Aha = QIV2QQ3ALL.copy()
        kk8i2kRZSi = []
        for j in range(m):
            a, b = aRg5_[j][0], aRg5_[j][1]
            if a <= i + 1 <= b:
                kk8i2kRZSi.append(j + 1)
                for q in range(a - 1, b):
                    i0Aha[q] -= 1
        Rhy7O3wF = max(i0Aha)
        if kVVpVYbn < Rhy7O3wF - mi:
            kVVpVYbn = Rhy7O3wF - mi
            DHnXn = kk8i2kRZSi.copy()
    print(kVVpVYbn)
    print(len(DHnXn))
    print(' '.join(map(str, DHnXn)))
else:
    aRg5_ = []
    for i in range(m):
        a, b = list(map(int, input().split()))
        aRg5_.append([a, b])
    kVVpVYbn = 0
    DHnXn = []
    for i in range(n):
        i0Aha = QIV2QQ3ALL.copy()
        kk8i2kRZSi = []
        for j in range(m):
            a, b = aRg5_[j][0], aRg5_[j][1]
            if a <= i + 1 <= b:
                kk8i2kRZSi.append(j + 1)
                for q in range(a - 1, b):
                    i0Aha[q] -= 1
        Rhy7O3wF = max(i0Aha)
        if kVVpVYbn < Rhy7O3wF - i0Aha[i]:
            kVVpVYbn = Rhy7O3wF - i0Aha[i]
            DHnXn = kk8i2kRZSi.copy()
    print(kVVpVYbn)
    print(len(DHnXn))
    print(' '.join(map(str, DHnXn)))
</ans>",True,{}
307,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,EOQSBRT,Q618Z=[]):
        #print(v,end="" "")
        EOQSBRT[v]=True
        for z7RwhCsmUn in self.adj_list[v]:
            if EOQSBRT[z7RwhCsmUn]==False:
                self.dfsUTIL(z7RwhCsmUn,EOQSBRT,Q618Z)
                Q618Z.append(z7RwhCsmUn)        
    
    def dfs(self,v):
        EOQSBRT=[False]*(max(self.adj_list)+1)
        Q618Z=[v]
        self.dfsUTIL(v,EOQSBRT,Q618Z)
        return len(Q618Z)
        
        
        
#####sorting a dictionary by the values#####
def dict_sort(kRgjV7n2Nz):
    kRgjV7n2Nz=sorted(list(kRgjV7n2Nz.items()),reverse=True,key=lambda kv:(kv[1]))
##### naive method for testing prime or not O(n^.5)#####
def is_prime(nND):
    if nND==1:
        return 0
    for z7RwhCsmUn in range(2,int(math.sqrt(nND))+1):
        if nND%z7RwhCsmUn==0:
            return False
    return True
#####swap function#####
def swap(xEyX8du0D,pDe):
    V9Bg3FhXBT=xEyX8du0D
    xEyX8du0D=pDe
    pDe=V9Bg3FhXBT
    return xEyX8du0D,pDe
#####Primes till Nth O(n)#####
def seive_primes(nND):
    uLA_1=[0]*(nND+10)
    uLA_1[1]=uLA_1[0]=1
    z7RwhCsmUn=2
    while z7RwhCsmUn*z7RwhCsmUn<=nND+1:
        if uLA_1[z7RwhCsmUn]==0:
            J4vt0fSL=z7RwhCsmUn*z7RwhCsmUn
            while J4vt0fSL<=nND+1:
                uLA_1[J4vt0fSL]=1
                J4vt0fSL+=z7RwhCsmUn
        z7RwhCsmUn+=1
    return uLA_1
#####greatest common divisor of two numbers#####
def gcd(xEyX8du0D,pDe):
    if pDe==0:
        return xEyX8du0D
    return gcd(pDe,xEyX8du0D%pDe)
#####least common multiplyer of two numbers#####
def lcm(xEyX8du0D,pDe):
    return (xEyX8du0D*pDe)//gcd(xEyX8du0D,pDe)
#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""
#####binary search O(logN)#####
def binary_search(RTk24CE8,nND,uLA_1):
    YlfWwkp=0
    Ac3z=nND-1
    while(YlfWwkp<=Ac3z):
        zRxMB9_T2=(YlfWwkp+Ac3z)//2
        if RTk24CE8[zRxMB9_T2]==uLA_1:
            return zRxMB9_T2
        elif RTk24CE8[zRxMB9_T2]>uLA_1:
            Ac3z=zRxMB9_T2-1
        else:
            YlfWwkp=zRxMB9_T2+1
    return -1
#####quadratic#####
def qdrt(xEyX8du0D,pDe,DrRfk):
    jj_sm=pDe*pDe-4*xEyX8du0D*DrRfk
    if jj_sm>=0:
        _EDgBrF4k=(-pDe+jj_sm**0.5)/(2*xEyX8du0D)
        QmPil=(-pDe-jj_sm**0.5)/(2*xEyX8du0D)
        return [int(_EDgBrF4k),int(QmPil)]
    return -1
#####taking an array/list as input#####
def inp():
    RTk24CE8=list(map(int,input().split()))
    return RTk24CE8
#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))
#####Main function starts from here#####
nND=int(input())
hHcnr7={}
while(nND%2==0):
    if 2 in hHcnr7:
        hHcnr7[2]+=1
    else:
        hHcnr7[2]=1
    nND/=2
for z7RwhCsmUn in range(3,int(nND**0.5)+1,2):
    while(nND%z7RwhCsmUn==0):
        if z7RwhCsmUn in hHcnr7:
            hHcnr7[z7RwhCsmUn]+=1
        else:
            hHcnr7[z7RwhCsmUn]=1
        nND/=z7RwhCsmUn
nND=int(nND)
if nND>1:
    hHcnr7[nND]=1
nND=1
#print(hHcnr7,nND)
kRgjV7n2Nz=0
for z7RwhCsmUn in hHcnr7:
    DrRfk=-2*hHcnr7[z7RwhCsmUn]
    xEyX8du0D=pDe=1
    RTk24CE8=qdrt(xEyX8du0D,pDe,DrRfk)
    if RTk24CE8[0]>=0:
        kRgjV7n2Nz+=RTk24CE8[0]
    elif RTk24CE8[1]>=0:
        kRgjV7n2Nz+=RTk24CE8[1]
print(kRgjV7n2Nz)
    

    
    
    
            
    
    

</ans>",0,{}
308,"<ans>
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
# set型だと、 | と & が使えるよ
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
sxAEA = 10**9 + 7
# sxAEA = 9982443453
# sxAEA = 998244353
yRyI13 = float('inf')
vBF5x8ae = [0,1,0,-1]
uRHG = [1,0,-1,0]
from sys import stdin
K3m = stdin.readline
def readInts():
  return list(map(int,K3m().split()))
def readTuples():
    return tuple(map(int,K3m().split()))
def I():
    return int(K3m())
nSdLx, S = input().split()
nSdLx = int(nSdLx)
gnnWd = 0
for i in range(nSdLx):
    FInNw = 0;Cjj18rl = 0;C86loso = 0;wXuEv = 0;
    for j in range(i,nSdLx):
        if S[j] == 'A':
            FInNw += 1
        elif S[j] == 'T':
            Cjj18rl += 1
        elif S[j] == 'C':
            C86loso += 1
        else:
            wXuEv += 1
        if FInNw == Cjj18rl and C86loso == wXuEv:
            gnnWd += 1
print(gnnWd)
</ans>",0,{}
309,"<ans>
from collections import deque
import math
    
def dfs(knO2qXS9J, s):
    Ws1cKX = deque([s])
    mqc3Pw  = {s}
    while Ws1cKX:
        BprebA7o = Ws1cKX.pop()
        for y in knO2qXS9J[BprebA7o]:
            if y not in mqc3Pw:
                mqc3Pw.add(y)
                Ws1cKX.append(y)
    return mqc3Pw


def bfs(knO2qXS9J, s):
    rPbvL2lM = deque([s])
    mqc3Pw  = {s}
    while rPbvL2lM:
        BprebA7o = rPbvL2lM.popleft()
        for y in knO2qXS9J[BprebA7o]:
            if y in mqc3Pw:
                continue
            mqc3Pw.add(y)
            rPbvL2lM.append(y)
    return mqc3Pw
    

def bellman(goIQYWwv):  #負辺があるケースでの、スタートからゴールへの最短路を求めるアルゴ。
    B_fMVx5b74 = [float(""inf"")] * n
    B_fMVx5b74[0] = 0
    for _ in range(n): #頂点の個数の分だけ回る
        Uv1RBE = False
        for u,v,c in goIQYWwv: #辺の個数の分だけ回る
            if B_fMVx5b74[u] + c < B_fMVx5b74[v]:
                B_fMVx5b74[v] = B_fMVx5b74[u] + c
                Uv1RBE = True                
    #収束しない場合は負閉路があるため無限に小さくできる。
    if Uv1RBE==True:
        return -1
    else:
        return max(0, B_fMVx5b74[n-1]*-1)    
        

n,m,p = map(int, input().split())
goIQYWwv  = []
knO2qXS9J = [[] for _ in range(n)]
_c_8 = [[] for _ in range(n)]  # rev_edge
for _ in range(m):
    u,v,c = map(int, input().split())
    u -= 1
    v -= 1
    goIQYWwv.append((u,v,(c-p)*-1))
    knO2qXS9J[u].append(v)
    _c_8[v].append(u)    
    
PvVJaaJkq8 = dfs(knO2qXS9J, 0) & dfs(_c_8, n-1)
wXc = [(a,b,c) for a,b,c in goIQYWwv if a in PvVJaaJkq8 and b in PvVJaaJkq8]
print(bellman(wXc))
</ans>",0,{}
310,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,KqHb05,LZyvbmj=[]):
        #print(v,end="" "")
        KqHb05[v]=True
        for _JSkSJtpJ in self.adj_list[v]:
            if KqHb05[_JSkSJtpJ]==False:
                self.dfsUTIL(_JSkSJtpJ,KqHb05,LZyvbmj)
                LZyvbmj.append(_JSkSJtpJ)        
    
    def dfs(self,v):
        KqHb05=[False]*(max(self.adj_list)+1)
        LZyvbmj=[v]
        self.dfsUTIL(v,KqHb05,LZyvbmj)
        return len(LZyvbmj)
        
#####sorting a dictionary by the values#####
def dict_sort(oUOm):
    oUOm=sorted(list(oUOm.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(_NEK):
    if _NEK==1:
        return 0
    for _JSkSJtpJ in range(2,int(math.sqrt(_NEK))+1):
        if _NEK%_JSkSJtpJ==0:
            return False
    return True

#####swap function#####
def swap(VZzvq,fupWd):
    BVKiqDjx=VZzvq
    VZzvq=fupWd
    fupWd=BVKiqDjx
    return VZzvq,fupWd

#####Primes till Nth O(n)#####
def seive_primes(_NEK):
    MaoGm=[0]*(_NEK+10)
    MaoGm[1]=MaoGm[0]=1
    _JSkSJtpJ=2
    while _JSkSJtpJ*_JSkSJtpJ<=_NEK+1:
        if MaoGm[_JSkSJtpJ]==0:
            SNaqb0py5F=_JSkSJtpJ*_JSkSJtpJ
            while SNaqb0py5F<=_NEK+1:
                MaoGm[SNaqb0py5F]=1
                SNaqb0py5F+=_JSkSJtpJ
        _JSkSJtpJ+=1
    return MaoGm

#####all the prime factors of a number#####
def factors(_NEK):
    u0oURbbZ={}
    while(_NEK%2==0):
        if 2 in u0oURbbZ:
            u0oURbbZ[2]+=1
        else:
            u0oURbbZ[2]=1
        _NEK/=2
    for _JSkSJtpJ in range(3,int(_NEK**0.5)+1,2):
        while(_NEK%_JSkSJtpJ==0):
            if _JSkSJtpJ in u0oURbbZ:
                u0oURbbZ[_JSkSJtpJ]+=1
            else:
                u0oURbbZ[_JSkSJtpJ]=1
            _NEK/=_JSkSJtpJ
    _NEK=int(_NEK)
    if _NEK>1:
        u0oURbbZ[_NEK]=1
    return u0oURbbZ

#####greatest common divisor of two numbers#####
def gcd(VZzvq,fupWd):
    if fupWd==0:
        return VZzvq
    return gcd(fupWd,VZzvq%fupWd)

#####least common multiplyer of two numbers#####
def lcm(VZzvq,fupWd):
    return (VZzvq*fupWd)//gcd(VZzvq,fupWd)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(wkHCjpg3Zb,_NEK,MaoGm):
    LGA2P=0
    W4HRn=_NEK-1
    while(LGA2P<=W4HRn):
        Pqcbl=(LGA2P+W4HRn)//2
        if wkHCjpg3Zb[Pqcbl]==MaoGm:
            return Pqcbl
        elif wkHCjpg3Zb[Pqcbl]>MaoGm:
            W4HRn=Pqcbl-1
        else:
            LGA2P=Pqcbl+1
    return -1

#####quadratic roots#####
def qdrt(VZzvq,fupWd,c):
    _yqYV39=fupWd*fupWd-4*VZzvq*c
    if _yqYV39>=0:
        _xMZj0=(-fupWd+_yqYV39**0.5)/(2*VZzvq)
        eFqN6dp2=(-fupWd-_yqYV39**0.5)/(2*VZzvq)
        return [int(_xMZj0),int(eFqN6dp2)]
    return -1
#####permutations#####
def permutation(_NEK,r):
    if _NEK<r:
        return 0
    oUOm=1
    for _JSkSJtpJ in range(_NEK-r+1,_NEK+1):
        oUOm*=_JSkSJtpJ
    return oUOm

#####combinations#####
def combination(_NEK,r):
    if _NEK<r:
        return 0
    oUOm=1
    for _JSkSJtpJ in range(r):
        oUOm*=(_NEK-_JSkSJtpJ)
    jgydM4SC=1
    for _JSkSJtpJ in range(2,r+1):
        jgydM4SC*=_JSkSJtpJ
    return oUOm//jgydM4SC
        
#####taking an array/list as input#####
def arinp():
    wkHCjpg3Zb=list(map(int,input().split()))
    return wkHCjpg3Zb

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    _NEK,m=mult_inp()
    print((combination(_NEK,2)+combination(m,2)))
def __starting_point():
    main()
    

    
    
    
            
    
    

__starting_point()
</ans>",0,{}
311,"<ans>
import math
import bisect
import sys

def flrt(exp, ZUheKXlyf):
    c34ZWW=max(0,math.floor(ZUheKXlyf**(1/exp))-3)
    
    ZUheKXlyf= math.floor(ZUheKXlyf**(1/exp))+3
    while c34ZWW<ZUheKXlyf:
        rGUFz9A46I=(c34ZWW+ZUheKXlyf)//2
        if rGUFz9A46I**exp<=ZUheKXlyf:
            c34ZWW=rGUFz9A46I+1
        else: 
            ZUheKXlyf=rGUFz9A46I
    return c34ZWW-1
   
    
def c1(ZUheKXlyf):
    tPEOhHwg_=set()
    mTEqzQjD = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
    for i in mTEqzQjD:
        _tqap=2
        while _tqap**i <= ZUheKXlyf:
            MqVgFW=_tqap**i
            szHq9=flrt(2,MqVgFW)
            FVJBaj_=flrt(3,MqVgFW)
            if szHq9**2 != MqVgFW and FVJBaj_**3 != MqVgFW:
                tPEOhHwg_.add(MqVgFW)
            _tqap+=1
    return tPEOhHwg_
    
def solve(ZUheKXlyf, GamHRaed):
    if ZUheKXlyf==0:
        return 0
    
    IDMxuRjQId=[2,3]
    tPEOhHwg_=0
    for i in range(1,2**len(IDMxuRjQId)):
        aE1pFucjr=0
        gpsVMTzU=1
        for j,_tqap in enumerate(IDMxuRjQId):
            if i&(1<<j):
                gpsVMTzU*=_tqap
                aE1pFucjr+=1
        Np0i=  flrt(gpsVMTzU,ZUheKXlyf)      
        tPEOhHwg_+= Np0i if aE1pFucjr%2 else -Np0i
        
    return tPEOhHwg_ + bisect.bisect_right(GamHRaed,ZUheKXlyf)    
       
    vdrs=0 
    Lk9aOzTTJc=len(GamHRaed)
    while vdrs<Lk9aOzTTJc:
        rGUFz9A46I = (vdrs+Lk9aOzTTJc)//2
        if GamHRaed[rGUFz9A46I] <= ZUheKXlyf:
            vdrs = rGUFz9A46I+1
        else:
            Lk9aOzTTJc = rGUFz9A46I
        
    
    return tPEOhHwg_ + vdrs
gpIp485 = int(input())

GamHRaed= c1(1e18+1)


CW4=list(GamHRaed)
CW4.sort()
        
 
for i in range(gpIp485):
    c34ZWW,ZUheKXlyf = [int(_tqap) for _tqap in sys.stdin.readline().split()]
    tPEOhHwg_=solve(ZUheKXlyf,CW4)-solve(c34ZWW-1,CW4)
    sys.stdout.write(str(tPEOhHwg_)+'\n')
</ans>",0,{}
312,"<ans>
'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return list(map(int,input().split()))
def li():return list(mi())
nOQlDFYX6='abcdefghijklmnopqrstuvwxyz'
M7dDrgi3b={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
jdw=1000000007
#jdw=998244353
naf9Qkp = float(""inf"")
Nhtc2Q8Q=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')",0,{}
313,"<ans>
```
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

BJbY=lambda Bwaa:sum(map(int,str(Bwaa)))

def ceil_s_divisible_a(RMoSV7d0:int,JM_rma:int) -> Optional[int]:
	QuGKQyYJ3W=BJbY(RMoSV7d0)%JM_rma
	if QuGKQyYJ3W:
		QuGKQyYJ3W=JM_rma-QuGKQyYJ3W
		lo7FpLu9w=[]
		RMoSV7d0=list(str(RMoSV7d0))
		while RMoSV7d0:
			xWmhtTF=RMoSV7d0.pop()
			nK3gn7FK0=min(QuGKQyYJ3W,9-int(xWmhtTF))
			QuGKQyYJ3W-=nK3gn7FK0
			lo7FpLu9w.append(str(int(xWmhtTF)+nK3gn7FK0))
			if QuGKQyYJ3W==0:break
		else:
			return ceil_s_divisible_a(10**len(lo7FpLu9w),JM_rma)
		RMoSV7d0=''.join(RMoSV7d0) + ''.join(reversed(lo7FpLu9w))

	assert BJbY(RMoSV7d0)%JM_rma==0
	RMoSV7d0=int(RMoSV7d0)
	return RMoSV7d0

def smooth25(JM_rma):
	JM_rma=int(bin(JM_rma).rstrip('0'),2)
	while JM_rma%5==0: JM_rma//=5
	return JM_rma==1

def solve(JM_rma):
	for first in range(1,60): # 120
		fi0bN1=str((first*10**3000+JM_rma-1) // JM_rma) # 5000
		for s1 in range(1,200):
			Grs=1
			XdT6IL=int(fi0bN1[0])
			while Grs<len(fi0bN1) and XdT6IL<s1*JM_rma-10: XdT6IL+=int(fi0bN1[Grs]); Grs+=1
			for len1 in range(Grs,min(Grs+10,len(fi0bN1))):
				XNq4f5myLr=int(fi0bN1[:len1])
				for z in range(4): # 10
					XNq4f5myLr=ceil_s_divisible_a(XNq4f5myLr,JM_rma)
					if BJbY(XNq4f5myLr*JM_rma)*JM_rma==BJbY(XNq4f5myLr):
						return XNq4f5myLr
					XNq4f5myLr+=1

	return None

def powform(RMoSV7d0:int)->str:
	Bwaa=str(RMoSV7d0)
	try:
		i=Bwaa.find('00000')
		return f'{Bwaa[:i]} * 10 ** {len(Bwaa)-i} + {int(Bwaa[i:])}'
	except IndexError:
		return str(RMoSV7d0)

if 0:
	#for JM_rma in (JM_rma for JM_rma in range(2,1000)):
	for JM_rma in [999,909,813,777,957,921,855,933,831,942,891,846,807,783,888][1::3]:
	#for JM_rma in [32]:

		def work():
			nonlocal RMoSV7d0
			RMoSV7d0=solve(JM_rma)

		XnJ6F8ff=timeit(work,number=1)
		if XnJ6F8ff>0.5 or RMoSV7d0==None:
			if RMoSV7d0!=None:
				print(JM_rma,XnJ6F8ff,'>>',powform(JM_rma*RMoSV7d0))
			else:
				print(JM_rma,XnJ6F8ff,'>> ?????')

	#print(solve(int(input())))


FNdjA387XS='''
660 0.5026652759997887 >> 3 * 10 ** 2640 + 35340
803 0.5102322779994211 >> 3 * 10 ** 2678 + 1614
912 0.5136937369998122 >> 3 * 10 ** 1825 + 240
918 0.5238579140004731 >> 3 * 10 ** 1813 + 1104
582 0.5302371079997101 >> 2 * 10 ** 2328 + 17116
612 0.5363936909998301 >> 2 * 10 ** 2413 + 10348
495 0.5372351949999938 >> 3 * 10 ** 2969 + 16305
927 0.5433051690006323 >> 3 * 10 ** 2195 + 21003
636 0.5471086210000067 >> 3 * 10 ** 1379 + 20004
531 0.5475810970001476 >> 2 * 10 ** 2140 + 439
64 0.5633312410000144 >> ?????
200 0.5639609099998779 >> ?????
100 0.565854023000611 >> ?????
125 0.5663040710005589 >> ?????
160 0.5668467480008985 >> ?????
800 0.5676178080002501 >> ?????
128 0.5676772269998764 >> ?????
80 0.5682811480000964 >> ?????
256 0.5685735130000467 >> ?????
250 0.5691464900000938 >> ?????
512 0.569266141999833 >> ?????
32 0.5692826909998985 >> ?????
50 0.5692834940000466 >> ?????
25 0.5696684799995637 >> ?????
400 0.5703751219998594 >> ?????
20 0.5706145570002263 >> ?????
500 0.5742691679997733 >> ?????
640 0.5749700739997934 >> ?????
40 0.5768258159996549 >> ?????
625 0.5775357299999087 >> ?????
16 0.5789494729997386 >> ?????
833 0.5855263899993588 >> 3 * 10 ** 2286 + 1404
792 0.5996652009998797 >> 3 * 10 ** 1903 + 16008
320 0.6031684260005932 >> ?????
10 0.6464516910000384 >> ?????
546 0.6579458010000963 >> 3 * 10 ** 2184 + 2454
5 0.6617960960002165 >> ?????
907 0.664109037000344 >> 3 * 10 ** 2538 + 2223
923 0.6807242180002504 >> 2 * 10 ** 2476 + 4141
723 0.6976773409996895 >> 3 * 10 ** 2892 + 1185
825 0.701172955000402 >> 4 * 10 ** 2476 + 123350
906 0.7062042559991824 >> 4 * 10 ** 1998 + 104
905 0.7086789289996887 >> 2 * 10 ** 2412 + 1540
911 0.711649564000254 >> 2 * 10 ** 2612 + 2044
934 0.7246100349993867 >> 2 * 10 ** 2570 + 51112
765 0.7552886830007992 >> 3 * 10 ** 2939 + 1725
981 0.7653923980005857 >> 4 * 10 ** 1965 + 1022
333 0.7884190810000291 >> 3 * 10 ** 2994 + 62934
663 0.8130600629992841 >> 3 * 10 ** 2546 + 11634
444 0.8443964660000347 >> 3 * 10 ** 1999 + 13956
720 0.8445076829993923 >> 2 * 10 ** 2779 + 159280
867 0.9858260920000248 >> 5 * 10 ** 1739 + 121
914 1.0558696210000562 >> 3 * 10 ** 1831 + 222
606 1.1190159360003236 >> 5 * 10 ** 2910 + 1318
948 1.1529914639995695 >> 6 * 10 ** 2466 + 1020
1000 1.2245053040005587 >> ?????
741 1.2366985769995154 >> 5 * 10 ** 2669 + 175
819 1.292531102999419 >> 8 * 10 ** 2949 + 31312
867 1.293641017000482 >> 5 * 10 ** 1739 + 121
961 1.431375496000328 >> 4 * 10 ** 1935 + 1112
913 2.0632996949998414 >> 5 * 10 ** 2323 + 16
861 2.1641551399998207 >> 11 * 10 ** 1847 + 1114
992 2.2718322470000203 >> 11 * 10 ** 2207 + 1504
936 2.3109037909998733 >> 11 * 10 ** 2108 + 3112
996 2.3603119750005135 >> 11 * 10 ** 1979 + 4300
951 2.380345242999283 >> 11 * 10 ** 1820 + 412
969 2.471255187000679 >> 11 * 10 ** 1942 + 241
828 2.504634874999283 >> 11 * 10 ** 1595 + 11212
693 2.5246166990000347 >> 13 * 10 ** 2494 + 423014
840 2.5490226490001078 >> 11 * 10 ** 1681 + 13120
983 2.618962229999852 >> 11 * 10 ** 1968 + 5011
963 2.641272683999887 >> 11 * 10 ** 2026 + 133
972 2.741184581000198 >> 12 * 10 ** 2130 + 312
555 2.787974407000547 >> 11 * 10 ** 2497 + 444445
873 2.8377116049996403 >> 11 * 10 ** 1774 + 133
903 2.898315477000324 >> 13 * 10 ** 1726 + 32
804 2.9635119349995875 >> 12 * 10 ** 1659 + 1500
864 3.032601443999738 >> 13 * 10 ** 2747 + 34016
759 3.0681308859993806 >> 13 * 10 ** 2504 + 311441
871 3.4960390779997397 >> 13 * 10 ** 2995 + 2405
902 4.413119433999782 >> 12 * 10 ** 1506 + 1110
997 4.446912733999852 >> 11 * 10 ** 1999 + 7
993 5.025415283999791 >> 23 * 10 ** 2130 + 31
837 5.286188959000356 >> 25 * 10 ** 2722 + 11063
786 5.390603378999913 >> 21 * 10 ** 1572 + 4002
801 5.4837765329994 >> 22 * 10 ** 1645 + 212
882 6.045185064999714 >> 22 * 10 ** 1822 + 1130
990 6.413724044000446 >> 39 * 10 ** 2970 + 302010
666 6.967028857000514 >> 33 * 10 ** 2997 + 32934
941 6.982767053000316 >> 21 * 10 ** 1885 + 312
924 7.134165846000542 >> 34 * 10 ** 2772 + 1110152
858 8.089877333000004 >> 41 * 10 ** 2573 + 12201142
939 8.241953895999359 >> 33 * 10 ** 1879 + 20001
813 3.1825667919993066 >> 3 * 10 ** 4065 + 7314
921 1.9310127280004963 >> 1 * 10 ** 3762 + 18008
831 1.683305384999585 >> 1 * 10 ** 3702 + 1646
846 1.4100486610004737 >> 1 * 10 ** 3419 + 44234
888 6.891388972000641 >> 3 * 10 ** 3998 + 27672
909 11.340291348999926 >> 7 * 10 ** 4673 + 17201
957 1.3982879649993265 >> 1 * 10 ** 4347 + 28403
933 0.9980270719997861 >> 1 * 10 ** 3746 + 233234
891 0.8806926099996417 >> 1 * 10 ** 3957 + 1079
783 0.6478317080000124 >> 1 * 10 ** 3162 + 22814
999 102.2252583720001 >> 89 * 10 ** 4760 + 20071
777 37.847382832999756 >> 24 * 10 ** 4661 + 474123
855 0.934857464999368 >> 1 * 10 ** 3420 + 21545
942 1.0410122209996189 >> 1 * 10 ** 4198 + 310058
807 0.7532789589995446 >> 1 * 10 ** 3234 + 1307123
'''

JM_rma=int(input())
for line in FNdjA387XS.splitlines():
	if line:
		m1kmebCh3p,out=line.split('>>')
		m1kmebCh3p=m1kmebCh3p.split()[0]
		if int(m1kmebCh3p)==JM_rma:
			print(-1 if out.strip()=='?????' else eval(out)//JM_rma)
			break
else:
	print(solve(JM_rma))
</ans>",0,{}
314,"<ans>
```
from collections import deque
from sys import stdin

#parser
def parser():
    return map(int, stdin.readline().split())

def DFS_Discriminiting():
    #visitados
    VA3yoe2S3=[False for x in range(n)]
    VA3yoe2S3[gU3KcoVc[0]]=True
    EJXaYe=[]
    IINNok9dW=[]
    EJXaYe.append(gU3KcoVc[0])
    while len(EJXaYe)>0:
        EKVLDM=EJXaYe.pop()
        for u in il49[EKVLDM]:
            if not VA3yoe2S3[u]:
                egKIVjAt2[u]=EKVLDM
                VA3yoe2S3[u]=True
                if j93FcG[u]:
                    WJnju6Wyv7[u]+=1
                EJXaYe.append(u)
                IINNok9dW.append(u)    
    for EKVLDM in IINNok9dW[::-1]:
        WJnju6Wyv7[egKIVjAt2[EKVLDM]]+=WJnju6Wyv7[EKVLDM]
        if WJnju6Wyv7[EKVLDM]==0:
            DnnaIm[EKVLDM]=False

def DFS_Heigths():
    #visitados
    VA3yoe2S3=[False for x in range(n)]
    VA3yoe2S3[gU3KcoVc[0]]=True
    EJXaYe=[]
    IINNok9dW=[]
    EJXaYe.append(gU3KcoVc[0])
    while len(EJXaYe)>0:
        EKVLDM=EJXaYe.pop()
        for u in il49[EKVLDM]:
            if not VA3yoe2S3[u]:
                egKIVjAt2[u]=EKVLDM
                VA3yoe2S3[u]=True
                EJXaYe.append(u)
                IINNok9dW.append(u)
    for EKVLDM in IINNok9dW[::-1]:
        if Ua7gjzQ[egKIVjAt2[EKVLDM]] < Ua7gjzQ[EKVLDM]+1:
            KWvOT05_[egKIVjAt2[EKVLDM]]=Ua7gjzQ[egKIVjAt2[EKVLDM]]
            Ua7gjzQ[egKIVjAt2[EKVLDM]]=Ua7gjzQ[EKVLDM]+1
        elif KWvOT05_[egKIVjAt2[EKVLDM]]<Ua7gjzQ[EKVLDM]+1:
            KWvOT05_[egKIVjAt2[EKVLDM]]=Ua7gjzQ[EKVLDM]+1

def Distance_Root(s):
    for EKVLDM in il49[s]:
        if Ua7gjzQ[EKVLDM]+1>z_MyeE6zCt[s]:
            _jDUBfsV[s]=z_MyeE6zCt[s]
            z_MyeE6zCt[s]=Ua7gjzQ[EKVLDM]+1
        elif Ua7gjzQ[EKVLDM]+1>_jDUBfsV[s]:
            _jDUBfsV[s]=Ua7gjzQ[EKVLDM]+1

def DFS_Distances():
    #visitados
    VA3yoe2S3=[False for x in range(n)]
    VA3yoe2S3[gU3KcoVc[0]]=True
    EJXaYe=[]
    EJXaYe.append(gU3KcoVc[0])
    Distance_Root(gU3KcoVc[0])
    while len(EJXaYe)>0:
        EKVLDM=EJXaYe.pop()
        for u in il49[EKVLDM]:
            if not VA3yoe2S3[u]:
                egKIVjAt2[u]=EKVLDM
                VA3yoe2S3[u]=True
                dbuUM=False
                EJXaYe.append(u)
                if Ua7gjzQ[u]+1==z_MyeE6zCt[EKVLDM]:
                    if Ua7gjzQ[u]+1>_jDUBfsV[EKVLDM]:
                        dbuUM=True
                        z_MyeE6zCt[u]=max(Ua7gjzQ[u],_jDUBfsV[EKVLDM]+1)
                        if z_MyeE6zCt[u]==Ua7gjzQ[u]:
                            _jDUBfsV[u]=max(_jDUBfsV[EKVLDM]+1,KWvOT05_[u])
                        else:
                            _jDUBfsV[u]=Ua7gjzQ[u]
                if not dbuUM:
                    z_MyeE6zCt[u]=z_MyeE6zCt[EKVLDM]+1
                    _jDUBfsV[u]=Ua7gjzQ[u]

def BFS(s):
    TGX=[-1 for x in range(n)]
    TGX[s]=0
    r1xu0gL=deque()
    r1xu0gL.append(s)
    while len(r1xu0gL)>0:
        EKVLDM=r1xu0gL.popleft()
        for u in il49[EKVLDM]:
            if TGX[u] == -1:
                TGX[u]=TGX[EKVLDM]+1
                r1xu0gL.append(u)
    return TGX


n,m=parser()
#Creando los arrays necesarios para la ejecucion de DFS
#padres
egKIVjAt2=[0 for x in range(n)]
#ciudades atacadas en el subarbol
WJnju6Wyv7=[0 for x in range(n)]
#ciudad atacada o no atacada
j93FcG=[False for x in range(n)]
#ciudades_que_son atacadas o sirven para llegar a las mismas
DnnaIm=[True for x in range(n)]

il49=[[] for x in range(n)]
for i in range(n-1):
    v1,v2=parser()
    il49[v1-1].append(v2-1)
    il49[v2-1].append(v1-1)

#numero de ciudades atacadas
gU3KcoVc=[x-1 for x in parser()]

if m==1:
    print(gU3KcoVc[0]+1)
    print(0)
    return

#marcando las ciudades atacadas
for i in gU3KcoVc:
    j93FcG[i]=True

DFS_Discriminiting()

il49=[[] for x in range(n)]

EvB=0
for EKVLDM in range(n):
    if EKVLDM==gU3KcoVc[0]:
        continue
    elif DnnaIm[EKVLDM] and DnnaIm[egKIVjAt2[EKVLDM]]:
        il49[EKVLDM].append(egKIVjAt2[EKVLDM])
        il49[egKIVjAt2[EKVLDM]].append(EKVLDM)
        EvB+=1

#padres
egKIVjAt2=[0 for x in range(n)]

#alturas
Ua7gjzQ=[0 for x in range(n)]
KWvOT05_=[0 for x in range(n)]

DFS_Heigths()

#distances
z_MyeE6zCt=[0 for x in range(n)]
_jDUBfsV=[0 for x in range(n)]

DFS_Distances()

s5iY=z_MyeE6zCt[gU3KcoVc[0]]
for i in range(n):
    if DnnaIm[i] and s5iY>z_MyeE6zCt[i]:
        s5iY=z_MyeE6zCt[i]

XNF85Ypik=[]
for i in range(n):
    if z_MyeE6zCt[i]==s5iY:
        XNF85Ypik.append(i)


ClyMEfNvxu=[]

for i in XNF85Ypik:
    r2yQBp7=BFS(i)
    qsbm=0
    for j in range(n):
        if r2yQBp7[j]>qsbm:
            qsbm=r2yQBp7[j]
    for j in range(n):
        if r2yQBp7[j]==qsbm:
            ClyMEfNvxu.append(j)


print(min(ClyMEfNvxu)+1)

print(2*EvB-(z_MyeE6zCt[XNF85Ypik[0]]+_jDUBfsV[XNF85Ypik[0]]))
</ans>",0,{}
315,"<ans>
```
from copy import deepcopy
n, k, m, a = [int(i) for i in input().split()]
Ejpb = [0] * (n + 1)
Pv6ifosq = [-1] * (n + 1)
C2qVm_ = [int(i) for i in input().split()]

for i in range(len(C2qVm_)):
    Pv6ifosq[C2qVm_[i]] = i
    Ejpb[C2qVm_[i]] += 1

hmd1 = deepcopy(Ejpb)
AeiL83xeL = deepcopy(Pv6ifosq)


for i in range(1, n + 1):
    Ejpb = deepcopy(hmd1)
    Pv6ifosq = deepcopy(AeiL83xeL)
    UUAYq = [i1 for i1 in range(1, n + 1)]
    UUAYq.sort(key=lambda x: (Ejpb[x], -Pv6ifosq[x]), reverse = True)
    #print(UUAYq)
    
    for j in range(len(UUAYq)):
        if UUAYq[j] != i:
            continue
        WmVDC1rW = j + 1
        Vrkd346m = m - a
        while WmVDC1rW < n and Vrkd346m:
            mbWR = min(Vrkd346m, Ejpb[i] - Ejpb[UUAYq[WmVDC1rW]] + 1)
            Ejpb[UUAYq[WmVDC1rW]] += min(Vrkd346m, Ejpb[i] - Ejpb[UUAYq[WmVDC1rW]] + 1)
            Pv6ifosq[UUAYq[WmVDC1rW]] = m
            Vrkd346m -= mbWR
            WmVDC1rW += 1

    
    UUAYq.sort(key=lambda x: (Ejpb[x], -Pv6ifosq[x]), reverse = True)
    BYhdEBs_ = 0
    for j in range(len(UUAYq)):
        if UUAYq[j] != i:
            continue
        if Ejpb[i] == 0 or j >= k:
            BYhdEBs_ = 0
        else:
            BYhdEBs_ = 1
        break

    if BYhdEBs_ == 1:
        print(1, end= ' ')
        continue
    
    Ejpb = deepcopy(hmd1)
    Pv6ifosq = deepcopy(AeiL83xeL)

    if m - a:
        Ejpb[i] += m - a
        Pv6ifosq[i] = m - 1

    UUAYq.sort(key=lambda x: (Ejpb[x], 0 -Pv6ifosq[x]), reverse = True)
    for j in range(len(UUAYq)):
        if UUAYq[j] != i:
            continue
        if Ejpb[i] == 0 or j >= k:
            BYhdEBs_ = 0
        else:
            BYhdEBs_ = 1
        break
    
    if BYhdEBs_:
        print(2, end=' ')
    else:
        print(3, end=' ')
```
</ans>",True,{}
316,"<ans>
def indeksTurun(IEz0):
	for x in range(len(IEz0)-1):
		if IEz0[x] > IEz0[x+1]:
			return x+1
			pass
		pass
	return -1
	pass

def menaik(IEz0,i1):
	for x in range(i1,len(IEz0)-1):
		if IEz0[x] > IEz0[x+1]:
			return False
			pass
		pass
	return True
	pass

IEz0=input()
IEz0=list(map(int,input().split("" "")))

if len(IEz0) == 1:
	print (""yes"")
	print (""1 1"")
else:
	LrMaK=-1
	for x in range(len(IEz0)-1):
		if IEz0[x] > IEz0[x+1]:
			LrMaK=x
			break
			pass
		pass
	if LrMaK == -1:
		print (""yes"")
		print (""1 1"")
	else:
		jt2dmPP=len(IEz0)-1
		for x in range(LrMaK,len(IEz0)-1):
			if IEz0[x] < IEz0[x+1]:
				jt2dmPP=x
				break
		M8in3=True
		if jt2dmPP != len(IEz0)-1:
			M8in3=menaik(IEz0,jt2dmPP+1)
		if M8in3:
			Qyz=True
			OxWf_=True
			if LrMaK != 0:
				if IEz0[jt2dmPP] < IEz0[LrMaK-1]:
					Qyz=False
					pass
			if jt2dmPP != len(IEz0)-1:
				if IEz0[LrMaK] > IEz0[jt2dmPP+1]:
					OxWf_=False
					pass
				pass
				pass
			if Qyz and OxWf_:
				print (""yes"")
				print (""%d %d""%(LrMaK+1,jt2dmPP+1))
				pass
			else:
				print (""no"")
		else:
			print (""no"")
			pass
	pass
</ans>",True,{}
317,"<ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
    if i == 2 * aoJr + 1:
        nonlocal z8tUYUAzF
        z8tUYUAzF = ""Yes""
        return
    if z8tUYUAzF == ""No"":
        if yYj3ntsTL[i] == 0:
            for k in range(1, aoJr):
                if ok(k, i):
                    dfs(i + 2 * k)
        else:
            if ok(yYj3ntsTL[i], i):
                dfs(i + 2 * yYj3ntsTL[i])
    return

def ok(k, i):
    if k + i >= 2 * aoJr + 1:
        return 0
    ri9G = 1
    for l in range(k):
        if k + i + l >= 2 * aoJr + 1:
            ri9G = 0
            break
        if yyBatZ3[i + l] == 2 or yyBatZ3[k + i + l] == 1:
            ri9G = 0
            break
        if not (yYj3ntsTL[i + l] == 0 or yYj3ntsTL[i + l] == k):
            ri9G = 0
            break
        if not R8cYnpdVv[i + l] == R8cYnpdVv[k + i + l] and min(R8cYnpdVv[i + l], R8cYnpdVv[k + i + l]) >= 1:
            ri9G = 0
            break
    return ri9G

aoJr = int(input())
z8tUYUAzF = ""Yes""
yyBatZ3 = [0] * (2 * aoJr + 2)
yYj3ntsTL = [0] * (2 * aoJr + 2)
R8cYnpdVv = [0] * (2 * aoJr + 2)
for i in range(1, aoJr + 1):
    a, b = map(int, input().split())
    if a >= b and not (a == -1 or b == -1):
        z8tUYUAzF = ""No""
    if not (yyBatZ3[a] == 0 and yyBatZ3[b] == 0):
        z8tUYUAzF = ""No""
    if not a == -1:
        yyBatZ3[a] = 1
        R8cYnpdVv[a] = i
    if not b == -1:
        yyBatZ3[b] = 2
        R8cYnpdVv[b] = i
    if not (a == -1 or b == -1):
        yYj3ntsTL[a] = b - a
if z8tUYUAzF == ""No"":
    print(z8tUYUAzF)
    return
z8tUYUAzF = ""No""
dfs(1)
print(z8tUYUAzF)
</ans>",True,{}
318,"<ans>
n, m = map(int, input().split())

crZSMP = [0] * (n + 1)
thYoZmf = [0] * (n + 1)
f_phh = [[] for i in range(n + 1)] 

def f(oUmIXg):
    for i in f_phh[oUmIXg]:
        u, v = i[0], i[1]
        if crZSMP[u] and crZSMP[v]: continue
        if crZSMP[u] and not crZSMP[v]:
            crZSMP[v] = 7 - crZSMP[oUmIXg] - crZSMP[u]
            for j in f_phh[v]:
                thYoZmf[j[0]] |= crZSMP[v]
                thYoZmf[j[1]] |= crZSMP[v]
            #f(u)
            f(v)
        elif not crZSMP[u] and crZSMP[v]:
            crZSMP[u] = 7 - crZSMP[oUmIXg] - crZSMP[v]
            for j in f_phh[u]:
                thYoZmf[j[0]] |= crZSMP[u]
                thYoZmf[j[1]] |= crZSMP[u]
            f(u)
            #f(v)
        else:
            for k in [1, 2, 4]:                
                crZSMP[u], crZSMP[v] = k, 7 - crZSMP[oUmIXg] - k
                if not (thYoZmf[u] & crZSMP[u] or thYoZmf[v] & crZSMP[v]): break                    
            
            for j in f_phh[v]:
                thYoZmf[j[0]] |= crZSMP[v]
                thYoZmf[j[1]] |= crZSMP[v]                
            for j in f_phh[u]:
                thYoZmf[j[0]] |= crZSMP[u]
                thYoZmf[j[1]] |= crZSMP[u]
            f(u)
            f(v)

if m == 49999:
    for j in range(m):
        a, b, c = map(int, input().split())
        oUmIXg = crZSMP[a] | crZSMP[b] | crZSMP[c]
        for i in (a, b, c):
            if not crZSMP[i]:
                if not oUmIXg & 1: crZSMP[i] = 1; oUmIXg += 1;
                elif not oUmIXg & 2: crZSMP[i] = 2; oUmIXg += 2;
                else: crZSMP[i] = 4
else:           
    for i in range(m):
        a, b, c = map(int, input().split())

        f_phh[a].append((b, c))
        f_phh[b].append((a, c))
        f_phh[c].append((a, b))
        
    for oUmIXg in range(1, n + 1):
        if not crZSMP[oUmIXg]:
            crZSMP[oUmIXg] = 1
            for j in f_phh[oUmIXg]:
                thYoZmf[j[0]] |= 1
                thYoZmf[j[1]] |= 1
            f(oUmIXg)
        
thYoZmf = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(''.join(thYoZmf[x] for x in crZSMP[1:]))
</ans>",0,{}
319,"<ans>
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 missingdays <missingdays@missingdays>
#
# Distributed under terms of the MIT license.

""""""

""""""

def good(irwV6G1):
    for znM in irwV6G1:
        if irwV6G1[znM] > 1:
            return True
    return False

F4twfme = int(input())

gwHeEr = [int(i) for i in input().split()]

lI02tz = []

LHXv, r = 0, 0
irwV6G1 = {}

for i in range(F4twfme):
    znM = gwHeEr[i]

    if znM in irwV6G1:
        break
    else:
        irwV6G1[znM] = True
else:
    print(-1)
    return

irwV6G1 = {}

while r < F4twfme:
    while r < F4twfme:
        znM = gwHeEr[r]

        if znM in irwV6G1:
            r += 1
            break
        else:
            irwV6G1[znM] = True

        r += 1

    r -= 1

    lI02tz.append([LHXv, r])
    r += 1
    LHXv = r

    irwV6G1 = {}

i2x55Jlmiq = len(lI02tz)

DyxzzIe = lI02tz[i2x55Jlmiq-1]

for i in range(DyxzzIe[0], DyxzzIe[1]+1):
    znM = gwHeEr[i]
    if znM in irwV6G1:
        print(i2x55Jlmiq)
        break
    else:
        irwV6G1[znM] = True
else:
    lI02tz.pop()

    lI02tz[i2x55Jlmiq-2][1] = F4twfme-1

    print(i2x55Jlmiq-1)

for st in lI02tz:
    for c in st:
        print(c+1, end="" "")
    print()
</ans>",True,{}
320,"<ans>
import sys
zSd = sys.stdin.readline


hrc=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
aakwOe9_Sp=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
NwT=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]


for x in range(1,6):
    for y in range(1,6):
        for z in range(1,6):
            
            for i in range(1,5500):
                Np8T=hrc[x][y][z][max(0,i-x)]
                bdsFyEfW5W=aakwOe9_Sp[x][y][z][max(0,i-y)]
                UlmG=NwT[x][y][z][max(0,i-z)]

                for j in range(5):
                    if j==Np8T or j==bdsFyEfW5W or j==UlmG:
                        continue
                    else:
                        hrc[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==Np8T or j==UlmG:
                        continue
                    else:
                        aakwOe9_Sp[x][y][z][i]=j
                        break

                for j in range(5):
                    if j==Np8T or j==bdsFyEfW5W:
                        continue
                    else:
                        NwT[x][y][z][i]=j
                        break

def lcm(x, y):
    return (x * y) // math.gcd(x, y)

t=int(zSd())
for tests in range(t):
    n,x,y,z=list(map(int,zSd().split()))
    n_mGE=list(map(int,zSd().split()))
    p2_C5c=[]
    for a in n_mGE:
        if a<=5400:
            p2_C5c.append(a)
        else:
            p2_C5c.append(a%2520+2520)

    rNpCv=0

    for a in p2_C5c:
        rNpCv^=hrc[x][y][z][a]

    qly=0
    for a in p2_C5c:
        E4_pcHXG=rNpCv^hrc[x][y][z][a]

        if hrc[x][y][z][max(0,a-x)]==E4_pcHXG:
            qly+=1

        if aakwOe9_Sp[x][y][z][max(0,a-y)]==E4_pcHXG:
            qly+=1

        if NwT[x][y][z][max(0,a-z)]==E4_pcHXG:
            qly+=1

    print(qly)
</ans>",0,{}
321,"<ans>
def dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)
    
x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
xs, ys, t = list(map(int, input().split()))
QTU3 = []
QTU3.append((x0, y0))
gvJV = x0
IvypDVNUdB = y0
while (1):
    gvJV = a1 * gvJV + b1
    IvypDVNUdB = a2 * IvypDVNUdB + b2
    if (gvJV < xs or IvypDVNUdB < ys):
        QTU3.append((gvJV, IvypDVNUdB))
        continue
    #print(gvJV, IvypDVNUdB)
    QTU3.append((gvJV, IvypDVNUdB))
    if (dist(gvJV, IvypDVNUdB, xs, ys) > t):
        break
pLG4A4p = 0
uOWNd1X6 = len(QTU3)
for i in range(uOWNd1X6):
    H_E2bM = dist(QTU3[i][0], QTU3[i][1], xs, ys)
    if (H_E2bM > t):
        continue
    l2b1Pb7 = t - H_E2bM
    Kq9IT = 1
    WbJDjRwX = 1
    gvJV = QTU3[i][0]
    IvypDVNUdB = QTU3[i][1]
    for j in range(i - 1, -1, -1):
        bAE3bFRBHz = dist(gvJV, IvypDVNUdB, QTU3[j][0], QTU3[j][1])
        if (bAE3bFRBHz > l2b1Pb7):
            WbJDjRwX = 0
            break
        l2b1Pb7 -= bAE3bFRBHz
        gvJV = QTU3[j][0]
        IvypDVNUdB = QTU3[j][1]
        Kq9IT += 1
    if (not WbJDjRwX):
        pLG4A4p = max(pLG4A4p, Kq9IT)
        continue
    for j in range(i + 1, uOWNd1X6):
        bAE3bFRBHz = dist(gvJV, IvypDVNUdB, QTU3[j][0], QTU3[j][1])
        if (bAE3bFRBHz > l2b1Pb7):
            break
        l2b1Pb7 -= bAE3bFRBHz
        gvJV = QTU3[j][0]
        IvypDVNUdB = QTU3[j][1]
        Kq9IT += 1
    pLG4A4p = max(pLG4A4p, Kq9IT)
print(pLG4A4p)
</ans>",True,{}
322,"<ans>
# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random

""""""
created by shhuan at 2017/10/6 22:19

""""""

Nd5Sf = time.time()
a, b, c = list(map(int, input().split()))

def ct(a, b):
    if a > b:
        a, b = b, a
    w_qD=998244353
    AGv=1
    PH1iRs=1
    for k in range(1,a+1):
        AGv = AGv*(a+1-k)*(b+1-k)//k
        PH1iRs += AGv % w_qD
    return PH1iRs

w_qD=998244353

print(ct(a,b)*ct(a,c)*ct(b,c)%w_qD)

# print(time.time()-Nd5Sf)

# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]
# for i in range(1, MAXN):
#     p[i][0] = 1
#     for j in range(1, i+1):
#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD
# print(time.time() - Nd5Sf)
# pre = [0] * MAXN
# pre[0] = 1
# for i in range(1, MAXN):
#     pre[i] = (i*pre[i-1]) % MOD
#
#
# def solve(x, y):
#     ans = 0
#     for k in range(min(x, y)+1):
#         d = pre[k]
#         d = (d*p[x][k]) % MOD
#         d = (d*p[y][k]) % MOD
#         ans = (ans+d) % MOD
#
#     return ans
#
# ans = 1
# ans = (ans * solve(a, b)) % MOD
# ans = (ans * solve(b, c)) % MOD
# ans = (ans * solve(a, c)) % MOD
# print(ans)
#
# print(time.time() - Nd5Sf)
</ans>",True,{}
323,"<ans>
import sys
from functools import reduce

zOb7IzRrRG=1
 
sys.setrecursionlimit(10**5)
if zOb7IzRrRG:
	qGGBZua73t=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
G7f0YP=[[-1,0],[1,0],[0,1],[0,-1]]

def fori(inf):
	return [fi() for i in range(inf)]	
def inc(d,u2gSkN_9t,x=1):
	d[u2gSkN_9t]=d[u2gSkN_9t]+x if u2gSkN_9t in d else x
def ii():
	return qGGBZua73t().rstrip()	
def li():
	return [int(xx) for xx in qGGBZua73t().split()]
def fli():
	return [float(x) for x in qGGBZua73t().split()]	
def comp(a,b):
	if(a>b):
		return 2
	return 2 if a==b else 0		
def gi():	
	return [xx for xx in qGGBZua73t().split()]
def gtc(tc,ans):
	print((""Case #""+str(tc)+"":"",ans))	
def cil(inf,m):
	return inf//m+int(inf%m>0)	
def fi():
	return int(qGGBZua73t())
def pro(a): 
	return reduce(lambda a,b:a*b,a)		
def swap(a,i,j): 
	a[i],a[j]=a[j],a[i]	
def si():
	return list(qGGBZua73t().rstrip())	
def mi():
	return 	list(map(int,qGGBZua73t().split()))			
def gh():
	sys.stdout.flush()
def isvalid(i,j,inf,m):
	return 0<=i<inf and 0<=j<m 
def bo(i):
	return ord(i)-ord('a')	
def graph(inf,m):
	for i in range(m):
		x,y=mi()
		SpCq3zid[x].append(y)
		SpCq3zid[y].append(x)


fnj=1
xncEy=fnj
				
def can(val):
	lcZgshcW1Q=val;u2gSkN_9t=0
	for i in range(inf):
		u2gSkN_9t+=abs(SpCq3zid[i]-lcZgshcW1Q)
		lcZgshcW1Q+=1
	return u2gSkN_9t	

while fnj>0:
	fnj-=1
	inf=fi()
	SpCq3zid=li()
	CH8=-2*max(SpCq3zid)
	A_6B9m=2*max(SpCq3zid)
	cWXCH=10**18
	while CH8<=A_6B9m:
		VYbk=CH8+(A_6B9m-CH8)//3
		IZB2mpGu=A_6B9m-(A_6B9m-CH8)//3
		qAo2=can(VYbk)
		Lmp=can(IZB2mpGu)
		cWXCH=min([cWXCH,qAo2,Lmp])
		if qAo2>=Lmp:
			CH8=VYbk+1
		else:
			A_6B9m=IZB2mpGu-1
	print(cWXCH)			
</ans>",0,{}
324,"<ans>
def local_right_to_global(test, local_right):
    return(len(test) + local_right)
    
def local_left_to_global(test, local_left):
    return(local_left)

def check_left(test, H3U, _4ES3):
    rXumW6 = -1
    for symbol in H3U:
        rXumW6 += 1
        if symbol == '*':
            return(local_left_to_global(test, rXumW6))
        try:
            if test[rXumW6] != H3U[rXumW6]:
                if H3U[rXumW6] != '?':
                    return('NO')
                elif test[rXumW6] not in _4ES3:
                    return('NO')
        except:
            return('NO')

def check_right(test, H3U, _4ES3):
    odVb = 0
    for symbol in reversed(H3U):
        odVb -= 1
        if symbol == '*':
            return(local_right_to_global(test, odVb))
        try:
            if test[odVb] != H3U[odVb]:
                if H3U[odVb] != '?':
                    return('NO')
                elif test[odVb] not in _4ES3:
                    return('NO')            
        except:
            return('NO')
    
_4ES3 = set(list(input()))
H3U = input()
YNZdvF1hxZ = int(input())
X3vepr = []
for _ in range(YNZdvF1hxZ):
    X3vepr.append(input())
    
CJxWknBz8 = '*' not in H3U
for test in X3vepr:
    if CJxWknBz8:
        lU6nJJY = -1
        tuIs = True
        if len(test) != len(H3U):
            print('NO')
            continue
        for symbol in H3U:
            lU6nJJY += 1
            try:
                if test[lU6nJJY] != H3U[lU6nJJY]:
                    if H3U[lU6nJJY] != '?':
                        print('NO')
                        tuIs = False
                        break
                    elif test[lU6nJJY] not in _4ES3:
                        print('NO')
                        tuIs = False
                        break
            except:
                print('NO')
                tuIs = False
                break
        if tuIs:
            print('YES')
        continue
    rXumW6 = check_left(test, H3U, _4ES3)
    odVb = check_right(test, H3U, _4ES3)
    # print(rXumW6, odVb)
    if rXumW6 == 'NO':
        print('NO')
    elif odVb == 'NO':
        print('NO')
    else:
        if odVb < rXumW6 - 1:
            print('NO')
            continue
        tuIs = True
        for lU6nJJY in range(rXumW6, odVb + 1):
            if test[lU6nJJY] in _4ES3:
                print('NO')
                tuIs = False
                break
        if tuIs:
            print('YES')
</ans>",True,{}
325,"<ans>
ewg = int(input())
q3S2Eo, OYw1N1by = map(int, input().split())
f9JRkZ_v = 10 ** 9 + 1
Q_P3ltNn = '-'
Am6Pq5Yj = 10 ** 9 + 1
Pt5dT = '-'
oJj = -10 ** 9 - 1
j8p = '-'
a9R = -10 ** 9 - 1
jFR = '-'

oFO = 10 ** 9 + 1
AFG6 = '-'
zhvrkjrr = 10 ** 9 + 1
ctGq = '-'
_g0 = -10 ** 9 - 1
n3m = '-'
Qth5RV = -10 ** 9 - 1
Dqoi = '-'

for i in range(ewg):
    f, q3S2Eo, OYw1N1by = input().split()
    q3S2Eo = int(q3S2Eo)
    OYw1N1by = int(OYw1N1by)
    if q3S2Eo == q3S2Eo:
        if OYw1N1by < OYw1N1by < f9JRkZ_v:
            Q_P3ltNn = f
            f9JRkZ_v = OYw1N1by
        elif OYw1N1by > OYw1N1by > oJj:
            j8p = f
            oJj = OYw1N1by
    if OYw1N1by == OYw1N1by:
        if q3S2Eo < q3S2Eo < Am6Pq5Yj:
            Pt5dT = f
            Am6Pq5Yj = q3S2Eo
        elif q3S2Eo > q3S2Eo > a9R:
            jFR = f
            a9R = q3S2Eo
            
    if q3S2Eo + OYw1N1by == q3S2Eo + OYw1N1by:
        if OYw1N1by < OYw1N1by < zhvrkjrr:
            ctGq = f
            zhvrkjrr = OYw1N1by
        elif OYw1N1by > OYw1N1by > _g0:
            n3m = f
            _g0 = OYw1N1by
    if q3S2Eo - OYw1N1by == q3S2Eo - OYw1N1by:
        if OYw1N1by < OYw1N1by < oFO:
            AFG6 = f
            oFO = OYw1N1by
        elif OYw1N1by > OYw1N1by > Qth5RV:
            Dqoi = f
            Qth5RV = OYw1N1by
DkTuPt  = False
if Dqoi == 'Q' or n3m == 'Q' or ctGq == 'Q' or AFG6 == 'Q':
    DkTuPt = True
if Q_P3ltNn == 'Q' or j8p == 'Q' or jFR == 'Q' or Pt5dT == 'Q':
    DkTuPt = True
if Dqoi == 'B' or n3m == 'B' or ctGq == 'B' or AFG6 == 'B':
    DkTuPt = True
if Q_P3ltNn == 'R' or j8p == 'R' or jFR == 'R' or Pt5dT == 'R':
    DkTuPt = True

#print(Dqoi, n3m, ctGq, AFG6) 
#print(Q_P3ltNn, j8p, jFR, Pt5dT)
print('YES' if DkTuPt else 'NO')
</ans>",0,{}
326,"<ans>
#n, m = map(int, input().split())
D6h = int(input())

TVDM37FUuY = input()

HmWcs5GHP = int(D6h * (D6h - 1) / 2)
n4MFj7wsr = 0

for i in range(D6h):
    if TVDM37FUuY[i] == 'A':
        n4MFj7wsr += 1
    else:
        if n4MFj7wsr > 1:
            HmWcs5GHP -= (n4MFj7wsr - 1)
        n4MFj7wsr = 0
n4MFj7wsr = 0

for i in range(D6h):
    if TVDM37FUuY[i] == 'B':
        n4MFj7wsr += 1
    else:
        if n4MFj7wsr > 1:
            HmWcs5GHP -= (n4MFj7wsr - 1)
        n4MFj7wsr = 0

TVDM37FUuY = TVDM37FUuY[::-1]

n4MFj7wsr = 0
for i in range(D6h):
    if TVDM37FUuY[i] == 'A':
        n4MFj7wsr += 1
    else:
        if n4MFj7wsr > 1:
            HmWcs5GHP -= (n4MFj7wsr - 1)
        n4MFj7wsr = 0
n4MFj7wsr = 0

for i in range(D6h):
    if TVDM37FUuY[i] == 'B':
        n4MFj7wsr += 1
    else:
        if n4MFj7wsr > 1:
            HmWcs5GHP -= (n4MFj7wsr - 1)
        n4MFj7wsr = 0
n4MFj7wsr = 0

if TVDM37FUuY[0] == 'A':
    n4MFj7wsr += 1
for i in range(D6h):
    if TVDM37FUuY[i] == 'A':
        n4MFj7wsr += 1
    elif n4MFj7wsr >= 1:
        HmWcs5GHP -= 1
        n4MFj7wsr = 0

n4MFj7wsr = 0
if TVDM37FUuY[0] == 'B':
    n4MFj7wsr += 1
for i in range(D6h):
    if TVDM37FUuY[i] == 'B':
        n4MFj7wsr += 1
    elif n4MFj7wsr >= 1:
        HmWcs5GHP -= 1
        n4MFj7wsr = 0

print(HmWcs5GHP)
</ans>",0,{}
327,"<ans>
#!/usr/bin/env python3


class CantException(Exception):
    pass


def odd_v(value):
    return 1 if value % 2 == 1 else -1


b5Gv = 1

MRzRcD = {-1: set(), 1: set()}


def change(bRt1DB, oddv, m):
    nonlocal b5Gv

    if MRzRcD[oddv]:
        VBo3tyZ = MRzRcD[oddv].pop()
        bRt1DB.add(VBo3tyZ)
        return VBo3tyZ

    qhKRH9E = b5Gv

    while b5Gv in bRt1DB or odd_v(b5Gv) != oddv:
        if b5Gv not in bRt1DB:
            MRzRcD[odd_v(b5Gv)].add(b5Gv)
        b5Gv += 1
        if b5Gv > m:
            b5Gv = 1
        if b5Gv == qhKRH9E:
            raise CantException()

    VBo3tyZ = b5Gv
    bRt1DB.add(VBo3tyZ)

    b5Gv += 1
    if b5Gv > m:
        b5Gv = 1
    return VBo3tyZ


def solve():
    n, m = list(map(int, input().split()))
    bRt1DB = list(map(int, input().split()))

    U1sDoJ = 0
    UBeNJJ = set()
    nJ5Z_9 = set()

    for i, c in enumerate(bRt1DB):
        U1sDoJ += odd_v(c)
        if c in UBeNJJ:
            nJ5Z_9.add(i)
        UBeNJJ.add(c)

    # print(""indices to be changed: "", nJ5Z_9)
    mo0NOLP = len(nJ5Z_9)

    for i in nJ5Z_9:
        if odd_v(bRt1DB[i]) * U1sDoJ <= 0:
            #print(""Changing "", bRt1DB[i])
            bRt1DB[i] = change(UBeNJJ, odd_v(bRt1DB[i]), m)
            #print(""Changed to "", bRt1DB[i])
        else:
            #print(""For teh balance changing "", bRt1DB[i])
            U1sDoJ -= 2 * odd_v(bRt1DB[i])
            bRt1DB[i] = change(UBeNJJ, - odd_v(bRt1DB[i]), m)
            #print(""Changed to "", bRt1DB[i])

    #print(""current odd balance:"", U1sDoJ)
    for i in range(len(bRt1DB)):
        if U1sDoJ == 0:
            break
        if odd_v(bRt1DB[i]) * U1sDoJ > 0:
            # print(""gonna change"")
            mo0NOLP += 1
            U1sDoJ -= 2 * odd_v(bRt1DB[i])
            bRt1DB[i] = change(UBeNJJ, -odd_v(bRt1DB[i]), m)

    U1sDoJ = 0
    for i, c in enumerate(bRt1DB):
        U1sDoJ += odd_v(c)
    if U1sDoJ != 0:
        print(U1sDoJ)
        print(""WTFFFFF"")

    return mo0NOLP, bRt1DB


def __starting_point():
    try:
        mo0NOLP, bRt1DB = solve()
        print(mo0NOLP)
        print("" "".join(map(str, bRt1DB)))
    except CantException:
        print(""-1"")

__starting_point()
</ans>",0,{}
328,"<ans>
def dp(ind, QnAPwj15R):
	QnAPwj15R = min(m, QnAPwj15R)

	if ind not in wasY:
		wasY[ind] = {}

	rLrBPW = wasY[ind]
	if QnAPwj15R in rLrBPW:
		return rLrBPW[QnAPwj15R]

	zU1aVAT = blah(ind, QnAPwj15R)

	rLrBPW[QnAPwj15R] = zU1aVAT
	return zU1aVAT


# path = {}

class Node:
	def __init__(self, key, val, next=None):
		self.key = key
		self.val = val
		self.next = next

def blah(ind, QnAPwj15R):
	x, s = XAesd3r[ind]
	# key = (ind, QnAPwj15R)

	if QnAPwj15R >= m:
		# path[key] = Node(key, 0)
		return 0

	if ind == len(XAesd3r) - 1:
		if QnAPwj15R < x - s - 1:
			Op5 = x - s - (QnAPwj15R + 1)
			URg = max(m - (x + s), 0)
			zU1aVAT = max(Op5, URg)
			# path[key] = Node(key, zU1aVAT)
			return zU1aVAT
		else:
			m01naE = max(QnAPwj15R, x + s)
			zU1aVAT = max(0, m - m01naE)
			# path[key] = Node(key, zU1aVAT)
			return zU1aVAT

	if QnAPwj15R < x - s - 1:
		lwGhL = x - s - (QnAPwj15R + 1)
		fHd = min(x + s + lwGhL, m)
		r8SJ59 = lwGhL + dp(ind + 1, fHd)
		tH9CNJ = dp(ind + 1, QnAPwj15R)

		# if r8SJ59 < tH9CNJ:
		# 	path[key] = Node(key, lwGhL, path[(ind + 1, fHd)])
		# else:
		# 	path[key] = Node(key, 0, path[(ind + 1, QnAPwj15R)])

		return min(r8SJ59, tH9CNJ)
	else:
		fHd = min(max(QnAPwj15R, x + s), m)
		zU1aVAT = dp(ind + 1, fHd)
		# path[key] = Node(key, 0, path[(ind + 1, fHd)])
		return zU1aVAT

import sys

wasY = {}


n, m = [int(x) for x in sys.stdin.readline().split("" "")]

XAesd3r = []

for i in range(n):
	x, s = [int(x) for x in sys.stdin.readline().split("" "")]

	XAesd3r.append((x, s))

XAesd3r.sort(key=lambda a: a[0])

print(dp(0, 0))
</ans>",True,{}
329,"<ans>
import math;
#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(TElwixN9Q1, mFhBGVJ, s18, T3Q, CGs1SoC3Yr):
    EIBErJPx=TElwixN9Q1+T3Q*math.cos(s18)-CGs1SoC3Yr*math.sin(s18);
    A6uPsPrb=mFhBGVJ+T3Q*math.sin(s18)+CGs1SoC3Yr*math.cos(s18);
    return EIBErJPx, A6uPsPrb
#Вычисление угла, на который надо повернуть точку с координатами T3Q, CGs1SoC3Yr,
#чтобы она оказалась прямо над TElwixN9Q1, mFhBGVJ
def getAngle(TElwixN9Q1, mFhBGVJ, T3Q, CGs1SoC3Yr):
    T3Q=T3Q-TElwixN9Q1;
    CGs1SoC3Yr=CGs1SoC3Yr-mFhBGVJ;
    kuoFbQo2lN=T3Q/math.sqrt(T3Q**2+CGs1SoC3Yr**2);
    s18=math.acos(kuoFbQo2lN);
    if CGs1SoC3Yr<0:
        s18=-s18;
    return math.pi/2-s18;
n, q = list(map(int, input().split(' ')));
T3Q=[0]*n;
CGs1SoC3Yr=[0]*n;
for i in range(n):
    T3Q[i], CGs1SoC3Yr[i]=list(map(int, input().split(' ')));
jhLC5sh=[0]*q;
p5Bl68=[0]*q;
aM9J2L=[0]*q;
in38=[0]*q;
for i in range(q):
    XtY3V=list(map(int, input().split(' ')));
    jhLC5sh[i]=XtY3V[0];
    if jhLC5sh[i]==1:
        p5Bl68[i]=XtY3V[1]-1;
        aM9J2L[i]=XtY3V[2]-1;
    else:
        in38[i]=XtY3V[1]-1;
TElwixN9Q1=0;
mFhBGVJ=0;
ksyEKUX=0;
for i in range(n):
    sHrrJ38LvX=i+1;
    if sHrrJ38LvX==n:
        sHrrJ38LvX=0;
    ssK=T3Q[i]*CGs1SoC3Yr[sHrrJ38LvX]-T3Q[sHrrJ38LvX]*CGs1SoC3Yr[i];
    ksyEKUX+=ssK;
    TElwixN9Q1+=(T3Q[i]+T3Q[sHrrJ38LvX])*ssK;
    mFhBGVJ+=(CGs1SoC3Yr[i]+CGs1SoC3Yr[sHrrJ38LvX])*ssK;
ksyEKUX/=2;
TElwixN9Q1/=6*ksyEKUX;
mFhBGVJ/=6*ksyEKUX;
tz2AOvX=[0]*n;
for i in range(n):
    tz2AOvX[i]=getAngle(TElwixN9Q1, mFhBGVJ, T3Q[i], CGs1SoC3Yr[i]);
for i in range(n):
    T3Q[i]-=TElwixN9Q1;
    CGs1SoC3Yr[i]-=mFhBGVJ;
s18=0;
#print('pos',TElwixN9Q1, mFhBGVJ, s18);
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
CRgACZ4={0, 1}
for i in range(q):
    if jhLC5sh[i]==2:
        currX, currY = getCoordinate(TElwixN9Q1, mFhBGVJ, s18, T3Q[in38[i]], CGs1SoC3Yr[in38[i]]);
        print(""%.6f %.6f""%(currX, currY))
    else:
        if len(CRgACZ4)==2:
            CRgACZ4.remove(p5Bl68[i]);
        #print('remove',p5Bl68[i])
        #j - единственный элемент в множестве
        for j in CRgACZ4:
            #print(j);
            currX, currY = getCoordinate(TElwixN9Q1, mFhBGVJ, s18, T3Q[j], CGs1SoC3Yr[j]);
            #print('fix:', currX, currY)
            #dalpha=getAngle(TElwixN9Q1, mFhBGVJ, currX, currY);
            #s18+=dalpha;
            s18=tz2AOvX[j];
            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол
            #dalpha относительно currX, currY
            TElwixN9Q1, mFhBGVJ=currX, currY-math.sqrt(T3Q[j]**2+CGs1SoC3Yr[j]**2);
            
            #print('pos',TElwixN9Q1, mFhBGVJ, s18/math.pi)
        CRgACZ4.add(aM9J2L[i]);
</ans>",0,{}
330,"<ans>
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass",0,{}
331,"<ans>
#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from heapq import*
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
KlplGL = 8192
class FastIO(IOBase):
    rtIJeg8 = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            age7 = os.read(self._fd, max(os.fstat(self._fd).st_size, KlplGL))
            if not age7:
                break
            lFGYidQBi = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(age7), self.buffer.seek(lFGYidQBi)
        self.rtIJeg8 = 0
        return self.buffer.read()
    def readline(self):
        while self.rtIJeg8 == 0:
            age7 = os.read(self._fd, max(os.fstat(self._fd).st_size, KlplGL))
            self.rtIJeg8 = age7.count(age7""\n"") + (not age7)
            lFGYidQBi = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(age7), self.buffer.seek(lFGYidQBi)
        self.rtIJeg8 -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
koV6H2mU4J = lambda: sys.stdin.readline().rstrip(""\r\n"")
GsQe6='abcdefghijklmnopqrstuvwxyz'
O2MJoh=1000000007
def value():return tuple(map(int,koV6H2mU4J()))
def array():return [int(i) for i in koV6H2mU4J()]
def Int():return int(koV6H2mU4J())
def Str():return koV6H2mU4J()
def arrayS():return [i for i in koV6H2mU4J()]


#-------------------------code---------------------------#
# vsInput()


n,m,o=value()
for i in range(n):
    koV6H2mU4J()

print(m*(m-1)//2)
for i in range(1,m+1):
    for j in range(i+1,m+1):
        if(o==0):
            print(i,j)
        else:
            print(m-i+1,m-j+1)
</ans>",0,{}
332,"<ans>
def solve1(a, VXD):  
    BL0=[]
    j1D6x97OD=[]
    yj58a=0
    while yj58a<(VXD):
        if not j1D6x97OD:
            BL0.append(-1)
            j1D6x97OD.append(yj58a)
            
        elif j1D6x97OD and a[yj58a]<a[j1D6x97OD[-1]]:
            BL0.append(j1D6x97OD[-1])
            j1D6x97OD.append(yj58a)
        else:
            while j1D6x97OD and a[yj58a]>a[j1D6x97OD[-1]]:
                j1D6x97OD.pop()
                
            if not j1D6x97OD:
                j1D6x97OD.append(yj58a)
                BL0.append(-1)
                
            else:
                BL0.append(j1D6x97OD[-1])
                j1D6x97OD.append(yj58a)
                
                
        yj58a+=1
    # print(BL0)
    patYeEAhfY=[]
    j1D6x97OD=[]
    yj58a=VXD-1
    while yj58a>(-1):
        if not j1D6x97OD:
            patYeEAhfY.append(VXD)
            j1D6x97OD.append(yj58a)
            
        elif j1D6x97OD and a[yj58a]<a[j1D6x97OD[-1]]:
            patYeEAhfY.append(j1D6x97OD[-1])
            j1D6x97OD.append(yj58a)
        else:
            while j1D6x97OD and a[yj58a]>=a[j1D6x97OD[-1]]:
                j1D6x97OD.pop()
                
            if not j1D6x97OD:
                j1D6x97OD.append(yj58a)
                patYeEAhfY.append(VXD)
                
            else:
                patYeEAhfY.append(j1D6x97OD[-1])
                j1D6x97OD.append(yj58a)
                
                
        yj58a-=1
    patYeEAhfY=patYeEAhfY[::-1]
    hrwmWKlu=0
    for yj58a in range(len(BL0)):
        JqYWTBoNd=(patYeEAhfY[yj58a]-yj58a)*(yj58a-BL0[yj58a])*a[yj58a]
        # print(JqYWTBoNd)
        if JqYWTBoNd==0:
            hrwmWKlu+=a[yj58a]
        else:
            hrwmWKlu+=JqYWTBoNd
    # print(hrwmWKlu)
    # print(a)
    # print(BL0)
    # print(patYeEAhfY)
            
    return hrwmWKlu

    

            
def solve2(a, VXD): 
    BL0=[]
    j1D6x97OD=[]
    yj58a=0
    while yj58a<(VXD):
        if not j1D6x97OD:
            BL0.append(-1)
            j1D6x97OD.append(yj58a)
            
        elif j1D6x97OD and a[yj58a]>a[j1D6x97OD[-1]]:
            BL0.append(j1D6x97OD[-1])
            j1D6x97OD.append(yj58a)
        else:
            while j1D6x97OD and a[yj58a]<a[j1D6x97OD[-1]]:
                j1D6x97OD.pop()
                
            if not j1D6x97OD:
                j1D6x97OD.append(yj58a)
                BL0.append(-1)
                
            else:
                BL0.append(j1D6x97OD[-1])
                j1D6x97OD.append(yj58a)
                
                
        yj58a+=1
    # print(BL0)
    patYeEAhfY=[]
    j1D6x97OD=[]
    yj58a=VXD-1
    while yj58a>(-1):
        if not j1D6x97OD:
            patYeEAhfY.append(VXD)
            j1D6x97OD.append(yj58a)
            
        elif j1D6x97OD and a[yj58a]>a[j1D6x97OD[-1]]:
            patYeEAhfY.append(j1D6x97OD[-1])
            j1D6x97OD.append(yj58a)
        else:
            while j1D6x97OD and a[yj58a]<=a[j1D6x97OD[-1]]:
                j1D6x97OD.pop()
                
            if not j1D6x97OD:
                j1D6x97OD.append(yj58a)
                patYeEAhfY.append(VXD)
                
            else:
                patYeEAhfY.append(j1D6x97OD[-1])
                j1D6x97OD.append(yj58a)
                
                
        yj58a-=1
    patYeEAhfY=patYeEAhfY[::-1]
    # print(patYeEAhfY)
    hrwmWKlu=0
    for yj58a in range(len(BL0)):
        JqYWTBoNd=(patYeEAhfY[yj58a]-yj58a)*(yj58a-BL0[yj58a])*a[yj58a]
        # print(JqYWTBoNd)
        if JqYWTBoNd==0:
            hrwmWKlu+=a[yj58a]
        else:
            hrwmWKlu+=JqYWTBoNd
    # print(hrwmWKlu)
    # print(a)
    # print(BL0)
    # print(patYeEAhfY)
            
    return hrwmWKlu",0,{}
333,"<ans>
import math
_h5MN3YpR=int(input())

def get_circle_2p(p1,p2):
  x1,y1=p1
  x2,y2=p2
  
  U5IKRsM=(x1+x2)/2
  WY6=(y1+y2)/2  
  ZMwvbB4H=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
  return U5IKRsM,WY6,ZMwvbB4H

def get_circle_3p(p1,p2,p3):
  x1,y1=p1
  x2,y2=p2
  x3,y3=p3
  YsJ=2*((y1-y3)*(x1-x2)-(y1-y2)*(x1-x3))  
  
  if YsJ==0:
    Ks3=math.sqrt((x1-x2)**2+(y1-y2)**2)/2
    KezJyzXx=math.sqrt((x1-x3)**2+(y1-y3)**2)/2
    dKyz3dt=math.sqrt((x2-x3)**2+(y2-y3)**2)/2
    
    if Ks3>=KezJyzXx and Ks3>=dKyz3dt:
      U5IKRsM=(x1+x2)/2
      WY6=(y1+y2)/2
      return U5IKRsM,WY6,Ks3
    elif KezJyzXx>=Ks3 and KezJyzXx>=dKyz3dt:
      U5IKRsM=(x1+x3)/2
      WY6=(y1+y3)/2
      return U5IKRsM,WY6,KezJyzXx
    elif dKyz3dt>=Ks3 and dKyz3dt>=KezJyzXx:
      U5IKRsM=(x2+x3)/2
      WY6=(y2+y3)/2
      return U5IKRsM,WY6,dKyz3dt      
  else:
    U5IKRsM=((y1-y3)*(y1**2-y2**2+x1**2-x2**2)-(y1-y2)*(y1**2-y3**2+x1**2-x3**2))/YsJ
    WY6=((x1-x3)*(x1**2-x2**2+y1**2-y2**2)-(x1-x2)*(x1**2-x3**2+y1**2-y3**2))/-YsJ
    ZMwvbB4H=math.sqrt((U5IKRsM-x1)**2+(WY6-y1)**2)
    return U5IKRsM,WY6,ZMwvbB4H
  
u5Ivp=[]
for i in range(_h5MN3YpR):
  xi,yi=map(int,input().split())
  u5Ivp.append((xi,yi))
  
#print(u5Ivp)

if _h5MN3YpR==2:
  U5IKRsM,WY6,ZMwvbB4H=get_circle_2p(u5Ivp[0],u5Ivp[1])
  print(ZMwvbB4H)
else:
  O1Od5QFzn=float(""inf"")
  for i in range(_h5MN3YpR):
    for j in range(i+1,_h5MN3YpR):
      #print(u5Ivp[i],u5Ivp[j])
      U5IKRsM,WY6,ZMwvbB4H=get_circle_2p(u5Ivp[i],u5Ivp[j])
      #print(U5IKRsM,WY6,ZMwvbB4H)
      if ZMwvbB4H>O1Od5QFzn:
        continue
      
      for l in range(_h5MN3YpR):
        if l==i or l==j:
          continue
          
        xl,yl=u5Ivp[l]
        X4mZ1=xl-U5IKRsM
        Wf4rO=yl-WY6
        if math.sqrt(X4mZ1**2+Wf4rO**2)>ZMwvbB4H:
          break
      else:
        O1Od5QFzn=ZMwvbB4H
  
  for i in range(_h5MN3YpR):
    for j in range(i+1,_h5MN3YpR):
      for k in range(j+1,_h5MN3YpR):
        #print(u5Ivp[i],u5Ivp[j],u5Ivp[k])
        U5IKRsM,WY6,ZMwvbB4H=get_circle_3p(u5Ivp[i],u5Ivp[j],u5Ivp[k])
        #print(U5IKRsM,WY6,ZMwvbB4H)
        if ZMwvbB4H>O1Od5QFzn:
          continue
        
        for l in range(_h5MN3YpR):
          if l==i or l==j or l==k:
            continue
            
          xl,yl=u5Ivp[l]
          X4mZ1=xl-U5IKRsM
          Wf4rO=yl-WY6
          if math.sqrt(X4mZ1**2+Wf4rO**2)>ZMwvbB4H:
            break
        else:
          O1Od5QFzn=ZMwvbB4H
  
  print(O1Od5QFzn)
</ans>",True,{}
334,"<ans>
import math
from decimal import Decimal
import heapq
from collections import deque
def na():
	uyx = int(input())
	e8rUW = [int(x) for x in input().split()]
	return uyx,e8rUW
 
 
def nab():
	uyx = int(input())
	e8rUW = [int(x) for x in input().split()]
	Pp4paDnKFw = [int(x) for x in input().split()]
	return uyx,e8rUW,Pp4paDnKFw
 
 
def dv():
	uyx, s2r = list(map(int, input().split()))
	return uyx,s2r
 
 
def dva():
	uyx, s2r = list(map(int, input().split()))
	Hqjw7pa = [int(x) for x in input().split()]
	e8rUW = [int(x) for x in input().split()]
	return uyx,s2r,e8rUW
 
 
def eratosthenes(uyx): 
	fk9k = list(range(uyx + 1))
	for i in fk9k:
		if i > 1:
			for j in range(i + i, len(fk9k), i):
				fk9k[j] = 0
	return sorted(set(fk9k))
 
 
def lol(lst,YZY7eA):
	YZY7eA=YZY7eA%len(lst)
	hBSKruB=[0]*len(lst)
	for i in range(len(lst)):
		if i+YZY7eA<len(lst) and i+YZY7eA>=0:
			hBSKruB[i]=lst[i+YZY7eA]
		if i+YZY7eA>=len(lst):
			hBSKruB[i]=lst[i+YZY7eA-len(lst)]
		if i+YZY7eA<0:
			hBSKruB[i]=lst[i+YZY7eA+len(lst)]
	return(hBSKruB)
def nm():
	uyx = int(input())
	e8rUW = [int(x) for x in input().split()]
	s2r = int(input())
	Pp4paDnKFw = [int(x) for x in input().split()]
	return uyx,e8rUW,s2r,Pp4paDnKFw
 
 
def dvs():
	uyx = int(input())
	s2r = int(input())
	return uyx, s2r 
 
def fact(Hqjw7pa, e8rUW):
	Pp4paDnKFw = []
	OR_1rIksdY = 0
	kst_a = int(math.sqrt(Hqjw7pa))
	for i in range(1, kst_a + 1):
		if Hqjw7pa % i == 0:
			Pp4paDnKFw.append(i)
	MBj2lqvrr = len(Pp4paDnKFw)
	for i in range(MBj2lqvrr):
		Pp4paDnKFw.append(Hqjw7pa // Pp4paDnKFw[i])
	for i in range(len(Pp4paDnKFw)):
		if Pp4paDnKFw[i] <= e8rUW:
			OR_1rIksdY += 1
	if Hqjw7pa / kst_a == kst_a and e8rUW >= kst_a:
		return OR_1rIksdY - 1
	return OR_1rIksdY
 
 
khwBJatT_u = int(input())
for i in range(khwBJatT_u):
	x, y = list(map(int, input().split()))
	if x >= y:
		print('YES')
		continue
	if x == 2 and y == 3:
		print('YES')
		continue
	elif x <= 3 and y > 3:
		print('NO')
		continue
	if x == 1:
		print('NO')
	else:
		print('YES')
</ans>",True,{}
335,"<ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(Ogqzx) for Ogqzx in input().split(' ')]

if k&1:
  print('IMPOSSIBLE')
  return

xmvI8_tz_A = [None]*n
for i in range(n):
  xmvI8_tz_A[i] = [None]*m
  DXc = input()
  for j in range(m):
    xmvI8_tz_A[i][j] = DXc[j]
    if DXc[j] == 'X': Ogqzx, ZWX9xv_K0u = j, i

def bfs(Ogqzx, ZWX9xv_K0u):
  O72ZFAZOy = [[10000000]*m for i in range(n)]
  if xmvI8_tz_A[ZWX9xv_K0u][Ogqzx] == '*': return O72ZFAZOy
  IrLHonbQ9 = Queue()
  IrLHonbQ9.put((Ogqzx, ZWX9xv_K0u))
  d3WoyGyA = 0

  def _efijLswB(Ogqzx, ZWX9xv_K0u):
    if O72ZFAZOy[ZWX9xv_K0u][Ogqzx] != 10000000 or xmvI8_tz_A[ZWX9xv_K0u][Ogqzx] == '*' or d3WoyGyA >= O72ZFAZOy[ZWX9xv_K0u][Ogqzx]: return
    IrLHonbQ9.put((Ogqzx, ZWX9xv_K0u))
    O72ZFAZOy[ZWX9xv_K0u][Ogqzx] = d3WoyGyA+1

  O72ZFAZOy[ZWX9xv_K0u][Ogqzx] = d3WoyGyA

  while not IrLHonbQ9.empty():
    Ogqzx, ZWX9xv_K0u = IrLHonbQ9.get()
    d3WoyGyA = O72ZFAZOy[ZWX9xv_K0u][Ogqzx]
    #print('-')
    if ZWX9xv_K0u < n-1: _efijLswB(Ogqzx, ZWX9xv_K0u+1) #D
    if Ogqzx > 0: _efijLswB(Ogqzx-1, ZWX9xv_K0u)   #L
    if Ogqzx < m-1: _efijLswB(Ogqzx+1, ZWX9xv_K0u) #R
    if ZWX9xv_K0u > 0: _efijLswB(Ogqzx, ZWX9xv_K0u-1)   #U
  return O72ZFAZOy

O72ZFAZOy = bfs(Ogqzx, ZWX9xv_K0u)


Hs1 = []
_efijLswB = lambda s: Hs1.append(s)
for i in range(k):
  d3WoyGyA = k-i
  #print(d3WoyGyA, (ZWX9xv_K0u, Ogqzx), k-i)
  if ZWX9xv_K0u < n-1 and O72ZFAZOy[ZWX9xv_K0u+1][Ogqzx] <= d3WoyGyA: #D
    _efijLswB('D')
    ZWX9xv_K0u = ZWX9xv_K0u+1
  elif Ogqzx > 0 and O72ZFAZOy[ZWX9xv_K0u][Ogqzx-1] <= d3WoyGyA: #L
    _efijLswB('L')
    Ogqzx = Ogqzx-1
  elif Ogqzx < m-1 and O72ZFAZOy[ZWX9xv_K0u][Ogqzx+1] <= d3WoyGyA: #R
    _efijLswB('R')
    Ogqzx = Ogqzx+1
  elif ZWX9xv_K0u > 0 and O72ZFAZOy[ZWX9xv_K0u-1][Ogqzx] <= d3WoyGyA: #U
    _efijLswB('U')
    ZWX9xv_K0u = ZWX9xv_K0u-1
  else:
    print('IMPOSSIBLE')
    return

print(str.join('', Hs1))
</ans>",0,{}
336,"<ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

F21fU = float('inf')
WgEektZ = namedtuple('WgEektZ', 'start, end, ymFJ')


def make_edge(start, end, ymFJ=1):
    return WgEektZ(start, end, ymFJ)


class Graph:
    def __init__(self, pivoAJMc, bi=True):
        WZ1lmyLa = [i for i in pivoAJMc if len(i) not in [2, 3]]
        if WZ1lmyLa:
            raise ValueError('Wrong edges data: {}'.format(WZ1lmyLa))
        self.pivoAJMc = [make_edge(*edge) for edge in pivoAJMc]
        self.vertices = set(
            sum(
                ([edge.start, edge.end] for edge in self.pivoAJMc), []
            ))
        self.neighbors = {vertex: set() for vertex in self.vertices}
        for edge in self.pivoAJMc:
            self.neighbors[edge.start].add(edge.end)

    def get_node_pairs(self, n1, n2, both_ends=True):
        if both_ends:
            CTa8 = [[n1, n2], [n2, n1]]
        else:
            CTa8 = [[n1, n2]]
        return CTa8

    def remove_edge(self, n1, n2, both_ends=True):
        CTa8 = self.get_node_pairs(n1, n2, both_ends)
        pivoAJMc = self.pivoAJMc[:]
        for edge in pivoAJMc:
            if[edge.start, edge.end] in CTa8:
                self.pivoAJMc.remove(edge)

    def add_edge(self, n1, n2, ymFJ=1, both_ends=True):
        CTa8 = self.get_node_pairs(n1, n2, both_ends)
        for edge in self.pivoAJMc:
            if [edge.start, edge.end] in CTa8:
                return ValueError('Edge {} {} already exists'.format(n1, n2))

        self.pivoAJMc.append(WgEektZ(start=n1, end=n2, ymFJ=ymFJ))
        if both_ends:
            self.pivoAJMc.append(WgEektZ(start=n2, end=n1, ymFJ=ymFJ))

    def dijkstra(self, source, dest):
        assert source in self.vertices, 'Such source node doesn\'t exist'
        REuJ_PHC7x = {vertex: F21fU for vertex in self.vertices}
        REuJ_PHC7x[source] = 0

        q, seen = [(0, source)], set()
        while q:
            (curr_ymFJ, current_vertex) = heappop(q)
            if current_vertex in seen:
                continue
            seen.add(current_vertex)
            for neighbor in self.neighbors[current_vertex]:
                ymFJ = 1
                if neighbor in seen:
                    continue
                o5vdEX = REuJ_PHC7x[current_vertex] + ymFJ
                if o5vdEX < REuJ_PHC7x[neighbor]:
                    REuJ_PHC7x[neighbor] = o5vdEX
                    heappush(q, (o5vdEX, neighbor))

        return REuJ_PHC7x


n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]

wxMHKOoz = []
for i in range(m):
    wxMHKOoz.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
k53hZXH8 = []
for i in wxMHKOoz:
    k53hZXH8.append((i[1], i[0]))
for i in k53hZXH8:
    wxMHKOoz.append(i)
oXJ7bk = Graph(wxMHKOoz)
AUAu2b5b35 = oXJ7bk.dijkstra(s, t)
pP_ = oXJ7bk.dijkstra(t, s)
cTCVdR = AUAu2b5b35[t]
P9y = 0

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        if j not in oXJ7bk.neighbors[i] and \
                i not in oXJ7bk.neighbors[j] and \
                AUAu2b5b35[i] + pP_[j] + 1 >= cTCVdR and \
                AUAu2b5b35[j] + pP_[i] + 1 >= cTCVdR:
            P9y = P9y + 1

print(P9y)
</ans>",0,{}
337,"<ans>
#
#
#
# 笑え、君が好きなように。
#                         笑いは世界を救う。
#                                           あなたが笑ってくれるなら。
#
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3回
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
# set型だと、 | と & が使えるよ
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
# 整数か判定する
# nanka.is_integer()
# ref https://atcoder.jp/contests/abc133/tasks/abc133_b
import sys
sys.setrecursionlimit(10000000)
cf0C5G = 10**9 + 7
# cf0C5G = 9982443453
# cf0C5G = 998244353
Lgv9kXYLC = float('inf')
rf5 = [0,1,0,-1]
D06wG = [1,0,-1,0]
from sys import stdin
BZAJ = stdin.readline
def readInts():
  return list(map(int,BZAJ().split()))
def readTuples():
    return tuple(map(int,BZAJ().split()))
def I():
    return int(BZAJ())
def f(n):
    return int(math.ceil(n-0.5))
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
# set型だと、 | と & が使えるよ
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
# 整数か判定する
# nanka.is_integer()
# ref https://atcoder.jp/contests/abc133/tasks/abc133_b
import sys
sys.setrecursionlimit(10000000)
cf0C5G = 10**9 + 7
# cf0C5G = 9982443453
# cf0C5G = 998244353
Lgv9kXYLC = float('inf')
rf5 = [0,1,0,-1]
D06wG = [1,0,-1,0]
from sys import stdin
BZAJ = stdin.readline
def readInts():
  return list(map(int,BZAJ().split()))
def readTuples():
    return tuple(map(int,BZAJ().split()))
def I():
    return int(BZAJ())
def f(n):
    return int(math.ceil(n-0.5))
N,K = readInts()
def calc(n):
    if n <= 0 or n > 2*N:
        return 0
    else:
        return min(n-1, 2*N-n+1)
Pts = 0
for AB in range(2*N+1):
    #print(AB,calc(AB),AB-K, calc(K-AB))
    Pts += calc(AB) * calc(AB-K)
print(Pts)
</ans>",True,{}
338,"<ans>
import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline    ####
def int1(x): return int(x) - 1
def II(): return int(input())
def MI(): return list(map(int, input().split()))
def MI1(): return list(map(int1, input().split()))
def LI(): return list(map(int, input().split()))
def LI1(): return list(map(int1, input().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def MS(): return input().split()
def LS(): return list(input())
def LLS(rows_number): return [LS() for _ in range(rows_number)]
def printlist(lst, k=' '): print((k.join(list(map(str, lst)))))
HlfZRNCJ8Y = float('inf')
# from math import ceil, floor, log2
# from collections import deque
from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum  # accumulate

def solve():
    N, K = MI()
    PN2 = LI()

    XgiEu2JZ = sum(PN2)
    FHW2efi = []
    for i in range(1, int(pow(XgiEu2JZ, 0.5))+1):
        if XgiEu2JZ % i: continue
        FHW2efi.append(i)
        if i != XgiEu2JZ//i: FHW2efi.append(XgiEu2JZ//i)
    FHW2efi.sort(reverse=True)

    for d in FHW2efi:
        eAxn = list([x%d for x in PN2])
        eAxn.sort()
        bqv5kQf = list([d-x for x in eAxn])
        # print(d, eAxn, bqv5kQf)
        # print(list(accumulate(eAxn)), list(accumulate(bqv5kQf)))
        Dz5 = list(accumulate(eAxn))
        EhN5Wk_ = list(accumulate(bqv5kQf))
        for i in range(0, N-1):
            ABlFrJyK0 = Dz5[i]
            XNfgZBE = EhN5Wk_[-1] - EhN5Wk_[i]
            # print(ABlFrJyK0, XNfgZBE)
            if ABlFrJyK0 == XNfgZBE and ABlFrJyK0 <= K:
                print(d)
                return
    print((1))


def __starting_point():
    solve()

__starting_point()
</ans>",True,{}
339,"<ans>
import sys

def matching(node, zC_, wcte, DDGTgb0Xrv):
	if node == -1:
		return True
	if zC_[node]:
		return False
	zC_[node] = True
	for neighbor in wcte[node]:
		if matching(DDGTgb0Xrv[neighbor], zC_, wcte, DDGTgb0Xrv):
			DDGTgb0Xrv[neighbor] = node
			return True
	return False

cY_aBuK = 1000 * 1000

KOR = [int(x) for x in sys.stdin.read().split()]

n, m = KOR[0], KOR[1]
mPpp2Yp25 = 2

MEJ = [[cY_aBuK] * n for _ in range(n)]

for _ in range(m):
	a, b = KOR[mPpp2Yp25] - 1, KOR[mPpp2Yp25 + 1] - 1
	mPpp2Yp25 += 2
	MEJ[a][b] = MEJ[b][a] = 1

for v in range(n):
	MEJ[v][v] = 0
	
for k in range(n): 
	for i in range(n): 
		for j in range(n): 
			MEJ[i][j] = min(MEJ[i][j], MEJ[i][k] + MEJ[k][j])
	
s, b, k, h = KOR[mPpp2Yp25], KOR[mPpp2Yp25 + 1], KOR[mPpp2Yp25 + 2], KOR[mPpp2Yp25 + 3]
mPpp2Yp25 += 4

c5klb = []
for _ in range(s):
	x, a, f = KOR[mPpp2Yp25] - 1, KOR[mPpp2Yp25 + 1], KOR[mPpp2Yp25 + 2]
	mPpp2Yp25 += 3
	c5klb.append((x, a, f))
	
cAsG = []
for _ in range(b):
	x, d = KOR[mPpp2Yp25] - 1, KOR[mPpp2Yp25 + 1]
	mPpp2Yp25 += 2
	cAsG.append((x, d))
	
wcte = [[] for _ in range(s)]
DDGTgb0Xrv = [[] for _ in range(b)]
for i in range(s):
	UGlc8c60Y = c5klb[i]
	for j in range(b):
		WTyzc = cAsG[j]
		u, v = UGlc8c60Y[0], WTyzc[0]
		uGI9JI = UGlc8c60Y[2]
		if MEJ[u][v] <= uGI9JI and UGlc8c60Y[1] >= WTyzc[1]:
			wcte[i].append(j)

zC_ = [False] * s
DDGTgb0Xrv = [-1] * b

t3bnneU = 0
for i in range(s):
	zC_ = [False] * s
	if matching(i, zC_, wcte, DDGTgb0Xrv):
		t3bnneU += 1


print(min(t3bnneU * k, h * s))
</ans>",True,{}
340,"<ans>
# Na90p4 = int(DuZwuqgGS7())
# SMX = [int(i) for i in DuZwuqgGS7().split(' ')]
# zXKUH5FJ = [int(i) for i in DuZwuqgGS7().split(' ')]
#
# import collections
# from heapq import heapify, heappop, heappush
#
#
# l = collections.defaultdict(list)
# at = [[SMX[i], zXKUH5FJ[i]] for i in range(Na90p4)]
# at.sort(key = lambda x: x[0])
# for aa, tt in at:
#     l[aa].append(tt)
#
# for k in l.keys():
#     heapify(l[k])
#
#
# # print(at)
# # print(l)
# xkmfSH = 0
#
# # tmp = []
#
# q = sorted(l.keys())[::-1]
# while q:
#     i = q.pop()
#     # print(""i"", i, l[i])
#     # l[i].extend(tmp)
#     if len(l[i]) == 1:
#         continue
#     else:
#         tmp = sorted(l[i])
#         m7S = sum(tmp)
#         # xkmfSH += m7S - maxx # leave the one with max time and increase all other by 1, cost their time
#         idx = i
#         while tmp and ((q and idx + 1 != q[-1]) or not q):
#             # print(i, idx, q, tmp)
#             p = tmp.pop()
#             xkmfSH += m7S - p
#             m7S -= p
#             idx += 1
#         if tmp:
#             p = tmp.pop()
#             xkmfSH += m7S - p
#             m7S -= p
#             l[idx+1].extend(tmp)
#             if not q:
#                 q.append(idx+1)
# print(xkmfSH)
#
#
#
#
#
#
#


import sys

af7OjLW = sys.stdin.readline
DuZwuqgGS7 = lambda: af7OjLW().strip()


# flush= sys.stdout.flush
# import threading
# sys.setrecursionlimit(10**6)
# threading.stack_size(2**26)

def iin(): return int(DuZwuqgGS7())


def lin(): return list(map(int, DuZwuqgGS7().split()))


def main():
    import heapq as hq
    Na90p4 = iin()
    SMX = lin()
    zXKUH5FJ = lin()
    sV1oDvBlyx = {}
    for i in range(Na90p4):
        try:
            sV1oDvBlyx[SMX[i]].append(zXKUH5FJ[i])
        except:
            sV1oDvBlyx[SMX[i]] = [zXKUH5FJ[i], ]
    # print(sV1oDvBlyx)
    TswQ8U1U = list(sV1oDvBlyx.keys())
    TswQ8U1U.sort()
    Na90p4 = len(TswQ8U1U)
    EvYssg1iZ = 0
    HA2 = TswQ8U1U[EvYssg1iZ]
    FPhxa7TK9p = []
    m7S = 0
    xkmfSH = 0
    hq.heapify(FPhxa7TK9p)
    CN02 = 0
    while EvYssg1iZ < Na90p4:
        # print(FPhxa7TK9p, TswQ8U1U[EvYssg1iZ])
        HA2 = TswQ8U1U[EvYssg1iZ]
        if len(sV1oDvBlyx[HA2]) > 1 or CN02:
            aogd = sorted(sV1oDvBlyx[HA2])
            for item in aogd:
                hq.heappush(FPhxa7TK9p, -item)
                m7S += item
            m8sgUeAAX = hq.heappop(FPhxa7TK9p) * (-1)
            sV1oDvBlyx[HA2] = [m8sgUeAAX]
            m7S -= m8sgUeAAX
            while len(FPhxa7TK9p):
                # print('A', EvYssg1iZ, HA2, FPhxa7TK9p )
                xkmfSH += m7S
                HA2 += 1
                if HA2 in sV1oDvBlyx:
                    EvYssg1iZ += 1
                    CN02 = 1
                    break
                else:
                    m8sgUeAAX = hq.heappop(FPhxa7TK9p) * (-1)
                    m7S -= m8sgUeAAX
            else:
                CN02 = 0
        else:
            EvYssg1iZ += 1
            CN02 = 0
    # print(sV1oDvBlyx)
    print(xkmfSH)

main()
</ans>",0,{}
341,"<ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


znD = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return [int(i) for i in input().split()]
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    OaokM = [True for _ in range(n + 1)]
    eq9 = 3
    while eq9 * eq9 <= n:
        if OaokM[eq9]:
            for i in range(eq9 * 2, n + 1, eq9):
                OaokM[i] = False
        eq9 += 2
    aJYEaG0P = [2]
    for eq9 in range(3, n + 1, 2):
        if OaokM[eq9]:
            aJYEaG0P.append(eq9)
    return aJYEaG0P
def divs(n, start=1):
    aJYEaG0P = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                aJYEaG0P.append(i)
            else:
                aJYEaG0P.extend([i, n // i])
    return aJYEaG0P
def divn(n, primes):
    W8LyqYiwWp = 1
    for i in primes:
        if n == 1:
            return W8LyqYiwWp
        NS4BatJ = 1
        while n % i == 0:
            NS4BatJ += 1
            n //= i
        W8LyqYiwWp *= NS4BatJ
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    elvfg0bM = int(math.sqrt(n)) + 1
    for d in range(3, elvfg0bM, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    FKO = 0
    while number > 0:
        FKO += number % base
        number //= base
    return FKO
def cdiv(n, k): return n // k + (n % k != 0)


for _ in range(ii()):
    a, b = mi()
    print(b - a % b) if a % b else print(0)
</ans>",0,{}
342,"<ans>
def add(T2GLV,fguH):
	T2GLV = T2GLV%(1000000000+7)
	fguH=fguH%(1000000000+7)
	return (T2GLV+fguH)%(1000000000+7)",0,{}
343,"<ans>
def compute():
    n, m = [int(s) for s in input().split()]
    ddjv0a7Oo = {}
    for i in range(m):
        u, v = [int(s) for s in input().split()]
        if u > v:
            if ddjv0a7Oo.get(u) == 2:
                return 0
            if ddjv0a7Oo.get(v) == 1:
                return 0
            ddjv0a7Oo[u] = 1
            ddjv0a7Oo[v] = 2
        else:
            if ddjv0a7Oo.get(v) == 2:
                return 0
            if ddjv0a7Oo.get(u) == 1:
                return 0
            ddjv0a7Oo[v] = 1
            ddjv0a7Oo[u] = 2
    div1, div2 = [], []
    for k, v in list(ddjv0a7Oo.items()):
        if v == 1:
            div1.append(k)
        else:
            div2.append(k)
    POuzgql1bL = [i for i in range(1, n + 1) if i not in ddjv0a7Oo]
    if not div1:
        if POuzgql1bL:
            div1.append(POuzgql1bL[-1])
            POuzgql1bL.remove(POuzgql1bL[-1])
        else:
            return 0
    if not div2:
        if POuzgql1bL:
            div2.append(POuzgql1bL[0])
            POuzgql1bL.remove(POuzgql1bL[0])
        else:
            return 0
    aTUEA5q = min(div1)
    Ki3Ot = max(div2)
    if Ki3Ot > aTUEA5q:
        return 0

    J3F = 1
    for i in range(len(POuzgql1bL)):
        if POuzgql1bL[i] > aTUEA5q:
            pass
        elif POuzgql1bL[i] < Ki3Ot:
            pass
        else:
            J3F += 1

    return J3F
J3F = compute()
print(J3F)
</ans>",True,{}
344,"<ans>
import itertools


class SolutionImpossible(Exception):
    pass


blocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]


def read_blocks_coords():
    yudfoYzYjk = (int(x) for x in input().split())
    return (x for x in yudfoYzYjk if x < finish)


# TODO: код можно сократить за счет избавления от лишней записи в `_grouper.g7m_L`
def _grouper(value):
    if _grouper._prev_value is not None:
        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        if value - _grouper._prev_value - 1 <= min_sprint:
            # расстояние между препятствиями слишком мало
            # чтобы между ними приземляться, и затем разогнаться для нового прыжка, считаем их за одно
            g7m_L = _grouper.g7m_L
        else:
            g7m_L = id(value)
    else:
        # первое вхождение, ставим данные по умолчанию
        g7m_L = id(_grouper)

    _grouper._prev_value = value
    _grouper.g7m_L = g7m_L

    return g7m_L


_grouper._prev_value = None
_grouper.g7m_L = None


def check_chunk(ir78, Zl6PLh=None):
    if Zl6PLh is None:
        return

    BCZvlh1fg = Zl6PLh[-1] + 1  # следующая за преградой позиция (точка приземления)
    if BCZvlh1fg - Zl6PLh[0] >= max_jump:
        # если преграда слишком длинная, то мы не можем ее пересечь
        raise SolutionImpossible

    if abs(ir78 - Zl6PLh[0]) <= min_sprint:
        # нет возможности для разбега
        raise SolutionImpossible


def solve_chunk(ir78, Zl6PLh=None):
    if Zl6PLh is not None:
        rrWXQXRTY = Zl6PLh[0] - ir78 - 1  # добегаем ДО преграды
        Rcg2LBL = Zl6PLh[-1] - Zl6PLh[0] + 2  # прыгаем ЗА нее
        print((
            ""RUN {rrWXQXRTY}\n""
            ""JUMP {Rcg2LBL}"".format(
                rrWXQXRTY=rrWXQXRTY,
                Rcg2LBL=Rcg2LBL,
            )
        ))

    else:
        rrWXQXRTY = finish - ir78
        if rrWXQXRTY > 0:
            print(""RUN {rrWXQXRTY}"".format(rrWXQXRTY=rrWXQXRTY))


def main():
    # некоторые препятствия могут находиться так близко, что между ними нет возможности разогнаться
    # считаем такие препятствия за одно
    u879 = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))

    XHmeV = []

    ir78 = 0
    while True:
        Zl6PLh = next(u879, None)

        EXYYqaw = (ir78, Zl6PLh)
        check_chunk(*EXYYqaw)

        XHmeV.append(EXYYqaw)

        if Zl6PLh is None:
            break

        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        ir78 = Zl6PLh[-1] + 1

    #print(XHmeV)

    for EXYYqaw in XHmeV:
        solve_chunk(*EXYYqaw)


def __starting_point():
    try:
        main()
    except SolutionImpossible:
        print(""IMPOSSIBLE"")

__starting_point()
</ans>",0,{}
345,"<ans>
#import sys
#sys.stdin = open('in.txt')
#sys.setrecursionlimit(10000)
def isPrefix(sa, sb):
    if len(sa) <= len(sb):
        return False
    return sa[0:len(sb)] == sb

def getOrder(sa, sb):
    for i in range(0, min(len(sa), len(sb))):
        if sa[i] != sb[i]: 
            return sa[i], sb[i]

oBa = False
if oBa:
    LFXb1Pt84 = open(""in.txt"", 'r')
    jrKhNz = int(LFXb1Pt84.readline().strip())
    qVuUtT = [LFXb1Pt84.readline().strip() for i in range(0, jrKhNz)]
    LFXb1Pt84.close()
else:
    jrKhNz = int(input().strip())
    qVuUtT = [input().strip() for i in range(0, jrKhNz)]
 
pFj3sb2v = [[False] * 26 for i in range(0, 26)]

XjVV = True
for i in range(1, jrKhNz):
    if qVuUtT[i - 1] == qVuUtT[i] or isPrefix(qVuUtT[i], qVuUtT[i - 1]):
        continue
    elif isPrefix(qVuUtT[i - 1], qVuUtT[i]):
        XjVV = False
        break
    else:
        ca, cb = getOrder(qVuUtT[i - 1], qVuUtT[i])
        #print(ca, '<', cb)
        if pFj3sb2v[ord(cb) - ord('a')][ord(ca) - ord('a')]:
            XjVV = False
            break
        else:
            pFj3sb2v[ord(ca) - ord('a')][ord(cb) - ord('a')] = True

def printG():
    print(""   abcdefghijklmnopqrstuvwxyz"")
    for i in range(0, 26):
        print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in pFj3sb2v[i]]), sep = 

"""")
#printG()

if not XjVV:
    print(""Impossible"")
else:
    
    def getZeroIndegreeNode():
        for i in range(0, 26):
            if not mOvvI[i] and lGn[i] == 0:
                return i
        return -1
    #topo sort
    ZJZA = []
    lGn = [0] * 26
    mOvvI = [False] * 26
    
    #calc indegree
    for i in range(0, 26):
        PyANaAc = 0
        for j in range(0, 26):
           if pFj3sb2v[j][i]: PyANaAc += 1
        lGn[i] = PyANaAc
    for i in range(0, 26):
        c0D = getZeroIndegreeNode()
        if c0D == -1:
            XjVV = False
            break
        else:
            mOvvI[c0D] = True
            ZJZA.append(chr(ord('a') + c0D))
            for j in range(0, 26):
                if pFj3sb2v[c0D][j]:
                    lGn[j] -= 1
    if not XjVV:
        print(""Impossible"")
    else:
        print("""".join(ZJZA))
</ans>",0,{}
346,"<ans>
```
#!/usr/bin/env python3
class UnionFind:
    # 作りたい要素数nで初期化
    # 使用するインスタンス変数の初期化
    def __init__(self, n):
        self.n = n
        # root[PyTtT]<0ならそのノードが根かつその値が木の要素数
        # rootノードでその木の要素数を記録する
        self.root = [-1] * (n + 1)
        # 木をくっつける時にアンバランスにならないように調整する
        self.rnk = [0] * (n + 1)

    # ノードPyTtTのrootノードを見つける
    def Find_Root(self, PyTtT):
        if self.root[PyTtT] < 0:
            return PyTtT
        else:
            # ここで代入しておくことで、後の繰り返しを避ける
            self.root[PyTtT] = self.Find_Root(self.root[PyTtT])
            return self.root[PyTtT]

    # 木の併合、入力は併合したい各ノード
    def Unite(self, PyTtT, us0):
        # 入力ノードのrootノードを見つける
        PyTtT = self.Find_Root(PyTtT)
        us0 = self.Find_Root(us0)
        # すでに同じ木に属していた場合
        if PyTtT == us0:
            return
        # 違う木に属していた場合rnkを見てくっつける方を決める
        elif self.rnk[PyTtT] > self.rnk[us0]:
            self.root[PyTtT] += self.root[us0]
            self.root[us0] = PyTtT

        else:
            self.root[us0] += self.root[PyTtT]
            self.root[PyTtT] = us0
            # rnkが同じ（深さに差がない場合）は1増やす
            if self.rnk[PyTtT] == self.rnk[us0]:
                self.rnk[us0] += 1

    # PyTtTとus0が同じグループに属するか判断
    def isSameGroup(self, PyTtT, us0):
        return self.Find_Root(PyTtT) == self.Find_Root(us0)

    # ノードPyTtTが属する木のサイズを返す
    def Count(self, PyTtT):
        return -self.root[self.Find_Root(PyTtT)]


def main():
    n, m = list(map(int, input().split()))
    jcJygY = UnionFind(n)

    for i in range(m):
        a, b = list(map(int, input().split()))
        jcJygY.Unite(a, b)

    for i in range(n):
        i += 1
        jcJygY.isSameGroup(i, i)

    gE0gTYWgcX = 0
    for i in range(n):
        gE0gTYWgcX = max(gE0gTYWgcX, -jcJygY.root[i + 1])

    # print(jcJygY.root)
    print(gE0gTYWgcX)


main()
```
</ans>",0,{}
347,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
rPAELC = sys.maxsize
xckxiLf3 = 10**5+10
MLYUw5 = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(JjsXQNg3,hMUz8):
    return abs(JjsXQNg3[0]-hMUz8[0])+abs(hMUz8[1]-JjsXQNg3[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    JjsXQNg3 = y[0]-x[0]
    hMUz8 = x[1]-y[1]
    return (JjsXQNg3*JjsXQNg3+hMUz8*hMUz8)**0.5

def lgcd(JjsXQNg3):
    tPJ8Xjt = JjsXQNg3[0]
    for i in range(1,len(JjsXQNg3)):
        tPJ8Xjt = math.gcd(tPJ8Xjt,JjsXQNg3[i])
    return tPJ8Xjt

def ms(JjsXQNg3):
    pFCp = -rPAELC
    cX6tix = 0
    pNDf = acWWZoC = ZiTMWsy2 = 0
    for i in range(len(JjsXQNg3)):
        cX6tix+=JjsXQNg3[i]
        if pFCp<cX6tix:
            pFCp = cX6tix
            pNDf = ZiTMWsy2
            acWWZoC = i
        if cX6tix<0:
            cX6tix = 0
            ZiTMWsy2 = i+1
    return pFCp,pNDf,acWWZoC

def ncr(L7VESiE,r):
    izenTF=bn8=1
    for i in range(r):
        izenTF = (izenTF*(L7VESiE-i))%MLYUw5
        bn8 = (bn8*(i+1))%MLYUw5

    return (izenTF*(pow(bn8,MLYUw5-2,MLYUw5)))%MLYUw5",0,{}
348,"<ans>
```
f7bUpUBpB = int(input())
l_H2w9VGg = input()

ac0CIM = True
if f7bUpUBpB == 1:
    if l_H2w9VGg == '0':
        print(pow(10, 10))
    elif l_H2w9VGg == '1':
        print(pow(10, 10) * 2)
elif f7bUpUBpB == 2:
    if l_H2w9VGg in ['11', '10']:
        print(pow(10, 10))
    elif l_H2w9VGg == '01':
        print(pow(10, 10) - 1)
    else:
        print(0)
else:
    ac0CIM = True
    kNXcKkFv = f7bUpUBpB // 3
    iBULV0 = f7bUpUBpB % 3
    for i in range(0, f7bUpUBpB, 3):
        if i == 0:
            IeNKI8Ye = l_H2w9VGg[0:3]
            if IeNKI8Ye not in ['110', '101', '011']:
                ac0CIM = False
                break
        elif i < 3 * kNXcKkFv:
            BUI = l_H2w9VGg[i:i + 3]
            if BUI != IeNKI8Ye:
                ac0CIM = False
                break
        else:
            BUI = l_H2w9VGg[i:f7bUpUBpB]
            if BUI != IeNKI8Ye[0:f7bUpUBpB - i]:
                ac0CIM = False
                break
    if not ac0CIM:
        print(0)
    else:
        if IeNKI8Ye == '110':
            if iBULV0 == 0:
                print(pow(10, 10) - kNXcKkFv + 1)
            else:
                print(pow(10, 10) - kNXcKkFv)
        elif IeNKI8Ye == '101':
            print(pow(10, 10) - kNXcKkFv)
        elif IeNKI8Ye == '011':
            if iBULV0 < 2:
                print(pow(10, 10) - kNXcKkFv)
            else:
                print(pow(10, 10) - kNXcKkFv - 1)
```
</ans>",True,{}
349,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

def gcd(a,b):
	while b != 0:
		a,b = b,a%b
	return a

def stupid(Y6GKqVAg):
	QxZDaFYet = 1
	for LCUDbZ24hG in range(1, Y6GKqVAg):
		QxZDaFYet = max(QxZDaFYet, gcd(LCUDbZ24hG&Y6GKqVAg, LCUDbZ24hG^Y6GKqVAg))
	return QxZDaFYet

dwQdVK = dict()
dwQdVK[511] = 73
dwQdVK[2047] = 89
dwQdVK[32767] = 4681
dwQdVK[2097151] = 299593
dwQdVK[8388607] = 178481
dwQdVK[33554431] = 1082401
def smart(Y6GKqVAg):
	if Y6GKqVAg in dwQdVK:
		return dwQdVK[Y6GKqVAg]
	if (Y6GKqVAg & (Y6GKqVAg+1)) == 0:
		LCUDbZ24hG = 0
		while ((1<<LCUDbZ24hG)-1) != Y6GKqVAg:
			LCUDbZ24hG += 1
		if LCUDbZ24hG % 2 == 0:
			n_RBp = 0
			for LCUDbZ24hG in range(0,LCUDbZ24hG,2):
				n_RBp += (1<<LCUDbZ24hG)
			return n_RBp
		else:
			return 1
	else:
		LCUDbZ24hG = 1
		n_RBp = 0
		while LCUDbZ24hG < Y6GKqVAg:
			if (LCUDbZ24hG & Y6GKqVAg) == 0:
				n_RBp += LCUDbZ24hG
			LCUDbZ24hG *= 2
		return Y6GKqVAg+n_RBp

anCYx = mint()
for LCUDbZ24hG in range(anCYx):
	Y6GKqVAg = mint()
	print(smart(Y6GKqVAg))
	#if (Y6GKqVAg & (Y6GKqVAg+1)) == 0:
	#	a = stupid(Y6GKqVAg)
	#	b = smart(Y6GKqVAg)
	#	if a != b:
	#		print(Y6GKqVAg,a,b)
</ans>",True,{}
350,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
t6mAa = sys.maxsize
E5DBHKI = 1000010
A0YQA = 10**9+7
tZaTU = [i for i in range(E5DBHKI)]
tZaTU[0]=tZaTU[1] = -1
def sieve():
    for i in range(2,E5DBHKI,2):
        tZaTU[i] = 2
    for i in range(3,int(E5DBHKI**0.5)+1):
        if tZaTU[i]==i:
            for j in range(i*i,E5DBHKI,i):
                if tZaTU[j]==j:
                    tZaTU[j]=i
def fib(ZBPkHz81,m):
    if ZBPkHz81 == 0:
        return [0, 1]
    else:
        a, b = fib(ZBPkHz81 // 2)
        oOtIr = ((a%m) * ((b%m) * 2 - (a%m)))%m
        epxIc = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m
        if ZBPkHz81 % 2 == 0:
            return [oOtIr, epxIc]
        else:
            return [epxIc, oOtIr + epxIc]
 
def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))
 
def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))
 
def ncr(ZBPkHz81,r):
    nsO=TaeE=1
    for i in range(r):
        nsO = (nsO*(ZBPkHz81-i))%A0YQA
        TaeE = (TaeE*(i+1))%A0YQA
 
    return (nsO*(pow(TaeE,A0YQA-2,A0YQA)))%A0YQA
 
def flush():
    return sys.stdout.flush()
 
'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    ZBPkHz81 = int(input())
    if ZBPkHz81%2:
        print(ZBPkHz81//2)
    else:
        print(ZBPkHz81//2-1)
</ans>",True,{}
351,"<ans>
from math import log
from decimal import Decimal

def a1(x, y, z):
    return (y ** z) * Decimal(log(x))

def s1(x, y, z):
    return ""x^y^z""

def a2(x, y, z):
    return (z ** y) * Decimal(log(x))

def s2(x, y, z):
    return ""x^z^y""

def a3(x, y, z):
    return (y * z) * Decimal(log(x))

def s3(x, y, z):
    return ""(x^y)^z""

def a4(x, y, z):
    return (y * z) * Decimal(log(x))

def s4(x, y, z):
    return ""(x^z)^y""

def a5(x, y, z):
    return (x ** z) * Decimal(log(y))

def s5(x, y, z):
    return ""y^x^z""

def a6(x, y, z):
    return (z ** x) * Decimal(log(y))

def s6(x, y, z):
    return ""y^z^x""

def a7(x, y, z):
    return (x * z) * Decimal(log(y))

def s7(x, y, z):
    return ""(y^x)^z""

def a8(x, y, z):
    return (z * x) * Decimal(log(y))

def s8(x, y, z):
    return ""(y^z)^x""

def a9(x, y, z):
    return (x ** y) * Decimal(log(z))

def s9(x, y, z):
    return ""z^x^y""

def a10(x, y, z):
    return (y ** x) * Decimal(log(z))

def s10(x, y, z):
    return ""z^y^x""

def a11(x, y, z):
    return (x * y) * Decimal(log(z))

def s11(x, y, z):
    return ""(z^x)^y""

def a12(x, y, z):
    return (y * x) * Decimal(log(z))

def s12(x, y, z):
    return ""(z^y)^x""

x, y, z = list(map(Decimal, input().split()))
ea8 = s1(x, y, z)
q13Wod5vra = [a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]
lTNxclV7FL = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12]
qtX = a1(x, y, z)
for i in range (12):
    if qtX < q13Wod5vra[i](x, y, z):
        ea8 = lTNxclV7FL[i](x, y, z)
        qtX = q13Wod5vra[i](x, y, z)
print(ea8)
</ans>",True,{}
352,"<ans>
pp1 = input()

zcLgXhqV = 1
DTMR = []
Hlet21fgK_ = []
for i in range(1, len(pp1)):
    if pp1[i] == pp1[i-1]: zcLgXhqV += 1
    else:
      DTMR.append(zcLgXhqV)
      Hlet21fgK_.append(pp1[i-1])
      zcLgXhqV = 1
      
DTMR.append(zcLgXhqV)
Hlet21fgK_.append(pp1[len(pp1)-1])

HptYmKT = 0
while len(DTMR) > 1:
    w8hPDQ4_TX = len(DTMR)
    kqF24 = 100000000
    for i in range(1,w8hPDQ4_TX-1):
        if DTMR[i] < kqF24: kqF24 = DTMR[i]
        
    tWz = min(DTMR[0], DTMR[w8hPDQ4_TX-1],(kqF24 + 1)//2)
    #print(""a: "", DTMR, ""; k = "", tWz)
    Z2wga = []
    B6hn9Y = []
    for i in range(w8hPDQ4_TX):
        if i == 0 or i == w8hPDQ4_TX-1:
            if DTMR[i] > tWz:
                Z2wga.append(DTMR[i]-tWz)
                B6hn9Y.append(Hlet21fgK_[i])
        else:
            if DTMR[i] > 2*tWz:
                Z2wga.append(DTMR[i] - 2*tWz)
                B6hn9Y.append(Hlet21fgK_[i])
##    print(b)
    HptYmKT += tWz
    if len(Z2wga) > 1:
        Mj4pCh = [0]*w8hPDQ4_TX
        V18_JXNAv = [B6hn9Y[0]]
        OPNTOs = 0
    
        for i in range(0,len(Z2wga)-1):
            Mj4pCh[OPNTOs] += Z2wga[i]
            if B6hn9Y[i] == B6hn9Y[i+1]: continue
            else:
                OPNTOs += 1
                V18_JXNAv.append(B6hn9Y[i+1])
        if B6hn9Y[len(Z2wga)-2] == B6hn9Y[len(Z2wga) - 1]: Mj4pCh[OPNTOs] += Z2wga[len(Z2wga)-1]
        else:
            #count += 1
            V18_JXNAv.append(B6hn9Y[i+1])
            Mj4pCh[OPNTOs] = Z2wga[len(Z2wga)-1]
        DTMR = Mj4pCh[:OPNTOs+1]
        Hlet21fgK_ = V18_JXNAv[:]
    else:
        DTMR = Z2wga[:]

print(HptYmKT)
</ans>",0,{}
353,"<ans>
a,r,l,m = list(map(int,input().split()))
Yl_K = list(map(int,input().split()))
vX3 = set(Yl_K)
if(abs(a)>l):
    print(0)
    return
if(a==0):
    if(0 in vX3):
        print(0)
        return
    else:
        print(""inf"")
        return
if(r==0):
    if(a==0):
        if(0 in vX3):
            print(0)
            return
        else:
            print(""inf"")
            return
    else:
        if(a not in vX3):
            if(abs(a)<=l):
                if(0 in vX3):
                    print(1)
                    return
                else:
                    print(""inf"")
                    return
            else:
                print(0)
                return
        else:
            if(0 in vX3):
                print(0)
                return
            else:
                print(""inf"")
                return
if(r==1):
    if(a in vX3 or abs(a)>l):
        print(0)
        return
    else:
        print(""inf"")
        return
if(r==-1):
    if(a in vX3):
        if(0-a in vX3):
            print(0)
            return
        else:
            if(abs(a)<=l):
                print(""inf"")
                return
            else:
                print(0)
                return
    else:
        if(abs(a)<=l):
            print(""inf"")
            return
        else:
            print(0)
            return
pXgc = 0
while(abs(a)<=l):
    if(a not in vX3):
        pXgc+=1
    a*=r
print(pXgc)
</ans>",True,{}
354,"<ans>
import datetime
import sys
import copy
import functools
import collections
import itertools

class Solution:
    def __init__(self):
        self.ToIgj = 0
        self.boards = None

    def test(self):
        pass

    def readInput(self):
        self.ToIgj = int(input())
        self.boards = []
        for i in range(self.ToIgj):
            self.boards.append(list(input()))

    def readMockInput(self):
        pass

    def solve(self):
        ToIgj = self.ToIgj
        SQls = set()
        Wc2o = list()
        P12kSHc = list()
        # record all impossible moves
        for r in range(ToIgj):
            for c in range(ToIgj):
                if self.boards[r][c] == 'o':
                    Wc2o.append((r, c))
                elif self.boards[r][c] == '.':
                    P12kSHc.append((r, c))
        # print(Wc2o)
        # print(P12kSHc)
        for r, c in Wc2o:
            for i, j in P12kSHc:
                SQls.add((i-r, j-c))
        # print(SQls)

        # check whether there are any conflicts
        # reboard = [['.' for c in range(ToIgj)] for r in range(ToIgj)]
        # for r, c in Wc2o:
        #     reboard[r][c] = 'o'

        PP2U13DM = datetime.datetime.now()

        for i in range(ToIgj):
            for j in range(ToIgj):
                if self.boards[i][j] == 'o':
                    continue
                for r, c in Wc2o:
                    if (i-r, j-c) not in SQls:
                        if self.boards[i][j] == '.':
                            print('NO')
                            return
                        self.boards[i][j] = 'v'


        # for r, c in Wc2o:
        #     for i in range(-ToIgj+1, ToIgj):
        #         for j in range(-ToIgj+1, ToIgj):
        #             # much faster than 2 for
        #             if (i, j) not in SQls:
        #                 nr = r + i
        #                 nc = c + j
        #                 if 0 <= nr < ToIgj and 0 <= nc < ToIgj and self.boards[nr][nc] != 'o':
        #                     # reboard[nr][nc] = 'x'
        #
        #                     if self.boards[nr][nc] == '.':
        #                         print('NO')
        #                         return
        #                     self.boards[nr][nc] = 'v'
        if sum([row.count('x') for row in self.boards]) > 0:
            print('NO')
            return
        # for r in range(ToIgj):
        #     for c in range(ToIgj):
        #         if self.boards[r][c] != reboard[r][c]:
        #             print('NO')
        #             return
        sys.stderr.write('Check Cost: {}\n'.format(datetime.datetime.now()-PP2U13DM))",0,{}
355,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import copy
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


def pop_count(CwhrglpAyg):
    CwhrglpAyg = CwhrglpAyg - ((CwhrglpAyg >> 1) & 0x5555555555555555)
    CwhrglpAyg = (CwhrglpAyg & 0x3333333333333333) + ((CwhrglpAyg >> 2) & 0x3333333333333333)
    CwhrglpAyg = (CwhrglpAyg + (CwhrglpAyg >> 4)) & 0x0f0f0f0f0f0f0f0f
    CwhrglpAyg = CwhrglpAyg + (CwhrglpAyg >> 8)
    CwhrglpAyg = CwhrglpAyg + (CwhrglpAyg >> 16)
    CwhrglpAyg = CwhrglpAyg + (CwhrglpAyg >> 32)
    return CwhrglpAyg & 0x0000007f


def solve():
    QPFXq9 = Scanner.string()
    dVnbj = len(QPFXq9)
    AoZaKNk = Scanner.int()
    xdO_aRgD5 = [[[0 for _ in range(2)] for _ in range(AoZaKNk + 1)] for _ in range(dVnbj + 1)]
    xdO_aRgD5[0][0][0] = 1
    for i in range(dVnbj):
        for j in range(4):
            for k in range(2):
                twM9z6A = int(QPFXq9[i])
                for d in range(10):
                    ni, nj, nk = i + 1, j, k
                    if d != 0:
                        nj += 1
                    if nj > AoZaKNk:
                        continue
                    if k == 0:
                        if d > twM9z6A:
                            continue
                        if d < twM9z6A:
                            nk += 1
                    xdO_aRgD5[ni][nj][nk] += xdO_aRgD5[i][j][k]
    print((xdO_aRgD5[dVnbj][AoZaKNk][0] + xdO_aRgD5[dVnbj][AoZaKNk][1]))


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
356,"<ans>
import heapq


EvWoug29s = float('inf')
N, M = map(int, input().split())
QKdmP = [[] for _ in range(N)]

#GzlRG[i][j] : i-->jへ向かう辺を通るかどうかを保持
# 1 : 通る、0 : 通らない
GzlRG = [[0] * N for _ in range(N)]


for _ in range(M):
    a, b, c = map(int, input().split())
    a, b = a - 1, b - 1
    QKdmP[a].append((c, b))
    QKdmP[b].append((c, a))
    GzlRG[a][b] = 1 #a, b間に辺がある
    GzlRG[b][a] = 1


# dijkstraで最短経路木をつくる
def dijkstra(s):
    T9ux = [(0, s)]
    heapq.heapify(T9ux) 
    F8Ln_vq = [[EvWoug29s, []] for i in range(N)]
    F8Ln_vq[s][0] = 0
    while T9ux:
        c, v = heapq.heappop(T9ux)
        if c > F8Ln_vq[v][0]:
            continue
        for d, u in QKdmP[v]:
            xxz652McG = d + F8Ln_vq[v][0]
            if xxz652McG < F8Ln_vq[u][0]:
                F8Ln_vq[u][0] = xxz652McG
                F8Ln_vq[u][1] = [v] # 更新する場合は直前の頂点を保持
                heapq.heappush(T9ux, (xxz652McG, u))
            elif xxz652McG == F8Ln_vq[u][0]:
                F8Ln_vq[u][1].append(v) # 距離が等しい場合はリストで直前の頂点を保持  
                heapq.heappush(T9ux, (xxz652McG, u))
    return F8Ln_vq


# 作成した最短経路木を探索して、通る辺を調べる
def dfs(v, MBfL, p=-1):
    if p >= 0:
        GzlRG[v][p] = 0
        GzlRG[p][v] = 0
    for nv in MBfL[v][1]:
        dfs(nv, MBfL, v)


def main():
    for s in range(N):
        MBfL = dijkstra(s)
        for g in range(N):
            dfs(g, MBfL)

    print(sum(sum(column) for column in GzlRG) // 2)


def __starting_point():
    main()
__starting_point()
</ans>",True,{}
357,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return list(map(int, minp().split()))

n, k = mints()
it0ptx = list(mints())
for i in range(n):
	it0ptx[i] -= 1
noHp = list(mints())
ukGwgg0vZ = [i for i in range(1,n+1)]
n2in = [0]*n
YVDBZz = [False]*(k+1)
zr8Rox = [False]*(k+1)
ch0aM = [10000]*2
BE53hsuCXb = [10000]*2
for i in range(k+1):
	#print(ukGwgg0vZ)
	YVDBZz[i] = (ukGwgg0vZ == noHp)
	if YVDBZz[i]:
		ch0aM[i%2] = min(ch0aM[i%2], i)
	for j in range(n):
		n2in[j] = ukGwgg0vZ[it0ptx[j]]
	ukGwgg0vZ,n2in = n2in,ukGwgg0vZ
#print('====')
ukGwgg0vZ = [i for i in range(1,n+1)]
for i in range(k+1):
	#print(ukGwgg0vZ)
	zr8Rox[i] = (ukGwgg0vZ == noHp)
	if zr8Rox[i]:
		BE53hsuCXb[i%2] = min(BE53hsuCXb[i%2], i)
	for j in range(n):
		n2in[it0ptx[j]] = ukGwgg0vZ[j]
	ukGwgg0vZ,n2in = n2in,ukGwgg0vZ
#print('====')
#print(ch0aM)
#print(BE53hsuCXb)
if ch0aM[0] == 0:
	print('NO')
elif ch0aM[1] == 1:
	if BE53hsuCXb[1] == 1 and k > 1:
		print('NO')
	elif k%2 == 1 or BE53hsuCXb[k%2] <= k:
		print('YES')
	else:
		print('NO')
elif BE53hsuCXb[1] == 1:
	if k%2 == 1 or ch0aM[k%2] <= k:
		print('YES')
	else:
		print('NO')
else:
	if ch0aM[k%2] <= k or BE53hsuCXb[k%2] <= k:
		print('YES')
	else:
		print('NO')
</ans>",True,{}
358,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    i3yMIcv = [True for _ in range(n + 1)]
    X8rF = 3
    while X8rF * X8rF <= n:
        if i3yMIcv[X8rF]:
            for i in range(X8rF * 2, n + 1, X8rF):
                i3yMIcv[i] = False
        X8rF += 2
    D2ZPfKna = [2]
    for X8rF in range(3, n + 1, 2):
        if i3yMIcv[X8rF]:
            D2ZPfKna.append(X8rF)
    return D2ZPfKna

def divs(n, start=1):
    fxP = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                fxP.append(i)
            else:
                fxP.extend([i, n // i])
    return fxP

def divn(n, primes):
    u5vJ2M7MC = 1
    for i in primes:
        if n == 1:
            return u5vJ2M7MC
        nUlNtcnVY = 1
        while n % i == 0:
            nUlNtcnVY += 1
            n //= i
        u5vJ2M7MC *= nUlNtcnVY

def flin(d, x, default=-1):
    mSdGDD5_RW = iKZ_eyG = -1
    for i in range(len(d)):
        if d[i] == x:
            if mSdGDD5_RW == -1: mSdGDD5_RW = i
            iKZ_eyG = i
    if mSdGDD5_RW == -1:
        return default, default
    else:
        return mSdGDD5_RW, iKZ_eyG

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' ', end='\n'): print(sep.join(map(str, a)), end=end)
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, m = mi()
    if n == 1:
        print(0)
    elif n == 2:
        print(m)
    else:
        print(2*m)
</ans>",True,{}
359,"<ans>
```
from random import randint

def factMod(f9_xwaEc3, mod):
    HQ3x = 1
    for i in range(2, f9_xwaEc3+1):
        HQ3x = (HQ3x * i) % mod
    return HQ3x

def powMod(f9_xwaEc3, p, mod):
    HQ3x = 1

    while p > 0:
        if p % 2 == 1:
            HQ3x = (HQ3x * f9_xwaEc3) % mod
        
        p //= 2
        f9_xwaEc3 = (f9_xwaEc3 * f9_xwaEc3) % mod

    return HQ3x

def invMod(f9_xwaEc3, mod):
    return powMod(f9_xwaEc3, mod - 2, mod)

#t = 6
#print(invMod(t, 97))
#print( (invMod(t, 97) * t) % 97 )
#return

def CnkMod(f9_xwaEc3, k, mod):
    return (
        factMod(f9_xwaEc3, mod) *
        invMod(factMod(k, mod) * factMod(f9_xwaEc3-k, mod), mod)
    ) % mod

def computeCnksMod(N, mod):
    HQ3x = [[0] * (N+1) for i in range(N+1)]
    HQ3x[0][0] = 1
    for f9_xwaEc3 in range(1, N+1):
        HQ3x[f9_xwaEc3][0] = HQ3x[f9_xwaEc3-1][0]
        for k in range(1, f9_xwaEc3+1):
            HQ3x[f9_xwaEc3][k] = (HQ3x[f9_xwaEc3-1][k] + HQ3x[f9_xwaEc3-1][k-1]) % mod

    return HQ3x

iPLaW = 998244353

f9_xwaEc3 = int(input()) + 1
bOSvgE = [1] + [int(s)+1 for s in input().split(' ')]

#bOSvgE = [1] + [randint(0, 999) for i in range(1000)]
#f9_xwaEc3 = len(bOSvgE)

YdU = computeCnksMod(f9_xwaEc3, iPLaW)

#print('bOSvgE:', bOSvgE)

EeJC = [0] * (f9_xwaEc3 + 1)
EeJC[f9_xwaEc3] = 1

for i in reversed(list(range(f9_xwaEc3))):
    if i != 0 and bOSvgE[i] < 2:
        continue
    
    HdGRt63v6z = 0

    GCxa9yRae = bOSvgE[i] - 1
    for j in range(i + GCxa9yRae + 1, f9_xwaEc3 + 1):
        gPx = j - i - 1
        #HdGRt63v6z = (HdGRt63v6z + CnkMod(gPx, GCxa9yRae, iPLaW) * EeJC[j]) % iPLaW
        HdGRt63v6z = (HdGRt63v6z + YdU[gPx][GCxa9yRae] * EeJC[j]) % iPLaW
    
    EeJC[i] = HdGRt63v6z

#print(EeJC)
print(EeJC[0] - 1)
```
</ans>",True,{}
360,"<ans>
from math import sin
def mp():  return list(map(int,input().split()))
def lt():  return list(map(int,input().split()))
def pt(x):  print(x)
def ip():  return input()
def it():  return int(input())
def sl(x):  return [t for t in x]
def spl(x): return x.split()
def aj(liste, item): liste.append(item)
def bin(x):  return ""{0:b}"".format(x)
def listring(l): return ' '.join([str(x) for x in l])
def ptlist(l): print(' '.join([str(x) for x in l]))

e4QcZ = it()
RxS = lt()
GRC = {}
def explosion(start,s,d):
    (i,j) = start
    _gZHGhtD = s+1
    if d == 0:
        for k in range(j+1,j+_gZHGhtD):
            GRC[(i,k)] = True
        return ((i,j+_gZHGhtD-1),(d+7)%8),((i,j+_gZHGhtD-1),(d+1)%8)
    if d == 1:
        for k in range(1,_gZHGhtD):
            GRC[(i+k,j+k)] = True
        return ((i+_gZHGhtD-1,j+_gZHGhtD-1),(d+7)%8),((i+_gZHGhtD-1,j+_gZHGhtD-1),(d+1)%8)
    if d == 2:
        for k in range(1,_gZHGhtD):
            GRC[(i+k,j)] = True
        return ((i+_gZHGhtD-1,j),(d+7)%8),((i+_gZHGhtD-1,j),(d+1)%8)
    if d == 3:
        for k in range(1,_gZHGhtD):
            GRC[(i+k,j-k)] = True
        return ((i+_gZHGhtD-1,j-_gZHGhtD+1),(d+7)%8),((i+_gZHGhtD-1,j-_gZHGhtD+1),(d+1)%8)
    if d == 4:
        for k in range(1,_gZHGhtD):
            GRC[(i,j-k)] = True
        return ((i,j-_gZHGhtD+1),(d+7)%8),((i,j-_gZHGhtD+1),(d+1)%8)
    if d == 5:
        for k in range(1,_gZHGhtD):
            GRC[(i-k,j-k)] = True
        return ((i-_gZHGhtD+1,j-_gZHGhtD+1),(d+7)%8),((i-_gZHGhtD+1,j-_gZHGhtD+1),(d+1)%8)
    if d == 6:
        for k in range(1,_gZHGhtD):
            GRC[(i-k,j)] = True
        return ((i-_gZHGhtD+1,j),(d+7)%8),((i-_gZHGhtD+1,j),(d+1)%8)
    if d == 7:
        for k in range(1,_gZHGhtD):
            GRC[(i-k,j+k)] = True
        return ((i-_gZHGhtD+1,j+_gZHGhtD-1),(d+7)%8),((i-_gZHGhtD+1,j+_gZHGhtD-1),(d+1)%8)
            
MQj7 = [((0,0),0)]
for i in range(e4QcZ):
    sBOCwE_dg = []
    for p,q in MQj7:
        a,b = explosion(p,RxS[i],q)
        sBOCwE_dg.append(a)
        sBOCwE_dg.append(b)
    MQj7 = set(sBOCwE_dg)
pt(len(GRC))
</ans>",0,{}
361,"<ans>
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
import itertools
from functools import *
from itertools import permutations,combinations,groupby
import sys
import bisect
import string
import math
import time
import random
def Golf():
    *S2DK4u,=map(int,open(0))
def S_():
    return eWnR()
def IS():
    return eWnR().split()
def LS():
    return [i for i in eWnR().split()]
def I():
    return int(eWnR())
def MI():
    return map(int,eWnR().split())
def LI():
    return [int(i) for i in eWnR().split()]
def LI_():
    return [int(i)-1 for i in eWnR().split()]
def NI(xoV):
    return [int(eWnR()) for i in range(xoV)]
def NI_(xoV):
    return [int(eWnR())-1 for i in range(xoV)]
def StoI():
    return [ord(i)-97 for i in eWnR()]
def ItoS(nn):
    return chr(nn+97)
def LtoS(ls):
    return ''.join([chr(i+97) for i in ls])
def GI(V,E,Directed=False,index=0):
    kGGtY=[]
    tdzIrHaG=[[] for i in range(xoV)]
    for i in range(E):
        r7bDRD=LI()
        kGGtY.append(r7bDRD)
        if index==0:
            r7bDRD[0]-=1
            r7bDRD[1]-=1
        if len(r7bDRD)==2:
            a,b=r7bDRD
            tdzIrHaG[a].append(b)
            if not Directed:
                tdzIrHaG[b].append(a)
        elif len(r7bDRD)==3:
            a,b,c=r7bDRD
            o43gItbEh=(r7bDRD[0],r7bDRD[2])
            Ff3w7=(r7bDRD[1],r7bDRD[2])
            tdzIrHaG[a].append(Ff3w7)
            if not Directed:
                tdzIrHaG[b].append(o43gItbEh)
    return tdzIrHaG,kGGtY
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):
#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage
    SzxRRKAs5U=[1]*(w+2)
    YT_32Xo={}
    for i in range(h):
        BO4E=eWnR()
        for char in search:
            if char in BO4E:
                YT_32Xo[char]=((i+1)*(w+2)+BO4E.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        SzxRRKAs5U+=[1]+[mp_def[j] for j in BO4E]+[1]
    SzxRRKAs5U+=[1]*(w+2)
    return h+2,w+2,SzxRRKAs5U,YT_32Xo
def bit_combination(k,xoV=2):
    TnqTSrn=[]
    for tb in range(xoV**k):
        BO4E=[tb//(xoV**bt)%xoV for bt in range(k)]
        TnqTSrn+=[BO4E]
    return TnqTSrn
def show(*r7bDRD,end='\n'):
    if dZtar:
        print(*r7bDRD,end=end)
PWUKYF3=['YES','NO']
enewwE=['Yes','No']

jZcx=10**9+7
WQ4qx7cECa=float('inf')
y9esykbn4x=string.ascii_lowercase
bu1yZr2IE6=string.ascii_uppercase
#ts=time.time()
#sys.setrecursionlimit(10**7)
eWnR=lambda: sys.stdin.readline().rstrip()
 
def ran_input():
    import random
    xoV=random.randint(4,16)
    rmin,rmax=1,10
    S2DK4u=[random.randint(rmin,rmax) for _ in range(xoV)]
    return xoV,S2DK4u

def ran_input():
    import random
    xoV=random.randint(4,16)
    rmin,rmax=1,10
    S2DK4u=[random.randint(rmin,rmax) for _ in range(xoV)]
    return xoV,S2DK4u

dZtar=False
dZtar=True

byZGOMAm=0

xoV=I()
gutZ=LI()
fMuN2=0
for i in range(xoV):
    l,r=[],[]
    
    gvQV=gutZ[i]
    GnU=gutZ[i]
    
    # right
    for j in range(i+1,xoV):
        if gutZ[j]<GnU:
            GnU=gutZ[j]
        gvQV+=GnU
        r+=[GnU]
    
    GnU=gutZ[i]
    # left
    for j in range(i-1,-1,-1):
        if gutZ[j]<GnU:
            GnU=gutZ[j]
        gvQV+=GnU
        l+=[GnU]
    
    if gvQV>fMuN2:
        fMuN2=gvQV
        byZGOMAm=l[::-1]+[gutZ[i]]+r
        
print(*byZGOMAm)
</ans>",0,{}
362,"<ans>
#_rTA = lambda: input()
#file = open(""btest"", ""r"")
#_rTA = lambda:file.readline()

# n, m = map(int, _rTA().split())

# g = []

# for i in range(n):
#     g.append(_rTA())

# pwc3B = [[False for _ in range(m)] for _ in range(n)]

# #print(pwc3B)
# #print(parent)
          
# def found_cycle(w):
#     nonlocal pwc3B
#     s = []
#     s.append(w)
#     while s:
#         v = s.pop()
#         if pwc3B[v[0]][v[1]] == False:
#             if v[0] > 0 and g[v[0]-1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]-1, v[1]])
                
#             if v[0] < n-1 and g[v[0]+1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]+1, v[1]])
                
#             if v[1] > 0 and g[v[0]][v[1]-1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]-1])
                
#             if v[1] < m-1 and g[v[0]][v[1]+1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]+1])
                
#         else:
#             pwc3B[v[0]][v[1]] = True
#     return False

# found = False
# for i in range(n):
#     if found:
#         break
#     for j in range(m):
#         if pwc3B[i][j] == False:
#             found = found_cycle([i,j])
#             break

# if found:
#     print (""Yes"")
# else:
#     print (""No"")

#Editorial
import sys
sys.setrecursionlimit(10000)

#file = open(""btest"", ""r"")
#_rTA = lambda:file.readline()
_rTA = lambda:input()

n,m = list(map(int, _rTA().split()))

Fqk = []

pwc3B = [[0 for _ in range(m)] for _ in range(n)]

for i in range(n):
    Fqk.append(_rTA())

def valid_node(i, j):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, AhyP, cc = 0):
    if pwc3B[i][j] == AhyP:
        return True
    
    pwc3B[i][j] = AhyP

    odIK = False
    iqX = [[0,1], [1,0], [-1,0], [0,-1]]
    for d in iqX:
        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
            if Fqk[i + d[0]][j+ d[1]] == Fqk[i][j]:
                odIK = odIK or dfs(i + d[0], j+d[1], [i,j], AhyP, cc+1)

    return odIK

FJ9fhfi = False
AhyP = 1
for i in range(n):
    for j in range(m):
        if pwc3B[i][j] == 0:
            FJ9fhfi = FJ9fhfi or dfs(i, j, [i, j], AhyP)
            AhyP += 1

if FJ9fhfi:
    print(""Yes"")
else:
    print(""No"")
</ans>",True,{}
363,"<ans>
QuAnsmRuC = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100}

J5FPZc = int(input())
Icdm3Jsh2 = J5FPZc - J5FPZc%100
lid = QuAnsmRuC[Icdm3Jsh2]
f7Cx = Icdm3Jsh2

while f7Cx < J5FPZc:
    lid += 1
    if sum(int(d) for d in str(lid))==10:
        f7Cx += 1
print(lid)
</ans>",True,{}
364,"<ans>
```

i55Wi9 = 998244353


def pop_count(obj) :
    Vj8H = 0
    while (obj > 0) :
        Vj8H = Vj8H + obj % 2
        obj = obj // 2
    return Vj8H

def check(obj, k) :
    OEt = 0
    N2CWvtdnr6 = int(obj)
    while (N2CWvtdnr6 > 0) :
        OEt = OEt | (1 << (N2CWvtdnr6 % 10))
        N2CWvtdnr6 = N2CWvtdnr6 // 10
    if (pop_count(OEt) <= k) :
        return obj
    return 0

HSW = []
xaQ9M = []
RYuesgIhN = [[0 for j in range(1 << 10)] for i in range(20)]
StS8gUR0 = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    xaQ9M.append(1)
    for i in range(20) :
        xaQ9M.append(xaQ9M[i] * 10 % i55Wi9)
    for i in range(1 << 10) :
        HSW.append(pop_count(i))
    StS8gUR0[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                StS8gUR0[i][j | (1 << use)] = (StS8gUR0[i][j | (1 << use)] + StS8gUR0[i - 1][j]) % i55Wi9
                RYuesgIhN[i][j | (1 << use)] = (RYuesgIhN[i][j | (1 << use)] + StS8gUR0[i - 1][j] * use * xaQ9M[i - 1] + RYuesgIhN[i - 1][j]) % i55Wi9

def solve(obj, k) :
    F5Rq = [int(d) for d in str(obj)] 
    _p6 = len(F5Rq) 
    Vj8H = 0
    for i in range(1, _p6) :
        for use in range(1, 10) :
            for OEt in range(1 << 10) : 
                if (HSW[(1 << use) | OEt] <= k) :
                    Vj8H = (Vj8H + RYuesgIhN[i - 1][OEt] + use * StS8gUR0[i - 1][OEt] % i55Wi9 * xaQ9M[i - 1]) % i55Wi9
    rLeRX = 0
    KilnGJUZ = 0
    for i in range(_p6) :
        nrF = F5Rq[i]
        for use in range(nrF) : 
            if (i == 0 and use == 0) :
                continue
            BN_pF = rLeRX | (1 << use)
            for OEt in range(1 << 10) : 
                if (HSW[BN_pF | OEt] <= k) :
                    Vj8H = (Vj8H + RYuesgIhN[_p6 - i - 1][OEt] + (KilnGJUZ * 10 + use) * StS8gUR0[_p6 - i - 1][OEt] % i55Wi9 * xaQ9M[_p6 - i - 1]) % i55Wi9
        rLeRX |= 1 << nrF
        KilnGJUZ = (10 * KilnGJUZ + nrF) % i55Wi9
    return Vj8H

prepare()
l, r, k = list(map(int, input().split()))
Vj8H = (check(r, k) + solve(r, k) - solve(l, k) + i55Wi9) % i55Wi9
print(Vj8H)
    
</ans>",0,{}
365,"<ans>
def main():
    N, M = (int(i) for i in input().split())

    G5Jp1 = [i for i in range(N)]
    YB8U = [1 for i in range(N)]

    def find(XIW_2Ugx):
        if G5Jp1[XIW_2Ugx] == XIW_2Ugx:
            return XIW_2Ugx
        else:
            G5Jp1[XIW_2Ugx] = find(G5Jp1[XIW_2Ugx])
            YB8U[XIW_2Ugx] = YB8U[G5Jp1[XIW_2Ugx]]
            return G5Jp1[XIW_2Ugx]

    def same(XIW_2Ugx, xrBSrWui7j):
        return find(XIW_2Ugx) == find(xrBSrWui7j)

    def union(XIW_2Ugx, xrBSrWui7j):
        XIW_2Ugx = find(XIW_2Ugx)
        xrBSrWui7j = find(xrBSrWui7j)
        if XIW_2Ugx == xrBSrWui7j:
            return
        if YB8U[XIW_2Ugx] < YB8U[xrBSrWui7j]:
            XIW_2Ugx, xrBSrWui7j = xrBSrWui7j, XIW_2Ugx
        YB8U[XIW_2Ugx] += YB8U[xrBSrWui7j]
        G5Jp1[xrBSrWui7j] = XIW_2Ugx

    def get_size(XIW_2Ugx):
        return YB8U[find(XIW_2Ugx)]

    ThLAgQKW = [[] for _ in range(N)]
    for _ in range(M):
        a, Oiht9Ly = (int(i) for i in input().split())
        ThLAgQKW[a-1].append(Oiht9Ly-1)
        ThLAgQKW[Oiht9Ly-1].append(a-1)
        union(a-1, Oiht9Ly-1)

    QeRAH85l = [False]*4
    for i in range(N):
        QeRAH85l[min(3, get_size(i))] = True
        if QeRAH85l[3]:
            break
    wMofEil = 0
    if QeRAH85l[3]:
        wMofEil = 1
    elif QeRAH85l[2]:
        wMofEil = 2
    else:
        wMofEil = 3

    aRrnwL = [-1]*N

    def dfs(s):
        ZUtr = [s]
        aRrnwL[s] = 0
        Oiht9Ly = 1
        p4nMMEs = 0
        while ZUtr:
            uVXMa = ZUtr.pop()
            for u in ThLAgQKW[uVXMa]:
                if aRrnwL[u] != -1:
                    if aRrnwL[u] == aRrnwL[uVXMa]:
                        return False, Oiht9Ly*p4nMMEs
                    continue
                aRrnwL[u] = aRrnwL[uVXMa] ^ 1
                if aRrnwL[u] == 0:
                    Oiht9Ly += 1
                else:
                    p4nMMEs += 1
                ZUtr.append(u)
        return True, Oiht9Ly*(Oiht9Ly-1)//2 + p4nMMEs*(p4nMMEs-1)//2

    is_bipartite, _ = dfs(0)
    if is_bipartite:
        p4nMMEs = 0
        if wMofEil == 3:
            p4nMMEs = N*(N-1)*(N-2)//3//2
        elif wMofEil == 2:
            Bkthdnp2 = [False]*N
            for i in range(N):
                if not Bkthdnp2[find(i)] and get_size(i) == 2:
                    p4nMMEs += (N-2)
                    Bkthdnp2[find(i)] = True
        elif wMofEil == 1:
            Bkthdnp2 = [False]*N
            aRrnwL = [-1]*N
            for i in range(N):
                if not Bkthdnp2[find(i)] and get_size(i) >= 3:
                    _, ways = dfs(i)
                    p4nMMEs += ways
                    Bkthdnp2[find(i)] = True
        print(wMofEil, p4nMMEs)
    else:
        print(0, 1)


def __starting_point():
    main()

__starting_point()
</ans>",True,{}
366,"<ans>
FZhWrj = 'Michael Ilyin'

import math

# RGoCr = True
RGoCr = False


def dist(x1, y1, x2, y2):
    return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))


def get_y(x1, y1, x2, y2, x):
    return (((x - x1) * (y2 - y1)) / (x2 - x1)) + y1

if RGoCr:
    with open(""input.txt"", ""r"") as inp:
        icmUC9N = inp.readline()
        sUKqNh9at = inp.readline()
        niue7 = inp.readline()
        zew = inp.readline()
else:
    icmUC9N = input()
    sUKqNh9at = input()
    niue7 = input()
    zew = input()

dnNxVjEbF = icmUC9N.split()
l8HKAXm = float(dnNxVjEbF[0])
wJe9IV = float(dnNxVjEbF[1])
SUDYdEdVG = float(dnNxVjEbF[2])
F_d0_ = float(dnNxVjEbF[3])

aox_m5I = [float(x) for x in sUKqNh9at.split()]
TnKXjKa = [float(x) for x in niue7.split()]
RcdT8s4U1 = [float(x) for x in zew.split()]

if RGoCr:
    print(aox_m5I)
    print(TnKXjKa)
    print(RcdT8s4U1)

NoOJKdEza = float(""inf"")
z9Pd7S = -1
for i, bi in enumerate(TnKXjKa):
    uOL = dist(0, 0, F_d0_, bi) + RcdT8s4U1[i]
    if uOL <= NoOJKdEza:
        NoOJKdEza = uOL
        z9Pd7S = i

if RGoCr:
    print(z9Pd7S + 1, NoOJKdEza)

zBM67h = get_y(0, 0, F_d0_, TnKXjKa[z9Pd7S], SUDYdEdVG)

if RGoCr:
    print(zBM67h)

NTJG = float(""inf"")
kc8GHj = -1
for i, ai in enumerate(aox_m5I):
    uOL = dist(SUDYdEdVG, ai, SUDYdEdVG, zBM67h)
    if uOL < NTJG:
        NTJG = uOL
        kc8GHj = i

if RGoCr:
    print(kc8GHj + 1, NTJG)

NoOJKdEza = float(""inf"")
z9Pd7S = -1
for i, bi in enumerate(TnKXjKa):
    uOL = dist(SUDYdEdVG, aox_m5I[kc8GHj], F_d0_, bi) + RcdT8s4U1[i]
    if uOL <= NoOJKdEza:
        NoOJKdEza = uOL
        z9Pd7S = i

print(kc8GHj + 1, z9Pd7S + 1)
</ans>",True,{}
367,"<ans>
from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
mPkR4oKE = sys.stdin.readline

# M = mod = 998244353
def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))
def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in mPkR4oKE().rstrip('\n').split(' ')]
def st():return mPkR4oKE().rstrip('\n')
def val():return int(mPkR4oKE().rstrip('\n'))
def li2():return [i for i in mPkR4oKE().rstrip('\n').split(' ')]
def li3():return [int(i) for i in mPkR4oKE().rstrip('\n')]


E2UUAl1 = val()
u3yDl2cL = li()
nsaa = u3yDl2cL[:]
jYvmgMcPkv = u3yDl2cL[:]

CgH0S = 0
nsaa = sorted(list(set(nsaa)))
E1d0WN = Zsdhnvcc = 0
wD4 = Counter(nsaa)
u3yDl2cL = nsaa[:]
while CgH0S < len(nsaa):
    if wD4[u3yDl2cL[CgH0S] - 1] > 0:
        wD4[u3yDl2cL[CgH0S]] -= 1
        wD4[u3yDl2cL[CgH0S] - 1] += 1
        u3yDl2cL[CgH0S] -= 1
        CgH0S += 1
    else:
        wD4[u3yDl2cL[CgH0S]] -= 1
        wD4[u3yDl2cL[CgH0S] + 1] += 1
        u3yDl2cL[CgH0S] += 1
        if CgH0S<len(nsaa) - 1 and u3yDl2cL[CgH0S + 1] == u3yDl2cL[CgH0S]:CgH0S += 2
        else:CgH0S += 1
# print(wD4)
Zsdhnvcc = sum(1 for i in wD4 if wD4[i])",0,{}
368,"<ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect_right, bisect_left
from heapq import heapify, heappop, heappush
    
Ag3M = sys.stdin.readline
def RD(): return Ag3M().rstrip()
def F(): return float(Ag3M().rstrip())
def I(): return int(Ag3M().rstrip())
def MI(): return map(int, Ag3M().split())
def MF(): return map(float,Ag3M().split())
def LI(): return list(map(int, Ag3M().split()))
def TI(): return tuple(map(int, Ag3M().split()))
def LF(): return list(map(float,Ag3M().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]
    
    
def main():
    vV0X = I()
    if vV0X == 0:
        print(0)
        return
    if vV0X < 0:
        vV0X = -vV0X
        yLagPM = defaultdict(int)
        LhTlNRM7 = 0
        while vV0X >= 1:
            #bitフラグがたっていたら
            if vV0X & 1 == 1:
                #2の倍数の場合yLagPM[LhTlNRM7]とyLagPM[LhTlNRM7+1]に1を足す
                if LhTlNRM7 % 2 == 0:
                    yLagPM[LhTlNRM7] += 1
                    yLagPM[LhTlNRM7+1] += 1
                else:
                    yLagPM[LhTlNRM7] += 1
            else:
                yLagPM[LhTlNRM7] = yLagPM[LhTlNRM7]
            vV0X = vV0X>>1
            LhTlNRM7 += 1
    else:
        yLagPM = defaultdict(int)
        if vV0X & 1 == 1:
            yLagPM[0] = 1
        else:
            yLagPM[0] = 0
        LhTlNRM7 = 1
        vV0X = vV0X >> 1

        while vV0X >= 1:
            #bitフラグがたっていたら
            if vV0X & 1 == 1:
                #2の倍数の場合yLagPM[LhTlNRM7]とyLagPM[LhTlNRM7+1]に1を足す
                if LhTlNRM7 % 2 == 1:
                    yLagPM[LhTlNRM7] += 1
                    yLagPM[LhTlNRM7+1] += 1
                else:
                    yLagPM[LhTlNRM7] += 1
            else:
                yLagPM[LhTlNRM7] = yLagPM[LhTlNRM7]
            vV0X = vV0X>>1
            LhTlNRM7 += 1
            
            
    LhTlNRM7 = 0
    while True:
        if not LhTlNRM7 in yLagPM.keys():
            break
        if yLagPM[LhTlNRM7] <= 1:
            pass
        else:
            dYyxEj7 = yLagPM[LhTlNRM7]
            yLagPM[LhTlNRM7] = dYyxEj7 % 2
            yLagPM[LhTlNRM7+1] += (dYyxEj7 // 2)
            yLagPM[LhTlNRM7+2] += (dYyxEj7 // 2)
            if yLagPM[LhTlNRM7+1] >= yLagPM[LhTlNRM7+2] * 2:
                dYyxEj7 = yLagPM[LhTlNRM7+2]
                yLagPM[LhTlNRM7+2] -= dYyxEj7
                yLagPM[LhTlNRM7+1] -= dYyxEj7 * 2
        LhTlNRM7 += 1
    r0NvlvHetd = True

    for i in reversed(yLagPM.values()):
        if r0NvlvHetd and i == 1:
            r0NvlvHetd = False
        if not r0NvlvHetd:
            print(i, end="""")
    print()

def __starting_point():
    main()
__starting_point()
</ans>",0,{}
369,"<ans>
n, k = map(int, input().split())
Rezc0o = [list(map(int, input().split())) for _ in range(n)]
Rezc0o.sort(key=lambda x: x[0])
Rezc0o = [xy + [x] for x, xy in enumerate(Rezc0o)]
Rezc0o.sort(key=lambda x: x[1])
Rezc0o = [xy + [y] for y, xy in enumerate(Rezc0o)]

dB46_CGkXF = [[0] * n for _ in range(n)]
for _, _, i, j in Rezc0o:
  dB46_CGkXF[i][j] = 1
  
x1zYF = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
  for j in range(n):
    x1zYF[i + 1][j + 1] = x1zYF[i + 1][j] + x1zYF[i][j + 1] - x1zYF[i][j] + dB46_CGkXF[i][j]
    
# Rezc0oの2点,3点,4点を総当たり
bHOaB = 10 ** 21
for i in range(n - 1):
  for j in range(i + 1, n):
    ZdDowS = [Rezc0o[m][0] for m in [i, j]]
    XLc6P28Kl = [Rezc0o[m][1] for m in [i, j]]
    sjU = [Rezc0o[m][2] for m in [i, j]]
    bKgpjs = [Rezc0o[m][3] for m in [i, j]]
    zkkFrUJ = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                + x1zYF[min(sjU)][min(bKgpjs)] \
                - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                - x1zYF[max(sjU) + 1][min(bKgpjs)]
    if zkkFrUJ >= k:
      s2ewbMYXG0 = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
      if s2ewbMYXG0 < bHOaB:
        bHOaB = s2ewbMYXG0

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        ZdDowS = [Rezc0o[m][0] for m in [i, j, l]]
        XLc6P28Kl = [Rezc0o[m][1] for m in [i, j, l]]
        sjU = [Rezc0o[m][2] for m in [i, j, l]]
        bKgpjs = [Rezc0o[m][3] for m in [i, j, l]]
        zkkFrUJ = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                    + x1zYF[min(sjU)][min(bKgpjs)] \
                    - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                    - x1zYF[max(sjU) + 1][min(bKgpjs)]
        if zkkFrUJ >= k:
          s2ewbMYXG0 = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
          if s2ewbMYXG0 < bHOaB:
            bHOaB = s2ewbMYXG0

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          ZdDowS = [Rezc0o[m][0] for m in [i, j, o, l]]
          XLc6P28Kl = [Rezc0o[m][1] for m in [i, j, o, l]]
          sjU = [Rezc0o[m][2] for m in [i, j, o, l]]
          bKgpjs = [Rezc0o[m][3] for m in [i, j, o, l]]
          zkkFrUJ = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                      + x1zYF[min(sjU)][min(bKgpjs)] \
                      - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                      - x1zYF[max(sjU) + 1][min(bKgpjs)]
          if zkkFrUJ >= k:
            s2ewbMYXG0 = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
            if s2ewbMYXG0 < bHOaB:
              bHOaB = s2ewbMYXG0

print(bHOaB)
</ans>",0,{}
370,"<ans>
import math
from fractions import gcd

def primes(limit):
    dz6VC3Na=[]
    WYkdPLWaqo=[True]*(limit+1)
    x7pJ5QC=list(range(2,limit+1))
    for item in x7pJ5QC:
        if(WYkdPLWaqo[item]):
            OSaNC=2
            while(item*OSaNC<=limit):
                WYkdPLWaqo[item*OSaNC]=False
                OSaNC+=1
    for item in x7pJ5QC:
        if(WYkdPLWaqo[item]):
            dz6VC3Na+=[item]
    return dz6VC3Na


VunbfCxlhG,XOwnbFot=list(map(int,input().split()))
VunbfCxlhG=VunbfCxlhG
XOwnbFot=XOwnbFot
ijIBPrDW=[]
cIVG=[]

oXa=primes(int(math.sqrt(10**9)))

for OSaNC in range(len(oXa)):
    if(oXa[OSaNC]>VunbfCxlhG):
        break
    while(VunbfCxlhG%oXa[OSaNC]==0):
        ijIBPrDW.append(oXa[OSaNC])
        VunbfCxlhG//=oXa[OSaNC]
if(VunbfCxlhG!=1):
    ijIBPrDW.append(VunbfCxlhG)


for OSaNC in range(len(oXa)):
    if(oXa[OSaNC]>XOwnbFot):
        break
    while(XOwnbFot%oXa[OSaNC]==0):
        cIVG.append(oXa[OSaNC])
        XOwnbFot//=oXa[OSaNC]
if(XOwnbFot!=1):
    cIVG.append(XOwnbFot)

if(VunbfCxlhG==1 and XOwnbFot==1):
    print(0)

elif(VunbfCxlhG==1):
    kd1zuF5t4=True
    for item in cIVG:
        if(item>5):
            kd1zuF5t4=False
            break
    if(kd1zuF5t4):
        print(len(cIVG))
    else:
        print(-1)
elif(XOwnbFot==1):
    kd1zuF5t4=True
    for item in ijIBPrDW:
        if(item>5):
            kd1zuF5t4=False
            break
    if(kd1zuF5t4):
        print(len(ijIBPrDW))
    else:
        print(-1)

else:

    cIVG.sort()
    ijIBPrDW.sort()
    kd1zuF5t4=True
    Vugt=0
    qDrCoqF=0
    while(ijIBPrDW!=cIVG):
        if(Vugt>=len(ijIBPrDW) and Vugt>=len(cIVG)):
            kd1zuF5t4=False
            break
        elif(Vugt>=len(ijIBPrDW)):
            if(cIVG[-1]>5):
                kd1zuF5t4=False
                break
            else:
                qDrCoqF+=len(cIVG)-Vugt
                break
        elif(Vugt>=len(cIVG)):
            if(ijIBPrDW[-1]>5):
                kd1zuF5t4=False
                break
            else:
                qDrCoqF+=len(ijIBPrDW)-Vugt
                break
        if(ijIBPrDW[Vugt]==cIVG[Vugt]):
            Vugt+=1
            continue
        
        if(ijIBPrDW[Vugt]<cIVG[Vugt]):
            if(ijIBPrDW[Vugt]>5):
                kd1zuF5t4=False
                break
            else:
                qDrCoqF+=1
                ijIBPrDW.pop(Vugt)
        else:
            if(cIVG[Vugt]>5):
                kd1zuF5t4=False
                break
            else:
                qDrCoqF+=1
                cIVG.pop(Vugt)
    if(kd1zuF5t4):
        print(qDrCoqF)
    else:
        print(-1)
</ans>",0,{}
371,"<ans>
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


FjT3 = int(1e09) + 7
lbJYb = int(1e15)


def solve():
    HSKoBpvs = Scanner.int()
    htHYRq2 = [0 for _ in range(HSKoBpvs)]
    su2 = [0 for _ in range(HSKoBpvs)]
    for i in range(HSKoBpvs):
        htHYRq2[i], su2[i] = Scanner.map_int()
    htHYRq2.sort()
    su2.sort()
    if HSKoBpvs % 2 == 0:
        Vg8KiBUC7 = htHYRq2[HSKoBpvs // 2] + htHYRq2[HSKoBpvs // 2 - 1]
        uNEA = su2[HSKoBpvs // 2] + su2[HSKoBpvs // 2 - 1]
        print((uNEA - Vg8KiBUC7 + 1))
    else:
        Vg8KiBUC7 = htHYRq2[HSKoBpvs // 2]
        uNEA = su2[HSKoBpvs // 2]
        print((uNEA - Vg8KiBUC7 + 1))


def main():
    # sys.setrecursionlimit(1000000)
    # sys.stdin = open(""sample.txt"")
    # T = Scanner.int()
    # for _ in range(T):
    #     solve()
    # print('YNeos'[not solve()::2])
    solve()


def __starting_point():
    main()

__starting_point()
</ans>",True,{}
372,"<ans>
iPlBt5IZ=int(input())
SfXiEuPnu=list(map(int,input().split()))

H7JY=[0]*1001

for i in range (len(SfXiEuPnu)):
	H7JY[SfXiEuPnu[i]]+=1

e4P2=0
V17=0

for i in range (1001):
	e4P2+=(H7JY[i]//4)
	if(H7JY[i]%2==1):
		V17+=1

if(iPlBt5IZ%2==0 and e4P2==((iPlBt5IZ*iPlBt5IZ)//4)):
	a3rR8sl= [([0]*(iPlBt5IZ//2)) for i in range (iPlBt5IZ//2)]
	LYm6xAdOj=[]
	for i in range (1001):
		while(H7JY[i]>=4):
			LYm6xAdOj.append(i)
			H7JY[i]-=4
	
	iFprK9VZTj=0
	for i in range (iPlBt5IZ//2):
		for j in range (iPlBt5IZ//2):
			a3rR8sl[i][j]=LYm6xAdOj[iFprK9VZTj]
			iFprK9VZTj+=1

	RrIDMlc=[([0]*iPlBt5IZ) for i in range (iPlBt5IZ)]
	for i in range (iPlBt5IZ//2):
		for j in range (iPlBt5IZ//2):
			RrIDMlc[i][j]=a3rR8sl[i][j]
			RrIDMlc[iPlBt5IZ-i-1][j]=a3rR8sl[i][j]
			RrIDMlc[iPlBt5IZ-i-1][iPlBt5IZ-j-1]=a3rR8sl[i][j]
			RrIDMlc[i][iPlBt5IZ-j-1]=a3rR8sl[i][j]

	print(""YES"")
	for i in range (iPlBt5IZ):
		for j in range (iPlBt5IZ):
			print(RrIDMlc[i][j],end="" "")
		print()

	
elif(iPlBt5IZ%2==1 and (((e4P2>=(((iPlBt5IZ//2) *(iPlBt5IZ//2)) ) ) and (V17==1)))):
	a3rR8sl= [([0]*(iPlBt5IZ//2)) for i in range (iPlBt5IZ//2)]
	LYm6xAdOj=[]
	for i in range (1001):
		while(H7JY[i]>=4):
			LYm6xAdOj.append(i)
			H7JY[i]-=4
	
	iFprK9VZTj=0
	for i in range (iPlBt5IZ//2):
		for j in range (iPlBt5IZ//2):
			a3rR8sl[i][j]=LYm6xAdOj[iFprK9VZTj]
			LYm6xAdOj.pop(iFprK9VZTj)

	RrIDMlc=[([0]*iPlBt5IZ) for i in range (iPlBt5IZ)]
	for i in range (iPlBt5IZ//2):
		for j in range (iPlBt5IZ//2):
			RrIDMlc[i][j]=a3rR8sl[i][j]
			RrIDMlc[iPlBt5IZ-i-1][j]=a3rR8sl[i][j]
			RrIDMlc[iPlBt5IZ-i-1][iPlBt5IZ-j-1]=a3rR8sl[i][j]
			RrIDMlc[i][iPlBt5IZ-j-1]=a3rR8sl[i][j]

	UdK=len(LYm6xAdOj)
	lqDyzQklMP=[]
	for i in range (UdK):
		lqDyzQklMP.append(LYm6xAdOj[i])
		lqDyzQklMP.append(LYm6xAdOj[i])

	for i in range (1001):
		while(H7JY[i]>=2):
			lqDyzQklMP.append(i)
			H7JY[i]-=2

	#print(LYm6xAdOj)
	for i in range (iPlBt5IZ//2):
		RrIDMlc[iPlBt5IZ//2 ][i]=lqDyzQklMP[0]
		RrIDMlc[iPlBt5IZ//2 ][iPlBt5IZ-i-1]=lqDyzQklMP[0]
		lqDyzQklMP.pop(0)
		RrIDMlc[i][iPlBt5IZ//2 ]=lqDyzQklMP[0]
		RrIDMlc[iPlBt5IZ-i-1][iPlBt5IZ//2 ]=lqDyzQklMP[0]
		lqDyzQklMP.pop(0)

	for i in range (1001):
		if(H7JY[i]==1):
			RrIDMlc[iPlBt5IZ//2][iPlBt5IZ//2]=i
	
	print(""YES"")
	for i in range (iPlBt5IZ):
		for j in range (iPlBt5IZ):
			print(RrIDMlc[i][j],end="" "")
		print()

else:
	print(""NO"")
</ans>",True,{}
373,"<ans>
import sys
WhGBW192nX=int(input())
HM6jpOHkNq=list(map(int,input().split()))
ENxZsclb6=WhGBW192nX
PyJnmHzwCA=[]
BACR=-1
pn9rNGoXp=0
yhJiz=-1
for i in range(WhGBW192nX):
    if HM6jpOHkNq[i]==3:
        if ENxZsclb6==WhGBW192nX:
            PyJnmHzwCA.append((WhGBW192nX-ENxZsclb6+1,i+1))
            ENxZsclb6-=1
        else:
            PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
            PyJnmHzwCA.append((WhGBW192nX+1-ENxZsclb6,i+1))
            ENxZsclb6-=1
        BACR=i
if BACR==WhGBW192nX-1:
    print(-1)
    return
if BACR>-1:
    ius5tOP=0
    for i in range(BACR,WhGBW192nX):
        if HM6jpOHkNq[i]==2:
            ius5tOP=1
            PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
            ENxZsclb6-=1
            break
    if ius5tOP==0:
        iZ1yVH=0
        for i in range(BACR,WhGBW192nX):
            if HM6jpOHkNq[i]==1:
                PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
                ENxZsclb6-=1
                iZ1yVH=1
                yhJiz=i
                break
        if iZ1yVH==0:
            print(-1)
            return
CPm=[]
if yhJiz==-1:
    ENxZsclb6-=1
for i in range(WhGBW192nX-1,-1,-1):
    if HM6jpOHkNq[i]==1 and i!=yhJiz:
        CPm.append(i)
    if HM6jpOHkNq[i]==2:
        if len(CPm)==0:
            print(-1)
            return
        jG0=CPm.pop()
        PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
        PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),jG0+1))
        ENxZsclb6-=1
if yhJiz>-1:
    CPm.append(yhJiz)
for i in CPm:
    PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
    ENxZsclb6-=1
print(len(PyJnmHzwCA))
for x,y in PyJnmHzwCA:
    print(x,y)
</ans>",True,{}
374,"<ans>
```
__author__ = 'yx5sh'

import time
[a1, b1] = [int(i) for i in input().split()]
[a2, b2] = [int(i) for i in input().split()]

t0 = Cu1rRgLsiV = time.time()
q1 = LZ1EgsfBC = [[a1, b1, 0]]
q2 = yr328O = [[a2, b2, 0]]
tested1 = oNiLrx = []
tested2 = mwj = []
tested_total1 = wmeJse = []
tested_total2 = ADIN = []


def equal(t, q):
    lo = cY97 = 0
    hi = YyCV5Y4COo = len(q)
    while True:
        if cY97 >= YyCV5Y4COo:
            return False
        m = nJw = (cY97 + YyCV5Y4COo) // 2
        p = wKhzt6L5jC = q[nJw]
        temp = T7h = wKhzt6L5jC[0] * wKhzt6L5jC[1]
        if t == T7h:
            return [wKhzt6L5jC[0], wKhzt6L5jC[1], wKhzt6L5jC[2]]
        if t < T7h:
            cY97 = nJw + 1
        elif t > T7h:
            YyCV5Y4COo = nJw


def found(key, a):
    lo = cY97 = 0
    hi = YyCV5Y4COo = len(a)
    while True:
        if cY97 >= YyCV5Y4COo:
            return False
        m = nJw = (cY97 + YyCV5Y4COo) // 2
        p = wKhzt6L5jC = a[nJw]
        if key[0] == wKhzt6L5jC[0] and key[1] == wKhzt6L5jC[1]:
            return True
        if key[0] < wKhzt6L5jC[0] or key[0] == wKhzt6L5jC[0] and key[1] < wKhzt6L5jC[1]:
            cY97 = nJw + 1
        if key[0] > wKhzt6L5jC[0] or key[0] == wKhzt6L5jC[0] and key[1] > wKhzt6L5jC[1]:
            YyCV5Y4COo = nJw


while True:
    if len(LZ1EgsfBC) > 0 and len(yr328O) > 0:
        total1 = eCblN = LZ1EgsfBC[0][0] * LZ1EgsfBC[0][1]
        total2 = FvwCleh1Li = yr328O[0][0] * yr328O[0][1]
        if eCblN > FvwCleh1Li:
            ans = N8zM = equal(eCblN, yr328O)
            if N8zM:
                print(str(N8zM[2] + LZ1EgsfBC[0][2]) + ""\n"" + str(LZ1EgsfBC[0][0]) + "" "" + str(LZ1EgsfBC[0][1]) + ""\n"" + str(N8zM[0]) + "" "" + str(N8zM[1]))
            else:
                if not(LZ1EgsfBC[0][0] & 1):
                    tt = rUMJ6_BcB = [LZ1EgsfBC[0][0] // 2, LZ1EgsfBC[0][1], LZ1EgsfBC[0][2] + 1]
                    #if len(oNiLrx) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], oNiLrx)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if LZ1EgsfBC[0][0] % 3 == 0:
                    tt = rUMJ6_BcB = [LZ1EgsfBC[0][0] // 3 * 2, LZ1EgsfBC[0][1], LZ1EgsfBC[0][2] + 1]
                    #if len(oNiLrx) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], oNiLrx)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if not(LZ1EgsfBC[0][1] & 1):
                    tt = rUMJ6_BcB = [LZ1EgsfBC[0][0], LZ1EgsfBC[0][1] // 2, LZ1EgsfBC[0][2] + 1]
                    #if len(oNiLrx) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], oNiLrx)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if LZ1EgsfBC[0][1] % 3 == 0:
                    tt = rUMJ6_BcB = [LZ1EgsfBC[0][0], LZ1EgsfBC[0][1] // 3 * 2, LZ1EgsfBC[0][2] + 1]
                    #if len(oNiLrx) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], oNiLrx)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                LZ1EgsfBC.pop(0)
                LZ1EgsfBC.sort(key=lambda x: x[0]*x[1], reverse=True)
                #oNiLrx.sort(key=lambda x: (x[0], x[1]), reverse=True)

        elif eCblN < FvwCleh1Li:
            ans = N8zM = equal(FvwCleh1Li, LZ1EgsfBC)
            if N8zM:
                print(str(N8zM[2] + yr328O[0][2]) + ""\n"" + str(N8zM[0]) + "" "" + str(N8zM[1]) + ""\n"" + str(yr328O[0][0]) + "" "" + str(yr328O[0][1]))
                break
            else:
                if not(yr328O[0][0] & 1):
                    tt = rUMJ6_BcB = [yr328O[0][0] // 2, yr328O[0][1], yr328O[0][2] + 1]
                    #if len(mwj) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], mwj)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if yr328O[0][0] % 3 == 0:
                    tt = rUMJ6_BcB = [yr328O[0][0] // 3 * 2, yr328O[0][1], yr328O[0][2] + 1]
                    #if len(mwj) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], mwj)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if not(yr328O[0][1] & 1):
                    tt = rUMJ6_BcB = [yr328O[0][0], yr328O[0][1] // 2, yr328O[0][2] + 1]
                    #if len(mwj) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], mwj)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                if yr328O[0][1] % 3 == 0:
                    tt = rUMJ6_BcB = [yr328O[0][0], yr328O[0][1] // 3 * 2, yr328O[0][2] + 1]
                    #if len(mwj) == 0 or (not found([rUMJ6_BcB[0], rUMJ6_BcB[1]], mwj)):
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = DgbcC = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if N8zM:
                            print(str(DgbcC[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(DgbcC[0]) + "" "" + str(DgbcC[1]))
                yr328O.pop(0)
                yr328O.sort(key=lambda x: x[0]*x[1], reverse=True)
                #mwj.sort(key=lambda x: (x[0], x[1]), reverse=True)

        else:
            print(str(LZ1EgsfBC[0][2] + yr328O[0][2]) + ""\n"" + str(LZ1EgsfBC[0][0]) + "" "" + str(LZ1EgsfBC[0][1]) + ""\n"" + str(yr328O[0][0]) + "" "" + str(yr328O[0][1]))
            break
    else:
        print(-1)
        break

t1 = JyFxSfpM = time.time()
#print(JyFxSfpM-Cu1rRgLsiV)

```
</ans>",0,{}
375,"<ans>
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from fractions import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
import heapq
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
A40ma = 10**9 + 7
#A40ma = 9982443453
#A40ma = 998244353
from sys import stdin
y0fymSG = stdin.readline
def readInts():
  return list(map(int,y0fymSG().split()))
def readTuples():
    return tuple(map(int,y0fymSG().split()))
def I():
  return int(y0fymSG())
n2apWo = I()
yS5LC = input()
KLw = """"
ZA4 = None
for i in range(n2apWo):
    if i == 0:
        ZA4 = yS5LC[i]
        KLw += yS5LC[i]
        continue
    if yS5LC[i] == ZA4:
        continue
    else:
        ZA4 = yS5LC[i]
        KLw += yS5LC[i]
print((len(KLw)))
</ans>",True,{}
376,"<ans>
import sys

ELm0YH2 = int(sys.stdin.readline().split()[0])

class Polynomial:
    def __init__(self, coef):
        b03gdg = False
        ZAFpOjpQu0 = len(coef) - 1
        while not b03gdg:
            if not coef[ZAFpOjpQu0] == 0:
                b03gdg = True
            else:
                if ZAFpOjpQu0 == 0:
                    b03gdg = True
                else:
                    ZAFpOjpQu0 -= 1
        self.degree = ZAFpOjpQu0
        self.coef = [coef[j] for j in range(ZAFpOjpQu0 + 1)]
    def multiply_by_x(self):
        mcV = [0]
        for j in range(self.degree + 1):
            mcV.append(self.coef[j])
        return Polynomial(mcV)
    def minus(self):
        mcV = [-self.coef[j] for j in range(self.degree + 1)]
        return Polynomial(mcV)
    def add(self, other):
        RaF = other.coef
        mcV = [0 for j in range(max(self.degree, other.degree) + 1)]
        ldLCr = min(self.degree, other.degree)
        E4dw = max(self.degree, other.degree)
        if self.degree > other.degree:
            lvKefpdY = self
        else:
            lvKefpdY = other
        for j in range(ldLCr + 1):
            mcV[j] = self.coef[j] + other.coef[j]
        for j in range(ldLCr + 1, E4dw+1):
            mcV[j] = lvKefpdY.coef[j]
            
        return Polynomial(mcV) 
    def is_legal(self):
        dfgAxX = True
        omuGPgS = [None for j in range(self.degree + 1)]
        omuGPgS[self.degree] = self.coef[self.degree] == 1
        for j in range(self.degree):
            omuGPgS[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1
        for j in range(self.degree + 1):
            dfgAxX = dfgAxX and omuGPgS[j]
        return dfgAxX
    def print(self):
        Hupttnem = """"
        for j in range(self.degree + 1):
            Hupttnem += str(self.coef[j]) + "" ""
        print(Hupttnem)
            
        

qRM7Ov = []

qRM7Ov.append(Polynomial([1]))
qRM7Ov.append(Polynomial([0, 1]))

for j in range(2, 151):
    aAOJ_nUaXA = qRM7Ov[j-1].multiply_by_x()
    B_7SaGHvF = aAOJ_nUaXA.add(qRM7Ov[j - 2])
    qv_xJYhNR = aAOJ_nUaXA.add(qRM7Ov[j - 2].minus())
    if B_7SaGHvF.is_legal():
        qRM7Ov.append(B_7SaGHvF)
    elif qv_xJYhNR.is_legal():
        qRM7Ov.append(qv_xJYhNR)
    #print("":("")


print(qRM7Ov[ELm0YH2].degree)
qRM7Ov[ELm0YH2].print()
print(qRM7Ov[ELm0YH2-1].degree)
qRM7Ov[ELm0YH2-1].print()

#for j in range(len(qRM7Ov)):
    #qRM7Ov[j].print()
</ans>",True,{}
377,"<ans>
class Combination:
    """"""
    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる
    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)
    使用例：
    roPjsSR = Combination(1000000)
    print(roPjsSR(5, 3))  # 10
    """"""
    def __init__(self, n_max, LYdyhS7p=10**9+7):
        self.LYdyhS7p = LYdyhS7p
        self.yxv = self.make_modinv_list(n_max)
        self.jzBQC1HxbB, self.ROwAYo = self.make_factorial_list(n_max)

    def __call__(self, n, r):
        return self.jzBQC1HxbB[n] * self.ROwAYo[r] % self.LYdyhS7p * self.ROwAYo[n-r] % self.LYdyhS7p

    def make_factorial_list(self, n):
        # 階乗のリストと階乗のmod逆元のリストを返す O(n)
        # self.make_modinv_list()が先に実行されている必要がある
        jzBQC1HxbB = [1]
        ROwAYo = [1]
        for i in range(1, n+1):
            jzBQC1HxbB.append(jzBQC1HxbB[i-1] * i % self.LYdyhS7p)
            ROwAYo.append(ROwAYo[i-1] * self.yxv[i] % self.LYdyhS7p)
        return jzBQC1HxbB, ROwAYo

    def make_modinv_list(self, n):
        # 0からnまでのmod逆元のリストを返す O(n)
        yxv = [0] * (n+1)
        yxv[1] = 1
        for i in range(2, n+1):
            yxv[i] = self.LYdyhS7p - self.LYdyhS7p//i * yxv[self.LYdyhS7p%i] % self.LYdyhS7p
        return yxv
LYdyhS7p = 998244353
K, N = map(int, input().split())
roPjsSR = Combination(10000, LYdyhS7p=LYdyhS7p)
def C(n, r):
    if n<r or r<0:
        return 0
    else:
        return roPjsSR(n, r)
def H(n, r):
    return C(n+r-1, r)
Thoj48u = []
for i in range(2, 2*K+1, 2):
    XlqA = 0
    ft6xsY = i//2
    jDzXlJKh = 1
    for j, a in enumerate(range(ft6xsY, K)):
        if ft6xsY-j<0:
            break
        XlqA += pow(2, ft6xsY-j, LYdyhS7p) * C(ft6xsY, j) * H(K-a, N) * jDzXlJKh
        #print((j, a), C(ft6xsY, j) , H(N, K-a), jDzXlJKh, pow(2, ft6xsY-j, LYdyhS7p) * C(ft6xsY, j) * H(K-a, N) * jDzXlJKh)
        XlqA %= LYdyhS7p
        jDzXlJKh = -jDzXlJKh
    print(XlqA)
    if i == K+1:
        break
    elif i == K:
        print(XlqA)
        print(XlqA)
        break
    Thoj48u.append(XlqA)
    print(XlqA)
    Thoj48u.append(XlqA)

print(*Thoj48u[::-1], sep=""\n"")
</ans>",0,{}
378,"<ans>
import sys
import math
import random
n, k, x = map(int, input().split())
bHXG = list(map(int, input().split()))
pbh2Xe_ux = 0
if n == 1:
    print(0)
    return
for i in range(0, n - 1):   
    if bHXG[i] == bHXG[i + 1] == x:
        N98I9q1 = i    
        while N98I9q1 >= 0 and bHXG[i] == bHXG[N98I9q1]:
            N98I9q1 -= 1
        _2XNY = i + 1
        while _2XNY < n and bHXG[_2XNY] == x:
            _2XNY += 1
        while (1):
            if N98I9q1 == -1 or _2XNY == n:
                break
            if bHXG[N98I9q1] != bHXG[_2XNY]:
                break
            if N98I9q1 == 0 and _2XNY == n - 1:
                break
            if N98I9q1 == 0:
                if bHXG[0] == bHXG[_2XNY + 1]:
                    while _2XNY < n and bHXG[_2XNY] == bHXG[0]:
                        _2XNY += 1
                    N98I9q1 -= 1
                    continue
                else:
                    break
            if _2XNY == n - 1:
                if bHXG[n - 1] == bHXG[N98I9q1 - 1]:
                    while N98I9q1 >= 0 and bHXG[N98I9q1] == bHXG[n - 1]:
                        N98I9q1 -= 1
                    _2XNY += 1
                    continue
                else:
                    break
            if bHXG[N98I9q1] == bHXG[_2XNY + 1] or bHXG[N98I9q1 - 1] == bHXG[_2XNY]:
                YCrmdN = bHXG[N98I9q1]
                while N98I9q1 >= 0 and bHXG[N98I9q1] == YCrmdN:
                    N98I9q1 -= 1
                while _2XNY < n and bHXG[_2XNY] == YCrmdN:
                    _2XNY += 1
            else:
                break
        pbh2Xe_ux = max(pbh2Xe_ux, _2XNY - N98I9q1 - 1)     
print(pbh2Xe_ux)
</ans>",True,{}
379,"<ans>
ka, kb = 0, 0

def g(a, b):
    nonlocal ka, kb
    if a == b:
        return
    if abs(a - b) == 2:
        if a == 1:
            ka += 1
        else:
            kb += 1
    else:
        if a > b:
            ka += 1
        else:
            kb += 1

def main():
    nonlocal ka, kb
    k, a, b = list(map(int, input().split()))
    wJHZ2C = [[] for i in [1, 1, 1]]
    xt_njf3qPJ = [[] for i in [1, 1, 1]]
    wJHZ2C[0] = list(map(int, input().split()))
    wJHZ2C[1] = list(map(int, input().split()))
    wJHZ2C[2] = list(map(int, input().split()))
    xt_njf3qPJ[0] = list(map(int, input().split()))
    xt_njf3qPJ[1] = list(map(int, input().split()))
    xt_njf3qPJ[2] = list(map(int, input().split()))
    jeWnuAY = a
    hsGW = b
    umtF = 1
    pXv1bjBD = [[jeWnuAY, hsGW]]
    QryhxJKtnq = [[0, 0]]
    g(jeWnuAY, hsGW)
    if k == 1:
        return
    jeWnuAY, hsGW = wJHZ2C[jeWnuAY - 1][hsGW - 1], xt_njf3qPJ[jeWnuAY - 1][hsGW - 1]
    #print(jeWnuAY, hsGW, ka, kb)
    while [jeWnuAY, hsGW] not in pXv1bjBD:
        umtF += 1
        pXv1bjBD += [[jeWnuAY, hsGW]]
        QryhxJKtnq += [[ka, kb]]
        g(jeWnuAY, hsGW)
        jeWnuAY, hsGW = wJHZ2C[jeWnuAY - 1][hsGW - 1], xt_njf3qPJ[jeWnuAY - 1][hsGW - 1]
        #print(jeWnuAY, hsGW, ka, kb)
        if umtF == k:
            return
    EOvJS = pXv1bjBD.index([jeWnuAY, hsGW])
    Eo7Ib = ka - QryhxJKtnq[EOvJS][0]
    FOPKvgW = kb - QryhxJKtnq[EOvJS][1]
    zLiu9T = umtF - EOvJS
    QYyyrVyBE = (k - EOvJS) // zLiu9T - 1
    #print(Eo7Ib, FOPKvgW, zLiu9T)
    ka += QYyyrVyBE * Eo7Ib
    kb += QYyyrVyBE * FOPKvgW
    umtF += QYyyrVyBE * zLiu9T
    while umtF != k:
        umtF += 1
        g(jeWnuAY, hsGW)
        jeWnuAY, hsGW = wJHZ2C[jeWnuAY - 1][hsGW - 1], xt_njf3qPJ[jeWnuAY - 1][hsGW - 1]
        #print(jeWnuAY, hsGW, ka, kb)

main()
print(ka, kb)
</ans>",True,{}
380,"<ans>
```
import sys
sys.setrecursionlimit(4100000)
import math
import fractions",0,{}
381,"<ans>
class UnionFind():
    def __init__(self, n):
        self.n = n + 1
        self.parents = [-1] * self.n

    def find(self, OlZAo2mtp3):
        if self.parents[OlZAo2mtp3] < 0:
            return OlZAo2mtp3
        else:
            self.parents[OlZAo2mtp3] = self.find(self.parents[OlZAo2mtp3])
            return self.parents[OlZAo2mtp3]

    def union(self, OlZAo2mtp3, vwRhzD0kh5):
        OlZAo2mtp3 = self.find(OlZAo2mtp3)
        vwRhzD0kh5 = self.find(vwRhzD0kh5)

        if OlZAo2mtp3 == vwRhzD0kh5:
            return

        if self.parents[OlZAo2mtp3] > self.parents[vwRhzD0kh5]:
            OlZAo2mtp3, vwRhzD0kh5 = vwRhzD0kh5, OlZAo2mtp3

        self.parents[OlZAo2mtp3] += self.parents[vwRhzD0kh5]
        self.parents[vwRhzD0kh5] = OlZAo2mtp3

        # TODO 根を返す
        return OlZAo2mtp3

    def size(self, OlZAo2mtp3):
        return -self.parents[self.find(OlZAo2mtp3)]

    def same(self, OlZAo2mtp3, vwRhzD0kh5):
        return self.find(OlZAo2mtp3) == self.find(vwRhzD0kh5)

    def members(self, OlZAo2mtp3):
        fLOCaY = self.find(OlZAo2mtp3)
        return [i for i in range(self.n) if self.find(i) == fLOCaY]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
    N, M = list(map(int, input().split()))
    laspIW = list(map(int, input().split()))
    Ol4gGdo = list(map(int, input().split()))
    laspIW.append(0)
    Ol4gGdo.append(0)
    ax7_Vc0Zl = UnionFind(N+1)
    for _ in range(M):
        c, d = list(map(int,input().split()))
        ax7_Vc0Zl.union(c, d)
    wu2w0Rb_ = defaultdict(int)
    JGc = defaultdict(int)
    for i in range(1, N+1):
        OlZAo2mtp3 = ax7_Vc0Zl.find(i)
        wu2w0Rb_[OlZAo2mtp3] += laspIW[i-1]
        JGc[OlZAo2mtp3] += Ol4gGdo[i-1]
    for a, b in zip(list(wu2w0Rb_.values()), list(JGc.values())):
        if a != b:
            print('No')
            return
    print('Yes')


main()
</ans>",0,{}
382,"<ans>
from sys import stdin, stdout",0,{}
383,"<ans>
import math
import sys
##### graph implementation with adjacancy list#####
class Graph:
    def __init__(self,Nodes,is_directed=False):
        self.nodes=Nodes
        self.adj_list={}
        self.is_directed=is_directed
 
        for node in self.nodes:
            self.adj_list[node]=[]
            
    def add_edge(self,u,v):
        self.adj_list[u].append(v)
        if self.is_directed==False:
            self.adj_list[v].append(u)
 
    def print_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj_list[node]))
 
    def degree_node(self,node):
        return len(self.adj_list[node])
 
    def dfsUTIL(self,v,gvV,Ffr=[]):
        #print(v,end="" "")
        gvV[v]=True
        for NUq8 in self.adj_list[v]:
            if gvV[NUq8]==False:
                self.dfsUTIL(NUq8,gvV,Ffr)
                Ffr.append(NUq8)        
    
    def dfs(self,v):
        gvV=[False]*(max(self.adj_list)+1)
        Ffr=[v]
        self.dfsUTIL(v,gvV,Ffr)
        return len(Ffr)
        
#####sorting a dictionary by the values#####
def dict_sort(GwIN9BT1):
    GwIN9BT1=sorted(list(GwIN9BT1.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is_prime(JeKrI):
    if JeKrI==1:
        return 0
    for NUq8 in range(2,int(math.sqrt(JeKrI))+1):
        if JeKrI%NUq8==0:
            return False
    return True

#####swap function#####
def swap(JcQY,fs4hhK):
    PiphfBEa=JcQY
    JcQY=fs4hhK
    fs4hhK=PiphfBEa
    return JcQY,fs4hhK

#####Primes till Nth O(n)#####
def seive_primes(JeKrI):
    bTLQ_=[0]*(JeKrI+10)
    bTLQ_[1]=bTLQ_[0]=1
    NUq8=2
    while NUq8*NUq8<=JeKrI+1:
        if bTLQ_[NUq8]==0:
            C0hLCfMJ3=NUq8*NUq8
            while C0hLCfMJ3<=JeKrI+1:
                bTLQ_[C0hLCfMJ3]=1
                C0hLCfMJ3+=NUq8
        NUq8+=1
    return bTLQ_

#####all the prime factors of a number#####
def factors(JeKrI):
    dbrUTQhS={}
    while(JeKrI%2==0):
        if 2 in dbrUTQhS:
            dbrUTQhS[2]+=1
        else:
            dbrUTQhS[2]=1
        JeKrI/=2
    for NUq8 in range(3,int(JeKrI**0.5)+1,2):
        while(JeKrI%NUq8==0):
            if NUq8 in dbrUTQhS:
                dbrUTQhS[NUq8]+=1
            else:
                dbrUTQhS[NUq8]=1
            JeKrI/=NUq8
    JeKrI=int(JeKrI)
    if JeKrI>1:
        dbrUTQhS[JeKrI]=1
    return dbrUTQhS

#####greatest common divisor of two numbers#####
def gcd(JcQY,fs4hhK):
    if fs4hhK==0:
        return JcQY
    return gcd(fs4hhK,JcQY%fs4hhK)

#####least common multiplyer of two numbers#####
def lcm(JcQY,fs4hhK):
    return (JcQY*fs4hhK)//gcd(JcQY,fs4hhK)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary_search(NfDSL84_8,JeKrI,bTLQ_):
    urd7N0b=0
    vgj=JeKrI-1
    while(urd7N0b<=vgj):
        nkA8R=(urd7N0b+vgj)//2
        if NfDSL84_8[nkA8R]==bTLQ_:
            return nkA8R
        elif NfDSL84_8[nkA8R]>bTLQ_:
            vgj=nkA8R-1
        else:
            urd7N0b=nkA8R+1
    return -1

#####quadratic roots#####
def qdrt(JcQY,fs4hhK,EUrnAxbKmL):
    EUrnAxbKmL=fs4hhK*fs4hhK-4*JcQY*EUrnAxbKmL
    if EUrnAxbKmL>=0:
        S0_OjLEmVr=(-fs4hhK+EUrnAxbKmL**0.5)/(2*JcQY)
        CCwF4sU0=(-fs4hhK-EUrnAxbKmL**0.5)/(2*JcQY)
        return [int(S0_OjLEmVr),int(CCwF4sU0)]
    return -1
#####permutations#####
def permutation(JeKrI,r):
    if JeKrI<r:
        return 0
    GwIN9BT1=1
    for NUq8 in range(JeKrI-r+1,JeKrI+1):
        GwIN9BT1*=NUq8
    return GwIN9BT1

#####combinations#####
def combination(JeKrI,r):
    if JeKrI<r:
        return 0
    GwIN9BT1=1
    for NUq8 in range(r):
        GwIN9BT1*=(JeKrI-NUq8)
    hw_8kcKV=1
    for NUq8 in range(2,r+1):
        hw_8kcKV*=NUq8
    return GwIN9BT1//hw_8kcKV
        
#####taking an array/list as input#####
def arinp():
    NfDSL84_8=list(map(int,input().split()))
    return NfDSL84_8

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    BzK8feb=input()
    JeKrI=len(BzK8feb)
    if BzK8feb==BzK8feb[::-1] and BzK8feb[:JeKrI//2]==BzK8feb[JeKrI//2+1:]:
        print('Yes')
    else:
        print('No')
def __starting_point():
    main()
    

    
    
    
            
    
    

__starting_point()
</ans>",0,{}
384,"<ans>
from array import array
DGC5 = (1 << 30)

def main():
    (n,k) = [int(x) for x in input().split(' ')]
    upFbjBR = []
    for i in range(n):
        upFbjBR.append(array('b',[ord(x) for x in input()]))
    jcvv = [array('l', [DGC5 for STS in range(n)]) for i in range(n)]
    pXLGL3kJC = [[ord('d') for STS in range(n)] for i in range(n)]
    wmeD = """"
    for s in range (2 * n - 1):
        HDtdwMTqF = chr(ord('z') + 1)
        u1RYl2 = []
        for i in range(0, s+1):
            STS = s - i;
            if STS < n and i < n:
                if(i > 0 and STS > 0):
                    if(jcvv[i-1][STS] < jcvv[i][STS-1]):
                        jcvv[i][STS] = jcvv[i-1][STS]
                        pXLGL3kJC[i][STS] = 'l'
                    else:
                       jcvv[i][STS] = jcvv[i][STS-1]
                       pXLGL3kJC[i][STS] = 'd'
                elif i > 0:
                    jcvv[i][STS] = jcvv[i-1][STS]
                    pXLGL3kJC[i][STS] = 'l'
                elif STS > 0:
                    jcvv[i][STS] = jcvv[i][STS-1]
                    pXLGL3kJC[i][STS] = 'd'
                else:
                    jcvv[i][STS] = 0
                    pXLGL3kJC[i][STS] = 'e'
                if(jcvv[i][STS] < k and upFbjBR[i][STS] is not ord('a')):
                    jcvv[i][STS]+=1
                    upFbjBR[i][STS] = ord('a')
                if(upFbjBR[i][STS] < ord(HDtdwMTqF) and jcvv[i][STS] <= k):
                     HDtdwMTqF = chr(upFbjBR[i][STS])
        for i in range(0, s+1):
            STS = s - i;
            if STS < n and i < n:
                if(upFbjBR[i][STS] is not ord(HDtdwMTqF)):
                    jcvv[i][STS] = DGC5
    O8RVK7gqm = """"
    a,b = (n-1,n-1)
    while(pXLGL3kJC[a][b] is not 'e'):
        O8RVK7gqm += chr(upFbjBR[a][b])
        if(pXLGL3kJC[a][b] is 'l'):
            a-=1
        else:
            b-=1
    O8RVK7gqm += chr(upFbjBR[0][0])
    print(O8RVK7gqm[::-1])

main()
</ans>",True,{}
385,"<ans>
import sys

uGe9p = False

# Pre-defined function
# Begin
def fast_pow(qVzON2b:int, jyR3pbfMLX:int):
    TUjQfC1H = 1
    while jyR3pbfMLX > 0:
        if jyR3pbfMLX & 1:
            TUjQfC1H *= qVzON2b
        qVzON2b *= qVzON2b
        jyR3pbfMLX >>= 1
    return TUjQfC1H

def c2(NnGfu0p6):
    return NnGfu0p6 * (NnGfu0p6-1) // 2

def get():
    return list(map(int, input().split()))

def bits(NnGfu0p6: int):
    return list(bin(NnGfu0p6)).count('1')

def main(test_case = False):
    NnGfu0p6 = int(input()) if test_case else 1
    for _ in range(NnGfu0p6):
        test()

def flush():
    sys.stdout.flush()

def parr(arr):
    print(*arr, sep=' ')

def gcd(qVzON2b, jyR3pbfMLX):
    while jyR3pbfMLX:
        if jyR3pbfMLX % qVzON2b == 0:
            break
        aItp8anOsc = qVzON2b
        qVzON2b = jyR3pbfMLX % qVzON2b
        jyR3pbfMLX = aItp8anOsc
    return qVzON2b

def ext_gcd(qVzON2b: int, jyR3pbfMLX: int):
    if (jyR3pbfMLX == 0):
        return [qVzON2b, [1, 0]]
 
    TUjQfC1H = ext_gcd(jyR3pbfMLX, qVzON2b % jyR3pbfMLX)
    NXg = TUjQfC1H[0]
    hWVk5JGDIP = TUjQfC1H[1][0]
    B0CyN = TUjQfC1H[1][1]
    rymjEJ4j = B0CyN
    uy3NilSgYD = hWVk5JGDIP - B0CyN * (qVzON2b // jyR3pbfMLX)
 
    return [NXg, [rymjEJ4j, uy3NilSgYD]]

# End

V1951wCZ4 = []
mpBtfq = []
NnGfu0p6 = jyR3pbfMLX = qVzON2b = 0
 
def check(cnt):
    if cnt == 0:
        return True
    rymjEJ4j = V1951wCZ4[-cnt:]
    uy3NilSgYD = mpBtfq[:cnt]
    sMP = qVzON2b
    DFFfCMJeBW = 0
    while DFFfCMJeBW < cnt and sMP >= 0:
        sMP -= max(0, uy3NilSgYD[DFFfCMJeBW]-rymjEJ4j[DFFfCMJeBW])
        DFFfCMJeBW += 1
    return sMP >= 0
 
def test():
    nonlocal NnGfu0p6, jyR3pbfMLX, qVzON2b, V1951wCZ4, mpBtfq
    NnGfu0p6, jyR3pbfMLX, qVzON2b = get()
    V1951wCZ4 = sorted(get())
    mpBtfq = sorted(get())
 
    oavUJQF1b = 0
    F1V = min(NnGfu0p6, jyR3pbfMLX)
 
    i8fRxjzIa = -1
 
    while oavUJQF1b <= F1V:
        t4qNWdq95F = (oavUJQF1b + F1V) // 2
        if check(t4qNWdq95F):
            i8fRxjzIa = max(i8fRxjzIa, t4qNWdq95F)
            oavUJQF1b = t4qNWdq95F + 1
        else:
            F1V = t4qNWdq95F - 1
 
    if i8fRxjzIa == -1:
        print(0, 0)
        return
 
    # print(i8fRxjzIa)
 
    x_Y4SZNhPO = 0
    rymjEJ4j = V1951wCZ4[-i8fRxjzIa:]
    uy3NilSgYD = mpBtfq[:i8fRxjzIa]
    DFFfCMJeBW = 0
    while DFFfCMJeBW < i8fRxjzIa:
        x_Y4SZNhPO += min(rymjEJ4j[DFFfCMJeBW], uy3NilSgYD[DFFfCMJeBW])
        qVzON2b -= max(0, uy3NilSgYD[DFFfCMJeBW]-rymjEJ4j[DFFfCMJeBW])
        DFFfCMJeBW += 1
    print(i8fRxjzIa, max(0, x_Y4SZNhPO-qVzON2b)) 

main(uGe9p)
</ans>",0,{}
386,"<ans>
uBXXRiy=int(input())
R6wfRIWV=[]
BWAvwpZO=[]
GxskBXYL=[]
K_fZPIgeja=[]
Oedar=[]
w2P=[]
XjXpl8u9D={}
for i in range(uBXXRiy):
    f1iquJ=input()
    hGb=f1iquJ.count('a')+f1iquJ.count('e')+f1iquJ.count('i')+f1iquJ.count('o')+f1iquJ.count('u')
    if hGb>0:
        
        for c in f1iquJ[::-1]:
            if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':
                break
        if (hGb,c) in XjXpl8u9D:
            XjXpl8u9D[(hGb,c)].append(f1iquJ)
        else :
            XjXpl8u9D[(hGb,c)]=[f1iquJ]
OCx4Q={}
rxXBPd5rE=[]
UEA1E=[]
for k in XjXpl8u9D:
    if len(XjXpl8u9D[k])%2==1:
        if k[0] in OCx4Q:
            OCx4Q[k[0]].append(XjXpl8u9D[k][0])
        else :
            OCx4Q[k[0]]=[XjXpl8u9D[k][0]]
        for i in range(1,len(XjXpl8u9D[k]),2):
            rxXBPd5rE.append((XjXpl8u9D[k][i],XjXpl8u9D[k][i+1]))
    else :
        for i in range(0,len(XjXpl8u9D[k]),2):
            rxXBPd5rE.append((XjXpl8u9D[k][i],XjXpl8u9D[k][i+1]))
for k in OCx4Q:
    if len(OCx4Q[k])>1:
        if len(OCx4Q[k])%2==1:
            OCx4Q[k].pop()
        for i in range(0,len(OCx4Q[k]),2):
            UEA1E.append((OCx4Q[k][i],OCx4Q[k][i+1]))
if len(rxXBPd5rE)<len(UEA1E):
    print(len(rxXBPd5rE))
    for i in range(len(rxXBPd5rE)):
        print(UEA1E[i][0],rxXBPd5rE[i][0])
        print(UEA1E[i][1],rxXBPd5rE[i][1])
else :
    print(len(UEA1E)+(len(rxXBPd5rE)-len(UEA1E))//2)
    for i in range(len(UEA1E)):
        print(UEA1E[i][0],rxXBPd5rE[i][0])
        print(UEA1E[i][1],rxXBPd5rE[i][1])
    for j in range(len(UEA1E),len(rxXBPd5rE),2):
        if j==len(rxXBPd5rE)-1:
            break
        else :
            print(rxXBPd5rE[j][0],rxXBPd5rE[j+1][0])
            print(rxXBPd5rE[j][1],rxXBPd5rE[j+1][1])
</ans>",True,{}
387,"<ans>
import sys
from functools import lru_cache

_7em = sys.stdin.read
IOa6Evf = sys.stdin.readline
R8lpHfwgL = sys.stdin.readlines
sys.setrecursionlimit(10 ** 9)
SbGel2Z = 1 << 60
ni0 = 1000000007


def main():
    N, BDUfuamTz, *A = list(map(int, _7em.split()))

    BDUfuamTz = list(map(int, f'{BDUfuamTz:>040b}'))
    KClRLDrPje = [list(map(int, f'{a:>040b}')) for a in A]
    htoMOBn = [0] * 40
    for a in KClRLDrPje:
        for i, bit in enumerate(a):
            htoMOBn[i] += bit
    for i in range(40):
        if htoMOBn[i] == N - htoMOBn[i]:
            htoMOBn[i] = 2
        elif htoMOBn[i] < N - htoMOBn[i]:
            htoMOBn[i] = 1
        else:
            htoMOBn[i] = 0

    @lru_cache(maxsize=None)
    def rec(i, x, smaller):
        if i == 40:
            fLLX = 0
            for a in A:
                fLLX += x ^ a
            return fLLX
        elif smaller:
            if htoMOBn[i] == 2:
                return rec(i + 1, (x << 1), True)
            else:
                return rec(i + 1, (x << 1) + htoMOBn[i], True)
        else:
            if htoMOBn[i] == 2:
                if BDUfuamTz[i] == 0:
                    return rec(i + 1, (x << 1), False)
                else:
                    return rec(i + 1, (x << 1), True)
            elif BDUfuamTz[i] == htoMOBn[i]:
                return rec(i + 1, (x << 1) + BDUfuamTz[i], False)
            elif BDUfuamTz[i] < htoMOBn[i]:
                return rec(i + 1, (x << 1) + BDUfuamTz[i], False)
            else:
                return rec(i + 1, (x << 1) + htoMOBn[i], True)

    print((rec(0, 0, False)))
    return


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
388,"<ans>
#
# abc069 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, mumf5, zt6d):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(mumf5)
        resolve()
        sys.stdout.seek(0)
        _PcYeSM3h2 = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(_PcYeSM3h2, zt6d)

    def test_入力例_1(self):
        mumf5 = """"""3
1 10 100""""""
        zt6d = """"""Yes""""""
        self.assertIO(mumf5, zt6d)

    def test_入力例_2(self):
        mumf5 = """"""4
1 2 3 4""""""
        zt6d = """"""No""""""
        self.assertIO(mumf5, zt6d)

    def test_入力例_3(self):
        mumf5 = """"""3
1 4 1""""""
        zt6d = """"""Yes""""""
        self.assertIO(mumf5, zt6d)

    def test_入力例_4(self):
        mumf5 = """"""2
1 1""""""
        zt6d = """"""No""""""
        self.assertIO(mumf5, zt6d)

    def test_入力例_5(self):
        mumf5 = """"""6
2 7 1 8 2 8""""""
        zt6d = """"""Yes""""""
        self.assertIO(mumf5, zt6d)


def resolve():
    bClQ_3ub = int(mumf5())
    dmI = list(map(int, mumf5().split()))

    mz3T1c = 0
    wsWD = 0
    qDswCDK8 = 0
    for a in dmI:
        if a % 4 == 0:
            mz3T1c += 1
        elif a % 2 == 0:
            wsWD += 1
        else:
            qDswCDK8 += 1

    if bClQ_3ub-2*mz3T1c <= 0 or (bClQ_3ub-2*mz3T1c) == 1 or bClQ_3ub-2*mz3T1c == wsWD:
        print(""Yes"")
    else:
        print(""No"")


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",True,{}
389,"<ans>
import sys
moa = sys.stdin.readline
oJT = enumerate
urP5 = 1001001001

import collections
import random

def linput(ty=int, cvt=list):
	return cvt(list(map(ty,moa().split())))

def vinput(rep=1, ty=int, cvt=list):
	return cvt(ty(moa().rstrip()) for _ in ""*""*rep)

def gcd(a: int, b: int):
	while b: a, b = b, a%b
	return a

def lcm(a: int, b: int):
	return a * b // gcd(a, b)

def dist(x1,y1,x2,y2):
	return abs(x1-x2)+abs(y1-y2)

#vD = [chr(ord(""a"")+i) for i in range(26)]

def ran():
	kpe = [random.randint(1, 10),
	        random.randint(0, 10),
	        random.randint(1, 100)]
	return kpe

def bye(NGu7U):
	dRFdZ = ""No Yes"".split()
	print((dRFdZ[NGu7U]))
	#return

def sol_n(a,b,c):
	NGu7U = 0
	fAGxAZReCo = 0
	while fAGxAZReCo<c:
		NGu7U += 1
		fAGxAZReCo += a
		if NGu7U%7==0:
			fAGxAZReCo += b
	return NGu7U


def sol(a,b,c):
	#a,b,c = linput()
	### 3 6 9 12 15
	### 1 2 3 4  5
	
	NGu7U = 0
	Byqpg9 = -(-a//c)
	m2E = (b//c)
	NGu7U = m2E-Byqpg9+1
	
	return NGu7U

def deb():
	#gX1IzE9LUq = linput()
	gX1IzE9LUq = ran()
	#print(gX1IzE9LUq)
	WqHnZy6H = sol_n(*gX1IzE9LUq)
	DIf = sol(*gX1IzE9LUq)
	if 1:#WqHnZy6H!=DIf:
		print((gX1IzE9LUq, WqHnZy6H, DIf))

def main():
	gX1IzE9LUq = linput()
	print((sol(*gX1IzE9LUq)))

def __starting_point():
	#for _ in ""*""*1000:
	#	deb()
	main()

__starting_point()
</ans>",True,{}
390,"<ans>
from math import sqrt, pow, log, log2, log10, exp
from copy import deepcopy
from fractions import gcd


def read_ints():
    return list(map(int, input().split()))


def read_int():
    return read_ints()[0]


def read_floats():
    return list(map(float, input().split()))


def read_float():
    return read_floats()[0]


def format_list(nJWWV):
    return ' '.join(list(map(str, nJWWV)))


def one_dim_array(n, value=0):
    return [deepcopy(value) for x in range(n)]


def two_dim_array(n, m, value=0):
    return [[deepcopy(value) for x in range(m)] for x in range(n)]


def is_prime(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, sqrt(n) + 1):
        if n % i == 0:
            return False
    return True


def max_len_sublist(nJWWV, f):
    KoAUjx0IW, KpPPf, Hih = 0, 0, 0
    for i in range(1, len(nJWWV)):
        if f(nJWWV[i], nJWWV[i - 1]):
            Hih += 1
        else:
            if KpPPf < Hih:
                KoAUjx0IW = i - Hih
                KpPPf = Hih
            Hih = 0
    return KoAUjx0IW, KpPPf


def tf_to_yn(b):
    return 'YES' if b else 'NO'


def longest_non_descent_subsequence(s, restore_sequence=False):
    YRSsK = one_dim_array(len(s), 0)
    for i in range(len(s)):
        QI82CiWln = [YRSsK[j] + 1 if s[j] <= s[i] else 1 for j in range(i)]
        YRSsK[i] = 1 if len(QI82CiWln) == 0 else max(QI82CiWln)

    if not restore_sequence:
        return YRSsK[-1] if len(YRSsK) != 0 else 0


nJWWV = read_int()
JbBs = read_int()
HxyK = read_int()
f8had1 = nJWWV / (JbBs + HxyK)
print(f8had1*JbBs)
</ans>",True,{}
391,"<ans>
```
Z6K47S9Rc=[int(p) for p in input().split()]
nuP4=Z6K47S9Rc[2]
isurZ4fxp=[]
isurZ4fxp.append(Z6K47S9Rc[0])
isurZ4fxp.append(Z6K47S9Rc[1])
ggIm99y7_u=min(isurZ4fxp)
rLPQ937YT=max(isurZ4fxp)

iTd9ZrpwRi=0
hqIeAipu6=[]


wGk=1000000000000000000
def fib(wGk):
        
        a, b = 0, 1
        while b < wGk:
                hqIeAipu6.append(b)
                a, b = b, a+b
    


def add(nuP4):
        wGk=10**18
        ggIm99y7_u=min(isurZ4fxp)
        rLPQ937YT=max(isurZ4fxp)
        iTd9ZrpwRi=0
        if(ggIm99y7_u>0 and rLPQ937YT>0 and nuP4>rLPQ937YT):
                fib(wGk)
                for p in range(1,len(hqIeAipu6)+1):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*ggIm99y7_u))>=nuP4):
                                iTd9ZrpwRi+=p
                                return iTd9ZrpwRi
        elif(ggIm99y7_u==0 or rLPQ937YT==0):
                iTd9ZrpwRi=1
                fib(wGk)
                ggIm99y7_u=rLPQ937YT+(ggIm99y7_u)
                for p in range(1,len(hqIeAipu6)):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*ggIm99y7_u))>=nuP4):
                                iTd9ZrpwRi+=p
                                return iTd9ZrpwRi

        elif(ggIm99y7_u<0 and rLPQ937YT>0):
                TbwynN=(-(ggIm99y7_u)//rLPQ937YT)+1
                iTd9ZrpwRi=TbwynN
                ggIm99y7_u=ggIm99y7_u+(TbwynN*rLPQ937YT)
                fib(wGk)
                for p in range(1,len(hqIeAipu6)):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*ggIm99y7_u))>=nuP4):
                                iTd9ZrpwRi+=p
                                return iTd9ZrpwRi

        ",0,{}
392,"<ans>
# NOT MY CODE
# https://codeforces.com/contest/919/submission/80857731
 
from types import GeneratorType
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        s32GHKrwXl = f(*args, **kwargs)
        if stack:
            return s32GHKrwXl
        else:
            while True:
                if type(s32GHKrwXl) is GeneratorType:
                    stack.append(s32GHKrwXl)
                    s32GHKrwXl = next(s32GHKrwXl)
                else:
                    stack.pop()
                    if not stack:
                        return s32GHKrwXl
                    s32GHKrwXl = stack[-1].send(s32GHKrwXl)
    return wrappedfunc
 
import sys
Jww9ZAcg=sys.stdin.readline
from collections import defaultdict as dd
'''
def iscyclic(g):
    for i in range(1,n+1):
        if(
'''
n,m=list(map(int,Jww9ZAcg().split()))
JkwFM22U=Jww9ZAcg()
Z3F8=dd(list)
Lm3MMe=0
for i in range(m):
    u,v=list(map(int,Jww9ZAcg().split()))
    if(u==v):
        Lm3MMe=1
        print(-1)
        return
    Z3F8[u].append(v)
'''
if(iscyclic(Z3F8)):
    Lm3MMe=1
    print(-1)
    return
'''
dd6VCztHE=[0]*(n+1)
zgLAKm=[0]*(n+1)
X23Oo1=[0]
iHHAVImJI=[dd(int) for i in range(n+1)]
qmq=[0]
E_mDJ5QX8=[0]
#print(Z3F8)
@bootstrap
def dfs(u):
    if(E_mDJ5QX8[0]==1):
        yield
    dd6VCztHE[u]=1
    zgLAKm[u]=1
    for i in Z3F8[u]:
        if(E_mDJ5QX8[0]==1):
            yield
        if(dd6VCztHE[i]==0):
            yield dfs(i)
            if(E_mDJ5QX8[0]==1):
                yield            
        elif(zgLAKm[i]==True):
            E_mDJ5QX8[0]=1
            yield
    zgLAKm[u]=0
    if(E_mDJ5QX8[0]==1):
        yield
    for i in Z3F8[u]:
        for j in iHHAVImJI[i]:
            iHHAVImJI[u][j]=max(iHHAVImJI[u][j],iHHAVImJI[i][j])
            qmq[0]=max(qmq[0],iHHAVImJI[u][j])
    iHHAVImJI[u][JkwFM22U[u-1]]+=1
    #print(u,iHHAVImJI[u])
    qmq[0]=max(qmq[0],iHHAVImJI[u][JkwFM22U[u-1]])
    yield
#print(iHHAVImJI)
for i in range(1,n+1):
    if(dd6VCztHE[i]==0):
        X23Oo1=[0]
        dfs(i)
if(E_mDJ5QX8[0]):
    print(-1)
else:
    print(qmq[0])
</ans>",True,{}
393,"<ans>
#!/usr/bin/env python3
import sys
from collections import defaultdict

IEOyos5 = float(""inf"")


def solve(AM7Qodw: int, KftMx6: int, oqN: int):
    if oqN == 0:
        if KftMx6 == 0:
            print((1))
        else:
            print((AM7Qodw+1))
        return

    if oqN < 0:
        KftMx6 = KftMx6 + (AM7Qodw-1)*oqN
        oqN = abs(oqN)

    KkI = defaultdict(list)
    for k in range(AM7Qodw+1):
        BN48w_K = k*(k-1)//2
        oZIkLIG = k*AM7Qodw - k*(k+1)//2
        Aqou = k*KftMx6 + oqN*BN48w_K
        Yi35BYZp = oZIkLIG-BN48w_K
        UmnFie_GXq = (Aqou//oqN, Aqou//oqN+Yi35BYZp+1)
        L95v4C1m = Aqou % oqN
        KkI[L95v4C1m].append(UmnFie_GXq)

    Dze5hj = 0
    for k in KkI:
        Wp7 = defaultdict(int)
        for l, r in KkI[k]:
            Wp7[l] += 1
            Wp7[r] -= 1

        E7px = 0
        Ez3 = -1
        for k in sorted(Wp7.keys()):
            if E7px > 0:
                Dze5hj += k - Ez3
            E7px += Wp7[k]
            Ez3 = k
    print(Dze5hj)

    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    umHcB = iterate_tokens()
    AM7Qodw = int(next(umHcB))  # type: int
    KftMx6 = int(next(umHcB))  # type: int
    oqN = int(next(umHcB))  # type: int
    solve(AM7Qodw, KftMx6, oqN)


def __starting_point():
    main()

__starting_point()
</ans>",True,{}
394,"<ans>
import sys
rmTjhA2Ica = (s.rstrip() for s in sys.stdin)
vBGJ3BStg = rmTjhA2Ica.__next__

LLZZ6hG = int(vBGJ3BStg())
_Pea2on = list(map(int, vBGJ3BStg().split()))
NHw = (LLZZ6hG+1)//2
MoHbAFkR = LLZZ6hG-NHw
for i in _Pea2on:
    if i:
        if i%2 == 0:
            MoHbAFkR -= 1
        else:
            NHw -= 1

if MoHbAFkR == 0:
    _Pea2on = [i if i else 1 for i in _Pea2on]
if NHw*MoHbAFkR == 0:
    LJP = 0
    tiqrUPKJhY = _Pea2on[0]
    for pi in _Pea2on:
        LJP += (pi+tiqrUPKJhY)%2
        tiqrUPKJhY = pi
    print(LJP)
    return

Q0wEqen9O6 = [[float(""inf"")]*(MoHbAFkR+1) for i in range(2)]
for i in range(LLZZ6hG):
    zxmBQvSpT3 = [[float(""inf"")]*(MoHbAFkR+1) for i in range(2)]
    if i == 0:
        if _Pea2on[i]:
            if _Pea2on[i]%2 == 0:
                zxmBQvSpT3[0][0] = 0
            else:
                zxmBQvSpT3[1][0] = 0
        else:
            zxmBQvSpT3[0][1] = 0
            zxmBQvSpT3[1][0] = 0
    else:
        if _Pea2on[i]:
            if _Pea2on[i]%2 == 0:
                for j in range(MoHbAFkR+1):
                    zxmBQvSpT3[0][j] = min(Q0wEqen9O6[0][j], Q0wEqen9O6[1][j]+1)
            else:
                for j in range(MoHbAFkR+1):
                    zxmBQvSpT3[1][j] = min(Q0wEqen9O6[0][j]+1, Q0wEqen9O6[1][j])
        else:
            for j in range(1, MoHbAFkR+1):
                zxmBQvSpT3[0][j] = min(Q0wEqen9O6[0][j-1], Q0wEqen9O6[1][j-1]+1)
            for j in range(MoHbAFkR+1):
                zxmBQvSpT3[1][j] = min(Q0wEqen9O6[0][j]+1, Q0wEqen9O6[1][j])
    Q0wEqen9O6 = zxmBQvSpT3
print(min(Q0wEqen9O6[0][-1], Q0wEqen9O6[1][-1]))
</ans>",True,{}
395,"<ans>
# E
PnC22f69a = int(input())
hYdIY6b = list(map(int, input().split()))
WCPKlfWf = list(map(int, input().split()))

# graph
CgfyX = [[] for _ in range(PnC22f69a+1)]
for i in range(2, PnC22f69a+1):
    CgfyX[hYdIY6b[i-2]].append(i)

# from root
# minimize local total weight

CjB8spQeuh = [0]+WCPKlfWf
jKST = [0]*(PnC22f69a+1)

# solve knapsack
def solve_knapsack(L, M):
    JyqWmg = sum([min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) for gVrelWu1 in L])
    if JyqWmg > M:
        return -1
    else:
        UrmzPKw = M - JyqWmg
        J953IUJct = set([0])
        for gVrelWu1 in L:
            riSqR = max(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) - min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1])
            f7t_ = set(J953IUJct)
            for s in J953IUJct:
                if s + riSqR <= UrmzPKw:
                    f7t_.add(s + riSqR)
            J953IUJct = f7t_
        
        CnrbGPK = sum([CjB8spQeuh[gVrelWu1]+jKST[gVrelWu1] for gVrelWu1 in L])
        return CnrbGPK - max(J953IUJct) - JyqWmg

HXIPAAtyOX = ""POSSIBLE""

for i in range(PnC22f69a, 0, -1):
    if len(CgfyX[i]) == 0:
        pass
    elif len(CgfyX[i]) == 1:
        gVrelWu1 = CgfyX[i][0]
        if min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) > WCPKlfWf[i-1]:
            HXIPAAtyOX = ""IMPOSSIBLE""
            break
        elif max(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) > WCPKlfWf[i-1]:
            jKST[i] = max(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1])
        else:
            jKST[i] = min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1])
    else:
        LKN = solve_knapsack(CgfyX[i], WCPKlfWf[i-1])
        if LKN < 0:
            HXIPAAtyOX = ""IMPOSSIBLE""
            break
        else:
            jKST[i] = LKN
    
print(HXIPAAtyOX)
</ans>",0,{}
396,"<ans>
def prime_factor(n):
    y5qYCOsG = 2
    xqMHM = []
    while y5qYCOsG * y5qYCOsG <= n:
        if n % y5qYCOsG:
            y5qYCOsG += 1
        else:
            while n % y5qYCOsG == 0:
                n //= y5qYCOsG
            xqMHM.append(y5qYCOsG)
    if n > 1:
        xqMHM.append(n)
    return xqMHM


def HeR(n):
    HeR = []
    for y5qYCOsG in range(1, int(n**0.5)+1):
        if n % y5qYCOsG == 0:
            HeR.append(y5qYCOsG)
            if y5qYCOsG != n // y5qYCOsG:
                HeR.append(n//y5qYCOsG)
    HeR.sort()
    return HeR


def mebius(n):
    PTFHiAc6GI = {}
    YqLtnu95 = prime_factor(n)
    cdnQqrTKM = len(YqLtnu95)
    for y5qYCOsG in range(1 << cdnQqrTKM):
        pRzb = 1
        bMsxH8QW = 1
        for j in range(cdnQqrTKM):
            if y5qYCOsG >> j & 1:
                pRzb *= -1
                bMsxH8QW *= YqLtnu95[j]
        PTFHiAc6GI[bMsxH8QW] = pRzb
    return PTFHiAc6GI


W1eqmCjaY = 10**9+7
N, K = list(map(int, input().split()))
SJK9QGS8 = HeR(N)

lZbXV = 0

for x in SJK9QGS8:
    f53GR8Sc6l = HeR(x)
    pRzb = mebius(x)
    kwhNn_ = 0
    for y in list(pRzb.keys()):
        kwhNn_ += pow(K, ((x//y)+1)//2, W1eqmCjaY)*pRzb[y]
    if x % 2 == 0:
        kwhNn_ *= pow(2, W1eqmCjaY-2, W1eqmCjaY)
    lZbXV += x*kwhNn_
    lZbXV %= W1eqmCjaY

print(lZbXV)
</ans>",True,{}
397,"<ans>
import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

HGkNYaB = int(minp())
s_9v59 = [None]*HGkNYaB
Ntif5 = [None]*3
O87Z = [None]*3
O87Z[0] = [None]*(HGkNYaB*HGkNYaB)
O87Z[1] = [None]*(HGkNYaB*HGkNYaB)
O87Z[2] = [None]*(HGkNYaB*HGkNYaB)
jJcD39NN = [None]*(HGkNYaB*HGkNYaB)
for i in range(HGkNYaB):
	s_9v59[i] = list(map(int, minp().split()))
	for j in range(HGkNYaB):
		jJcD39NN[s_9v59[i][j]-1] = (i,j)
for z in range(3):
	PrBX5Q = [None]*HGkNYaB
	for i in range(HGkNYaB):
		eWg2 = [None]*HGkNYaB
		for j in range(HGkNYaB):
			U8bEQzQmKF = [None]*3
			for zz in range(3):
				ymIPHVd9G = [None]*HGkNYaB
				for w in range(HGkNYaB):
					ymIPHVd9G[w] = [(1000000,0)]*HGkNYaB
				U8bEQzQmKF[zz] = ymIPHVd9G
			eWg2[j] = U8bEQzQmKF
		PrBX5Q[i] = eWg2
	Ntif5[z] = PrBX5Q

XNYo8Mb = [0]*(10*HGkNYaB*HGkNYaB)
rlmFpG = 0
zB6s = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
HDQCTMJD = [(1,1),(1,-1),(-1,1),(-1,-1)]
bOUJNm7ed = [(0,1),(0,-1),(-1,0),(1,0)]
TitdPvEIHD = [zB6s,HDQCTMJD,bOUJNm7ed]
for z in range(3):
	for i in range(HGkNYaB):
		for j in range(HGkNYaB):
			#print('========')
			cL2xjYS = 0
			rlmFpG = 1
			XNYo8Mb[0] = (z, i, j, (0,0))
			ftU = Ntif5[z][i][j]
			ftU[z][i][j] = (0, 0)
			while cL2xjYS < rlmFpG:
				t, x, y, wggzR = XNYo8Mb[cL2xjYS]
				#print(t,x,y,wggzR)
				WsQKiq = ftU[t][x][y]
				cL2xjYS += 1
				if WsQKiq != wggzR:
					continue
				wggzR = (WsQKiq[0]+1, WsQKiq[1]+1)
				for tt in range(3):
					if t != tt and ftU[tt][x][y] > wggzR:
						ftU[tt][x][y] = wggzR
						XNYo8Mb[rlmFpG] = (tt,x,y,wggzR)
						rlmFpG += 1
				wggzR = (WsQKiq[0]+1,WsQKiq[1])
				if t == 0:
					for w in TitdPvEIHD[t]:
						xx,yy = w[0]+x,w[1]+y
						if xx >= 0 and xx < HGkNYaB and yy >= 0 and yy < HGkNYaB:
							if ftU[t][xx][yy] > wggzR:
								ftU[t][xx][yy] = wggzR
								XNYo8Mb[rlmFpG] = (t,xx,yy,wggzR)
								rlmFpG += 1
				else:
					for w in TitdPvEIHD[t]:
						for hm in range(HGkNYaB*2):
							xx,yy = w[0]*hm+x,w[1]*hm+y
							if xx >= 0 and xx < HGkNYaB and yy >= 0 and yy < HGkNYaB:
								if ftU[t][xx][yy] > wggzR:
									ftU[t][xx][yy] = wggzR
									XNYo8Mb[rlmFpG] = (t,xx,yy,wggzR)
									rlmFpG += 1
							else:
								break
O87Z[0][0] = (0,0)
O87Z[1][0] = (0,0)
O87Z[2][0] = (0,0)
for i in range(0,HGkNYaB*HGkNYaB-1):
	x,y = jJcD39NN[i]
	xx,yy = jJcD39NN[i+1]
	for z in range(3):
		for j in range(3):
			ovw = Ntif5[j][x][y][z][xx][yy]
			if O87Z[j][i] != None:
				vwDTKBx = (O87Z[j][i][0]+ovw[0],O87Z[j][i][1]+ovw[1])
				if O87Z[z][i+1] == None:
					O87Z[z][i+1] = vwDTKBx
				else:
					O87Z[z][i+1] = min(O87Z[z][i+1],vwDTKBx)
for j in range(HGkNYaB*HGkNYaB-1,HGkNYaB*HGkNYaB):
	Re2 = [O87Z[i][j] if O87Z[i][j] != None else (1000000,0) for i in range(3)]
	mnD = min(Re2)
	#print(j,mnD)
	print(mnD[0], mnD[1])
</ans>",True,{}
398,"<ans>
def increasing(arr):
    lJ5aRez = len(arr)
    for i in range(lJ5aRez-1):
        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
            return False

    return True

def getFacts(lJ5aRez,_D_jS8f):
    jXFQoL = [1]*lJ5aRez
    for i in range(1,lJ5aRez):
        jXFQoL[i] = jXFQoL[i-1]*i
        jXFQoL[i] %= _D_jS8f

    return jXFQoL

def solve(arr1,arr2,lJ5aRez,_D_jS8f):
    jXFQoL = getFacts(4*10**5+1,_D_jS8f)
    yxHLf = jXFQoL[lJ5aRez]
    vsO2SMa4E = {}
    for i in arr1:
        if i[0] not in list(vsO2SMa4E.keys()):
            vsO2SMa4E[i[0]] = 1
        else:
            vsO2SMa4E[i[0]] += 1

    fJ3tLk = {}
    for i in arr2:
        if i[0] not in list(fJ3tLk.keys()):
            fJ3tLk[i[0]] = 1
        else:
            fJ3tLk[i[0]] += 1

    gnMNPm05gv = 1
    for i in vsO2SMa4E:
        gnMNPm05gv *= jXFQoL[vsO2SMa4E[i]]
        gnMNPm05gv = gnMNPm05gv%_D_jS8f

    yxHLf -= gnMNPm05gv
    gnMNPm05gv = 1
    
    for i in fJ3tLk:
        gnMNPm05gv *= jXFQoL[fJ3tLk[i]]
        gnMNPm05gv = gnMNPm05gv%_D_jS8f

    #print(gnMNPm05gv)
    yxHLf -= gnMNPm05gv

    arr1.sort()
    if increasing(arr1):
        gnMNPm05gv = 1
    else:
        gnMNPm05gv = 0
    LZXwxITC = {}
    for i in arr1:
        if i not in list(LZXwxITC.keys()):
            LZXwxITC[i] = 1
        else:
            LZXwxITC[i] += 1
        
    for i in LZXwxITC:
        gnMNPm05gv *= jXFQoL[LZXwxITC[i]]
        gnMNPm05gv = gnMNPm05gv%_D_jS8f

    #print(gnMNPm05gv,yxHLf)
    yxHLf += gnMNPm05gv
    yxHLf = yxHLf%_D_jS8f
    print(yxHLf)
    

def main():
    _D_jS8f = 998244353
    lJ5aRez = int(input())
    WyIPCx5l = []
    wqGII = []
    for i in range(lJ5aRez):
        a,b = list(map(int,input().split()))
        WyIPCx5l.append((a,b))
        wqGII.append((b,a))
    
    solve(WyIPCx5l,wqGII,lJ5aRez,_D_jS8f)


main()
</ans>",True,{}
399,"<ans>
import sys

#縦k、横kのマスに移動させて考える
n, k = map(int, sys.stdin.readline().strip().split())
tByhu = []
FJzH = []
X39oOH = []
Zhxusc = []
for _ in range(n):
    mjVilre, Eabiz, c = sys.stdin.readline().strip().split()
    mjVilre = int(mjVilre)
    Eabiz = int(Eabiz)
    if c == 'W':
        mjVilre += k
    mjVilre %= 2 * k
    Eabiz %= 2 * k
    if mjVilre >= k:
        if Eabiz >= k:
            tByhu.append(mjVilre - k)
            FJzH.append(Eabiz - k)
        else:
            X39oOH.append(mjVilre - k)
            Zhxusc.append(Eabiz)
    else:
        if Eabiz >= k:
            X39oOH.append(mjVilre)
            Zhxusc.append(Eabiz - k)
        else:
            tByhu.append(mjVilre)
            FJzH.append(Eabiz)

Db9n9zs5x = [[0 for _ in range(k)] for __ in range(k)]

#累積和
#lx + lmx = n
oGbgJpPKyf = len(tByhu)
Db9n9zs5x[0][0] += oGbgJpPKyf
for i in range(oGbgJpPKyf):
    Db9n9zs5x[tByhu[i]][0] -= 1
    Db9n9zs5x[0][FJzH[i]] -= 1
    Db9n9zs5x[tByhu[i]][FJzH[i]] += 2

K9uyYX0a0 = len(X39oOH)
Db9n9zs5x[0][0] -= K9uyYX0a0
for i in range(K9uyYX0a0):
    Db9n9zs5x[X39oOH[i]][0] += 1
    Db9n9zs5x[0][Zhxusc[i]] += 1
    Db9n9zs5x[X39oOH[i]][Zhxusc[i]] -= 2

for i in Db9n9zs5x:
    for j in range(k-1):
        i[j+1] += i[j]

for i in range(k):
    for j in range(k-1):
        Db9n9zs5x[j+1][i] += Db9n9zs5x[j][i]

#最大値、最小値を取得
HBhKstauE = max([max(i) for i in Db9n9zs5x]) + K9uyYX0a0
pjvxP9Exd = min([min(i) for i in Db9n9zs5x]) - oGbgJpPKyf

if HBhKstauE + pjvxP9Exd >= 0:
    print(HBhKstauE)
else:
    print(-pjvxP9Exd)
</ans>",0,{}
400,"<ans>
# coding: utf-8
import sys
#from operator import itemgetter
q24AqB = sys.stdin.buffer.readline
D8SULwGOS2 = sys.stdin.buffer.read
#from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque
#from decimal import Decimal
#from numba import jit

R7LkXiF = 1 << 50
HLHWYqEv = 1e-8
u82c_Nmjt = 10 ** 9 + 7

def run():
    _j8aK = int(input())
    qOluuIcku = [9 ** i for i in range(1, 10) if 9 ** i <= _j8aK]
    mWZ = [6 ** i for i in range(1, 10) if 6 ** i <= _j8aK][::-1]
    vcCtlTO9fA = len(qOluuIcku)
    #print(qOluuIcku, mWZ)
    hLrfq1vp3v = R7LkXiF
    for K in product(list(range(9)), repeat = vcCtlTO9fA):
        #print(K, '----------------')
        kIZ = 0
        RxJlk7U4 = 0
        for k, x in zip(K, qOluuIcku):
            if k:
                kIZ += k
                RxJlk7U4 += x * k
        #print(kIZ, RxJlk7U4)

        if RxJlk7U4 > _j8aK:continue
        YiiC9lwD = _j8aK - RxJlk7U4
        #print(YiiC9lwD)
        for six in mWZ:
            #print(YiiC9lwD)
            YtkPCm = YiiC9lwD // six
            if YtkPCm:
                kIZ += YtkPCm
                YiiC9lwD -= six * YtkPCm
        #print(YiiC9lwD, kIZ)
        #if YiiC9lwD >= 6:
        #    print(YiiC9lwD)
        kIZ += YiiC9lwD
        hLrfq1vp3v = min(hLrfq1vp3v,kIZ)

    print(hLrfq1vp3v)

def __starting_point():
    run()

__starting_point()
</ans>",True,{}
401,"<ans>
# -*- coding: utf-8 -*-
import sys
# from operator import itemgetter
# from fractions import gcd
# from math import ceil, floor
# from copy import deepcopy
# from itertools import accumulate
from collections import deque
# import math
# from functools import reduce
X7k = sys.stdin.readline
def ii(): return int(X7k())
def mi(): return list(map(int, X7k().rstrip().split()))
def lmi(): return list(map(int, X7k().rstrip().split()))
def li(): return list(X7k().rstrip())
# template

# BEGIN CUT HERE


class BIT:
    def __init__(self, bZHR, d=0):
        if isinstance(bZHR, int):
            self.size = bZHR
            self.tree = [d for _ in range(self.size + 1)]
        elif isinstance(bZHR, list):
            self.size = len(bZHR)
            self.tree = [d for _ in range(self.size + 1)]
            self.build(bZHR)
        else:
            raise TypeError

    def build(self, arr):
        if not isinstance(arr, list):
            raise TypeError
        for num, bZHR in enumerate(arr):
            self.add0(num, bZHR)

    def sum(self, i):
        ux0PpGC = self.tree[0]
        while i > 0:
            ux0PpGC += self.tree[i]
            i -= (i & -i)
        return ux0PpGC

    def add(self, i, a):
        if(i == 0):
            return
        while (i <= self.size):
            self.tree[i] += a
            i += (i & -i)

    def bisect_left(self, w):
        if w <= 0:
            return 0
        bZHR = 0
        gqAF30e = 1
        while (gqAF30e < self.size):
            gqAF30e <<= 1
        tCC8skgq = gqAF30e
        while (tCC8skgq > 0):
            if bZHR + tCC8skgq <= self.size and self.tree[bZHR + tCC8skgq] < w:
                w -= self.tree[bZHR + tCC8skgq]
                bZHR += tCC8skgq
            tCC8skgq >>= 1
        return bZHR + 1

    def query(self, l, gqAF30e):
        return self.sum(gqAF30e - 1) - self.sum(l - 1)

    def sum0(self, i):
        return self.sum(i + 1)

    def add0(self, i, a):
        self.add(i + 1, a)

    def query0(self, l, gqAF30e):
        return self.sum(gqAF30e) - self.sum(l)

    def __getitem__(self, item):
        CpbeCou = item.indices(self.size + 1)
        return [self.sum(i) - self.sum(i - 1) for i in range(CpbeCou[0], CpbeCou[1], CpbeCou[2])]

    def __str__(self):
        return str(self[1:self.size + 1])

# END CUT


def main():
    qOPMGTGi = ii()
    UjYrvBPrG = lmi()
    oIa = ii()
    jFV = BIT(UjYrvBPrG)
    # print(jFV)
    for i in range(oIa):
        l, gqAF30e = mi()
        UjYrvBPrG = jFV.query(l, gqAF30e+1)
        print((UjYrvBPrG-UjYrvBPrG % 10)//10)


def __starting_point():
    main()

__starting_point()
</ans>",0,{}
402,"<ans>
""""""Problem B - Bus of Characters.

http://codeforces.com/contest/982/problem/B

In the Bus of Characters there are `wcA` rows of seat, each having `2` seats.
The width of both seats in the `i`-th row is `k8Ptm_i` centimeters. All integers
`k8Ptm_i` are distinct.

Initially the bus is empty. On each of `2wcA` stops one passenger enters the
bus. There are two types of passengers:

- an introvert always chooses a row where both seats are empty. Among these
rows he chooses the one with the smallest seats width and takes one of the
seats in it;

- an extrovert always chooses a row where exactly one seat is occupied (by an
introvert). Among these rows he chooses the one with the largest seats width
and takes the vacant place in it.

You are given the seats width in each row and the order the passengers enter
the bus. Determine which row each passenger will take.

Input:

The first line contains a single integer `wcA` (`1 <= wcA <= 200\,000`) — the
number of rows in the bus.

The second line contains the sequence of integers `k8Ptm_1, k8Ptm_2, ..., k8Ptm_wcA` (`1 <=
k8Ptm_i <= 10^{9}`), where `k8Ptm_i` is the width of each of the seats in the `i`-th
row. It is guaranteed that all `k8Ptm_i` are distinct.

The third line contains a string of length `2wcA`, consisting of digits '0' and
'1' — the description of the order the passengers enter the bus. If the `j`-th
character is '0', then the passenger that enters the bus on the `j`-th stop is
an introvert. If the `j`-th character is '1', the the passenger that enters the
bus on the `j`-th stop is an extrovert. It is guaranteed that the number of
extroverts equals the number of introverts (i. e. both numbers equal `wcA`), and
for each extrovert there always is a suitable row.

Output:

Print `2wcA` integers — the rows the passengers will take. The order of
passengers should be the same as in input.

""""""
import logging
import collections


jRTFnu = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'
j69zZRX = logging.Formatter(jRTFnu)

a5wK = logging.StreamHandler()
a5wK.setLevel(logging.NOTSET)
a5wK.setFormatter(j69zZRX)

d9BQZj = logging.getLogger('bus_of_characters')
d9BQZj.setLevel(logging.NOTSET)
d9BQZj.addHandler(a5wK)


def solve(k8Ptm, RQst):
    BwfNp1pPD_ = collections.deque()
    jsD = collections.deque()

    for k8Ptm in sorted(enumerate(k8Ptm), key=lambda x: x[1]):
        BwfNp1pPD_.append([k8Ptm[0] + 1, k8Ptm[1]])
    
    OleNxsaIy = [-1] * len(RQst)

    yafc5R5 = []
    for pid, p in enumerate(RQst):
        d9BQZj.debug('pid: %s', pid)
        if p == '0':
            mtqpizGzJx = BwfNp1pPD_.popleft(), 
            jsD.appendleft(mtqpizGzJx)
            # yafc5R5.append(pid, mtqpizGzJx[0])
        else:
            d9BQZj.debug('jsD %s', jsD)
            mtqpizGzJx = jsD.popleft()
        #yafc5R5.append([pid, mtqpizGzJx[0]])
        OleNxsaIy[pid] = mtqpizGzJx[0]

    return [x for x, y in OleNxsaIy]",0,{}
403,"<ans>
#!/usr/bin/env python3
from sys import stdin
from bisect import bisect_left, bisect_right
    
kOhr = int(1e9)

def find(par, VBDU):
    if par[VBDU] == VBDU:
        return VBDU
    par[VBDU] = find(par, par[VBDU])
    return par[VBDU]

def union(par, bOkn, VBDU, _EZ):
    VBDU = find(par,VBDU)
    _EZ = find(par,_EZ)
    if VBDU==_EZ:
        return
    
    if bOkn[VBDU]<bOkn[_EZ]:
        par[VBDU] = _EZ
    else:
        par[_EZ] = VBDU
        if bOkn[VBDU]==bOkn[_EZ]:
            bOkn[VBDU] += 1
    
def solve():
    n, m, k = map(int, stdin.readline().split())
    NNSt = list(map(int, stdin.readline().split()))
    for i in range(1,k):
        NNSt[i] += NNSt[i-1]
    
    qRXG3qRq = list(range(n))
    bOkn = [0 for i in range(n)]
    p10546xq = [[kOhr for j in range(k)] for i in range(k)]
    for i in range(m):
        u, v, x = map(int, stdin.readline().split())
        if x==0:
            union(qRXG3qRq, bOkn, u-1, v-1)
        oCZ = bisect_left(NNSt, u)
        wHy4Bi7 = bisect_left(NNSt, v)
        p10546xq[oCZ][wHy4Bi7] = min(p10546xq[oCZ][wHy4Bi7], x)
        p10546xq[wHy4Bi7][oCZ] = min(p10546xq[wHy4Bi7][oCZ], x)
    
    N0v_JsYID = 0
    for i in range(k):
        pm37PJIn9U = qRXG3qRq[N0v_JsYID]
        while N0v_JsYID<NNSt[i]:
            if qRXG3qRq[N0v_JsYID]!=pm37PJIn9U:
                print(""No"")
                return
            N0v_JsYID += 1
    print(""Yes"")
    
    for N0v_JsYID in range(k):
        for i in range(k):
            for j in range(k):
                p10546xq[i][j] = min(p10546xq[i][j], p10546xq[i][N0v_JsYID]+p10546xq[N0v_JsYID][j])
    
    for i in range(k):
        p10546xq[i][i] = 0
        for j in range(k):
            if p10546xq[i][j] == kOhr:
                p10546xq[i][j] = -1
    
    for i in range(k):
        print(' '.join(map(lambda x: str(x), p10546xq[i])))
    
    
solve()
</ans>",True,{}
404,"<ans>
from sys  import stdin,stdout

Yy8NS=lambda:list(stdin.readline().strip())
k6YTh1z=lambda:list(map(int,stdin.readline().split()))
wuPs_F=lambda:list(map(int,stdin.readline().split()))
PoZdOi=lambda:int(stdin.readline())
BeaeILKz1j=lambda n: stdout.write(str(n)+""\n"")

def valid(x,y):
    if x>=n or y>=m or x<0 or y<0:
        return False
    if Fref[x][y] or RDVUSnp[x][y]=='*':
        return False
    return True

OnjSJ=[-1,1,0,0]
eeyzKzy8D=[0,0,1,-1]

def DFS(i,j,ffRP):
    fsS0g=1
    ZCVrUWr9w=[(i,j)]
    RKkX_N9xXL=[(i,j)]
    Fref[i][j]=True
    while RKkX_N9xXL:
        a,b=RKkX_N9xXL.pop()
        for x in range(4):
            newX,newY=a+OnjSJ[x], b+eeyzKzy8D[x]
            if valid(newX,newY):
                RKkX_N9xXL.append((newX,newY))
                Fref[newX][newY]=True
                ZCVrUWr9w.append((newX,newY))
                fsS0g= (fsS0g%10 + 1%10) % 10
                
    for i in ZCVrUWr9w:
        a,b=i
        RDVUSnp[a][b]=(fsS0g,ffRP)
    
        
    
n,m=wuPs_F()
RDVUSnp=[Yy8NS() for i in range(n)]
ffRP=0
Qixs=[list(i) for i in RDVUSnp]
Fref=[[False for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if RDVUSnp[i][j]=='.' and not Fref[i][j]:
            DFS(i,j,ffRP)
            ffRP+=1

for  i in range(n):
    for j in range(m):
        if RDVUSnp[i][j]=='*':
            Qixs[i][j]=1
            jkthhZNB=set()
            for x in range(4):
                newX,newY= i+OnjSJ[x], j+eeyzKzy8D[x]
                if newX>=0 and newY>=0 and newX<n and newY<m:
                    if type(RDVUSnp[newX][newY])==tuple:
                        A,B=RDVUSnp[newX][newY]
                        if B not in jkthhZNB:
                            Qixs[i][j]+=A
                            Qixs[i][j]%=10
                            jkthhZNB.add(B)
                
            
print('\n'.join([''.join([str(i) for i in j]) for j in Qixs]))
            
                        
                
            

</ans>",True,{}
405,"<ans>
```
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
pxHLIhfuF = sys.stdin.readline

LAgLl = zuskkpX9gn = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, zuskkpX9gn - 2, zuskkpX9gn)

def li():return [int(i) for i in pxHLIhfuF().rstrip('\n').split()]
def st():return pxHLIhfuF().rstrip('\n')
def val():return int(pxHLIhfuF().rstrip('\n'))
def li2():return [i for i in pxHLIhfuF().rstrip('\n')]
def li3():return [int(i) for i in pxHLIhfuF().rstrip('\n')]


for _ in range(val()):
    n,l,r = li()
    DHdxBDb = r
    l -= 1
    r -= l


    a14 = 0
    aIK = n - 1
    while aIK and a14 + 2*aIK <= l:
        a14 += 2*aIK
        aIK -= 1
    
    kRS = n - aIK
    Nm09PV = []
    bYzQ = kRS
    l -= a14

    LNniPCZP2l = bYzQ + 1
    UBE = 0
    while l:
        UBE = 1
        kRS = LNniPCZP2l
        LNniPCZP2l += 1
        l -= 1
        if not l:break
        UBE = 0
        kRS = bYzQ
        l -= 1

    if UBE:
        Nm09PV.append(kRS)
        if LNniPCZP2l == n + 1:
            bYzQ += 1
            LNniPCZP2l = bYzQ + 1
        kRS = bYzQ
        r -= 1

    while r:
        Nm09PV.append(kRS)
        r -= 1
        if not r:break
        kRS = LNniPCZP2l
        Nm09PV.append(kRS)
        LNniPCZP2l += 1
        if LNniPCZP2l == n + 1:
            bYzQ += 1
            LNniPCZP2l = bYzQ + 1
        r -= 1
        kRS = bYzQ
    
    if DHdxBDb == n*(n-1) + 1:
        Nm09PV[-1] = 1

    print(*Nm09PV)
        

    

    

```
</ans>",True,{}
406,"<ans>
m3_V7PD3K=input("""").split(' ')
kwf4=0
LyBNp=list()
for t in range (0,int(m3_V7PD3K[0])):
    bwr=input("""")
    LyBNp.append(bwr)
if (int(m3_V7PD3K[1])==0):
    for b in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[b]:
            kwf4=kwf4+1
       

    print(kwf4)
if (int(m3_V7PD3K[1])==1):
    for c in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[c] and '1' in LyBNp[c]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==2):
    for d in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[d] and '1' in LyBNp[d] and '2' in LyBNp[d]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==3):
    for e in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[e] and '1' in LyBNp[e] and '2' in LyBNp[e] and '3' in LyBNp[e]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==4):
    for f in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[f] and '1' in LyBNp[f] and '2' in LyBNp[f] and '3' in LyBNp[f] and '4' in LyBNp[f]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==5):
    for g in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[g] and '1' in LyBNp[g] and '2' in LyBNp[g] and '3' in LyBNp[g] and '4' in LyBNp[g] and '5' in LyBNp[g]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==6):
    for h in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[h] and '1' in LyBNp[h] and '2' in LyBNp[h] and '3' in LyBNp[h] and '4' in LyBNp[h] and '5' in LyBNp[h] and '6' in LyBNp[h]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==7):
     for i in range (0,int(m3_V7PD3K[0])):
                if '0' in LyBNp[i] and '1' in LyBNp[i] and '2' in LyBNp[i] and '3' in LyBNp[i] and '4' in LyBNp[i] and '5' in LyBNp[i] and '6' in LyBNp[i] and '7' in LyBNp[i]:
                    kwf4=kwf4+1
     print(kwf4)
if (int(m3_V7PD3K[1])==8):
    for j in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[j] and '1' in LyBNp[j] and '2' in LyBNp[j] and '3' in LyBNp[j] and '4' in LyBNp[j] and '5' in LyBNp[j] and '6' in LyBNp[j] and '7' in LyBNp[j] and '8' in LyBNp[j]:
            kwf4=kwf4+1
    print(kwf4)
if (int(m3_V7PD3K[1])==9):
    for k in range (0,int(m3_V7PD3K[0])):
        if '0' in LyBNp[k] and '1' in LyBNp[k] and '2' in LyBNp[k] and '3' in LyBNp[k] and '4' in LyBNp[k] and '5' in LyBNp[k] and '6' in LyBNp[k] and '7' in LyBNp[k] and '8' in LyBNp[k] and '9' in LyBNp[k]:
            kwf4=kwf4+1
    print(kwf4)
            
            

</ans>",0,{}
407,"<ans>
import sys
import random
from math import *
 
def input():
    return sys.stdin.readline().strip()
 
def iinput():
    return int(input())

def finput():
    return float(input())

def tinput():
    return input().split()

def linput():
    return list(input())
 
def rinput():
    return map(int, tinput())

def fiinput():
    return map(float, tinput())
 
def rlinput():
    return list(map(int, input().split()))
def trinput():
    return tuple(rinput())

def srlinput():
    return sorted(list(map(int, input().split())))

def NOYES(fl):
    if fl:
        print(""NO"")
    else:
        print(""YES"")
def YESNO(fl):
    if fl:
        print(""YES"")
    else:
        print(""NO"")
    
def main():  
    #n = iinput()
    #k = iinput() 
    #m = iinput() 
    #n = int(sys.stdin.readline().strip()) 
    #n, k = rinput()
    #n, m = rinput()
    #m, k = rinput()
    #n, k, m = rinput()
    #n, m, k = rinput()
    #k, n, m = rinput()
    #k, m, n = rinput() 
    #m, k, n = rinput()
    #m, n, k = rinput()
    #q = srlinput()
    #q = linput()
    x, y, n = rinput()
    pmIGblj5 = n - y
    print(x * (pmIGblj5 // x) + y)

    
for inytd in range(iinput()):
    main()
</ans>",True,{}
408,"<ans>
def bitmake(digit):#bit文字列生成（取り扱い注意）
    mAcngh73nK =list()

    for i in range(2 ** digit):
        L6pcXER = []
        for j in range(digit):  # このループが一番のポイント
            if ((i >> j) & 1):  # 順に右にシフトさせ最下位bitのチェックを行う
                L6pcXER.append(j)
        mAcngh73nK.append(L6pcXER)
    return mAcngh73nK
h,w,k = list(map(int,input().split()))
gGu3Ag = [""""]*h
for i in range(h):
    gGu3Ag[i] = list(map(str,input()))
# print(gGu3Ag)

mAcngh73nK = bitmake(h+w)
# print(mAcngh73nK)
GfA2h = [0]*h#横
dsy9ca = [0]*w#縦
H3OdKlWD = 0
for i in range(h):
    for j in range(w):
        if(gGu3Ag[i][j] == ""#""):
            GfA2h[i]+=1
            dsy9ca[j]+=1
            gGu3Ag[i][j] = 1
            H3OdKlWD += 1
        else:
            gGu3Ag[i][j] = 0
# print(GfA2h,dsy9ca)
AWQ = 0
for i in range(2**(h+w)):
    L6pcXER = mAcngh73nK[i]#h:0~(h-1),w:h~(h+w)-1
    Z8jrDiE = 0
    HrEH6 = []
    WHMbgj = []
    for j in range(len(L6pcXER)):
        _WYT = L6pcXER[j]
        if(_WYT <= h-1):
            Z8jrDiE += GfA2h[_WYT]
            HrEH6.append(_WYT)
        else:
            DAj = _WYT - h
            Z8jrDiE += dsy9ca[DAj]
            WHMbgj.append(DAj)
    # print(HrEH6,WHMbgj)
    lNcZxn = 0
    for j in range(len(HrEH6)):
        for l in range(len(WHMbgj)):
            if(gGu3Ag[HrEH6[j]][WHMbgj[l]] == 1):
                lNcZxn += 1
    
    if((H3OdKlWD - Z8jrDiE) + lNcZxn == k):
        # print(H3OdKlWD,Z8jrDiE,lNcZxn,""___"",H3OdKlWD-Z8jrDiE+lNcZxn)  
        AWQ += 1
print(AWQ)

# 2 3 2
# ..#
# ###
</ans>",0,{}
409,"<ans>
N78Q4hUTB=int(input())
if (N78Q4hUTB == 1) :
 print (""Washington"")
elif (N78Q4hUTB == 2):
 print (""Adams"")
elif (N78Q4hUTB == 3):
 print (""Jefferson"")
elif (N78Q4hUTB == 4):
 print (""Madison"")
elif (N78Q4hUTB == 5):
 print (""Monroe"")
elif (N78Q4hUTB == 6):
 print (""Adams"")
elif (N78Q4hUTB == 7):
 print (""Jackson"")
elif (N78Q4hUTB == 8):
 print (""Van Buren"")
elif (N78Q4hUTB == 9):
 print(""Harrison"")
elif (N78Q4hUTB == 10):
 print(""Tyler"")
elif (N78Q4hUTB == 11):
 print(""Polk"")
elif (N78Q4hUTB == 12):
 print(""Taylor"")
elif (N78Q4hUTB == 13):
 print(""Fillmore"")
elif (N78Q4hUTB == 14):
 print(""Pierce"")
elif (N78Q4hUTB == 15):
 print(""Buchanan"")
elif (N78Q4hUTB == 16):
 print (""Lincoln"")
elif (N78Q4hUTB == 17):
 print (""Johnson"")
elif (N78Q4hUTB == 18):
 print (""Grant"")
elif (N78Q4hUTB == 19):
 print (""Hayes"")
elif (N78Q4hUTB == 20):
 print (""Garfield"")
elif (N78Q4hUTB == 21):
 print (""Arthur"")
elif (N78Q4hUTB == 22):
 print (""Cleveland"")
elif (N78Q4hUTB == 23):
 print (""Harrison"")
elif (N78Q4hUTB == 24):
 print (""Cleveland"")
elif (N78Q4hUTB == 25):
 print (""McKinley"")
elif (N78Q4hUTB == 26):
 print (""Roosevelt"")
elif (N78Q4hUTB == 27):
 print (""Taft"")
elif (N78Q4hUTB == 28):
 print (""Wilson"")
elif (N78Q4hUTB == 29):
 print ('Harding')
elif (N78Q4hUTB == 30):
 print (""Coolidge"")
elif (N78Q4hUTB == 31):
 print (""Hoover"")
elif (N78Q4hUTB == 32):
 print (""Roosevelt"")
elif (N78Q4hUTB == 33):
 print (""Truman"")
elif (N78Q4hUTB == 34):
 print (""Eisenhower"")
elif (N78Q4hUTB == 35):
 print (""Kennedy"")
elif (N78Q4hUTB == 36):
 print (""Johnson"")
elif (N78Q4hUTB == 37):
 print (""Nixon"")
elif N78Q4hUTB == 38:
 print (""Ford"")
elif N78Q4hUTB == 39:
 print (""Carter"")
elif N78Q4hUTB == 40:
 print (""Reagan"")
</ans>",True,{}
410,"<ans>
import math
from decimal import Decimal
import heapq
def na():
	GcSn6MPh = int(input())
	dNDK = [int(x) for x in input().split()]
	return GcSn6MPh,dNDK
 
 
def nab():
	GcSn6MPh = int(input())
	dNDK = [int(x) for x in input().split()]
	MFsrGZUJqY = [int(x) for x in input().split()]
	return GcSn6MPh,dNDK,MFsrGZUJqY
 
 
def dv():
	GcSn6MPh, F98p8rf8m = list(map(int, input().split()))
	return GcSn6MPh,F98p8rf8m
 
 
def dva():
	GcSn6MPh, F98p8rf8m = list(map(int, input().split()))
	rADjK73XEH = [int(x) for x in input().split()]
	dNDK = [int(x) for x in input().split()]
	return GcSn6MPh,F98p8rf8m,dNDK
 
 
def eratosthenes(GcSn6MPh): 
	vliG = list(range(GcSn6MPh + 1))
	for i in vliG:
		if i > 1:
			for j in range(i + i, len(vliG), i):
				vliG[j] = 0
	return sorted(set(vliG))
 
 
def lol(lst,Sc8r2MO):
	Sc8r2MO=Sc8r2MO%len(lst)
	Lhsqwm=[0]*len(lst)
	for i in range(len(lst)):
		if i+Sc8r2MO<len(lst) and i+Sc8r2MO>=0:
			Lhsqwm[i]=lst[i+Sc8r2MO]
		if i+Sc8r2MO>=len(lst):
			Lhsqwm[i]=lst[i+Sc8r2MO-len(lst)]
		if i+Sc8r2MO<0:
			Lhsqwm[i]=lst[i+Sc8r2MO+len(lst)]
	return(Lhsqwm)
def nm():
	GcSn6MPh = int(input())
	dNDK = [int(x) for x in input().split()]
	F98p8rf8m = int(input())
	MFsrGZUJqY = [int(x) for x in input().split()]
	return GcSn6MPh,dNDK,F98p8rf8m,MFsrGZUJqY
 
 
def dvs():
	GcSn6MPh = int(input())
	F98p8rf8m = int(input())
	return GcSn6MPh, F98p8rf8m 
def Factor(GcSn6MPh):
	CSQg = []
	W5Se = 2
	while W5Se * W5Se <= GcSn6MPh:
		if GcSn6MPh % W5Se == 0:
			CSQg.append(W5Se)
			GcSn6MPh //= W5Se
		else:
			W5Se += 1
	if GcSn6MPh > 1:
		CSQg.append(GcSn6MPh)
	return CSQg


RIdrIx3 = input()
AuCP5uxu = 'Mike'
kOGp69tGHk = 'Ann'
if len(RIdrIx3) == 1:
	print(AuCP5uxu)
	return
print(AuCP5uxu)
DH8M3 = RIdrIx3[0]
CMnIw = []
GcSn6MPh = len(RIdrIx3)
for i in range(1, GcSn6MPh):
	W5Se = min(RIdrIx3[i], DH8M3)
	CMnIw.append(W5Se)
	DH8M3 = W5Se
for i in range(1, GcSn6MPh):
	if CMnIw[i - 1] < RIdrIx3[i]:
		print(kOGp69tGHk)
	else:
		print(AuCP5uxu)
</ans>",True,{}
411,"<ans>
t,sx,sy,ex,ey=map(int,input().split())
oQ9=input()
Wg7Skx4xd=len(oQ9)
oQ9+="" ""
oGCrZf_F=-1
RmFMl6BD0=0
PrAz=ex-sx
A1SApIAnj5=ey-sy
if abs(PrAz)+abs(A1SApIAnj5)>t:
    pass
else:
    while RmFMl6BD0<=t and RmFMl6BD0<Wg7Skx4xd:
        if PrAz==0 and A1SApIAnj5==0:
            oGCrZf_F=RmFMl6BD0
            break
        if PrAz>=0 and A1SApIAnj5>=0:
            if ((oQ9[RmFMl6BD0]!=""E"" and oQ9[RmFMl6BD0]!=""N"") or (PrAz==0 and oQ9[RmFMl6BD0]==""E"") or (A1SApIAnj5==0 and oQ9[RmFMl6BD0]==""N"")) and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
            if PrAz>0 and oQ9[RmFMl6BD0]==""E"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                PrAz-=1
            if A1SApIAnj5>0 and oQ9[RmFMl6BD0]==""N""and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                A1SApIAnj5-=1
        elif PrAz>=0 and A1SApIAnj5<=0:
            if ((oQ9[RmFMl6BD0]!=""E"" and oQ9[RmFMl6BD0]!=""S"") or (PrAz==0 and oQ9[RmFMl6BD0]==""E"") or (A1SApIAnj5==0 and oQ9[RmFMl6BD0]==""S"")) and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
            if PrAz>0 and oQ9[RmFMl6BD0]==""E"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                PrAz-=1
            if A1SApIAnj5<0 and oQ9[RmFMl6BD0]==""S"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                A1SApIAnj5+=1
        elif PrAz<=0 and A1SApIAnj5>=0:
            if ((oQ9[RmFMl6BD0]!=""W"" and oQ9[RmFMl6BD0]!=""N"") or (PrAz==0 and oQ9[RmFMl6BD0]==""W"") or (A1SApIAnj5==0 and oQ9[RmFMl6BD0]==""N"")) and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
            if PrAz<0 and oQ9[RmFMl6BD0]==""W"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                PrAz+=1
            if A1SApIAnj5>0 and oQ9[RmFMl6BD0]==""N"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                A1SApIAnj5-=1
        elif PrAz<=0 and A1SApIAnj5<=0:
            if ((oQ9[RmFMl6BD0]!=""W"" and oQ9[RmFMl6BD0]!=""S"") or (PrAz==0 and oQ9[RmFMl6BD0]==""W"") or (A1SApIAnj5==0 and oQ9[RmFMl6BD0]==""S"")) and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
            if PrAz<0 and oQ9[RmFMl6BD0]==""W"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                PrAz+=1
            if A1SApIAnj5<0 and oQ9[RmFMl6BD0]==""S"" and RmFMl6BD0<Wg7Skx4xd:
                RmFMl6BD0+=1
                A1SApIAnj5+=1
if PrAz==0 and A1SApIAnj5==0:
            oGCrZf_F=RmFMl6BD0
print(oGCrZf_F)  
</ans>",True,{}
412,"<ans>
def __starting_point():
    lxk0kJMOIr = input()
    herm2z0E4 = lxk0kJMOIr.split(' ')
    sEBv = [int(x) for x in herm2z0E4]
    qFg = [0,0,0]
    gdwV = 0
    for l in sEBv:
        gdwV+=l
    MEbg3n = False
    for l in sEBv:
        if l>gdwV/2:
            MEbg3n = True
    if MEbg3n:
        print('Impossible')
    else:
##        m = min(sEBv)//2
##        for i in (0,1,2):
##            qFg[i]+=m
##            sEBv[i]-=m*2
####        print(qFg)
        MEbg3n = False
        if sEBv[0]==min(sEBv):
            if sEBv[1]>sEBv[2]:
                BOC8QCBy = sEBv[1]-sEBv[2]
                qFg[0] += BOC8QCBy
                sEBv[0]-= BOC8QCBy
                sEBv[1] -=BOC8QCBy
            else:
                BOC8QCBy = sEBv[2]-sEBv[1]
                qFg[2] += BOC8QCBy
                sEBv[0] -= BOC8QCBy
                sEBv[2] -= BOC8QCBy
            if sEBv[0]%2==1:
                MEbg3n = True
            else:
                BOC8QCBy = sEBv[0]//2
                qFg[0] += BOC8QCBy
                qFg[2] += BOC8QCBy
                qFg[1] += (sEBv[1]+sEBv[2])//2 - BOC8QCBy
        elif sEBv[1]==min(sEBv):
            if sEBv[0]>sEBv[2]:
                BOC8QCBy = sEBv[0]-sEBv[2]
                qFg[0] += BOC8QCBy
                sEBv[1]-= BOC8QCBy
                sEBv[0] -= BOC8QCBy
            else:
                BOC8QCBy = sEBv[2]-sEBv[0]
                qFg[1] += BOC8QCBy
                sEBv[1] -= BOC8QCBy
                sEBv[2] -= BOC8QCBy 
            if sEBv[1]%2==1:
                MEbg3n = True
            else:
                BOC8QCBy = sEBv[1]//2
                qFg[0] += BOC8QCBy
                qFg[1] += BOC8QCBy
                qFg[2] += (sEBv[0]+sEBv[2])//2 - BOC8QCBy

        else:
            if sEBv[0]>sEBv[1]:
                BOC8QCBy = sEBv[0]-sEBv[1]
                qFg[2] += BOC8QCBy
                sEBv[2]-= BOC8QCBy
                sEBv[0]-=BOC8QCBy
            else:
                BOC8QCBy = sEBv[1]-sEBv[0]
                qFg[1] += BOC8QCBy
                sEBv[2] -= BOC8QCBy
                sEBv[1] -= BOC8QCBy
            if sEBv[2]%2==1:
                MEbg3n = True
            else:
                BOC8QCBy = sEBv[2]//2
                qFg[2] += BOC8QCBy
                qFg[1] += BOC8QCBy
                qFg[0] += (sEBv[0]+sEBv[1])//2 - BOC8QCBy
            
        for i in qFg:
            if i<0:
                MEbg3n = True
        if MEbg3n:
            print('Impossible')
        else:
            for i in range(3):
                print(qFg[i],end=' ')
            print()

__starting_point()
</ans>",True,{}
413,"<ans>
import math as ma
import sys
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))


# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/
def modInverse(a , _6WbnU10H):
	D0uxsx = _6WbnU10H
	Iyj3fJ = 0
	YnrMd5NWa = 1
	if (_6WbnU10H == 1):
		return 0
	while (a > 1):
		yf90kK3 = a // _6WbnU10H
		P4MrapiGZ5 = _6WbnU10H
		_6WbnU10H = a % _6WbnU10H
		a = P4MrapiGZ5
		P4MrapiGZ5 = Iyj3fJ
		Iyj3fJ = YnrMd5NWa - yf90kK3 * Iyj3fJ
		YnrMd5NWa = P4MrapiGZ5
	if (YnrMd5NWa < 0):
		YnrMd5NWa = YnrMd5NWa + D0uxsx
	return YnrMd5NWa


def num():
	return map(int , input().split())


def nu():
	return int(input())


def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x


n,k=num()
TMAZK_S=li()
eVmXUrdi=[0]*(max(TMAZK_S)+5)
Q94=max(TMAZK_S)
nNBxyXtA=min(TMAZK_S)
riSYbKJd=True
for i in range(1,n):
	if(TMAZK_S[i]!=TMAZK_S[i-1]):
		riSYbKJd=False
		break
for i in range(n):
	eVmXUrdi[0]+=1
	eVmXUrdi[TMAZK_S[i]+1]-=1
for i in range(1,len(eVmXUrdi)):
	eVmXUrdi[i]=eVmXUrdi[i]+eVmXUrdi[i-1]
d8vlXF078=eVmXUrdi[Q94]
egSUPFUj=0
Klu5MY8X=False
for i in range(Q94-1,nNBxyXtA,-1):
	if(d8vlXF078+eVmXUrdi[i]>k):
		Klu5MY8X=True
		d8vlXF078=eVmXUrdi[i]
		egSUPFUj+=1
	else:
		Klu5MY8X=False
		d8vlXF078+=eVmXUrdi[i]
if(d8vlXF078<=k and riSYbKJd==False):
	egSUPFUj+=1
print(egSUPFUj)
</ans>",0,{}
414,"<ans>
D8ZU = [(2,-2),(-2,2),(-2,-2),(2,2)]
def check(a):
    return 0<=a<8
yDkKjiQx = set()
RW30Heg5 = set()
zyQI8fOI = dict()
JPCO = dict()
def cango1(gqw1,Zi_P,lap):
    for dx,dy in D8ZU:
        nx,ny = dx+Zi_P[0],dy+Zi_P[1]
        if not check (nx) or not check(ny):
            continue
        if (nx,ny) in yDkKjiQx:
            continue
        zyQI8fOI[(nx,ny)]=lap%2
        yDkKjiQx.add((nx,ny))
        cango1(gqw1,(nx,ny),lap+1)
def cango2(gqw1,Zi_P,lap):
    for dx,dy in D8ZU:
        nx,ny = dx+Zi_P[0],dy+Zi_P[1]
        if not check(nx) or not check(ny):
            continue
        if (nx,ny) in RW30Heg5:
            continue
        JPCO[(nx,ny)]=lap%2
        RW30Heg5.add((nx,ny))
        cango2(gqw1,(nx,ny),lap+1)
QmW = int(input())
for ww in range(QmW):
    gqw1 = [input().strip() for i in range(8)]
    Zi_P = []
    KZZZSs = set()
    for i in range(8):
        for j in range(8):
            if gqw1[i][j] == 'K':
                Zi_P.append((i,j))
            if gqw1[i][j]=='#':
                KZZZSs.add((i,j))
    yDkKjiQx,RW30Heg5,zyQI8fOI,JPCO=set(),set(),dict(),dict()
    cango1(gqw1, Zi_P[0],0)
    cango2(gqw1,Zi_P[1],0)
    if ww!=QmW-1:
        input()
    whtABBUQ = (yDkKjiQx&RW30Heg5) - KZZZSs
    for x,y in whtABBUQ:
        if zyQI8fOI[(x,y)]==JPCO[(x,y)]:
            print(""YES"")
            break
    else:
        print(""NO"")
</ans>",True,{}
415,"<ans>
'''input
3
0 2 0
1 0 3
'''
from sys import stdin
from copy import deepcopy
from collections import deque",0,{}
416,"<ans>
def xmax(x, y):
    if x[1] > y[1]:
        return x
    return y

class SegTree:
    def __init__(self, init_val, n, ide_ele, seg_func):
        self.segfunc = seg_func
        self.num = 2**(n-1).bit_length()
        self.ide_ele = ide_ele
        self.seg=[self.ide_ele]*2*self.num
        for i in range(n):
            self.seg[i+self.num-1]=init_val[i]    
        for i in range(self.num-2,-1,-1) :
            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) 
        
    def update(self, YUFq, x):
        vKprx = YUFq
        YUFq += self.num-1
        self.seg[YUFq] = (vKprx, self.seg[YUFq][1] + x)
        while YUFq+1:
            YUFq = (YUFq-1)//2
            self.seg[YUFq] = self.segfunc(self.seg[YUFq*2+1],self.seg[YUFq*2+2])

    def update2(self, YUFq, x):
        YUFq += self.num-1
        self.seg[YUFq] = x
        while YUFq+1:
            YUFq = (YUFq-1)//2
            self.seg[YUFq] = self.segfunc(self.seg[YUFq*2+1],self.seg[YUFq*2+2])
        
    def query(self, kxPrnZjP, FaF0D):
        if FaF0D<=kxPrnZjP:
            return self.ide_ele
        kxPrnZjP += self.num-1
        FaF0D += self.num-2
        oBPM=self.ide_ele
        while FaF0D-kxPrnZjP>1:
            if kxPrnZjP&1 == 0:
                oBPM = self.segfunc(oBPM,self.seg[kxPrnZjP])
            if FaF0D&1 == 1:
                oBPM = self.segfunc(oBPM,self.seg[FaF0D])
                FaF0D -= 1
            kxPrnZjP = kxPrnZjP//2
            FaF0D = (FaF0D-1)//2
        if kxPrnZjP == FaF0D:
            oBPM = self.segfunc(oBPM,self.seg[kxPrnZjP])
        else:
            oBPM = self.segfunc(self.segfunc(oBPM,self.seg[kxPrnZjP]),self.seg[FaF0D])
        return oBPM

import sys;q1GR1=sys.stdin.readline
N, M = map(int, q1GR1().split())
Vd1Q = list(map(int, q1GR1().split()))
oxv = [[] for _ in range(N)]
for i in range(1, M+1):
    a, b = map(int, q1GR1().split())
    oxv[a-1].append((i, b-1))
    oxv[b-1].append((i, a-1))
    Vd1Q[a-1] -= 1
    Vd1Q[b-1] -= 1
rgwRAFA = -(10 ** 18)-1
Zlg = SegTree([(i, x) for i, x in enumerate(Vd1Q)], N, (-1, rgwRAFA), xmax)
iSs = False
rmjOx = []
CDRS6h4S = set()
while True:
    j, mx = Zlg.query(0, N)
    if mx<0:
        iSs=True
        break
    while oxv[j]:
        i, co = oxv[j].pop()
        if i in CDRS6h4S:
            continue
        CDRS6h4S.add(i)
        Zlg.update(co, 1)
        rmjOx.append(i)
    if len(rmjOx) == M:break
    Zlg.update2(j, (j, rgwRAFA))

if iSs or len(rmjOx) != M:print(""DEAD"")
else:print(""ALIVE"");print(*rmjOx[::-1])
</ans>",True,{}
417,"<ans>
import sys
import math

def ii():
    return sys.stdin.readline().strip()

def idata():
    return [int(LbWV85s8wt) for LbWV85s8wt in ii().split()]

def bfs(graph1, root1):
    k1iL0yfl5 = set()
    cZQL8uvjeh = [[root1, 0]]
    k1iL0yfl5.add(root1)
    qw, ver = 0, 1
    while cZQL8uvjeh:
        usCY4U1xD = cZQL8uvjeh[0]
        cZQL8uvjeh = cZQL8uvjeh[1:]
        for neig1 in graph1[usCY4U1xD[0]]:
            if neig1 not in k1iL0yfl5:
                k1iL0yfl5.add(neig1)
                cZQL8uvjeh += [[neig1, usCY4U1xD[1] + 1]]
                if qw < usCY4U1xD[1] + 1:
                    ver, qw = neig1, usCY4U1xD[1] + 1
    return ver, qw

def dfs(graph, ver):
    h8MGc = set()
    UOPkFzLaBo = [0] * (len(graph) + 1)
    Fu7kacu = [ver]
    acjpa_Z = 0
    while Fu7kacu:
        FadXjVh5a = []
        for v in Fu7kacu:
            UOPkFzLaBo[v] = acjpa_Z
            h8MGc.add(v)
            for v1 in graph[v]:
                if v1 not in h8MGc:
                    FadXjVh5a += [v1]
        Fu7kacu = FadXjVh5a
        acjpa_Z += 1
    return UOPkFzLaBo

def binary_search(array, LbWV85s8wt):
    fBW2d, DkNB = -1, len(array)
    while fBW2d + 1 != DkNB:
        agojsbw9 = (fBW2d + DkNB) // 2
        if array[agojsbw9] >= LbWV85s8wt:
            DkNB = agojsbw9
        elif array[agojsbw9] < LbWV85s8wt:
            fBW2d = agojsbw9
    return DkNB

def c_mod(Fmn3, k1, mod1):
    M5S87rMF = SN99pK = 1
    for i in range(Fmn3 - k1):
        M5S87rMF = (M5S87rMF * (Fmn3 - i)) % mod1
        SN99pK = (SN99pK * (i + 1)) % mod1
    return (M5S87rMF * pow(SN99pK, mod1 - 2, mod1)) % mod1

def c(Fmn3, k1):
    M5S87rMF = SN99pK = 1
    for i in range(Fmn3 - k1):
        M5S87rMF = M5S87rMF * (Fmn3 - i)
        SN99pK = SN99pK * (i + 1)
    return M5S87rMF // SN99pK

def v_sistemu(LbWV85s8wt, k):
    LbWV85s8wt = int(LbWV85s8wt)
    fyFoaqhr = ''
    while LbWV85s8wt:
        fyFoaqhr += str(LbWV85s8wt % k)
        LbWV85s8wt //= k
    return fyFoaqhr[::-1]

def iz_sistemi(LbWV85s8wt, k):
    LbWV85s8wt = str(LbWV85s8wt)[::-1]
    QaGo = 0
    for i in range(len(LbWV85s8wt)):
        QaGo += int(LbWV85s8wt[i]) * pow(k, i)
    return QaGo

def solve_of_problem():
    Fmn3 = int(ii())
    QaGo = 2
    for i in range(Fmn3):
        QaGo *= 2
        if Fmn3 % (QaGo - 1) == 0:
            print(Fmn3 // (QaGo - 1))
            return
    return

for ______ in range(int(ii())):
    solve_of_problem()
</ans>",0,{}
418,"<ans>
import sys

def Min(x, y):
    if x > y:
        return y
    else:
        return x

def Gcd(x, y):
    if x == 0:
        return y
    else:
        return Gcd(y % x, x)

def Lcm(x, y):
    return x * y // Gcd(x, y)

yAW = int(input())
yn4xdeLSP = [int(i) for i in input().split()]
oYfQWPta = [int(0) for i in range(0, yAW)]

qHKTwnX = 0

ahycXZW = 0

BtrUw7St7z = Lcm(7, yAW)

for i in range(0, 7 * yAW):
    if yn4xdeLSP[i % yAW] == 0 :
        print(i % yAW + 1)
        qHKTwnX = 1
        break
    if ahycXZW != 6:
        yn4xdeLSP[i % yAW] -= 1
        oYfQWPta[i % yAW] += 1
    ahycXZW = (ahycXZW + 1) % 7

if qHKTwnX == 0:
    h2dlJxw = 10**20

    for i in range(0, yAW):
        yn4xdeLSP[i] += oYfQWPta[i]
        if oYfQWPta[i] == 0: continue
        if yn4xdeLSP[i] % oYfQWPta[i] > 0:
            h2dlJxw = Min(h2dlJxw, yn4xdeLSP[i] // oYfQWPta[i])
        else:
            h2dlJxw = Min(h2dlJxw, yn4xdeLSP[i] // oYfQWPta[i] - 1)

    if h2dlJxw == 10**20:
        h2dlJxw = 0

    for i in range(0, yAW):
        yn4xdeLSP[i] -= h2dlJxw * oYfQWPta[i]

    hY4NjSPy8 = 0
    ahycXZW = 0

    while True:
        if yn4xdeLSP[hY4NjSPy8] == 0:
            print(hY4NjSPy8 % yAW + 1)
            break
        else:
            if ahycXZW != 6:
                yn4xdeLSP[hY4NjSPy8] -= 1
            ahycXZW = (ahycXZW + 1) % 7
            hY4NjSPy8 = (hY4NjSPy8 + 1) % yAW
</ans>",True,{}
419,"<ans>
# import itertools
# import math
# from functools import reduce
# import sys
# sys.setrecursionlimit(500*500)
# import numpy as np
# import heapq
# from collections import deque

# N = int(input())
# S = input()
# n, *a = map(int, open(0))
A, B, C, X, Y = map(int, input().split())
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# tree = [[] for _ in range(N + 1)]
# B_C = [list(map(int,input().split())) for _ in range(M)]
# S = input()

# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])
# all_cases = list(itertools.permutations(P))
# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))
# itertools.product((0,1), repeat=n)

# A = np.array(A)
# cum_A = np.cumsum(A)
# cum_A = np.insert(cum_A, 0, 0)

# def dfs(tree, s):
#     for l in tree[s]:
#         if depth[l[0]] == -1:
#             depth[l[0]] = depth[s] + l[1]
#             dfs(tree, l[0])
# dfs(tree, 1)

# def factorization(n):
#     arr = []
#     temp = n
#     for i in range(2, int(-(-n**0.5//1))+1):
#         if temp%i==0:
#             cnt=0
#             while temp%i==0:
#                 cnt+=1
#                 temp //= i
#             arr.append([i, cnt])
#     if temp!=1:
#         arr.append([temp, 1])
#     if arr==[]:
#         arr.append([n, 1])
#     return arr

# def gcd_list(numbers):
#     return reduce(math.gcd, numbers)

# if gcd_list(A) > 1:
#     print(""not coprime"")
#     return

# 高速素因数分解準備
#MAXN = 10**6+10
#sieve = [i for i in range(MAXN+1)]
#p = 2
#while p*p <= MAXN:
#    if sieve[p] == p:
#        for q in range(2*p, MAXN+1, p):
#            if sieve[q] == q:
#                sieve[q] = p
#    p += 1

if 2 * C > A + B:
    print(A * X + B * Y)
else:
    if X > Y:
        print(min(2 * C * X, 2 * C * Y + A * (X - Y)))
    else:
        print(min(2 * C * Y, 2 * C * X + B * (Y - X)))
</ans>",True,{}
420,"<ans>
import sys
sys.setrecursionlimit(10**9)
N,M=map(int,input().split())

def find_negative_loop(n,w,es):
  HVk1R=[float(""inf"")]*n
  #この始点はどこでもよい
  HVk1R[1]=0
  
  for i in range(n):
    for j in range(w):
      K0PT=es[j]
      if HVk1R[K0PT[1]]>HVk1R[K0PT[0]]+K0PT[2]:
        HVk1R[K0PT[1]]=HVk1R[K0PT[0]]+K0PT[2]
        if i==n-1:
          return True
  return False

def shortest_path(s,n,w,es):
  #s→iの最短距離
  #s:始点, n:頂点数, w:辺の数, es[i]:[辺の始点,辺の終点,辺のコスト]
  HVk1R=[float(""inf"")]*n
  #d[i]: s→iの最短距離
  HVk1R[s]=0

  while True:
    Jf_rAzfNA=False
    for p,q,r in es:
      # e: 辺iについて [from,to,cost]
      if HVk1R[p]!=float(""inf"") and HVk1R[q]>HVk1R[p]+r:
        HVk1R[q]=HVk1R[p]+r
        Jf_rAzfNA=True
    if not Jf_rAzfNA:
      break
      
  return HVk1R

Q4cxUT=[[] for _ in range(N+1)]
ece0=[]
for _ in range(M):
  a,b,c=map(int,input().split())
  Q4cxUT[a].append(b)
  ece0.append((a,b,-c))
  
#remove unnecessary vertex and edge
rAqX=[None]*(N+1)
def check_reachable(u):
  rAqX[u]=True
  if u==N:
    CfKg8zTOr[u]=True
    return True
  elif CfKg8zTOr[u]!=None:
    return CfKg8zTOr[u]  

  lLFWVHKk0U=0
  for v in Q4cxUT[u]:
    if not rAqX[v]:
      Qonna=check_reachable(v)
      if Qonna:
        lLFWVHKk0U+=1
        
  if lLFWVHKk0U>0:
    CfKg8zTOr[u]=True
    return True
  else:
    CfKg8zTOr[u]=False
    return False

CfKg8zTOr=[None]*(N+1)
for i in range(1,N+1):
  if CfKg8zTOr[i]==None:
    rAqX=[False]*(N+1)
    check_reachable(i)
#print(CfKg8zTOr)
  
FUpcCog=[]
for a,b,nc in ece0:
  if CfKg8zTOr[b]:
    FUpcCog.append((a,b,nc))
  
qqDVy7le1R=len(FUpcCog)
OA3=find_negative_loop(N+1,qqDVy7le1R,FUpcCog)

if OA3:
  print(""inf"")
else:
  JXxCN=shortest_path(1,N+1,qqDVy7le1R,FUpcCog)
  print(-JXxCN[N])
</ans>",0,{}
421,"<ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    _p4Kz0 = [True for _ in range(n + 1)]
    phCPK3ax = 3
    while phCPK3ax * phCPK3ax <= n:
        if _p4Kz0[phCPK3ax]:
            for i in range(phCPK3ax * 2, n + 1, phCPK3ax):
                _p4Kz0[i] = False
        phCPK3ax += 2
    Egfqu = [2]
    for phCPK3ax in range(3, n + 1, 2):
        if _p4Kz0[phCPK3ax]:
            Egfqu.append(phCPK3ax)
    return Egfqu

def divs(n, start=1):
    y3Hc = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                y3Hc.append(i)
            else:
                y3Hc.extend([i, n // i])
    return y3Hc

def divn(n, primes):
    JdtWS4 = 1
    for i in primes:
        if n == 1:
            return JdtWS4
        K9GfD = 1
        while n % i == 0:
            K9GfD += 1
            n //= i
        JdtWS4 *= K9GfD

def flin(d, x, default=-1):
    p0jez = s4eO2 = -1
    for i in range(len(d)):
        if d[i] == x:
            if p0jez == -1: p0jez = i
            s4eO2 = i
    if p0jez == -1:
        return default, default
    else:
        return p0jez, s4eO2

def ceil(n, k): return n // k + (n % k != 0)
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def prr(a, sep=' '): print(sep.join(map(str, a)))
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)

########################################################################################################################
# input = sys.stdin.readline

for _ in range(ii()):
    n, k = mi()
    FzFqSZJ7_C = n - 2*(k - 1)
    c5nSkph = n - (k - 1)
    if c5nSkph > 0 and c5nSkph % 2:
        DxBmHzfx = [1]*(k - 1) + [c5nSkph]
        print('YES')
        prr(DxBmHzfx, ' ')
    elif FzFqSZJ7_C > 0 and FzFqSZJ7_C % 2 == 0:
        DxBmHzfx = [2] * (k - 1) + [FzFqSZJ7_C]
        print('YES')
        prr(DxBmHzfx, ' ')
    else:
        print('NO')
</ans>",True,{}
422,"<ans>
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
import math

def isSubSequence(GWtY5EP, MPpO5ayt):
    FQRg = len(GWtY5EP)
    Q7Q48 = len(MPpO5ayt)
    qgDSPU = 0    # Index of GWtY5EP 
    v23Ji = 0    # Index of MPpO5ayt 
    while qgDSPU<FQRg and v23Ji<Q7Q48: 
        if GWtY5EP[qgDSPU] == MPpO5ayt[v23Ji]:     
            qgDSPU = qgDSPU+1    
        v23Ji = v23Ji + 1
    return qgDSPU==FQRg
    

AUA6qI = int(input())
 
#A,H,Q = [int(x) for x in stdin.readline().split()] 
for t in range(AUA6qI):
    #N,M = [int(x) for x in stdin.readline().split()]
    GWtY5EP = input()
    MPpO5ayt = input()
    mg60_rRb = input()
    
    q3TEEKzpZ = {}
    Jp0WveT = {}
    jgWWHjKuP = {}
    for v23Ji in range(26):
        q3TEEKzpZ[chr(97+v23Ji)] = 0
        Jp0WveT[chr(97+v23Ji)] = 0
        jgWWHjKuP[chr(97+v23Ji)] = 0
        
    for letter in GWtY5EP:
        q3TEEKzpZ[letter] += 1
    for letter in MPpO5ayt:
        Jp0WveT[letter] += 1
    for letter in mg60_rRb:
        jgWWHjKuP[letter] += 1
    
    # check GWtY5EP is subsequence of MPpO5ayt, if not, print no    
    Olm3 = isSubSequence(GWtY5EP, MPpO5ayt)
    if Olm3==0:
        print('NO')
    else:
        KBaukRw = 0
        for v23Ji in range(26):
            bdBiUwXr = Jp0WveT[chr(97+v23Ji)] - q3TEEKzpZ[chr(97+v23Ji)]
            if bdBiUwXr>0:
                #print(chr(97+v23Ji))
                if jgWWHjKuP[chr(97+v23Ji)]<bdBiUwXr and KBaukRw==0:
                    print('NO')
                    KBaukRw = 1
                    
        if KBaukRw==0:
            print('YES')
</ans>",0,{}
423,"<ans>
#
# abc147 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, NIDNtXd39r, oTm_):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(NIDNtXd39r)
        resolve()
        sys.stdout.seek(0)
        Ny9XlUPK = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(Ny9XlUPK, oTm_)

    def test_入力例_1(self):
        NIDNtXd39r = """"""3
1
2 1
1
1 1
1
2 0""""""
        oTm_ = """"""2""""""
        self.assertIO(NIDNtXd39r, oTm_)

    def test_入力例_2(self):
        NIDNtXd39r = """"""3
2
2 1
3 0
2
3 1
1 0
2
1 1
2 0""""""
        oTm_ = """"""0""""""
        self.assertIO(NIDNtXd39r, oTm_)

    def test_入力例_3(self):
        NIDNtXd39r = """"""2
1
2 0
1
1 0""""""
        oTm_ = """"""1""""""
        self.assertIO(NIDNtXd39r, oTm_)


def resolve():
    iRVST = int(NIDNtXd39r())
    Q53UHAbco = []
    for i in range(iRVST):
        R7vLo1PVEG = int(NIDNtXd39r())
        Q53UHAbco.append([list(map(int, NIDNtXd39r().split())) for j in range(R7vLo1PVEG)])

    SM59wi = 0
    for bit in range(1 << iRVST):
        sNw553sMw = True
        for i in range(iRVST):
            if bit & (1 << i):
                for c in Q53UHAbco[i]:
                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
                        sNw553sMw = False
                        break
        if sNw553sMw == True:
            SM59wi = max(SM59wi, bin(bit).count(""1""))
    print(SM59wi)


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
</ans>",True,{}
424,"<ans>
# alpha = ""abcdefghijklmnopqrstuvwxyz""
N58GOlzN = 998244353
hNjjv4 = 1#int(input())
from heapq import heappop, heappush
for test in range(hNjjv4):
    Nl6alkH19M = int(input())
    # Nl6alkH19M,m = (map(int, input().split()))
    sIltr5DVI = input()
    # d_Ian9z = 1
    # start = 1
    # C0cy1uroOb = sIltr5DVI[0]
    # iLM = 0
    # while sIltr5DVI[start]==C0cy1uroOb:
    #     start+=1
    #     iLM+=1
    # end = Nl6alkH19M-1
    # iLM = 1
    # while sIltr5DVI[end]==C0cy1uroOb:
    #     end-=1
    #     iLM+=1
    WJ71juUYNS = []
    fqbuWw = []
    iLM = 0
    C0cy1uroOb = sIltr5DVI[0]
    for i in sIltr5DVI:
        if i==C0cy1uroOb:
            iLM+=1
        else:
            WJ71juUYNS.append(C0cy1uroOb)
            fqbuWw.append(iLM)
            C0cy1uroOb = i
            iLM = 1
    WJ71juUYNS.append(C0cy1uroOb)
    fqbuWw.append(iLM)
    if len(WJ71juUYNS)==1:
        print(((Nl6alkH19M*(Nl6alkH19M+1))//2)%N58GOlzN)
    else:
        if WJ71juUYNS[0]==WJ71juUYNS[-1]:
            d_Ian9z = ((fqbuWw[0]+1)*(fqbuWw[-1]+1))%N58GOlzN
            # print(""here"", d_Ian9z)
            # if fqbuWw[0]+fqbuWw[-1]==Nl6alkH19M-1:
            #     d_Ian9z-=1
            #     d_Ian9z = d_Ian9z%N58GOlzN
            print(d_Ian9z)
        else:
            d_Ian9z = fqbuWw[0]+1+fqbuWw[-1]
            d_Ian9z = d_Ian9z%N58GOlzN
            # if fqbuWw[0]+fqbuWw[-1]==Nl6alkH19M-1:
            #     d_Ian9z-=1
            #     d_Ian9z = d_Ian9z%N58GOlzN
            print(d_Ian9z)
</ans>",True,{}
425,"<ans>
```
n, l, r = [int(i) for i in input().split()]

#ywg = [[0 for i in range(3)] for j in range(3)]

ffi11otJb4 = 0
TD_l = 0
UIvOlRW = 0

if l%3 == 0:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3
    if r%3 == 2:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
elif l%3 == 1:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3
    if r%3 == 2:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3 + 1
elif l%3 == 2:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3 + 1
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    elif r%3 == 2:
        ffi11otJb4 = (r-l+1)//3 
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3 + 1

ywg = [[-1 for i in range(3)] for j in range(n+1)]

ShyEb = 10**9 + 7
ywg[1][0] = ffi11otJb4%ShyEb
ywg[1][1] = TD_l%ShyEb
ywg[1][2] = UIvOlRW%ShyEb

for i in range(2,n+1):
    ywg[i][0] = (((ywg[i-1][0]%ShyEb)*(ffi11otJb4%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(TD_l%ShyEb))%ShyEb)%ShyEb
    ywg[i][1] = (((ywg[i-1][0]%ShyEb)*(TD_l%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(ffi11otJb4%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb)%ShyEb
    ywg[i][2] = (((ywg[i-1][0]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(TD_l%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(ffi11otJb4)%ShyEb)%ShyEb)%ShyEb

if ywg[n][0]!=-1:
    print(ywg[n][0]%ShyEb)
else:
    print(0)
```
</ans>",True,{}
426,"<ans>
from sys import stdin, stdout 
from bisect import bisect_left, bisect_right
from collections import defaultdict
import math
from fractions import Fraction as frac
from random import random
NhziiAL = stdin.readline
def cout(x):
	stdout.write(str(x)+'\n')
def var(type = int):
    return type(stdin.readline())
def readline(type = int):
    return list(map(type,stdin.readline().split()))
def readlist(type = int):
    return list(map(type,stdin.readline().split()))
def sorted_indexes(arr):
    return sorted(list(range(len(arr))),key=arr.__getitem__)
def printr(arr):
    [stdout.write(str(x)+' ')   for x in arr]
    cout('')
def find_lt(a, x):#'Find rightmost value less than x'
    tu_ = bisect_left(a, x)
    if tu_:
        return a[tu_-1]
    raise ValueError
def find_gt(a, x):#'Find leftmost value greater than x'
    tu_ = bisect_right(a, x)
    if tu_ != len(a):
        return a[tu_]
    raise ValueError
def dist(x,y):
    return math.sqrt(x*x + y*y)
def binary_search(arr, x):
    tu_ = bisect_left(arr, x)
    if tu_ == len(arr) or arr[tu_] != x:
        return -1
    return tu_

# ---------------------Template ends-------------sdpt,sdpt131[Sudipta Banik]---------------------

# mp = [0]*201
# ops = [0]*201
# def go(arr,i,j ,dp):
#     if i==j and ops[i] is None:
#         return [mp[i],mp[i]]
#     if i>j:
#         return [0,0]
#     if dp[i][j]:
#         return dp[i][j]
#     mx = -1000000000
#     mn = 1000000000
#     for k in range(i+1,j,2):
#         if ops[k]:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] + right[0])
#             mn = min(mn,left[1] + right[1])
#         else:
#             left = go(arr,i,k-1,dp)
#             right = go(arr,k+1,j,dp)
#             mx = max(mx,left[0] - right[1])
#             mn = min(mn,left[1] - right[0])
#     dp[i][j] = [mx,mn]
#     return [mx,mn]

    
n , a , b = readline(int)
uBBcB = [a,b]
Kr2ng = readlist(int)
O8zh = n//2
P9_m = 0
YP4qMUm = True
for tu_ in range(O8zh):
    if Kr2ng[tu_] == Kr2ng[n-1-tu_] == 2:
        P9_m += 2*min(a,b)
    elif Kr2ng[tu_] ==2 and Kr2ng[n-1-tu_] <= 1:
        P9_m += uBBcB[Kr2ng[n-1-tu_]]
    elif Kr2ng[tu_] <= 1 and Kr2ng[n-1-tu_] == 2:
        P9_m += uBBcB[Kr2ng[tu_]]
    elif Kr2ng[tu_] != Kr2ng[n-1-tu_]:
        YP4qMUm = False
        break
if n%2 == 1:
    if Kr2ng[O8zh] == 2:
        P9_m += min(a,b)
if not YP4qMUm:
    print(-1)
else:
    print(P9_m)",0,{}
427,"<ans>
```
from sys import stdin
import sys
import numpy as np
import collections
from functools import cmp_to_key
import heapq
sys.setrecursionlimit(100000)

##  input functions for me
def rsa(sep = ''):
    if sep == '' :
        return input().split() 
    else: return input().split(sep)
def rip(sep = ''):
    if sep == '' :
        return list(map(int, input().split())) 
    else: return list(map(int, input().split(sep)))
def ria(sep = ''): 
    return list(rip(sep))
def ri(): return int(input())
def rd(): return float(input())
def rs(): return input()
##
class mint:
    S_jtP6t = int(1e9 + 7)
    def __init__(self, GRvNav4J = 0):
        if not ((GRvNav4J >= 0) and (GRvNav4J < mint.S_jtP6t)):
            GRvNav4J %= mint.S_jtP6t
            if GRvNav4J < 0: GRvNav4J += mint.S_jtP6t
        self.V = GRvNav4J
    def __add__(self, other):
        GRvNav4J = self.V + (other.V if isinstance(other, mint) else other)
        return mint(GRvNav4J)
    def __sub__(self, other):
        GRvNav4J = self.V - (other.V if isinstance(other, mint) else other)
        return mint(GRvNav4J)
    def __mul__(self, other):
        GRvNav4J = self.V * (other.V if isinstance(other, mint) else other)
        return mint(GRvNav4J)
    def __floordiv__(self, other):
        GRvNav4J = self.V * mint.inv((other.V if isinstance(other, mint) else other))
        return mint(GRvNav4J)
    def __truediv__(self, other):
        GRvNav4J = self.V * mint.inv((other.V if isinstance(other, mint) else other))
        return mint(GRvNav4J)
    
    def __eq__(self, other):
        return self.V == (other.V if isinstance(other, mint) else mint(other).V)
    def __ne__(self, other):
        return self.V != (other.V if isinstance(other, mint) else other)
    def __int__(self): return self.V
    # right operand
    def __radd__(self, other):
        GRvNav4J = (other.V if isinstance(other, mint) else other) + self.V
        return mint(GRvNav4J)
    def __rsub__(self, other):
        GRvNav4J = (other.V if isinstance(other, mint) else other) - self.V
        return mint(GRvNav4J)
    def __rmul__(self, other):
        GRvNav4J = (other.V if isinstance(other, mint) else other) * self.V
        return mint(GRvNav4J)
    def __rfloordiv__(self, other):
        GRvNav4J = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
        return mint(GRvNav4J)
    def __rtruediv__(self, other):
        GRvNav4J = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
        return mint(GRvNav4J)

    @staticmethod
    def inv(G47):
        oRT, _, _ = mint.extGCD(G47, mint.S_jtP6t)
        return (oRT + mint.S_jtP6t) % mint.S_jtP6t
    @staticmethod
    def extGCD(G47, y):
        aQkuCC = G47
        tpFso0zq = y
        km99MY = 1
        OWBiWj0m = 0
        Vp_bnB = 0
        ZwY9jc9 = 1
        while(tpFso0zq > 0):
            hleX24aDQH = aQkuCC // tpFso0zq
            _kZM = aQkuCC % tpFso0zq
            wyFoUUOp = km99MY - hleX24aDQH * OWBiWj0m
            kPeEM9Od = Vp_bnB - hleX24aDQH * ZwY9jc9
            aQkuCC = tpFso0zq; tpFso0zq = _kZM
            km99MY = OWBiWj0m; OWBiWj0m = wyFoUUOp
            Vp_bnB = ZwY9jc9; ZwY9jc9 = kPeEM9Od
        GKcKKsozkz = aQkuCC
        oRT = km99MY
        uejzNO1QIn = Vp_bnB       
        return oRT, uejzNO1QIn, GKcKKsozkz
    @staticmethod
    def pow(G47, k):
        G47 = G47.V if isinstance(G47, mint) else G47
        return pow(G47, k, mint.S_jtP6t)

    
    def __str__(self):
        return str(self.V)
    def __repr__(self):
        return str(self.V)

def main():
    rXf9 = ri()
    ZsVvJrOOF9 = ria()
    ZsVvJrOOF9 = sorted(ZsVvJrOOF9)
    ZsVvJrOOF9 = list(reversed(ZsVvJrOOF9))
    lhUuAeXWU = [mint(0)] * (rXf9 + 1)
    lhUuAeXWU[0] = mint(1)
    for i in range(1,rXf9+1): lhUuAeXWU[i] = lhUuAeXWU[i-1] * 2

    XPF = mint(0)
    for i in range(rXf9):
        XPF += mint(ZsVvJrOOF9[i]) * lhUuAeXWU[rXf9-1]
        if i > 0: XPF += mint(ZsVvJrOOF9[i]) * i * lhUuAeXWU[rXf9-2]
    XPF *= lhUuAeXWU[rXf9]
    print(XPF)

def __starting_point():
    main()

__starting_point()
```
</ans>",0,{}
428,"<ans>
```
rftV2CQDr=input()
e4j0cjCDWI=input()
HJMg4G=len(rftV2CQDr)
OItp=[0]
for i in range(HJMg4G):
	if rftV2CQDr[i]=='0':
		if e4j0cjCDWI[i]=='0':
			OItp.append(2)
		else:
			OItp.append(1)
	else:
		if e4j0cjCDWI[i]=='X':
			OItp.append(0)
		else:
			OItp.append(-1)
OItp.append(0)
yTZL=len(OItp)
rrExr=0
rTRTzREp=1
QMH7xCop0=1
while(rTRTzREp<yTZL-1):
	if OItp[rTRTzREp]==2 and QMH7xCop0==1:
		if OItp[rTRTzREp+1]==2:
			QMH7xCop0=2
			rTRTzREp=rTRTzREp+1
			continue
		elif (OItp[rTRTzREp+1]==1 or OItp[rTRTzREp+1]==-1):
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+2
			continue
		else:
			rTRTzREp=rTRTzREp+2
			continue
	if OItp[rTRTzREp]==2 and QMH7xCop0==2:
		if OItp[rTRTzREp+1]==2:
			rrExr=rrExr+2
			rTRTzREp=rTRTzREp+2
			QMH7xCop0=1
			continue
		else:
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+1
			QMH7xCop0=1
			continue
	if OItp[rTRTzREp]==1 or OItp[rTRTzREp]==-1:
		if OItp[rTRTzREp+1]==2:
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+2
			continue
		else:
			rTRTzREp=rTRTzREp+1
			continue
	if OItp[rTRTzREp]==0:
		rTRTzREp=rTRTzREp+1
print (rrExr)
```
</ans>",True,{}
429,"<ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

xWI = ['#', '^', '&', '$']
Z1eDCJ = { ""res"" : (False, ""res"") }
fYAYIAv2qq = dict()
JWd = dict()
IzBwXB2S = -1

def get_tag(var):
    if var in Z1eDCJ:
        return Z1eDCJ[var][1]
    else:
        return var

JV5vnE = int(input())
for _ in range(JV5vnE):
    lval, rval = input().split('=')
    for c in xWI:
        if c in rval:
            arg1, arg2 = list(map(get_tag, rval.split(c)))
            WWcUtA9IMq = (arg1, arg2, c)
            if WWcUtA9IMq in fYAYIAv2qq:
                Z1eDCJ[lval] = (True, fYAYIAv2qq[WWcUtA9IMq])
            else:
                IzBwXB2S += 1
                Z1eDCJ[lval] = (True, IzBwXB2S)
                fYAYIAv2qq[WWcUtA9IMq] = IzBwXB2S
                JWd[IzBwXB2S] = WWcUtA9IMq
            break
    else:
        if rval in Z1eDCJ:
            Z1eDCJ[lval] = Z1eDCJ[rval]
        else:
            Z1eDCJ[lval] = (False, rval)

if Z1eDCJ[""res""] == (False, ""res""):
    print(""0"")
    return

xgUE2YoI = []
EHT = dict()

def reserve():
    return ''.join(chr(randint(0, 25) + ord('a')) for _ in range(4)) 

def implement(WWcUtA9IMq, final):
    if type(WWcUtA9IMq) == str:
        return WWcUtA9IMq
    elif WWcUtA9IMq in EHT:
        return EHT[WWcUtA9IMq]
    else:
        if final:
            AXv9t04n = ""res""
        else:
            AXv9t04n = reserve()
        EHT[WWcUtA9IMq] = AXv9t04n
        arg1, arg2, op = JWd[WWcUtA9IMq]
        var1, var2 = implement(arg1, False), implement(arg2, False)
        xgUE2YoI.append(AXv9t04n + ""="" + var1 + op + var2)
        return AXv9t04n

seed(123)
if Z1eDCJ[""res""][0]:
    implement(Z1eDCJ[""res""][1], True)
else:
    xgUE2YoI.append(""res="" + Z1eDCJ[""res""][1])
print(len(xgUE2YoI))
print(""\n"".join(xgUE2YoI))

#print(Z1eDCJ)
#print(fYAYIAv2qq)
</ans>",True,{}
430,"<ans>
''' CODED WITH LOVE BY SATYAM KUMAR '''

from sys import stdin, stdout
import heapq
import cProfile, math
from collections import Counter, defaultdict, deque
from bisect import bisect_left, bisect, bisect_right
import itertools
from copy import deepcopy
from fractions import Fraction
import sys, threading
import operator as op
from functools import reduce
import sys

sys.setrecursionlimit(10 ** 6)  # max depth of recursion
threading.stack_size(2 ** 27)  # new thread will get stack of such size
RtfMc6 = False
j_dnBq = str()
Q5ze = False
oTH = 10 ** 9 + 7


class MergeFind:
    def __init__(self, xDRQ):
        self.parent = list(range(xDRQ))
        self.size = [1] * xDRQ
        self.num_sets = xDRQ
        self.lista = [[_] for _ in range(xDRQ)]

    def find(self, e7WXJ5ZU):
        lRiyr = []
        while e7WXJ5ZU != self.parent[e7WXJ5ZU]:
            lRiyr.append(e7WXJ5ZU)
            e7WXJ5ZU = self.parent[e7WXJ5ZU]
        for AmgN64GMT in lRiyr:
            self.parent[AmgN64GMT] = e7WXJ5ZU
        return self.parent[e7WXJ5ZU]

    def merge(self, e7WXJ5ZU, AmgN64GMT):
        e7WXJ5ZU = self.find(e7WXJ5ZU)
        AmgN64GMT = self.find(AmgN64GMT)
        if e7WXJ5ZU == AmgN64GMT:
            return
        if self.size[e7WXJ5ZU] < self.size[AmgN64GMT]:
            e7WXJ5ZU, AmgN64GMT = AmgN64GMT, e7WXJ5ZU
        self.num_sets -= 1
        self.parent[AmgN64GMT] = e7WXJ5ZU
        self.size[e7WXJ5ZU] += self.size[AmgN64GMT]
        self.lista[e7WXJ5ZU] += self.lista[AmgN64GMT]

    def set_size(self, e7WXJ5ZU):
        return self.size[self.find(e7WXJ5ZU)]

    def __len__(self):
        return self.num_sets


def display(string_to_print):
    stdout.write(str(string_to_print) + ""\n"")


def prime_factors(xDRQ):  # xDRQ**0.5 complex
    xRKPWW = dict()
    for DaMXADA in range(2, math.ceil(math.sqrt(xDRQ)) + 1):
        while xDRQ % DaMXADA == 0:
            if DaMXADA in xRKPWW:
                xRKPWW[DaMXADA] += 1
            else:
                xRKPWW[DaMXADA] = 1
            xDRQ = xDRQ // DaMXADA
    if xDRQ > 2:
        xRKPWW[xDRQ] = 1
    return (xRKPWW)


def all_factors(xDRQ):
    return set(reduce(list.__add__,
                      ([DaMXADA, xDRQ // DaMXADA] for DaMXADA in range(1, int(xDRQ ** 0.5) + 1) if xDRQ % DaMXADA == 0)))


def fibonacci_modP(xDRQ, MOD):
    if xDRQ < 2: return 1
    return (cached_fn(fibonacci_modP, (xDRQ + 1) // 2, MOD) * cached_fn(fibonacci_modP, xDRQ // 2, MOD) + cached_fn(
        fibonacci_modP, (xDRQ - 1) // 2, MOD) * cached_fn(fibonacci_modP, (xDRQ - 2) // 2, MOD)) % MOD


def factorial_modP_Wilson(xDRQ, t6d8hnth):
    if (t6d8hnth <= xDRQ):
        return 0
    YjCi = (t6d8hnth - 1)
    for DaMXADA in range(xDRQ + 1, t6d8hnth):
        YjCi = (YjCi * cached_fn(InverseEuler, DaMXADA, t6d8hnth)) % t6d8hnth
    return YjCi


def binary(xDRQ, digits=20):
    AmgN64GMT = bin(xDRQ)[2:]
    AmgN64GMT = '0' * (digits - len(AmgN64GMT)) + AmgN64GMT
    return AmgN64GMT


def is_prime(xDRQ):
    """"""Returns True if xDRQ is prime.""""""
    if xDRQ < 4:
        return True
    if xDRQ % 2 == 0:
        return False
    if xDRQ % 3 == 0:
        return False
    DaMXADA = 5
    W85 = 2
    while DaMXADA * DaMXADA <= xDRQ:
        if xDRQ % DaMXADA == 0:
            return False
        DaMXADA += W85
        W85 = 6 - W85
    return True


def generate_primes(xDRQ):
    FT9fPBKp = [True for DaMXADA in range(xDRQ + 1)]
    t6d8hnth = 2
    while t6d8hnth * t6d8hnth <= xDRQ:
        if FT9fPBKp[t6d8hnth]:
            for DaMXADA in range(t6d8hnth * 2, xDRQ + 1, t6d8hnth):
                FT9fPBKp[DaMXADA] = False
        t6d8hnth += 1
    return FT9fPBKp


lz1xsZ = []


def warm_up_fac(MOD):
    nonlocal lz1xsZ, RtfMc6
    if RtfMc6: return
    lz1xsZ = [1 for _ in range(fac_warm_up_size + 1)]
    for DaMXADA in range(2, fac_warm_up_size):
        lz1xsZ[DaMXADA] = (lz1xsZ[DaMXADA - 1] * DaMXADA) % MOD
    RtfMc6 = True


def InverseEuler(xDRQ, MOD):
    return pow(xDRQ, MOD - 2, MOD)


def nCr(xDRQ, r, MOD):
    nonlocal RtfMc6, lz1xsZ
    if not RtfMc6:
        warm_up_fac(MOD)
        RtfMc6 = True
    return (lz1xsZ[xDRQ] * (
            (pow(lz1xsZ[r], MOD - 2, MOD) * pow(lz1xsZ[xDRQ - r], MOD - 2, MOD)) % MOD)) % MOD


def get_int():
    return int(stdin.readline().strip())


def get_tuple():
    return list(map(int, stdin.readline().split()))


def get_list():
    return list(map(int, stdin.readline().split()))


HIBu = dict()


def clear_cache():
    nonlocal HIBu
    HIBu = dict()


def cached_fn(HX2JD, *args):
    nonlocal HIBu
    if args in HIBu:
        return HIBu[args]
    else:
        N_6D8 = HX2JD(*args)
        HIBu[args] = N_6D8
        return N_6D8


def ncr(xDRQ, r):
    return math.factorial(xDRQ) / (math.factorial(xDRQ - r) * math.factorial(r))


def binary_search(DaMXADA, li):
    HX2JD = lambda _sC_JciW3v: li[_sC_JciW3v] - _sC_JciW3v // DaMXADA
    _sC_JciW3v = -1
    AmgN64GMT = len(li)
    while AmgN64GMT >= 1:
        while AmgN64GMT + _sC_JciW3v < len(li) and HX2JD(AmgN64GMT + _sC_JciW3v) > 0:  # Change this condition 2 to whatever you like
            _sC_JciW3v += AmgN64GMT
        AmgN64GMT = AmgN64GMT // 2
    return _sC_JciW3v


# -------------------------------------------------------------- MAIN PROGRAM


urWPQw = True
VGNG = True  # Can not be used clubbed with urWPQw WHen using recursive functions, use Python 3


def main():
    e7WXJ5ZU, AmgN64GMT, c, d, k = get_tuple()
    _sC_JciW3v = (e7WXJ5ZU+c-1)//c
    WZW = (AmgN64GMT+d-1)//d
    if _sC_JciW3v+WZW<=k:
        print(_sC_JciW3v, WZW)
    else: print(-1)
# --------------------------------------------------------------------- END=


if urWPQw:
    for DaMXADA in range(get_int()):
        main()
else:
    main() if not VGNG else threading.Thread(target=main).start()
</ans>",0,{}
431,"<ans>
import sys
bKJK = sys.stdin.readline

# def find(bxr0):
#     if duN[bxr0] == bxr0:
#         return bxr0
#     duN[bxr0] = find(duN[bxr0])
#     return duN[bxr0]

def find(bxr0):
    ogCLlmx2dd = []
    uowA8LPiD = bxr0
    while duN[uowA8LPiD] != uowA8LPiD:
        ogCLlmx2dd.append(uowA8LPiD)
        uowA8LPiD = duN[uowA8LPiD]
    for x in ogCLlmx2dd:
        duN[x] = uowA8LPiD
    return uowA8LPiD

def union(bxr0, ZSvMVmTj6):
    bxr0 = find(bxr0)
    ZSvMVmTj6 = find(ZSvMVmTj6)
    if bxr0 == ZSvMVmTj6:
        return
    duN[bxr0] = ZSvMVmTj6


def mst():
    diBV = []
    for kG0HE in JNljL6q:
        DutV8Yw, PnWQS, w = kG0HE
        DutV8Yw = find(DutV8Yw)
        PnWQS = find(PnWQS)
        if DutV8Yw != PnWQS:
            union(DutV8Yw, PnWQS)
            diBV.append(kG0HE)
    return diBV


def dfs(DutV8Yw, duN):
    for PnWQS, w in ruB[DutV8Yw]:
        if PnWQS != duN:
            vUaztUo1dc[PnWQS] = max(vUaztUo1dc[DutV8Yw], w)
            dfs(PnWQS, DutV8Yw)

def bfs(DutV8Yw):
    OJS5jYywZq = [False] * (n+1)
    from collections import deque

    TEBHXiH = deque()
    TEBHXiH.append(DutV8Yw)
    OJS5jYywZq[DutV8Yw] = True
    while TEBHXiH:
        DutV8Yw = TEBHXiH.popleft()
        for PnWQS, w in ruB[DutV8Yw]:
            if not OJS5jYywZq[PnWQS]:
                vUaztUo1dc[PnWQS] = max(vUaztUo1dc[DutV8Yw], w)
                TEBHXiH.append(PnWQS)
                OJS5jYywZq[PnWQS] = True


n, m, k = list(map(int, bKJK().split()))
bxr0 = list(map(int, bKJK().split()))
# n = 50000
# m = 2 * n
# k = n
# bxr0 = [i for i in range(1, n+1)]
# import random

duN = [0] * (n+1)
for i in range(1, n+1):
    duN[i] = i
JNljL6q = []
# for i in range(1, n+1):
#     kG0HE = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))
#     kG0HE = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))
#     JNljL6q.append(kG0HE)
for i in range(m):
    kG0HE = tuple(map(int, bKJK().split()))
    JNljL6q.append(kG0HE)
JNljL6q.sort(key=lambda x: x[2])
JNljL6q = mst()
ruB = [list() for i in range(n+1)]
for kG0HE in JNljL6q:
    DutV8Yw, PnWQS, w = kG0HE
    ruB[DutV8Yw].append((PnWQS, w))
    ruB[PnWQS].append((DutV8Yw, w))

vUaztUo1dc = [0] * (n+1)
# dfs(bxr0[0], -1)
bfs(bxr0[0])
Rwy = 0
for x in bxr0:
    Rwy = max(Rwy, vUaztUo1dc[x])
Rwy = [Rwy] * k
print(*Rwy)
</ans>",True,{}
432,"<ans>
""""""#N=int(input())
ov2,k=map(int,input().split())
s=input()
L=[0]*26
#s=[int(x) for x in input().split()]
for j in range(0,len(s)):
    L[ord(s[j])-65]=L[ord(s[j])-65]+1
ans=1000000007
for j in range(0,k):
    ans=min(ans,L[j])
ans=k*ans
print(ans)""""""
""""""import math
pre=[]
for i in range(0,45010):
    pre.append(((i*(i+1))//2))
#print(pre[:100])
ov2=int(input())
if(ov2==0 or ov2==1 or ov2==2):
    print('No')
else:
    temp=0
    t=pre[ov2]
    pos=-1
    for j in range(1,ov2+1):
        if(math.gcd(pre[j],t-pre[j])>1):
            temp=1
            pos=j
            break
    if(temp==0):
        print('No')
    else:
        print('Yes')
        print(pos,end="" "")
        for j in range(1,pos+1):
            print(j,end="" "")
        print("" "")
        print(ov2-j,end="" "")
        for j in range(pos+1,ov2+1):
            print(j,end="" "")
        print("" "")""""""",0,{}
433,"<ans>
import sys
# from collections import deque
GxkkIScnJT=sys.stdin.readline
def binary_search(org,arr,l,_qv5ZLlr,xjhACtSw,L,_ogcU):
	pESL=(l+_qv5ZLlr)//2
	# print(pESL,""ppppp"")
	if(pESL>0 and arr[pESL]-_ogcU>=org and arr[pESL-1]-_ogcU<org):
		return pESL
	elif(pESL==0 and arr[pESL]-_ogcU>=org ):
		return pESL
	elif(pESL==L and arr[pESL]-_ogcU>=org ):
		return pESL
	
	elif(pESL==xjhACtSw):
		return pESL

	elif(pESL>0 and arr[pESL]-_ogcU>org and arr[pESL-1]-_ogcU>=org):
		return binary_search(org,arr,l,pESL,xjhACtSw,L,_ogcU)
	
	elif(arr[pESL]-_ogcU<org):
		# print(""dddddd"")
		return binary_search(org,arr,pESL+1,_qv5ZLlr,xjhACtSw,L,_ogcU)
	return pESL
	",0,{}
434,"<ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
from math import *
from decimal import *
from copy import *
getcontext().prec = 30
vuKc = sys.maxsize
NAtm = 10**5+10
n4TXOV_ = 10**9+7
def isprime(vc8Pati7u):
    vc8Pati7u = abs(int(vc8Pati7u))
    if vc8Pati7u < 2:
        return False
    if vc8Pati7u == 2: 
        return True    
    if not vc8Pati7u & 1: 
        return False
    for J0O in range(3, int(vc8Pati7u**0.5) + 1, 2):
        if vc8Pati7u % J0O == 0:
            return False
    return True

def mhd(Ztn,mwewe):
    return abs(Ztn[0]-mwewe[0])+abs(mwewe[1]-Ztn[1])

def charIN(J0O= ' '):
    return(sys.stdin.readline().strip().split(J0O))

def arrIN(J0O = ' '):
    return list(map(int,sys.stdin.readline().strip().split(J0O)))

def dis(Ztn,mwewe):
    a = mwewe[0]-Ztn[0]
    mwewe = Ztn[1]-mwewe[1]
    return (a*a+mwewe*mwewe)**0.5

def lgcd(Ztn):
    NGmIVg = Ztn[0]
    for i in range(1,len(Ztn)):
        NGmIVg = math.gcd(NGmIVg,Ztn[i])
    return NGmIVg

def ms(Ztn):
    FoFKBA = -vuKc
    ZqIvk4mi = 0
    ib6XbP = XyJPzAfAA = bCl4r = 0
    for i in range(len(Ztn)):
        ZqIvk4mi+=Ztn[i]
        if FoFKBA<ZqIvk4mi:
            FoFKBA = ZqIvk4mi
            ib6XbP = bCl4r
            XyJPzAfAA = i
        if ZqIvk4mi<0:
            ZqIvk4mi = 0
            bCl4r = i+1
    return FoFKBA,ib6XbP,XyJPzAfAA

def flush():
    return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
    vc8Pati7u,k = arrIN()
    JgQbS = 0
    while 1:
        if vc8Pati7u%k==0:
            vc8Pati7u//=k
            JgQbS+=1
        else:
            J0O = vc8Pati7u%k
            JgQbS+=J0O
            vc8Pati7u-=J0O
        if vc8Pati7u==0:
            print(JgQbS)
            break
</ans>",0,{}
435,"<ans>
oGEfMTpX = 1000000007


def isSubset(a, b):
	return (a & b) == a


def isIntersect(a, b):
	return (a & b) != 0


# Solve for each weakly connected component (WCC)
def cntOrder(Q0Rm5UzIEb, Bf6Xpd2Y):
	MMZzFQx = len(Q0Rm5UzIEb)
	syQ = len(Bf6Xpd2Y)

	WYT7K = [0 for i in range(syQ)]

	for x in range(MMZzFQx):
		for i in range(syQ):
			if Bf6Xpd2Y[i] % Q0Rm5UzIEb[x] == 0:
				WYT7K[i] |= 1 << x

	EATtCIe = [0 for mask in range(1<<MMZzFQx)]
	for mask in range(1<<MMZzFQx):
		for i in range(syQ):
			if isSubset(WYT7K[i], mask):
				EATtCIe[mask] += 1

	CPIm7r = [[0 for mask in range(1<<MMZzFQx)] for k in range(syQ+1)]
	for i in range(syQ):
		CPIm7r[1][WYT7K[i]] += 1
	for k in range(syQ):
		for mask in range(1<<MMZzFQx):
			for i in range(syQ):
				if not isSubset(WYT7K[i], mask) and isIntersect(WYT7K[i], mask):
					CPIm7r[k+1][mask | WYT7K[i]] = (CPIm7r[k+1][mask | WYT7K[i]] + CPIm7r[k][mask]) % oGEfMTpX
			CPIm7r[k+1][mask] = (CPIm7r[k+1][mask] + CPIm7r[k][mask] * (EATtCIe[mask] - k)) % oGEfMTpX

	return CPIm7r[syQ][(1<<MMZzFQx)-1]


def dfs(u):
	nonlocal hGoUcrNe, o6vPvT, H0SbhsMmX, otpg, Q0Rm5UzIEb, Bf6Xpd2Y

	otpg[u] = True
	if H0SbhsMmX[u] == 0:
		Q0Rm5UzIEb.append(hGoUcrNe[u])
	else:
		Bf6Xpd2Y.append(hGoUcrNe[u])

	for v in o6vPvT[u]:
		if not otpg[v]:
			dfs(v)


def main():
	nonlocal hGoUcrNe, o6vPvT, H0SbhsMmX, otpg, Q0Rm5UzIEb, Bf6Xpd2Y

	# Reading input
	kHdN5x = int(input())
	hGoUcrNe = list(map(int, input().split()))

	# Pre-calculate C(n, k)
	Znkmip26Sk = [[0 for j in range(kHdN5x)] for i in range(kHdN5x)]
	for i in range(kHdN5x):
		Znkmip26Sk[i][0] = 1
		for j in range(1, i+1):
			Znkmip26Sk[i][j] = (Znkmip26Sk[i-1][j-1] + Znkmip26Sk[i-1][j]) % oGEfMTpX	

	# Building divisibility graph
	H0SbhsMmX = [0 for u in range(kHdN5x)]
	o6vPvT = [[] for u in range(kHdN5x)]
	for u in range(kHdN5x):
		for v in range(kHdN5x):
			if u != v and hGoUcrNe[v] % hGoUcrNe[u] == 0:
				o6vPvT[u].append(v)
				o6vPvT[v].append(u)
				H0SbhsMmX[v] += 1

	# Solve for each WCC of divisibility graph and combine result
	_KdMdGUQsw = 1
	xh_ = 0
	otpg = [False for u in range(kHdN5x)]
	for u in range(kHdN5x):
		if not otpg[u]:
			Q0Rm5UzIEb = []
			Bf6Xpd2Y = []
			dfs(u)

			if len(Bf6Xpd2Y) > 0:
				oR4Lp0e4m = len(Bf6Xpd2Y) - 1
				EATtCIe = cntOrder(Q0Rm5UzIEb, Bf6Xpd2Y)

				# Number of orders for current WCC
				_KdMdGUQsw = (_KdMdGUQsw * EATtCIe) % oGEfMTpX
				# Number of ways to insert <sz> number to array of <curLen> elements
				_KdMdGUQsw = (_KdMdGUQsw * Znkmip26Sk[xh_ + oR4Lp0e4m][oR4Lp0e4m]) % oGEfMTpX
				xh_ += oR4Lp0e4m		

	print(_KdMdGUQsw)

def __starting_point():
	main()
__starting_point()
</ans>",0,{}
436,"<ans>
```
BGyY=int(input())
hymzXRQYIk=input()
hymzXRQYIk=[1 if hymzXRQYIk[i]=='o' else -1 for i in range(BGyY)]

#0番目は羊のパターン
nCViBNaFdI=[0]*BGyY
nCViBNaFdI[0]=1
if hymzXRQYIk[0]==1: #0番目の両隣は同種
  #0番目の両隣は羊
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
    
  #0番目の両隣は狼
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, BGyY-1番目が狼
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
  #1番目が狼, BGyY-1番目が羊
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
#0番目は狼のパターン
nCViBNaFdI=[0]*BGyY
nCViBNaFdI[0]=-1
if hymzXRQYIk[0]==-1: #0番目の両隣は同種
  #0番目の両隣は羊
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
    
  #0番目の両隣は狼
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, BGyY-1番目が狼
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
  #1番目が狼, BGyY-1番目が羊
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*hymzXRQYIk[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*hymzXRQYIk[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*hymzXRQYIk[BGyY-1]:
    JpOfEywNgy=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(JpOfEywNgy))
    return
  
print(-1)
```
</ans>",0,{}
437,"<ans>
KBc2ZD=int(input())
gBOj4GwNd=list(map(int,input().split()))
cZXh=input()
AXBY1Lfr=0
HuAJERj=0
casIRMP=0
BjIhUrXsNd=0
rEtVkRX=False
for i in range(KBc2ZD):
    if cZXh[i]==""G"":
        Wdi=gBOj4GwNd[i]
        if AXBY1Lfr>=Wdi:
            AXBY1Lfr-=Wdi
            BjIhUrXsNd+=2*Wdi
            casIRMP+=Wdi
        else:
            Wdi-=AXBY1Lfr
            BjIhUrXsNd+=2*AXBY1Lfr
            casIRMP+=AXBY1Lfr
            AXBY1Lfr=0
            BjIhUrXsNd+=3*Wdi
            HuAJERj+=Wdi
    elif cZXh[i]==""W"":
        AXBY1Lfr+=gBOj4GwNd[i]
        BjIhUrXsNd+=2*gBOj4GwNd[i]
        rEtVkRX=True
    else:
        Wdi=gBOj4GwNd[i]
        if AXBY1Lfr>=Wdi:
            AXBY1Lfr-=Wdi
            BjIhUrXsNd+=2*Wdi
        else:
            Wdi-=AXBY1Lfr
            BjIhUrXsNd+=2*AXBY1Lfr
            AXBY1Lfr=0
            if casIRMP>=Wdi:
                casIRMP-=Wdi
                HuAJERj+=Wdi
                BjIhUrXsNd+=3*Wdi
            else:
                Wdi-=casIRMP
                HuAJERj+=casIRMP
                BjIhUrXsNd+=3*casIRMP
                casIRMP=0
                if HuAJERj>=Wdi:
                    HuAJERj-=Wdi
                    BjIhUrXsNd+=3*Wdi
                else:
                    Wdi-=HuAJERj
                    BjIhUrXsNd+=3*HuAJERj
                    HuAJERj=0
                    if rEtVkRX:
                        BjIhUrXsNd+=4*Wdi
                    else:
                        BjIhUrXsNd+=6*Wdi
print(BjIhUrXsNd)
</ans>",True,{}
438,"<ans>
from math import gcd

m,a,b = list(map(int,input().split()))

jclv319GsE = gcd(a,b)

P7RT = [0]*(a+b+1)
P7RT[0] = 1

xJ22JQBDY = 1

A4AXK = 0
mCjkh = 0
vyfTD6PJ = 0
while True:
    #print(vyfTD6PJ, P7RT)
    if vyfTD6PJ >= b:
        #print('back')
        vyfTD6PJ -= b
        if P7RT[vyfTD6PJ]:
            break
        P7RT[vyfTD6PJ] = 1
        xJ22JQBDY += 1
    else:
        vyfTD6PJ += a
        if vyfTD6PJ > m:
            break
        if vyfTD6PJ > mCjkh:
            #print('forward', vyfTD6PJ - mCjkh, 'with', xJ22JQBDY)
            A4AXK += (vyfTD6PJ - mCjkh)*xJ22JQBDY
            mCjkh = vyfTD6PJ
        if P7RT[vyfTD6PJ]:
            break
        P7RT[vyfTD6PJ] = 1
        xJ22JQBDY += 1
    #print(xJ22JQBDY,A4AXK)
    #print('---')

if vyfTD6PJ > m:
    # we're done
    A4AXK += (m - mCjkh + 1)*xJ22JQBDY
else:
    def sumto(n):
        fiM1qWoU = n//jclv319GsE + 1
        RgaZe = fiM1qWoU*(fiM1qWoU+1)//2 * jclv319GsE
        Mvc9KZfN2S = fiM1qWoU * (jclv319GsE-1 - (n%jclv319GsE))
        RgaZe -= Mvc9KZfN2S
        return RgaZe

    #S = 0
    #for i in range(mCjkh, m+1):
    #    S += i//jclv319GsE + 1
    #A4AXK += S
    #assert S == sumto(m) - sumto(mCjkh-1)

    A4AXK += sumto(m) - sumto(mCjkh-1)

#print(P7RT)
print(A4AXK)
</ans>",True,{}
