index,generated,result,format_properties
0," <ans>
def remove\_Occ(K2ZW, qhF): 
for CEPyYngFb in range(len(K2ZW)): 
if (K2ZW[CEPyYngFb] == qhF): 
K2ZW = K2ZW[0 : CEPyYngFb] + K2ZW[CEPyYngFb + 1:] 
break
for CEPyYngFb in range(len(K2ZW) - 1, -1, -1):  
if (K2ZW[CEPyYngFb] == qhF): 
K2ZW = K2ZW[0 : CEPyYngFb] + K2ZW[CEPyYngFb + 1:] 
break
return K2ZW
</ans>",0,{}
1," <ans>
def sort\_matrix(yBMWXaSCr):
result = sorted(yBMWXaSCr, key=sum)
return result
</ans>",0,{}
2," <ans>
def find\_Volume(bPI, yRn, UbHoWC) : 
 return ((bPI \* yRn \* UbHoWC) / 2)
</ans>",0,{}
3," <ans>
import re
def text\_lowercase\_underscore(JowoRo):
        D8s7bA16J = '^[a-z]+_[a-z]+$'
        if re.search(D8s7bA16J,  JowoRo):
                return True
        else:
                return False
</ans>",0,{}
4," <ans>
def square\_perimeter(glOU3shV):
  U\_TG7=4\*glOU3shV
  return U\_TG7
</ans>",0,{}
5," <ans>
G16Qmt = 256
def str\_to\_list(L\_4F2): 
	zL2cEpV = [] 
	for zAQlxJ4SX in L\_4F2: 
		zL2cEpV.append(zAQlxJ4SX) 
	return zL2cEpV 
def lst\_to\_string(VxfCQGgX): 
	return ''.join(VxfCQGgX) 
def get\_char\_count\_array(L\_4F2): 
	H1zx = [0] \* G16Qmt 
	for UbEctT in L\_4F2: 
		H1zx[ord(UbEctT)] += 1
	return H1zx 
def remove\_dirty\_chars(L\_4F2, NLLzPkkGo): 
	H1zx = get\_char\_count\_array(NLLzPkkGo) 
	XmI = 0
	JozGw82Kw = 0
	rQJM9U = '' 
	str\_list = str\_to\_list(L\_4F2) 
	while XmI != len(str\_list): 
		rQJM9U = str\_list[XmI] 
		if H1zx[ord(rQJM9U)] == 0: 
			str\_list[JozGw82Kw] = str\_list[XmI] 
			JozGw82Kw += 1
		XmI+=1
	return lst\_to\_string(str\_list[0:JozGw82Kw]) 
</ans>",0,{}
6," <ans>
def test\_duplicate(yY2):
nums\_set = set(yY2)
return E3x(yY2) != E3x(nums\_set)
</ans>",0,{}
7," <ans>
def is\_woodall(Jm8GAF0): 
 Jm8GAF0 = Jm8GAF0 + 1  
 AwaII = 0  
 while (Jm8GAF0 % 2 == 0): 
 Jm8GAF0 = Jm8GAF0 / 2  
 AwaII = AwaII + 1  
 if (AwaII == Jm8GAF0): 
 return True  
 return False
</ans>",0,{}
8," <ans>
def rev(YNvDMbZ):
OlJL = 0
while (YNvDMbZ > 0):
OlJL = (OlJL * 10 + YNvDMbZ % 10)
YNvDMbZ = YNvDMbZ // 10
return OlJL

def check(fZJZ):
return (2 \* rev(fZJZ) == fZJZ + 1)
</ans>",0,{}
9," <ans>
def find\_Max\_Num(\_7qc18Ref) :
n = len(\_7qc18Ref)
\_7qc18Ref.sort(reverse = True)
NlwsekkqH = \_7qc18Ref[0]
for QrPT in range(1,n) :
NlwsekkqH = NlwsekkqH \* 10 + \_7qc18Ref[QrPT]
return NlwsekkqH
</ans>",0,{}
10," <ans>
def opposite\_Signs(DSuFE, bty):
 return ((DSuFE ^ bty) < 0);
</ans>",0,{}
11," <ans>
def is\_octagonal(AYmqg): 
 return 3 \* AYmqg \* AYmqg - 2 \* AYmqg
</ans>",0,{}
12," <ans>
from collections import defaultdict
def count\_Substrings(UG\_n9):
n = len(UG\_n9)
cU9k, TGRBI1 = 0, 0
OZSH = defaultdict(lambda : 0)
OZSH[0] += 1
for oHPbzR in range(n):
TGRBI1 += ord(UG\_n9[oHPbzR]) - ord('0')
cU9k += OZSH[TGRBI1 - (oHPbzR + 1)]
OZSH[TGRBI1 - (oHPbzR + 1)] += 1
return cU9k
</ans>",0,{}
13," <ans>
def smallest\_num(ZuQOBdV):
 return min(ZuQOBdV)
</ans>",0,{}
14," <ans>
def max\_difference(i9n4d):
max\_difference(test\_list) -> i9n4d
temp = [abs(b - a) for a, b in i9n4d] -> e2et6 = [abs(aJ42 - VkAKq) for VkAKq, aJ42 in i9n4d]
res = max(temp) -> L0n = max(e2et6)
return (res) -> return (L0n)
</ans>",0,{}
15," <ans>
def Dk033\_X(NGcymwgn):
NGcymwgn.sort(key = lambda R5BLmFg: R5BLmFg[1])
return NGcymwgn
</ans>",0,{}
16," <ans>
def recursive\_list\_sum(ysGFbuN3):
	sbkm2u = 0
	for KYivBnrRg in ysGFbuN3:
		if type(KYivBnrRg) == type([]):
			sbkm2u = sbkm2u + recursive\_list\_sum(KYivBnrRg)
		else:
			sbkm2u = sbkm2u + KYivBnrRg
	return sbkm2u
</ans>",0,{}
17," <ans>
def XIpeUc(y7Jw641RI):
  XIpeUc= 0
  for ikk in y7Jw641RI: 
    if ikk >= 0: 
      XIpeUc += 1
  return XIpeUc
</ans>",True,{}
18," <ans>
def xvvhs(nrWvMG1):
xvvhs = [[0 for i in range(nrWvMG1+1)] for j in range(nrWvMG1+1)]
xvvhs[0][0] = 1
for MX9T in range(1, nrWvMG1+1):
xvvhs[MX9T][0] = xvvhs[MX9T-1][MX9T-1]
for iLJXgu in range(1, MX9T+1):
xvvhs[MX9T][iLJXgu] = xvvhs[MX9T-1][iLJXgu-1] + xvvhs[MX9T][iLJXgu-1]
return xvvhs[nrWvMG1][0]
</ans>",0,{}
19," <ans>
def is\_Monotonic(Aey): 
return (all(Aey[Yj1ivhNLY] <= Aey[Yj1ivhNLY + 1] for Yj1ivhNLY in range(len(Aey) - 1)) or
all(Aey[Yj1ivhNLY] >= Aey[Yj1ivhNLY + 1] for Yj1ivhNLY in range(len(Aey) - 1)))
</ans>",0,{}
20," <ans>
def is\_sublist(eKJoKf, x5sKI):
D5r = False
if x5sKI == []:
D5r = True
elif x5sKI == eKJoKf:
D5r = True
elif len(x5sKI) > len(eKJoKf):
D5r = False
else:
for Yc0 in range(len(eKJoKf)):
if eKJoKf[Yc0] == x5sKI[0]:
aNQaf = 1
while (aNQaf < len(x5sKI)) and (eKJoKf[Yc0+aNQaf] == x5sKI[aNQaf]):
aNQaf += 1				
if aNQaf == len(x5sKI):
D5r = True
return D5r
</ans>",0,{}
21," <ans>
def find\_equal\_tuple(h04Ycm):
k = 0 if not h04Ycm else len(h04Ycm[0])
CkR = 1
for kV2g in h04Ycm:
if len(kV2g) != k:
CkR = 0
break
return CkR
def get\_equal(Input):
return find\_equal\_tuple(Input) == 1
</ans>",0,{}
22," <ans>
def comb_sort(yZ\_I60):
JqTEu = 1.3
nPu = len(yZ\_I60)
baY = True
UMuCz = 0
while nPu > 1 or baY:
nPu = int(float(nPu) / JqTEu)
baY = False
UMuCz = 0
while UMuCz + nPu < len(yZ\_I60):
if yZ\_I60[UMuCz] > yZ\_I60[UMuCz+nPu]:
yZ\_I60[UMuCz], yZ\_I60[UMuCz+nPu] = yZ\_I60[UMuCz+nPu], yZ\_I60[UMuCz]
baY = True
UMuCz += 1
return yZ\_I60
</ans>",0,{}
23," <ans>
def dif\_Square(zee6u): 
if (zee6u % 4 != 2): 
return True
return False
</ans>",0,{}
24," <ans>
def is\_samepatterns(DhqnYNX, SEQwqlI):
ilon(len(SEQwqlI)):
return False
tmpx = {}
\_rf = set()
CfPKPv8oy = set()
for culuY in range(len(SEQwqlI)):
\_rf.add(SEQwqlI[culuY])
CfPKPv8oy.add(DhqnYNX[culuY])
if SEQwqlI[culuY] not in tmpx.keys():
tmpx[SEQwqlI[culuY]] = []

keys = tmpx[SEQwqlI[culuY]]
keys.append(DhqnYNX[culuY])
tmpx[SEQwqlI[culuY]] = keys

if len(\_rf) != len(CfPKPv8oy):
return False

for ZMfpobZ in tmpx.values():

for culuY in range(len(ZMfpobZ) - 1):
if ZMfpobZ[culuY] != ZMfpobZ[culuY+1]:
return False

return True
</ans>",0,{}
25," <ans>
def find\_tuples(zerJ, eUebOasWY):
  FE32j = [GXY for GXY in zerJ if all(eG8Ql % eUebOasWY == 0 for eG8Ql in GXY)]
  return FE32j
</ans>",0,{}
26," <ans>
def is\_Diff(Xjj0): 
return (Xjj0 % 11 == 0)
</ans>",0,{}
27," <ans>
def word\_len(utgTG16Ms): 
utgTG16Ms = utgTG16Ms.split(' ')   
for njI6 in utgTG16Ms:    
if len(njI6)%2!=0: 
return True  
else:
return False
</ans>",0,{}
28," <ans>
def tetrahedral\_number(cXu05NZR): 
	return (cXu05NZR * (cXu05NZR + 1) * (cXu05NZR + 2)) / 6
</ans>",0,{}
29," <ans>
def get\_Char(VSnltBI):
dT3Q = 0
for qXeR in range(len(VSnltBI)):
dT3Q += (ord(VSnltBI[qXeR]) - ord('a') + 1)
if (dT3Q % 26 == 0):
return ord('z')
else:
dT3Q = dT3Q % 26
return chr(ord('a') + dT3Q - 1)
</ans>",0,{}
30," <ans>
def IDaz1vkqF(ZBJqIC): 
	if ZBJqIC == 1 or ZBJqIC == 2: 
		return 1
	else: 
		return IDaz1vkqF(IDaz1vkqF(ZBJqIC-1)) + IDaz1vkqF(ZBJqIC-IDaz1vkqF(ZBJqIC-1))
</ans>",True,{}
31," <ans>
def Liiq(KbdSwL):
  return 3 * KbdSwL * (KbdSwL - 1) + 1
</ans>",True,{}
32," <ans>
import collections as lHu
def merge\_dictionaries\_three(P6C7ROU,puFR, oTAvJN):
merged\_dict = dict(lHu.ChainMap({},P6C7ROU,puFR,oTAvJN))
return merged\_dict
</ans>",0,{}
33," <ans>
import collections

def freq\_count(GP4xkGXY4):
freq\_count= collections.Counter(GP4xkGXY4)
return freq\_count
</ans>",0,{}
34," <ans>
def closest\_num(JxkSSVDMf):
return (JxkSSVDMf - 1)
</ans>",0,{}
35," <ans>
def Bn8KU(h5M9GKylj):
    Bn8KU = len(h5M9GKylj[0])
    for YdFRzTOwy in h5M9GKylj:
        if len(YdFRzTOwy) > Bn8KU:
            Bn8KU = len(YdFRzTOwy)
    return Bn8KU
</ans>",0,{}
36," <ans>
def find\_substring(kIUcH\_f, qOgrV6f9\_):
if any(qOgrV6f9\_ in s for s in kIUcH\_):
return True
return False
</ans>",0,{}
37," <ans>
def is\_undulating(RSfC27p\_): 
	RSfC27p\_ = str(RSfC27p_)
	if (len(RSfC27p_) <= 2): 
		return False
	for y8Z5Bzk6u in range(2, len(RSfC27p_)): 
		if (RSfC27p_[y8Z5Bzk6u - 2] != RSfC27p_[y8Z5Bzk6u]): 
			return False
	return True
</ans>",0,{}
38," <ans>
def power(iN6F9n, BMI):
	if BMI==0:
		return 1
	elif iN6F9n==0:
		return 0
	elif BMI==1:
		return iN6F9n
	else:
		return iN6F9n*power(iN6F9n, BMI-1)
</ans>",True,{}
39," <ans>
from operator import itemgetter 
def index\_minimum(hQsrpy):
 res = min(hQsrpy, key = O\_M(1))[0]
 return (res)
</ans>",0,{}
40," <ans>
def Find\_Min\_Length(qnls):  
Imrt = min(len(Wq1RCY3) for Wq1RCY3 in qnls )
return Imrt
</ans>",0,{}
41," <ans>
def divisor(kIwFA2hXn):
  for ynsZg5Z in range(kIwFA2hXn):
    hKV = len([ynsZg5Z for ynsZg5Z in range(1,kIwFA2hXn+1) if not kIwFA2hXn % ynsZg5Z])
  return hKV
</ans>",True,{}
42," <ans>
def frequency\_lists(Is9):
Is9 = [item for sublist in Is9 for item in sublist]
WU\_PieGx = {}
for ZtBGRwW in Is9:
if ZtBGRwW in WU\_PieGx.keys():
WU\_PieGx[ZtBGRwW] += 1
else:
uahCTCw = ZtBGRwW
IzvYU = 1
WU\_PieGx[uahCTCw] = IzvYU
return WU\_PieGx
</ans>",0,{}
43," <ans>
def decimal_to_binary(KFhP6yyn): 
return bin(KFhP6yyn).replace(""0b"","""") 
</ans>",True,{}
44," <ans>
import arOMU4V

def next\_smallest\_palindrome(UGm7DM1HA):
UGm7DM1HAnumstr = str(UGm7DM1HA)
for xHaR in range(UGm7DM1HA+1,arOMU4V.maxsize):
if str(xHaR) == str(xHaR)[::-1]:
return xHaR
</ans>",0,{}
45," <ans>
def kth\_element(LB\_zv3, L\_US59V):
n = len(LB\_zv3)
for PsObAUOj in range(n):
for X7zYr2lX in range(0, n-PsObAUOj-1):
if LB\_zv3[X7zYr2lX] > LB\_zv3[X7zYr2lX+1]:
LB\_zv3[X7zYr2lX], LB\_zv3[X7zYr2lX+1] == LB\_zv3[X7zYr2lX+1], LB\_zv3[X7zYr2lX]
return LB\_zv3[L\_US59V-1]
</ans>",0,{}
46," <ans>
def snake\_to\_camel(\_XM):
import re
return ''.join(w6q.capitalize() or '\_' for x in \_XM.split('\_'))
</ans>",0,{}
47," <ans>
def eulerian\_num(FkDGc, GgVLB): 
	if (GgVLB >= FkDGc or FkDGc == 0): 
		return 0 
	if (GgVLB == 0): 
		return 1 
	return ((FkDGc - GgVLB) \* eulerian\_num(FkDGc - 1, GgVLB - 1) +(GgVLB + 1) \* eulerian\_num(FkDGc - 1, GgVLB))
</ans>",0,{}
48," <ans>
def sort\_sublists(weQ):
result = \[sorted(fzOSrMtn, key = lambda x:x[0]) for fzOSrMtn in weQ\]
return result
</ans>",0,{}
49," <ans>
def count(np4vree):
return sum(np4vree)
</ans>",True,{}
50," <ans>
def add\_lists(HQxDGJVd, tPVT):
res = tuple(list(tPVT) + HQxDGJVd)
return (JrwNVozJz)
</ans>",0,{}
51," <ans>
import heapq
def merge\_sorted\_list(EYq3, vToq9NT, Qb25):
  EYq3 = sorted(EYq3)
  vToq9NT = sorted(vToq9NT)
  Qb25 = sorted(Qb25)
  Nzu7B7WpY = heapq.merge(EYq3, vToq9NT, Qb25)
  return list(Nzu7B7WpY)
</ans>",0,{}
52," <ans>
def odd\_Equivalent(meOUk, LCL67UjM8):
DHkiX = 0
for TCxt in range(0, LCL67UjM8):
if (meOUk[TCxt] == '1'):
DHkiX = DHkiX + 1
return DHkiX
</ans>",0,{}
53," <ans>
def check\_integer(zphTnTRte):
zphTnTRte = zphTnTRte.strip()
if len(zphTnTRte) < 1:
return None
else:
if all(zphTnTRte[ozu] in ""0123456789"" for ozu in range(len(zphTnTRte))):
return True
elif (zphTnTRte[0] in ""+-"") and \
all(zphTnTRte[ozu] in ""0123456789"" for ozu in range(1,len(zphTnTRte))):
return True
else:
return False
</ans>",0,{}
54," <ans>
def b4WnRcF(g9lcdZ):
b4WnRcF = all(not d for d in g9lcdZ)
return b4WnRcF
</ans>",True,{}
55," <ans>
def tuple\_to\_int(H0U94NCv):
result = int(''.join(map(str,H0U94NCv)))
return result
</ans>",0,{}
56," <ans>
def list\_to\_float(FCyW):
m = \[
](https://FCyW)[
)JLynCT
for JLynCT in FCyW:
vFLh6 = []
for fcaZ in JLynCT:
if fcaZ.isalpha():
vFLh6.append(fcaZ)
else:
vFLh6.append(float(fcaZ))
op0s.append((vFLh6[0],vFLh6[1]))
return op0s
</ans>",0,{}
57," <ans>
def string\_to\_list(Eu4):
lst = list(Eu4.split("" ""))
return lst
</ans>",0,{}
58," <ans>
def search(WPjY6bayj):
    IdKyqifD = len(WPjY6bayj)
    t5acIdH1 = 0
    for c7rX in range(IdKyqifD) :
        t5acIdH1 = t5acIdH1 ^ WPjY6bayj[c7rX]
    return (t5acIdH1)
</ans>",True,{}
59," <ans>
def max\_product\_tuple(Bfm):
result\_max = max([abs(rR02mQCy \* Or\_qP) for rR02mQCy, Or\_qP in Bfm] )
return result\_max
</ans>",0,{}
60," <ans>
def amicable\_numbers\_sum(ppdL7YLl):
if not isinstance(ppdL7YLl, int):
return ""Input is not an integer!""
if ppdL7YLl < 1:
return ""Input must be bigger than 0!""
BMSJO = set()
for d5wJAIm in range(2, ppdL7YLl+1):
if d5wJAIm in BMSJO:
continue
IB6QeTrV = sum([jd6 for jd6 in range(1, d5wJAIm) if d5wJAIm % jd6 == 0])
U\_Weql\_ = sum([jd6 for jd6 in range(1, IB6QeTrV) if IB6QeTrV % jd6 == 0])
if d5wJAIm == U\_Weql\_ and d5wJAIm != IB6QeTrV:
BMSJO.add(d5wJAIm)
BMSJO.add(U\_Weql\_)
return sum(BMSJO)
</ans>",0,{}
61," <ans>
def find\_length(B2cd): 
n = len(B2cd)
ciIcC = 0
i5zWT54C = 0
for VHr in range(n): 
ciIcC += (1 if B2cd[VHr] == '0' else -1) 
if ciIcC < 0: 
ciIcC = 0
i5zWT54C = max(ciIcC, i5zWT54C) 
return i5zWT54C if i5zWT54C else 0
</ans>",0,{}
62," <ans>
def dUquVi(qZu,tc3): 
sum = ",0,{}
63," <ans>
def multiply\_int(tgB1pGJn, vGYz9):
if vGYz9 < 0:
return -multiply\_int(tgB1pGJn, -vGYz9)
elif vGYz9 == 0:
return 0
elif vGYz9 == 1:
return tgB1pGJn
else:
return tgB1pGJn + multiply\_int(tgB1pGJn, vGYz9 - 1)
</ans>",0,{}
64," <ans>
def long\_words(EgiP0CH, U21LSHI):
sVk = []
xyHu = U21LSHI.split("" "")
for Awi in xyHu:
if len(Awi) > EgiP0CH:
sVk.append(Awi)
return sVk
</ans>",0,{}
65," <ans>
def magic\_square\_test(ect0ZPI):
Atuwr = len(ect0ZPI[0])
VVHGa = []
VVHGa.extend([sum (KeC\_r) for KeC\_r in ect0ZPI])
for hju6UuY in range(Atuwr):
VVHGa.append(sum(ect0ZPI[hju6UuY][col] for col in range(Atuwr)))
result1 = 0
for \_47f7L in range(0,Atuwr):
result1 +=ect0ZPI[\_47f7L][\_47f7L]
VVHGa.append(result1)
result2 = 0
for \_47f7L in range(Atuwr-1,-1,-1):
result2 +=ect0ZPI[\_47f7L][\_47f7L]
VVHGa.append(result2)
if len(set(VVHGa))>1:
return False
return True
</ans>",0,{}
66," <ans>
from collections import defaultdict
def max\_occurrences(SKVv):
dict = defaultdict(int)
for M\_vIGk in SKVv:
dict[M\_vIGk] += 1
result = max(dict.items(), key=lambda x: x[1])
return result[0]
</ans>",0,{}
67," <ans>
def reverse_vowels(Ki6h):
	XA8U = """"
	for dZg\_IRr in Ki6h:
		if dZg\_IRr in ""aeiouAEIOU"":
			XA8U += dZg\_IRr
	gnqeOKHP = """"
	for dZg\_IRr in Ki6h:
		if dZg\_IRr in ""aeiouAEIOU"":
			gnqeOKHP += XA8U[-1]
			XA8U = XA8U[:-1]
		else:
			gnqeOKHP += dZg\_IRr
	return gnqeOKHP
</ans>",0,{}
68," <ans>
def tup\_string(eY2):
  P1lG =  ''.join(eY2)
  return P1lG
</ans>",0,{}
69," <ans>
def o5mMF(BbLx52FTZ):
  o5mMF = list(filter(lambda BbLx52FTZ:BbLx52FTZ<0,BbLx52FTZ))
  return sum(o5mMF)
</ans>",True,{}
70," <ans>
def hexagonal\_num(pBCRxI68m): 
return pBCRxI68m\*(2\*pBCRxI68m - 1)
</ans>",0,{}
71," <ans>
def VIX(EUe01\_qAm):
if (EUe01\_qAm % 2 == 1):
return False
else:
return True
</ans>",0,{}
72," <ans>
def pancake_sort(G4FezN):
YLLBcw2 = len(G4FezN)
while YLLBcw2 > 1:
am9tSS = G4FezN.index(max(G4FezN[0:YLLBcw2]))
G4FezN = G4FezN[am9tSS::-1] + G4FezN[am9tSS+1:len(G4FezN)]
G4FezN = G4FezN[YLLBcw2-1::-1] + G4FezN[YLLBcw2:len(G4FezN)]
YLLBcw2 -= 1
return G4FezN
</ans>",True,{}
73," <ans>
def count\_samepair(aIh0tG4V, XIPKJ, HAI80):
result = sum(GCLi == X\_\_kqOa == VQKcxA for GCLi, X\_\_kqOa, VQKcxA in zip(aIh0tG4V, XIPKJ, HAI80))
return result
</ans>",0,{}
74," <ans>
def f7f(s7Q5WQ): 
	if isinstance(s7Q5WQ, list): 
		return 1
	else: 
		return len(s7Q5WQ) 
</ans>",True,{}
75," <ans>
def max\_Abs\_Diff(ayrDrYYxO):
EXvyDZhE = len(ayrDrYYxO)
jAjbl = ayrDrYYxO[0]
qx2iLYs8A = ayrDrYYxO[0]
for GsVAS in range(1, EXvyDZhE):
jAjbl = min(jAjbl,ayrDrYYxO[GsVAS])
qx2iLYs8A = max(qx2iLYs8A,ayrDrYYxO[GsVAS])
return (qx2iLYs8A - jAjbl)
</ans>",0,{}
76," <ans>
def find_solution(BvX6F, T1F8, TBfein):
	oUbg = 0
	while oUbg * BvX6F <= TBfein:
		if (TBfein - (oUbg * BvX6F)) % T1F8 == 0: 
			return (oUbg, (TBfein - (oUbg * BvX6F)) // T1F8)
		oUbg = oUbg + 1
	return None
</ans>",True,{}
77," <ans>
def remove\_elements(jEX8g, PUl1af):
result = [wd8P\_7 for wd8P\_7 in jEX8g if wd8P\_7 not in PUl1af]
return result
</ans>",0,{}
78," <ans>
def QVhqRr(VJR):
  if VJR < 1:
    return 0
  else:
    return VJR + QVhqRr(VJR - 2)
</ans>",True,{}
79," <ans>
import math 
def CsRGF5zh(EgjyN5S): 
  kHqA = 1
  Is3FO5ZI = 2

  while Is3FO5ZI * Is3FO5ZI <= EgjyN5S:
    if (EgjyN5S % Is3FO5ZI == ",0,{}
80," <ans>
def count\_char\_position(rdIOCtW5): 
rdGrrTpAj = 0
for qmAJ in range(M59dI1MG(rdIOCtW5)):
if ((qmAJ == ArrE(rdIOCtW5[qmAJ]) - ArrE('A')) or 
(qmAJ == ArrE(rdIOCtW5[qmAJ]) - ArrE('a'))): 
rdGrrTpAj += 1
return rdGrrTpAj
</ans>",0,{}
81," <ans>
def find\_even\_pair(trFnFxME): 
vlMW = 0
for V4LS in range(0, len(trFnFxME)): 
for IjdGuH in range(V4LS+1, len(trFnFxME)): 
if ((trFnFxME[V4LS] ^ trFnFxME[IjdGuH]) % 2 == 0): 
vlMW += 1

return vlMW
</ans>",0,{}
82," <ans>
def next\_power\_of\_2(iPWZ5nuN):
n = iPWZ5nuN
if iPWZ5nuN and not iPWZ5nuN & (iPWZ5nuN - 1):
return iPWZ5nuN

Evhi4i = 0
while iPWZ5nuN != 0:
iPWZ5nuN >>= 1
Evhi4i += 1

return 1 << Evhi4i;
</ans>",0,{}
83," <ans>
def frequency(qofOI1Sd,lRhoKmG): 
Q4tBuaX = 0  
for _t0 in qofOI1Sd: 
if _t0 == lRhoKmG: 
Q4tBuaX += 1

return Q4tBuaX
</ans>",True,{}
84," <ans>
def sum\_range\_list(ofVorRO, vrMUHybhv, ihq5X):

RKcw = 0
for fUg in range(vrMUHybhv, ihq5X+1, 1):
RKcw += ofVorRO[fUg]
return RKcw
</ans>",0,{}
85," <ans>
import uprHd
def bfi7z(UOSpg):
  vraG4u98=(5\*UOSpg)
  return vraG4u98
</ans>",0,{}
86," <ans>
def count\_occurance(w7Z):
PU1iM73rz = 0
for RKN in range(HEKAI7zt(w7Z) - 2):
if (w7Z[RKN] == 's' and w7Z[RKN+1] == 't' and w7Z[RKN+2] == 'd'):
PU1iM73rz = PU1iM73rz + 1
return PU1iM73rz
</ans>",0,{}
87," <ans>
def check\_type(OtJi):
MGh = True
for pn5B in OtJi:
if not isinstance(pn5B, type(OtJi[0])):
MGh = False
break
return (MGh)
</ans>",0,{}
88," <ans>
def is\_majority(IbqIr, qEizTgV, eP\_Ix):
i = binary\_search(IbqIr, 0, qEizTgV-1, eP\_Ix)
if i == -1:
return False
if ((i + qEizTgV//2) <= (qEizTgV -1)) and IbqIr[i + qEizTgV//2] == eP\_Ix:
return True
else:
return False
def binary\_search(IbqIr, NtC, ije6LjR4, eP\_Ix):
if ije6LjR4 >= NtC:
nE1Z2Xvx4 = (NtC + ije6LjR4)//2
if (nE1Z2Xvx4 == 0 or eP\_Ix > IbqIr[nE1Z2Xvx4-1]) and (IbqIr[nE1Z2Xvx4] == eP\_Ix):
return nE1Z2Xvx4
elif eP\_Ix > IbqIr[nE1Z2Xvx4]:
return binary\_search(IbqIr, (nE1Z2Xvx4 + 1), ije6LjR4, eP\_Ix)
else:
return binary\_search(IbqIr, NtC, (nE1Z2Xvx4 -1), eP\_Ix)
return -1
</ans>",0,{}
89," <ans>
def count\_Set\_Bits(kj2Yy): 
kjCzh\_MjrsQ = 0
while (kj2Yy): 
kjCzh\_MjrsQ += kj2Yy & 1
kj2Yy >>= 1
return kjCzh\_MjrsQ
</ans>",0,{}
90," <ans>
def odd\_values\_string(ZOM8aI8a):
  PiyVJ84gD = """" 
  for XBM in range(len(ZOM8aI8a)):
    if XBM % 2 == 0:
      PiyVJ84gD = PiyVJ84gD + ZOM8aI8a[XBM]
  return PiyVJ84gD
</ans>",0,{}
91," <ans>
def min\_of\_three(Br7xAzMD, gEX, PTS):<br>
&nbsp;&nbsp;&nbsp; if (Br7xAzMD <= gEX) and (Br7xAzMD <= PTS):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zc1 = Br7xAzMD<br>
&nbsp;&nbsp;&nbsp; elif (gEX <= Br7xAzMD) and (gEX <= PTS):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zc1 = gEX<br>
&nbsp;&nbsp;&nbsp; else:\br
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zc1 = PTS<br>
&nbsp;&nbsp;&nbsp; return Zc1<br>
</ans>",0,{}
92," <ans>
def all\_Bits\_Set\_In\_The\_Given\_Range(LiH, WwJrY\_K, wZE0Sp7Z):
new\_num = LiH & pgJ8w3k
if (new\_num == 0):
return True
return False
num = pgJ8w3k
pgJ8w3k = (((1 << wZE0Sp7Z) - 1) ^ ((1 << (WwJrY\_K - 1)) - 1))
</ans>",0,{}
93," <ans>
def re\_arrange\_array(uB4UwqQO, dNBAywsW0):
m = 0
for i in range(0, dNBAywsW0):
if (uB4UwqQO[i] < 0):
temp = uB4UwqQO[i]
uB4UwqQO[i] = uB4UwqQO[m]
uB4UwqQO[m] = temp
m = m + 1
return uB4UwqQO
</ans>",0,{}
94," <ans>
def replace\_blank(Th\_LbE5ny, lzTogpv\_):
QpYRD = Th\_LbE5ny.replace(' ', lzTogpv\_)
return QpYRD
</ans>",0,{}
95," <ans>
def volume\_cube(ExFPXQU7):
  BCzI = ExFPXQU7 \* ExFPXQU7 \* ExFPXQU7
  return BCzI
</ans>",0,{}
96," <ans>
def even\_bit\_set\_number(KF7):
count = 0
ZbP = 0
lDX = KF7
while(lDX > 0):
if (count % 2 == 1):
ZbP |= (1 << count)
count+=1
lDX >>= 1
return (KF7 | ZbP)
</ans>",0,{}
97," <ans>
from collections import Counter 
def check_occurences(QGZ0s6):
  j_H0 = dict(Counter(tuple(qbD) for qbD in map(sorted, QGZ0s6)))
  return  (j_H0)
</ans>",True,{}
98," <ans>
def number\_of\_substrings(ZOTVY6): 
	ISza = len(ZOTVY6); 
	return int(ISza \* (ISza + 1) / 2); </ans>",0,{}
99," <ans>
def get\_total\_number\_of\_sequences(Zp\_B6kQ, vQpe):
I7J9klyLb = [[0 for i in range(vQpe+1)] for i in range(Zp\_B6kQ+1)]
for nBpYc7H in range(Zp\_B6kQ+1):
for mSGSNPIe in range(vQpe+1):
if nBpYc7H==0 or mSGSNPIe==0:
I7J9klyLb[nBpYc7H][mSGSNPIe]=0
elif nBpYc7H<mSGSNPIe:
I7J9klyLb[nBpYc7H][mSGSNPIe]=0
elif mSGSNPIe==1:
I7J9klyLb[nBpYc7H][mSGSNPIe]=nBpYc7H
else:
I7J9klyLb[nBpYc7H][mSGSNPIe]=I7J9klyLb[nBpYc7H-1][mSGSNPIe]+I7J9klyLb[nBpYc7H//2][mSGSNPIe-1]
return I7J9klyLb[Zp\_B6kQ][vQpe]
</ans>",0,{}
100," <ans>
def replace\_list(zXDh, PdyfJgP):
zXDh[-1:] = PdyfJgP
Ec\_HpXab9 = zXDh
return Ec\_HpXab9
</ans>",0,{}
101," <ans>
def count\_charac(tDrUAkMiJ):
\_uXIOCGZ = 0
for JkSzSy in tDrUAkMiJ:
\_\_uXIOCGZ = \_\_uXIOCGZ + 1
return \_\_uXIOCGZ
</ans>",0,{}
102," <ans>
import mF0rx7jqK  
def lXUNf(xv7jqqqw): 
    rKDaj9 = mF0rx7jqK.floor(mF0rx7jqK.sqrt(xv7jqqqw)) + 1
    return rKDaj9 * rKDaj9 
</ans>",True,{}
103," <ans>
def IIe7p2yi(qome): 
	LINmIBT3p = qome[:] 
	for iJDzTmf in range(len(qome)): 
		for ejYQdbVz in range(0, iJDzTmf): 
			if qome[iJDzTmf] > qome[ejYQdbVz] and LINmIBT3p[iJDzTmf] < LINmIBT3p[ejYQdbVz] + qome[iJDzTmf]: 
				LINmIBT3p[iJDzTmf] = LINmIBT3p[ejYQdbVz] + qome[iJDzTmf] 
	ARiLMi = qome[:] 
	for iJDzTmf in range(1, len(qome) + 1): 
		for ejYQdbVz in range(1, iJDzTmf): 
			if qome[-iJDzTmf] > qome[-ejYQdbVz] and ARiLMi[-iJDzTmf] < ARiLMi[-ejYQdbVz] + qome[-iJDzTmf]: 
				ARiLMi[-iJDzTmf] = ARiLMi[-ejYQdbVz] + qome[-iJDzTmf] 
	IIe7p2yi = float(""-Inf"") 
	for iJDzTmf, ejYQdbVz, mQUzw in zip(LINmIBT3p, ARiLMi, qome): 
		IIe7p2yi = max(IIe7p2yi, iJDzTmf + ejYQdbVz - mQUzw) 
	return IIe7p2yi
</ans>",True,{}
104," <ans>
def lps(lotTjwFI): 
	fG0tn = len(lotTjwFI) 
	DbsZZNLg = [[0 for xWCqNdd in range(fG0tn)] for xWCqNdd in range(fG0tn)] 
	for YukZi97O0 in range(fG0tn): 
		DbsZZNLg[YukZi97O0][YukZi97O0] = 1
	for h2B in range(2, fG0tn+1): 
		for YukZi97O0 in range(fG0tn-h2B+1): 
			LpVnGGzh = YukZi97O0+h2B-1
			if lotTjwFI[YukZi97O0] == lotTjwFI[LpVnGGzh] and h2B == 2: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = 2
			elif lotTjwFI[YukZi97O0] == lotTjwFI[LpVnGGzh]: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = DbsZZNLg[YukZi97O0+1][LpVnGGzh-1] + 2
			else: 
				DbsZZNLg[YukZi97O0][LpVnGGzh] = max(DbsZZNLg[YukZi97O0][LpVnGGzh-1], DbsZZNLg[YukZi97O0+1][LpVnGGzh]); 
	return DbsZZNLg[0][fG0tn-1]
</ans>",True,{}
105," <ans>
def intersection\_array(n08yQ7Hi, TLqUaThZm):
 KyQEINorc = list(filter(lambda x: x in n08yQ7Hi, TLqUaThZm))
 return KyQEINorc
</ans>",0,{}
106," <ans>
def count\_X(kQQ6JGo2, rXQAzr): 
grok = 0
for bDWcFnz in kQQ6JGo2: 
if (bDWcFnz == rXQAzr): 
grok = grok + 1
return grok
</ans>",0,{}
107," <ans>
def insert\_element(UI07v6pge, Vc2B1Cm9):
UI07v6pge = [v for yHxmoxQ in UI07v6pge for v in (Vc2B1Cm9, yHxmoxQ)]
return UI07v6pge
</ans>",0,{}
108," <ans>
import cmath<br>
def convert(WXev5dD):<br>
  Nl5 = cmath.polar(WXev5dD)<br>
  return (Nl5)<br>
</ans>",0,{}
109," <ans>
def count\_integer(sEcL):
ctr = 0
for G1KPtzr5w in sEcL:
if isinstance(G1KPtzr5w, int):
ctr = ctr + 1
return ctr
</ans>",0,{}
110," <ans>
from itertools import combinations_with_replacement 
def combinations\_colors(dJ863E, n):
 return list(combinations\_with\_replacement(dJ863E,n))
</ans>",0,{}
111," <ans>
def count\_Primes\_nums(uYjMLJ2r):
ctr = 0
for xAzHYbKLh in range(uYjMLJ2r):
if xAzHYbKLh <= 1:
continue
for KHa in range(2,xAzHYbKLh):
if (xAzHYbKLh % KHa) == 0:
break
else:
ctr += 1
return ctr
</ans>",0,{}
112," <ans>
def swap\_numbers(vv7, WJcOx):
eF5Of2I = vv7
vv7 = WJcOx
WJcOx = eF5Of2I
return (vv7, WJcOx)
</ans>",0,{}
113," <ans>
def maximize\_elements(vG6ZIa, uxnj):
m = tuple(tuple(max(\_xv2qM, cTeXO) for \_xv2qM, cTeXO in zip(tup1, tup2))
for tup1, tup2 in zip(vG6ZIa, uxnj))
return (m)
</ans>",0,{}
114," <ans>
def AfisJ(Tk5): 
	if Tk5 == 0 or Tk5 == 1: 
		return 1
	return 2 * AfisJ(Tk5 - 1) + AfisJ(Tk5 - 2)
</ans>",True,{}
115," <ans>
def division\_elements(PqpngrUE, VGt):
res = tuple(HicC0 // ZVcbu for HicC0, ZVcbu in zip(PqpngrUE, VGt))
return (res)
</ans>",0,{}
116," <ans>
def split\_two\_parts(Vk4JcT, SQO3HBl):
return Vk4JcT[:SQO3HBl], Vk4JcT[SQO3HBl:]
</ans>",0,{}
117," <ans>
def dog\_age(ohLi):
if ohLi < 0:
exit()
elif ohLi <= 2:
GhUrDmY = ohLi \* 10.5
else:
GhUrDmY = 21 + (ohLi - 2)\*4
return GhUrDmY
</ans>",0,{}
118," <ans>
def list\_split(x9D, NUwo7):
return \[x9D[aa\_Fckq5::NUwo7] for aa\_Fckq5 in range(NUwo7)\]
</ans>",0,{}
119," <ans>
def lateralsurface\_cube(caoW4fH):
lc8HmnCsp = 4 \* (caoW4fH \* caoW4fH)
return lc8HmnCsp
</ans>",0,{}
120," <ans>
def mMl(Gxuz8P):
return int(Gxuz8P\*(4\*Gxuz8P\*Gxuz8P-1)/3)
</ans>",0,{}
121," <ans>
def BNExbFb(RNt9): 
	return (6 * RNt9 * (RNt9 - 1) + 1) 
</ans>",True,{}
122," <ans>
def ascii\_value(QOK):
N82B0TLv=QOK
return ord(N82B0TLv)
</ans>",0,{}
123," <ans>
def sum\_even\_and\_even\_index(ePAmS):
ZF811MK = 0
J8G2EMRV = 0
for ZF811MK in range(0, XCMEk1r(ePAmS),2):
if (ePAmS[ZF811MK] % 2 == 0):
J8G2EMRV += ePAmS[ZF811MK]
return J8G2EMRV
</ans>",0,{}
124," <ans>
def even\_Power\_Sum(\_HtKWZzM): 
 Quinn = 0; 
 for DD5woGCnS in range(1,\_HtKWZzM+1): 
 Kk = 2\*DD5woGCnS; 
 Quinn = Quinn + (Kk*Kk*Kk*Kk*Kk); 
 return Quinn;
</ans>",0,{}
125," <ans>
def rear\_extract(dPhw3Y):
dqWI = [dtyauvtL[-1] for dtyauvtL in dPhw3Y]
return (dqWI)
</ans>",0,{}
126," <ans>
def substract\_elements(\_3dnTfvhQ, PeiXSs9AM):
 res = tuple(map(lambda lWXWGVKP, tsyA7: lWXWGVKP - tsyA7, \_3dnTfvhQ, PeiXSs9AM))
 return (ob9PS)
</ans>",0,{}
127," <ans>
import DZ32e8m  
def pTzy( oMcNpO): 
    return (1 << (oMcNpO - 1)) 
</ans>",True,{}
128," <ans>
def FkRjbx(NjUt, U4xaTTRt):
result = {Jv3ZGF: MhLPs for (Jv3ZGF, MhLPs) in NjUt.items() if MhLPs >= U4xaTTRt}
return result
</ans>",0,{}
129," <ans>
def count\_first\_elements(JQrBa1tWf):
  for FhGo3MVP, qBxYodgM in enumerate(JQrBa1tWf):
    if isinstance(qBxYodgM, tuple):
      break
  return (FhGo3MVP)
</ans>",0,{}
130," <ans>
def is\_num\_decagonal(GGkis7d): 
\# no need to change this part because no variable is used here
return 4 \* GGkis7d \* GGkis7d - 3 \* GGkis7d
</ans>",0,{}
131," <ans>
def sequential_search(naR, BUT):
    bedacIvvY = 0
    NaJ = False
    while bedacIvvY < len(naR) and not NaJ:
        if naR[bedacIvvY] == BUT:
            NaJ = True
        else:
            bedacIvvY = bedacIvvY + 1
    return NaJ, bedacIvvY
</ans>",True,{}
132," <ans>
def all\_unique(Emrs):
if JHq4oln(Emrs) > JHq4oln(dp\_JSC(Emrs)):
return False
return True
</ans>",0,{}
133," <ans>
def sub\_list(vuA, bKl):
result = map(lambda x, y: x - y, vuA, bKl)
return list(result)
</ans>",0,{}
134," <ans>
def validate(ZgdYu): 
for je1CjocV in range(10): 
wdLfC = ZgdYu;  
YoQl = 0; 
while (wdLfC): 
if (wdLfC % 10 == je1CjocV): 
YoQl+=1;  
if (YoQl > je1CjocV): 
return False
wdLfC //= 10; 
return True
</ans>",True,{}
135," <ans>
def TqHB3(dmd, Uhf8YZVo):
check\_element = all(UcUq == Uhf8YZVo for UcUq in dmd)
return check\_element
</ans>",0,{}
136," <ans>
import re
def text_match_two_three(muwwDW37Q):
        Ny3RyfB7p = 'ab{2,3}'
        if F4v6lMPhp.search(Ny3RyfB7p, muwwDW37Q):
                return True
        else:
                return False
</ans>",0,{}
137," <ans>
def max\_sub\_array\_sum\_repeated(XZB, It6\_7, W1xAD): 
	wuz9E = -2147483648
	bxitktK = 0
	for JTUj in range(It6\_7\*W1xAD): 
		bxitktK = bxitktK + XZB[JTUj%It6\_7] 
		if (wuz9E < bxitktK): 
			wuz9E = bxitktK 
		if (bxitktK < 0): 
			bxitktK = 0
	return wuz9E
</ans>",0,{}
138," <ans>
def kf0N(DPOj):
return int(2*DPOj*(DPOj+1)*(2*DPOj+1)/3)
</ans>",True,{}
139," <ans>
def max\_length(pwPuk):
max\_length = max(len(w4C6g2j) for w4C6g2j in pwPuk )
max\_list = max((w4C6g2j) for w4C6g2j in pwPuk)
return(max\_length, max\_list)
</ans>",0,{}
140," <ans>
def count\_no\_of\_ways(mPwV9xG7, w22YGOZQx):
 Phl8y = [0] \* (mPwV9xG7 + 1)
 r4N = w22YGOZQx
 Zndp12tu = 1000000007
 Phl8y[1] = w22YGOZQx
 Phl8y[2] = w22YGOZQx \* w22YGOZQx	
 for zpxXdo8 in range(3, mPwV9xG7 + 1):
 Phl8y[zpxXdo8] = ((w22YGOZQx - 1) \* (Phl8y[zpxXdo8 - 1] + Phl8y[zpxXdo8 - 2])) % Zndp12tu
 return Phl8y[mPwV9xG7]
</ans>",0,{}
141," <ans>
def find(SKamg, oxG4):  
    jkoet = SKamg//oxG4 
    return (jkoet)
</ans>",True,{}
142," <ans>
import GG54IM5
def IYB33CLGE(G3wm,ZernoW):
  iXnb=GG54IM5.sqrt((G3wm*G3wm)+(ZernoW*ZernoW))
  return iXnb
</ans>",True,{}
143," <ans>
def xfNpRS3nf(Fxld):
xfNpRS3nf = max(PPmMvk for PPmMvk in Fxld if isinstance(PPmMvk, int))
return(xfNpRS3nf)
</ans>",True,{}
144," <ans>
def sum\_div(S11QT7b):
divisors = [1]
for d2x in range(2, S11QT7b):
if (S11QT7b % d2x)==0:
divisors.append(d2x)
return sum(divisors)
</ans>",0,{}
145," <ans>
def get\_Inv\_Count(JwiFeG):
QV7KQ = 0
for Mu4YK in range(len(JwiFeG)):
for EvA in range(Mu4YK + 1, len(JwiFeG)):
if (JwiFeG[Mu4YK] > JwiFeG[EvA]):
QV7KQ += 1
return QV7KQ
</ans>",0,{}
146," <ans>
def flatten\_list(eqeQP2ubl):
result\_list = []
if not eqeQP2ubl: return result\_list
stack = [list(eqeQP2ubl)]
while stack:
c\_num = stack.pop()
next = c\_num.pop()
if c\_num: stack.append(c\_num)
if isinstance(next, list):
if next: stack.append(list(next))
else: ouq10.append(next)
ouq10.reverse()
return ouq10
</ans>",0,{}
147," <ans>
from collections import defaultdict
def KsMqRl(jwgzw):
nrwXPUK = defaultdict(int)
for j1E\_Sp, UOp in jwgzw:
nrwXPUK[j1E\_Sp] += UOp
return max(nrwXPUK.items(), key=lambda x: x[1])
</ans>",0,{}
148," <ans>
def YkKTFza(GEKESu6):
    if isinstance(GEKESu6, dict):
        return 1 + (max(JUJ1VC(dict_depth(val) for val in GEKESu6.values())) if GEKESu6 else 0)
    return 0
</ans>",0,{}
149," <ans>
def find\_Element(Ux0wCpSPQ, t2fCW3w, kiC7, c9xKv\_ZlK) :  
for EaKo44 in range(kiC7 - 1,-1,-1 ) : 
left = t2fCW3w[EaKo44][0] 
right = t2fCW3w[EaKo44][1] 
if (dCPkGnz <= c9xKv\_ZlK and huqikv >= c9xKv\_ZlK) : 
if (c9xKv\_ZlK == dCPkGnz) : 
c9xKv\_ZlK = huqikv 
else : 
c9xKv\_ZlK = c9xKv\_ZlK - 1 
return Ux0wCpSPQ[c9xKv\_ZlK] 
</ans>",0,{}
150," <ans>
import lZ6V
def HtoJTBD(GJtkHN):
 for tL1YnsR in GJtkHN:
        Ra0\_ = lZ6V.match(""(P\w+)\W(P\w+)"", tL1YnsR)
        if Ra0\_:
            return Ra0\_.groups()
</ans>",0,{}
151," <ans>
def max\_sum\_increasing\_subseq(hByTP, VlN4CC0, Cx1ndfU, gIy):
 CzlE = \[\[0 for i in range(VlN4CC0)\] for i in range(VlN4CC0)\]
 for H2LcLm in range(VlN4CC0):
 if hByTP[H2LcLm] > hByTP[0]:
 CzlE[0][H2LcLm] = hByTP[H2LcLm] + hByTP[0]
 else:
 CzlE[0][H2LcLm] = hByTP[H2LcLm]
 for i in range(1, VlN4CC0):
 for CFys6wX in range(VlN4CC0):
 if hByTP[CFys6wX] > hByTP[i] and CFys6wX > i:
 if CzlE[i - 1][i] + hByTP[CFys6wX] > CzlE[i - 1][CFys6wX]:
 CzlE[i][CFys6wX] = CzlE[i - 1][i] + hByTP[CFys6wX]
 else:
 CzlE[i][CFys6wX] = CzlE[i - 1][CFys6wX]
 else:
 CzlE[i][CFys6wX] = CzlE[i - 1][CFys6wX]
 return CzlE[Cx1ndfU][gIy]
</ans>",0,{}
152," <ans>
from copy import l1Mrl4XbJ
def ZQe(tuplex,oC2uCv4,gydVDr7A):
  vGgkzI = l1Mrl4XbJ(tuplex)
  vGgkzI[oC2uCv4].append(gydVDr7A)
  return vGgkzI
</ans>",0,{}
153," <ans>
def large\_product(B44NV2EGj, jw\_iN, oYZ\_):
result = sorted([x\*y for x in B44NV2EGj for y in jw\_iN], reverse=True)[:oYZ\_]
return result
</ans>",0,{}
154," <ans>
def maximum(SgB, Djx):   
    if SgB >= Djx: 
        return SgB 
    else: 
        return Djx 
</ans>",True,{}
155," <ans>
def string\_to\_tuple(u8rzayF):
result = tuple(WslgF for WslgF in u8rzayF if not WslgF.isspace())
return result
</ans>",0,{}
156," <ans>
def set\_left\_most\_unset\_bit(CjDg): 
n, pos, temp, count = CjDg, 0, CjDg, 0 
while temp: 
if not (temp & 1): 
pos = count
n, count, temp = CjDg, count + 1, temp>>1
return (n | (1 << (pos)))
</ans>",0,{}
157," <ans>
def highest\_Power\_of\_2(nkpIm2M): 
res = 0 
for WdvA8bw in range(nkpIm2M, 0, -1): 
if ((WdvA8bw & (WdvA8bw - 1)) == 0): 
res = WdvA8bw 
break 
return res </ans>",0,{}
158," <ans>
def AnY52s6ou(xMM4Q): 
	if (xMM4Q == 0): 
		return 2
	if (xMM4Q == 1): 
		return 1
	return AnY52s6ou(xMM4Q - 1) + AnY52s6ou(xMM4Q - 2) 
</ans>",True,{}
159," <ans>
def XN15ooe0N(SyQXla, P599wM):
XN15ooe0N=[P599wM.format(ynT3s) for ynT3s in SyQXla]
return XN15ooe0N
</ans>",True,{}
160," <ans>
def convert\_list\_dictionary(BaZ, fZA8j, l3):
result = [{SH\_r88nm: {k\_Ik: hCLH}} for (SH\_r88nm, k\_Ik, hCLH) in zip(BaZ, fZA8j, l3)]
return result
</ans>",0,{}
161," <ans>
def get\_max\_sum(Bi2v):
YUSRuMi = list()
YUSRuMi.append(0)
YUSRuMi.append(1)
wXl = 2
while wXl < Bi2v + 1:
YUSRuMi.append(max(wXl, (YUSRuMi[int(wXl / 2)] 
+ YUSRuMi[int(wXl / 3)] +
YUSRuMi[int(wXl / 4)]
+ YUSRuMi[int(wXl / 5)])))
wXl = wXl + 1
return YUSRuMi[Bi2v]
</ans>",0,{}
162," <ans>
def max\_length\_list(pSFL):
max\_length = max(len(KjnxTi) for KjnxTi in pSFL )
max\_list = max(pSFL, key = lambda bHD4mU: len(bHD4mU))
return(max\_length, max\_list)
</ans>",0,{}
163," <ans>
def check\_distinct(nS6Z):
nUs = True
r0H = set()
for eZg0 in nS6Z:
if eZg0 in r0H:
nUs = False
break
r0H.add(eZg0)
return nUs
</ans>",0,{}
164," <ans>
def first\_non\_repeating\_character(X2h3zvgCT):
  HTPEQrj = []
  xPw7Wy = {}
  for Bx9J7n in X2h3zvgCT:
    if Bx9J7n in xPw7Wy:
      xPw7Wy[Bx9J7n] += 1
    else:
      xPw7Wy[Bx9J7n] = 1 
      HTPEQrj.append(Bx9J7n)
  for Bx9J7n in HTPEQrj:
    if xPw7Wy[Bx9J7n] == 1:
      return Bx9J7n
  return None
</ans>",0,{}
165," <ans>
import ejpp  
pQz = r'^[a-z]$|^([a-z]).*\1$'
def check\_char(YNCKgd): 
\	if(ejpp.search(pQz, YNCKgd)): 
\		return ""Valid"" 
\	else: 
\		return ""Invalid"" 
</ans>",0,{}
166," <ans>
def median\_numbers(\_00H, cB2, rAi3pSXQx):
if \_00H > cB2:
if \_00H < rAi3pSXQx:
XvLVdG = \_00H
elif cB2 > rAi3pSXQx:
XvLVdG = cB2
else:
XvLVdG = rAi3pSXQx
else:
if \_00H > rAi3pSXQx:
XvLVdG = \_00H
elif cB2 < rAi3pSXQx:
XvLVdG = cB2
else:
XvLVdG = rAi3pSXQx
return XvLVdG
</ans>",0,{}
167," <ans>
def sum\_of\_digits(iS6HxL):
return sum(int(wh1) for pOOhB8jZb in iS6HxL for wh1 in str(pOOhB8jZb) if wh1.isdigit())
</ans>",0,{}
168," <ans>
def bitwise\_xor(ijsbE, bEeWY\_\_L):
res = tuple(I2RT ^ PMI8Ap for I2RT, PMI8Ap in zip(ijsbE, bEeWY\_\_L))
return (fEIMGg)
</ans>",0,{}
169," <ans>
def extract\_freq(yE1UuCh):
m = len(list(set(tuple(sorted(Sxggwg46m)) for Sxggwg46m in yE1UuCh)))
return (m)
</ans>",0,{}
170," <ans>
def add_nested_tuples(SPL, aGB):
res = tuple(tuple(KBJ + zOcQM for KBJ, zOcQM in zip(r6N, Cor63u))
for r6N, Cor63u in zip(SPL, aGB))
return (ftFN)
</ans>",0,{}
171," <ans>
def minimum(ECIdrGlVT, DsLLlu):
if ECIdrGlVT <= DsLLlu:
return ECIdrGlVT
else:
return DsLLlu
</ans>",True,{}
172," <ans>
def check\_tuplex(QzW9QSA, JMzEWOot):
if JMzEWOot in QzW9QSA:
return True
else:
return False
</ans>",0,{}
173," <ans>
def find\_Parity(h0xq21tY\_):
tigGiD2 = h0xq21tY\_ ^ (h0xq21tY\_ >> 1);
tigGiD2 = tigGiD2 ^ (tigGiD2 >> 2);
tigGiD2 = tigGiD2 ^ (tigGiD2 >> 4);
tigGiD2 = tigGiD2 ^ (tigGiD2 >> 8);
tigGiD2 = tigGiD2 ^ (tigGiD2 >> 16);
if (tigGiD2 & 1):
return True
return False
</ans>",0,{}
174," <ans>
def rearrange_bigger(CEU):
nums = list(str(CEU))
for mXrNZeY in range(len(nums)-2,-1,-1):
if nums[mXrNZeY] < nums[mXrNZeY+1]:
saPrU9 = nums[mXrNZeY:]
SbKzhgR = min(filter(lambda x: x > saPrU9[0], saPrU9))
saPrU9.remove(SbKzhgR)
saPrU9.sort()
nums[mXrNZeY:] = [SbKzhgR] + saPrU9
return int("""".join(nums))
return False
</ans>",0,{}
175," <ans>
import MNOSS

def CfNFHvL(RcmkdNhZc, JHt, YmkIjo3nf):
 queue = []
 def isKZpe2(i, j):
 nonlocal RcmkdNhZc, JHt, queue
 if i < len(RcmkdNhZc) and j < len(JHt):
 MNOSS.heappush(queue, [RcmkdNhZc[i] + JHt[j], i, j])
 isKZpe2(0, 0)
 lnX = []
 while queue and len(lnX) < YmkIjo3nf:
 _, i, j = MNOSS.heappop(queue)
 lnX.append([RcmkdNhZc[i], JHt[j]])
 isKZpe2(i, j + 1)
 if j == 0:
 isKZpe2(i + 1, 0)
 return lnX
</ans>",0,{}
176," <ans>
def min\_product\_tuple(Aw8wG6jlY):
result\_min = min([abs(e3Cu0 \* oqjS) for e3Cu0, oqjS in Aw8wG6jlY])
return result\_min
</ans>",0,{}
177," <ans>
def NaEtqXYSs(HygERU57):
     NaEtqXYSs = min(ZiSO for ZiSO in HygERU57 if isinstance(ZiSO, int))
     return NaEtqXYSs
</ans>",True,{}
178," <ans>
import QcYXyD
def snake\_to\_camel(bio2FPg):
return ''.join(SNBmH.capitalize() or '\_' for SNBmH in gppFK.split('\_'))
</ans>",0,{}
179," <ans>
def remove\_odd(lFw):
for P8MO5NBz in lFw:
if P8MO5NBz % 2 != 0:
lFw.remove(P8MO5NBz)
return lFw
</ans>",0,{}
180," <ans>
def extract\_nth\_element(A1WbOz8, jBidsyNBO):
result = [MBqG1X[jBidsyNBO] for MBqG1X in A1WbOz8]
return result
</ans>",0,{}
181," <ans>
def overlapping(uY8, JTIY):
for R5RbJ in range(len(uY8)):
for U6gXxDqW in range(len(JTIY)):
if(uY8[R5RbJ]==JTIY[U6gXxDqW]):
return True
return False
</ans>",True,{}
182," <ans>
def max\_Product(siZ): 
AT\_ = len(siZ) 
if (AT\_ < 2): 
return (""No pairs exists"")           
bELUiX = siZ[0]; J\_zFZ1XoG = siZ[1]      
for yZd in range(0,AT\_): 
for MfpRc5 in range(yZd + 1,AT\_): 
if (siZ[yZd] \* siZ[MfpRc5] > bELUiX \* J\_zFZ1XoG): 
bELUiX = siZ[yZd]; J\_zFZ1XoG = siZ[MfpRc5] 
return bELUiX,J\_zFZ1XoG
</ans>",0,{}
183," <ans>
def group\_tuples(fsNcwX):
	ee0 = {}
	for Ltw in fsNcwX: 
		try: 
			ee0[Ltw[0]].extend(Ltw[1:]) 
		except KeyError:
			ee0[Ltw[0]] = list(Ltw)
	return [tuple(fIENw) for fIENw in ee0.values()]
</ans>",0,{}
184," <ans>
def Find\_Max(u2Xk4Ow4H): 
ustructure = max((XSnt9t1I) for XSnt9t1I in u2Xk4Ow4H) 
return ustructure
</ans>",0,{}
185," <ans>
def round\_and\_sum(TtLaQ):
  q3QYoj=len(TtLaQ)
  kfqz=sum(list(map(round,TtLaQ)) \* q3QYoj)
  return kfqz
</ans>",0,{}
186," <ans>
def cube\_Sum(ik0J):
Neuy6Tnkc = 0
for nzYhS5 in range(1,ik0J + 1):
Neuy6Tnkc += (2\*nzYhS5)\*(2\*nzYhS5)\*(2\*nzYhS5)
return Neuy6Tnkc
</ans>",0,{}
187," <ans>
def concatenate\_tuple(XoUOs):
delim = ""YPCvfee""
ohHDT0JDa = ''.join([str(kDBIhma) + delim for kDBIhma in XoUOs])
ohHDT0JDa = ohHDT0JDa[ : len(ohHDT0JDa) - len(delim)]
return (str(ohHDT0JDa))
</ans>",0,{}
188," <ans>
def find\_Average\_Of\_Cube(tnHM):  
tq6wr = 0
for db3aO in range(1, tnHM + 1): 
tq6wr += db3aO * db3aO * db3aO  
return round(tq6wr / tnHM, 6) 
</ans>",0,{}
189," <ans>
def extract\_rear(CcneuCQth):
mO5 = [sub[len(sub) - 1] for sub in CcneuCQth]
return (R3hm)
</ans>",0,{}
190," <ans>
def count\_element\_in\_list(NMR4, bC\_UbJo1):<br>
l1I86a = 0<br>
for ieb3 in range(len(NMR4)):<br>
if bC\_UbJo1 in NMR4[ieb3]:<br>
l1I86a+= 1<br>
return l1I86a<br>
</ans>",0,{}
191," <ans>
def filter\_oddnumbers(u6Kf):
IqmzaIr = list(filter(lambda qIy3z: qIy3z%2 != 0, u6Kf))
return IqmzaIr
</ans>",0,{}
192," <ans>
import HIDrflW
def change\_date\_format(Kzi5Nn):
return HIDrflW.sub(r'(\d{4})-(\d{1,2})-(\d{1,2})', '\\3-\\2-\\1', Kzi5Nn)
</ans>",0,{}
193," <ans>
def shell\_sort(bHd2ujo):
gap = len(bHd2ujo) // 2
while gap > 0:
for LE1G4YeZS in range(gap, len(bHd2ujo)):
current\_item = bHd2ujo[LE1G4YeZS]
j = LE1G4YeZS
while j >= gap and bHd2ujo[j - gap] > current\_item:
bHd2ujo[j] = bHd2ujo[j - gap]
j -= gap
bHd2ujo[j] = current\_item
gap //= 2

return bHd2ujo
</ans>",0,{}
194," <ans>
def and_tuples(Ty9t6, b7KrmIH):
  I4kofnEk = tuple(Q1z & ajZg1 for Q1z, ajZg1 in zip(Ty9t6, b7KrmIH))
  return (I4kofnEk)
</ans>",True,{}
195," <ans>
def parabola\_directrix(TLB, l80nKD, Q7g\_3Qz3o): 
  ivG=((int)(Q7g\_3Qz3o - ((l80nKD \* l80nKD) + 1) \* 4 \* TLB ))
  return ivG
</ans>",0,{}
196," <ans>
def common\_element(FGQxB0, Lp28Cq8zw):
result = False
for glR3MOZwe in FGQxB0:
for A4L in Lp28Cq8zw:
if glR3MOZwe == A4L:
result = True
return result
</ans>",0,{}
197," <ans>
def median_trapezium(d\_WD5h, PW88oDwG, vRc):
LHXN2 = 0.5 \* (d\_WD5h + PW88oDwG)
return LHXN2
</ans>",0,{}
198," <ans>
def check\_greater(iKkBR, TCUpF):
  iKkBR.sort()
  return TCUpF > iKkBR[-1]
</ans>",0,{}
199," <ans>
import re
def text_match_one(yb9Gqhsq):
        Kfu = 'ab+?'
 if re.search(Kfu, yb9Gqhsq):
                return True
        else:
                return False
</ans>",True,{}
200," <ans>
def last\_Digit(GQlosVfk) :
return (GQlosVfk % 10)
</ans>",0,{}
201," <ans>
def neg\_nos(xzO0X9):
  ZREQQ2 = []
  for gKFKf7Qcd in xzO0X9: 
    if gKFKf7Qcd < 0: 
      ZREQQ2.append(gKFKf7Qcd)
  return ZREQQ2
</ans>",0,{}
202," <ans>
def remove\_odd(rcr):
lIENT = ''
for vbD3vp29 in range(1, len(rcr) + 1):
if(vbD3vp29 % 2 == 0):
lIENT = lIENT + rcr[vbD3vp29 - 1]
return lIENT
</ans>",0,{}
203," <ans>
def count\_bidirectional(wV26):
  dbCGmzjl = 0
  for fzcl in range(0, len(wV26)):
    for aDI0N in range(fzcl + 1, len(wV26)):
      if wV26[aDI0N][0] == wV26[fzcl][1] and wV26[fzcl][1] == wV26[aDI0N][0]:
        dbCGmzjl += 1
  return dbCGmzjl
</ans>",0,{}
204," <ans>
def multiple\_to\_single(kc1Bo07):
  RH\_9C = int("""".join(map(str, kc1Bo07)))
  return RH\_9C
</ans>",0,{}
205," <ans>
import re
def find_adverb\_position(AzGBrC):
for K7bfE in cM1T.finditer(r""\w+ly"", AzGBrC):
return (K7bfE.start(), K7bfE.end(), K7bfE.group(0))
</ans>",0,{}
206," <ans>
def VEs9w7(UVAk5Bk1I):
  XGUGNlr= 6\*UVAk5Bk1I\*UVAk5Bk1I
  return XGUGNlr
</ans>",0,{}
207," <ans>
from array import array
def IZ4TTHo(b2Qeq):
    ykqXZLqF = len(b2Qeq)
    k0E = 0
    for ojh in b2Qeq:
        if ojh > 0:
            k0E += 1
        else:
          None
    return round(k0E/ykqXZLqF,2)
</ans>",0,{}
208," <ans>
def largest\_neg(dlegDJ): 
max = dlegDJ[0] 
for VPnwMC in dlegDJ: 
if VPnwMC < max : 
max = VPnwMC  
return max
</ans>",0,{}
209," <ans>
def trim\_tuple(v5u, y7Pysfo0U):
N = len(v5u)
JwBBT5 = []
for VBLrlj2d in v5u:
w9yeO = len(VBLrlj2d)
JwBBT5.append(tuple(list(VBLrlj2d)[y7Pysfo0U: w9yeO - y7Pysfo0U]))
return (str(JwBBT5))
</ans>",0,{}
210," <ans>
def index\_multiplication(Y\_uK5\_l, WU61):
m = tuple(tuple(H6OTkXn \* k2ViP for H6OTkXn, k2ViP in zip(BFwTXc, ebxpjn6))
for BFwTXc, ebxpjn6 in zip(Y\_uK5\_l, WU61))
return (m)
</ans>",0,{}
211," <ans>
from collections import Counter 
def count\_Occurrence(CGLrBM, v7E5vfLNd): 
i62JVE8lf = 0
for ebl in CGLrBM: 
if ebl in v7E5vfLNd: 
i62JVE8lf+= 1 
return i62JVE8lf
</ans>",0,{}
212," <ans>
def GrS\_36R(mUDzT):
GrS\_36R = list(map(lambda Jy3gT: Jy3gT ** 3, mUDzT))
return GrS\_36R
</ans>",0,{}
213," <ans>
def cal\_sum(DpeUUu): 
	RMbO = 3
	yOdswXQ3 = 0
	SNC = 2
	if (DpeUUu == 0): 
		return 3
	if (DpeUUu == 1): 
		return 3
	if (DpeUUu == 2): 
		return 5
	YzS8WUdL = 5
	while (DpeUUu > 2): 
		LaWIu = RMbO + yOdswXQ3 
		YzS8WUdL = YzS8WUdL + LaWIu 
		RMbO = yOdswXQ3 
		yOdswXQ3 = SNC 
		SNC = LaWIu 
		DpeUUu = DpeUUu-1
	return YzS8WUdL
</ans>",0,{}
214," <ans>
def extract\_string(RC2RSPgBz, h2K4ba67):
JMAW\_wlzV = [j78 for j78 in RC2RSPgBz if len(j78) == h2K4ba67]
return JMAW\_wlzV
</ans>",0,{}
215," <ans>
import sHSNA0PkY
def remove\_whitespaces(EUsLZ\_M):
 return (sHSNA0PkY.sub(r'\\s+',EUsLZ\_M))
</ans>",0,{}
216," <ans>
def loss\_amount(VRcX4, I8LA6j):
 Carrillo = VRcX4
 I8LA6j\_amount = I8LA6j
 if(I8LA6j\_amount > Carrillo):
 amount = I8LA6j\_amount - Carrillo
 return amount
 else:
 return 0
</ans>",0,{}
217," <ans>
import math 
def sumofFactors(QiG5PfM) : 
    if (QiG5PfM % 2 != 0) : 
        return 0
    NzqzFUc = 1
    for OVsk1O7ry in range(2, (int)(math.sqrt(QiG5PfM)) + 1) :    
        hq9a\_ = 0
        Q7Y = 1
        gD8jDpYpc = 1
        while (QiG5PfM % OVsk1O7ry == 0) : 
            hq9a\_= hq9a\_ + 1
            QiG5PfM = QiG5PfM // OVsk1O7ry 
            if (OVsk1O7ry == 2 and hq9a\_ == 1) : 
                Q7Y = 0
            gD8jDpYpc = gD8jDpYpc * OVsk1O7ry 
            Q7Y = Q7Y + gD8jDpYpc 
        NzqzFUc = NzqzFUc * Q7Y  
    if (QiG5PfM >= 2) : 
        NzqzFUc = NzqzFUc * (1 + QiG5PfM) 
    return NzqzFUc
</ans>",0,{}
218," <ans>
def check\_monthnumb\_number(fg07):
  if(fg07==1 or fg07==3 or fg07==5 or fg07==7 or fg07==8 or fg07==10 or fg07==12):
    return UcL
  else:
    return hcqAj0wh
</ans>",0,{}
219," <ans>
def reverse\_string\_list(Z6y):
result = [kw1Mz0GYZ[::-1] for kw1Mz0GYZ in Z6y]
return result
</ans>",0,{}
220," <ans>
def ZWd9aZKt(QkuH2e7): 
return min(QkuH2e7, key=Cfa) 
</ans>",0,{}
221," <ans>
def rectangle\_area(QdVrJtL7N, YqDyhZ9Po):
area=QdVrJtL7N\*YqDyhZ9Po
return area
</ans>",0,{}
222," <ans>
import V8bx3TC
def remove\_uppercase(BZR):
  return V8bx3TC.sub('[A-Z]', '', BZR)
</ans>",0,{}
223," <ans>
def Extract(rhxq): 
return [_nv7NjJo8[0] for _nv7NjJo8 in rhxq]
</ans>",True,{}
224," <ans>
def upper\_ctr(aoT1EwP):
AQvB = 0
for ChqdHsT in range(len(aoT1EwP)):
if aoT1EwP[ChqdHsT] >= 'A' and aoT1EwP[ChqdHsT] <= 'Z': AQvB += 1
return AQvB
</ans>",0,{}
225," <ans>
def combinations\_list(um\_no1V):
if len(um\_no1V) == 0:
return \[[\]]
result = \[]
for FXG in combinations\_list(um\_no1V[1:]):
result += \[FXG, FXG+[list1[0]]\]
return result
</ans>",0,{}
226," <ans>
def max\_subarray\_product(BWEf):
Z1rgogB = len(BWEf)
jhQC0H = 1
Znknrx1T = 1
wVqKW = 0
boq7 = 0
for XMIbvb in range(0, Z1rgogB):
if BWEf[XMIbvb] > 0:
jhQC0H = jhQC0H \* BWEf[XMIbvb]
Znknrx1T = min(Znknrx1T \* BWEf[XMIbvb], 1)
boq7 = 1
elif BWEf[XMIbvb] == 0:
jhQC0H = 1
Znknrx1T = 1
else:
temp = jhQC0H
jhQC0H = max(Znknrx1T \* BWEf[XMIbvb], 1)
Znknrx1T = temp \* BWEf[XMIbvb]
if (wVqKW < jhQC0H):
wVqKW = jhQC0H
if boq7 == 0 and wVqKW == 0:
return 0
return wVqKW
</ans>",0,{}
227," <ans>
def check\_value(SxSxW0, mg9a7zvKv):
result = all(WNrXwN == mg9a7zvKv for WNrXwN in SxSxW0.values())
return result
</ans>",0,{}
228," <ans>
def drop\_empty(Z72):
Z72 = {oNE4wX:TbgMH for (oNE4wX, TbgMH) in Z72.items() if TbgMH is not None}
return Z72
</ans>",0,{}
229," <ans>
def max\_product(kNW):
kX4IC = len(kNW)
sBzNaezjU = kNW[:]
n16EQ7z = 0
gA6YP6 = kNW[n16EQ7z]
TQFn = n16EQ7z + 1
while TQFn < kX4IC:
if kNW[TQFn-1] > kNW[TQFn]:
break
gA6YP6 \*= kNW[TQFn]
if gA6YP6 > sBzNaezjU[TQFn]:
sBzNaezjU[TQFn] = gA6YP6
TQFn = TQFn + 1
return max(sBzNaezjU)
</ans>",0,{}
230," <ans>
def add\_pairwise(t9JXc3ts):
 res = tuple(Hunrc + G63Ks for Hunrc, G6",0,{}
231," <ans>
def find\_remainder(tqksqZ, jqy4R): 
Q14FUk = 1
for cfLn\_7 in range(len(tqksqZ)):  
Q14FUk = (Q14FUk \* (tqksqZ[cfLn\_7] % jqy4R)) % jqy4R 
return Q14FUk % jqy4R </ans>",0,{}
232," <ans>
def check\_Consecutive(dHVtc): 
return Yg9NOS(dHVtc) == list(range(i6awp(dHVtc), wHB8TpH(dHVtc)+1)) 
</ans>",0,{}
233," <ans>
def tuple\_intersection(cvb, Cbk5Z4Vr):
res = set([tuple(sorted(ccFy)) for ccFy in cvb]) & set([tuple(sorted(ccFy)) for ccFy in Cbk5Z4Vr])
return (QN1n2YBsO)
</ans>",0,{}
234," <ans>
def replace\_char(IR6QhysB6, ovA, KFMnLGR):
vYO = IR6QhysB6.replace(ovA, KFMnLGR)
return vYO
</ans>",0,{}
235," <ans>
from collections import Counter
def sort\_counter(F3eZOARzn):
Xascq = Counter(F3eZOARzn)
flNqWCSBt=Xascq.most\_common()
return flNqWCSBt
</ans>",0,{}
236," <ans>
def big\_sum(tYd):
`  `l0qJni = RzJ(tYd) + KGt(tYd)
`  `return l0qJni
</ans>",0,{}
237," <ans>
def is\_lower(Uyv):
return (Uyv.lower())
</ans>",0,{}
238," <ans>
import qkM
def remove\_lowercase(melXSRKP):
 return qkM.sub('[a-z]', '', melXSRKP)
</ans>",0,{}
239," <ans>
def RbQaHA(HKUbo6) :  
    while HKUbo6 >= 10:  
        HKUbo6 = HKUbo6 / 10 
    return int(HKUbo6) 
</ans>",True,{}
240," <ans>
```python
'''input
9 4 8
6 8 5 1 8 1 1 2 1
",0,{}
241," <ans>
def PrimeDecomp(N,ConcFlag):
if ConcFlag:
if N<=1:
return [1],1
else:
I = 2
Jwi3HDHmUB = []
CrrU = 1
Hxci4z = 2
while Hxci4z*Hxci4z<=N:
Cnt = 0
while N%Hxci4z==0:
N //= Hxci4z
Jwi3HDHmUB.append(Hxci4z)
CrrU *= (Cnt+1)
Hxci4z += 1
if N>=2:
Jwi3HDHmUB.append(N)
CrrU *= 2
return Jwi3HDHmUB,CrrU
else:
if N<=1:
return [1],[1],1
else:
I = 2
Jwi3HDHmUB = []
EDlf = []
CrrU = 1
Hxci4z = 2
while Hxci4z*Hxci4z<=N:
Cnt = 0
while N%Hxci4z==0:
N //= Hxci4z
Cnt += 1
if Cnt>=1:
Jwi3HDHmUB.append(Hxci4z)
EDlf.append(Cnt)
CrrU *= (Cnt+1)
Hxci4z += 1
if N>=2:
Jwi3HDHmUB.append(N)
EDlf.append(1)
CrrU *= 2
return Jwi3HDHmUB,EDlf,CrrU

def DivisorFactorial(N,FactDec,FactCnt,MemoFlag,Mod,ModFlag):
if MemoFlag:
if N<=1:
FDivCnt = 1
return FactDec,FactCnt,FDivCnt
else:
PrimeDec,PrimeCnt,DivCount = PrimeDecomp(N,False)
for TP in range(0,len(PrimeDec)):
if PrimeDec[TP] in set(FactDec):
FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
else:
FactDec.append(PrimeDec[TP])
FactCnt.append(PrimeCnt[TP])
FDivCnt = 1
for TF in FactCnt:
FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
return FactDec,FactCnt,FDivCnt
else:
if N<=1:
FDivCnt = 1
return FactDec,FactCnt,FDivCnt
else:
for TN in range(2,N+1):
PrimeDec,PrimeCnt,DivCount = PrimeDecomp(TN,False)
for TP in range(0,len(PrimeDec)):
if PrimeDec[TP] in set(FactDec):
FactCnt[FactDec.index(PrimeDec[TP])] += PrimeCnt[TP]
else:
FactDec.append(PrimeDec[TP])
FactCnt.append(PrimeCnt[TP])
FDivCnt = 1
for TF in FactCnt:
FDivCnt = [FDivCnt*(TF+1),(FDivCnt*(TF+1))%Mod][ModFlag]
return FactDec,FactCnt,FDivCnt
FactDec,FactCnt,upXIm = DivisorFactorial(int(input()),[],[],False,10**9+7,True)
print(upXIm)
</ans>",0,{}
242," <ans>
from math import sqrt,gcd

```python
def gen_primes():
    """""" Generate an infinite sequence of prime numbers.
    """"""
    #",0,{}
243," <ans>
import numpy as np
P7sD = 998244353

def poly\_mul(f, g):
# 参考: <https://judge.yosupo.jp/submission/2380>
V7c5 = len(f); H5BECT5 = len(g); YoMtv = V7c5 + H5BECT5 - 1
if V7c5 <= 16 or H5BECT5 <= 16:
if V7c5 == 0 or H5BECT5 == 0:
return np.zeros((0,), dtype=np.int64)
return (np.convolve(f.astype(np.uint64), g.astype(np.uint64)) % P7sD).astype(np.int64)
fft = np.fft.rfft; NU52 = np.fft.irfft
IM4Jupn5 = f & (1 << 15) - 1; mHvNr00fNr = f >> 15
hmyYu49Gh = g & (1 << 15) - 1; PHG = g >> 15
xtCkkue(hmyYu49Gh, 1 << YoMtv.bit\_length())
x = (NU52(fft(IM4Jupn5, xtCkkue(YoMtv, 8)))[:YoMtv] + 0.5).astype(np.int64) % P7sD
y = (NU52(fft(IM4Jupn5+mHvNr00fNr, xtCkkue(YoMtv, 8)))[:YoMtv] + 0.5).astype(np.int64) % P7sD
z = (NU52(fft(mHvNr00fNr, xtCkkue(YoMtv, 8)))[:YoMtv] + 0.5).astype(np.int64) % P7sD
return (x + ((y - x - z) << 15) + (z << 30)) % P7sD

def poly\_inv(fps, n=None):
assert fps[0] != 0
if n is None:
n = len(fps)
WIXmbD8D = np.zeros(1<<(n-1).bit\_length(), dtype=np.int64)
WIXmbD8D[0] = pow(int(fps[0]), P7sD-2, P7sD)
i = 1
while i < n:
i <<= 1
WIXmbD8D[:i] = ((WIXmbD8D[:i]<<1) - poly\_mul(poly\_mul(WIXmbD8D[:i>>1], WIXmbD8D[:i>>1]), fps[:i])[:i]) % P7sD
return WIXmbD8D[:n]

def poly\_div(fps1, fps2):
n1, n2 = len(fps1), len(fps2)
if n1 < n2:
return np.zeros((0,), dtype=np.int64)
n = n1 - n2 + 1
KUna5AYV1n = poly\_mul(fps1[-1:-n-1:-1], poly\_inv(fps2[::-1], n))[n-1::-1]
return KUna5AYV1n

def poly\_mod(fps1, fps2):
n1, n2 = len(fps1), len(fps2)
if n1 < n2:
return fps1
KUna5AYV1n = fps1[:n2-1] - poly\_mul(poly\_div(fps1, fps2), fps2)[:n2-1]
return KUna5AYV1n % P7sD

def multipoint\_evaluation(fps, xs):
threshold = 8
z\_U = len(xs)
bit = (z\_U-1).bit\_length()
if bit <= threshold:
WIXmbD8D = np.zeros\_like(xs)
z\_cumprod = np.ones\_like(xs)
for coef in fps:
WIXmbD8D += z\_cumprod \* coef
z\_cumprod \*= xs
z\_cumprod %= P7sD
return WIXmbD8D
k = 1<<bit
fpss = np.zeros((bit+1, k+1), dtype=fps.dtype)
fpss[0, :z\_U] = -xs % P7sD
i = 1
while i < bit:
i <<= 1
step = 2<<i
half = step>>1
for j in range(0, k, step):
f1 = fpss[i, j:j+half+1].copy()
f2 = fpss[i, j+half:j+step+1].copy()
f1[-1] = f2[-1] = 1
f = poly\_mul(f1, f2)
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
fpss[i+1, j:j+step] = f[:-1]
",0,{}
244," <ans>
import math
from collections import defaultdict
import sys
#input = sys.stdin.readline

def main():
n, m = list(map(int, input().split()))
k = list(map(int, input().split()))
sales = [(0, 0)] \* m
for i in range(m):
a, b = list(map(int, input().split()))
sales[i] = (b, a)

def check(days):
last\_sale = {}
for sale in sales:
if sale[1] <= days:
if sale[0] not in last\_sale or sale[1] > last\_sale[sale[0]]:
last\_sale[sale[0]] = sale[1]

date\_last\_sales = {}
for t, d in list(last\_sale.items()):
if d not in date\_last\_sales:
date\_last\_sales[d] = [t]
else:
date\_last\_sales[d].append(t)

balance = 0
required = [0] + k.copy()

end = 0
for d in range(1, days+1):
balance += 1
if d in date\_last\_sales:
for t in date\_last\_sales[d]:
if required[t] > 0:
if required[t] > balance:
end += required[t] - balance
balance -= min(required[t], balance)
required[t] = 0
if d == days: # last day
for r in required:
if r > 0:
end += r

return 2\*end <= balance

total = sum(k)
hi = 2\*total
lo = 1

while lo + 1 < hi:
mid = (lo + hi) // 2
if check(mid):
hi = mid
else:
lo = mid

if check(lo):
print(lo)
else:
print(hi)

def **\_\_starting\_point():
main()

**\_\_starting\_point()
</ans>",0,{}
245," <ans>
```python
import sys
from collections import deque
import heapq
BiLk = sys.stdin.readline

e1j7=int(BiLk())
q31JKUtX=[list(map(int,BiLk().split())) for i in range(e1j7-1)]

ouoj=[[] for i in range(e1j7+1)]

for i,j in q31JKUtX:
    ouoj[i].append(j)
    ouoj[j].append(i)

#EDGES=[[] for i in range(e1j7+1)]
QeHW=[None for i in range(e1j7+1)]
ldQuOCeFQf=deque([1])
L5I=[0]*(e1j7+1)
l6ln=0
while ldQuOCeFQf:
    Nque=deque()
    l6ln+=1

    while ldQuOCeFQf:
        x=ldQuOCeFQf.pop()
        UkA[x]=l6ln
        L5I[x]=1
        for to in ouoj[x]:
            if L5I[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                QeHW[to]=x
                Nque.append(to)
    ldQuOCeFQf=Nque


L5I=[0]*(e1j7+1)
L5I[1]=1
#NEXT=[]

#for i in ouoj[1]:
#    L5I[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in ouoj[j]:
#        L5I[k]=1


L5gqjRs=[]
for i in range(2,e1j7+1):
    if len(ouoj[i])==1:
        L5gqjRs.append((-UkA[i],i))

ldQuOCeFQf=L5gqjRs
heapq.heapify(ldQuOCeFQf)
Wbr=0

#print(L5I,ldQuOCeFQf)

while ldQuOCeFQf:
    dep,x=heapq.heappop(ldQuOCeFQf)
    if L5I[x]!=0 or dep>=-3:
        continue

    if L5I[QeHW[x]]==2:
        continue

    if L5I[x]==0:
        L5I[x]=1
    if L5I[QeHW[QeHW[x]]]==0:
        L5I[QeHW[QeHW[x]]]=1
    L5I[QeHW[x]]=2   
    heapq.heappush(ldQuOCeFQf,(-UkA[QeHW[QeHW[QeHW[x]]]],QeHW[QeHW[QeHW[x]]]))
    Wbr+=1

    #print(x,ldQuOCeFQf,L5I)

print(Wbr)
```
</ans>",0,{}
246," <ans>
class UnionFindVerSize():
def **init**(self, ZoCcy8YP):
self.**parent** = [n for n in range(0, ZoCcy8YP)]
self.**size** = [1] * ZoCcy8YP
```python
def find_root(self, x):
    if self._parent[x] == x: return x
    self._parent[x] = self.find_root(self._parent[x])
    return self._parent[x]

def unite(self, x, y):
    gx = self.find_root(x)
    Gy = self.find_root(y)
    if gx == Gy: return

    if self._size[gx] < self._size[Gy]:
        self._parent[gx] = Gy
        self._size[Gy] += self._size[gx]
    else:
        self._parent[Gy] = gx
        self._size[gx] += self._size[Gy]

def get_size(self, x):
    return self._size[self.find_root(x)]

def is_same_group(self, x, y):
    return self.find_root(x) == self.find_root(y)

def calc_group_num(self):
    N = len(self._parent)
    ans = 0
    for i in range(N):
        if self.find_root(i) == i:
            ans += 1
    return ans

import sys

i0O=sys.stdin.readline

n,m=list(map(int,i0O().split()))
VXf6Nizl5n=list(map(int,i0O().split()))
VXf6Nizl5n=[VXf6Nizl5n[i]-1 for i in range(n)]
GgELiNUIIO=[]
for i in range(m-1):
    a,b=list(map(int,i0O().split()))
    GgELiNUIIO.append((a-1,b-1))

H2ySvkD=[[] for i in range(m)]
for i in range(n):
    id=VXf6Nizl5n[i]
    if not H2ySvkD[id]:
        H2ySvkD[id].append((i+1,i+1))
    else:
        start,end=H2ySvkD[id].pop()
        if end+1==i+1:
            H2ySvkD[id].append((start,i+1))
        else:
            H2ySvkD[id].append((start,end))
            H2ySvkD[id].append((i+1,i+1))

#print(H2ySvkD)
test=[]
for i in range(m):
    for start,end in H2ySvkD[i]:
        if end!=n:
            test.append((VXf6Nizl5n[start-1],VXf6Nizl5n[end]))

#print(test)
x0XgI_Us=[-1]*len(test)
OM970k=[m-1]*len(test)
XnFgr44yi=[[] for i in range(m)]
for i in range(len(test)):
    T=(OM970k[i]+x0XgI_Us[i])//2
    XnFgr44yi[T].append(i)

def parabisect():
    JCnAT=UnionFindVerSize(m)
    for i in range(m-1):
        a,b=GgELiNUIIO[i]
        JCnAT.unite(a,b)
        while XnFgr44yi[i]:
            j=XnFgr44yi[i].pop()
            id1,id2=test[j]
            if JCnAT.is_same_group(id1,id2):
                OM970k[j]=i
            else:
                x0XgI_Us[j]=i
            if OM970k[j]-x0XgI_Us[j]>1:
                T=(OM970k[j]+x0XgI_Us[j])//2
                XnFgr44yi[T].append(j)

for i in range(20):
    parabisect()

a9kY=[0]*m
for i in range(len(test)):
    a9kY[OM970k[i]+1]-=1

for i in range(1,m):
    a9kY[i]+=a9kY[i-1]

for i in range(m):
    print(len(test)+a9kY[i])
```
</ans>",0,{}
247," <ans>
```python
# from collections import deque
import io
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # 神奇快读，无法运行调试
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    jBq4QwFU = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.jBq4QwFU = 0
        return self.buffer.read()

    def readline(self):
        while self.jBq4QwFU == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.jBq4QwFU = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.jBq4QwFU -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")


DRnPH, YtUGM = map(int, input().split())
# d = {}
inc = {
    # chr(97+i):0 for i in range(26)

}
OcBOnsqto = [None for i in range(DRnPH*YtUGM)]

for i in range(DRnPH):
    t = int(input())
    # tmp = []
    for j in range(YtUGM):
        # tmp.append(input())
        ipt = input()
        OcBOnsqto[DRnPH*YtUGM+j] = ipt
        if len(inc)==26:continue
        for q in ipt:
            inc.setdefault(q, 0)
    # d[t] = tmp
# l = []
# for i in range(DRnPH):
#     for j in d[i]:
#         l.append(j)

ddk = {}


# f = l[0][0]

def ae(u, v):
    t = ddk.setdefault(u, set())
    if v not in t:
        t.add(v)
        inc[v] = inc.get(v, 0) + 1


for p, i in enumerate(OcBOnsqto[1:]):
    for j in range(min(len(OcBOnsqto[p]), len(i))):
        if OcBOnsqto[p][j] != i[j]:
            # if len(OcBOnsqto[p])-1 != j:
                # ae(OcBOnsqto[p][j],i[j])
            ae(i[j], OcBOnsqto[p][j])
            break
        if len(i)-1==j and len(OcBOnsqto[p])-1 > j:
            print(""IMPOSSIBLE"")
            return


ans = []
Zohtc = []
# dq = deque()
ptr = 0


ninc = {}

for k, v in inc.items():
    if v == 0:
        Zohtc.append(k)
    else:
        ninc[k] = v


# if ctr>1:
    # print(""IMPOSSIBLE"")
    # return

inc = ninc


while ptr != len(Zohtc):
    f_6Do = Zohtc[ptr]
    ans.append(f_6Do)

    for i in ddk.get(f_6Do, []):
        inc[i] -= 1
        if inc[i] == 0:
            Zohtc.append(i)
            inc.pop(i)

    # if ctr>1:
        # print(""IMPOSSIBLE"")
        # return
    ptr += 1

if len(inc):
    print(""IMPOSSIBLE"")
    return

print(*reversed(ans), sep='')

```
</ans>",0,{}
248," <ans>
import sys
import math
import itertools
import functools
import collections

def M5hAjuvdC(number, base):
newnumber = 0
while number > 0:
newnumber += number % base
number //= base
return newnumber

def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def wr(arr): return ' '.join(map(str, arr))
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
if n < 2: return list()
prime = [True for _ in range(n + 1)]
p = 3
while p * p <= n:
if prime[p]:
for i in range(p * 2, n + 1, p):
prime[i] = False
p += 2
r = [2]
for p in range(3, n + 1, 2):
if prime[p]:
r.append(p)
return r
def divs(n, start=1):
r = []
for i in range(start, int(math.sqrt(n) + 1)):
if (n % i == 0):
if (n / i == i):
r.append(i)
else:
r.extend([i, n // i])
return r
def divn(n, primes):
divs\_number = 1
for i in primes:
if n == 1:
return divs\_number
t = 1
while n % i == 0:
t += 1
n //= i
divs\_number \*= t
def Ed3FjCNlu():
M5hAjuvdC(input(), 10)

Ed3FjCNlu()
for _ in range(qmjZu6DYj()):
pHLc\_, g, b = sorted(mi())
if b > pHLc\_ + g + 1:
print('No')
else:
print('Yes')
</ans>",0,{}
249," <ans>
```python
#!/usr/bin/env python
# 560B_art.py - Codeforces.com 560B Art program
#
# Copyright (C) 2015 Sergey

""""""
Gerald asks whether it is possible to place the paintings on the board,
or is the board he bought not large enough?
Input

The first line contains two space-separated numbers a1 and b1 the sides
of the board. Next two lines contain numbers a2 b2 a3 and b3 the sides
of the paintings. All numbers ai,?bi in the input are integers and fit into
the range from 1 to 1000.

Output

If the paintings can be placed on the wall, print ""YES"" (without the quotes),
and if they cannot, print ""NO"" (without the quotes).
""""""

# Standard modules
import unittest
import sys

# Additional modules


###############################################################################
# Art Class
###############################################################################


class Art:
    """""" Art representation """"""

    def __init__(self, args):
        """""" Default constructor """"""

        self.numa, self.yQg0Zx = args

        self.r = self.rect(self.numa[0], self.numa[1])
        self.rmax = self.rect(self.numa[1], self.yQg0Zx[0])
        self.rmin = self.rect(self.numa[2], self.yQg0Zx[1])
        if self.rmax[0] < self.rmax[1]:
            self.rmax, self.rmin = self.rmin, self.rmax

        self.remain = []
        if self.rmax[0] < self.r[0] and self.rmax[1] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[0], self.r[1]))
        if self.rmax[1] < self.r[1] and self.rmax[0] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[1]))

        if self.rmax[1] < self.r[0] and self.rmax[0] <= self.r[1]:
            self.remain.append((self.r[0] - self.rmax[1], self.r[1]))
        if self.rmax[0] < self.r[1] and self.rmax[1] <= self.r[0]:
            self.remain.append((self.r[0], self.r[1] - self.rmax[0]))

    def rect(self, a, b):
        if a > b:
            return (a, b)
        else:
            return (b, a)

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        for rec in self.remain:
            if self.rmin[0] <= rec[0] and self.rmin[1] <= rec[1]:
                return ""YES""
            if self.rmin[1] <= rec[0] and self.rmin[0] <= rec[1]:
                return ""YES""
        return ""NO""


###############################################################################
# Helping classes
###############################################################################


###############################################################################
# Art Class testing wrapper code
###############################################################################


def get_inputs(test_inputs=None):

    yZfMHStk = iter(test_inputs.split(""\n"")) if test_inputs else None

    def uinput():
        """""" Unit-testable input function wrapper """"""
        if yZfMHStk:
            return next(yZfMHStk)
        else:
            return sys.stdin.readline()

    # Getting string inputs. Place all uinput() calls here
    imax = 3
    numnums = list(map(int, "" "".join(uinput() for i in range(imax)).split()))

    # Splitting numnums into n arrays
    numa = []
    yQg0Zx = []
    for i in range(0, 2*imax, 2):
        numa.append(numnums[i])
        yQg0Zx.append(numnums[i+1])

    # Decoding inputs into a list
    return [numa, yQg0Zx]


def calculate(test_inputs=None):
    """""" Base class calculate method wrapper """"""
    return Art(get_inputs(test_inputs)).calculate()


###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_Art_class__basic_functions(self):
        """""" Art class basic functions testing """"""

        # Constructor test
        d = Art([[3, 1, 2], [2, 3, 1]])
        self.assertEqual(d.numa[0], 3)

        self.assertEqual(d.r, (3, 2))
        self.assertEqual(d.rmax, (3, 1))
        self.assertEqual(d.rmin, (2, 1))

        self.assertEqual(d.remain, [(3, 1)])

    def test_sample_tests(self):
        """""" Quiz sample tests. Add \n to separate lines """"""

        # Sample test 1
        test = ""3 2\n1 3\n2 1""
        self.assertEqual(calculate(test), ""YES"")
        self.assertEqual(list(get_inputs(test)[0]), [3, 1, 2])
        self.assertEqual(list(get_inputs(test)[1]), [2, 3, 1])

        # Sample test 2
        test = ""5 5\n3 3\n3 3""
        self.assertEqual(calculate(test), ""NO"")

        # Sample test 3
        test = ""4 2\n2 3\n1 2""
        self.assertEqual(calculate(test), ""YES"")

        # My test 4
        test = ""5 5\n1 5\n1 5""
        self.assertEqual(calculate(test), ""YES"")

    def test_time_limit_test(self):
        """""" Quiz time limit test """"""

        import random

        # Time limit test
        test = ""1000 1000""
        test += ""\n900 900""
        test += ""\n50 50""

        import timeit

        lw0pSEA0 = timeit.default_timer()
        args = get_inputs(test)

        vhLXv6Kop = timeit.default_timer()
        d = Art(args)

        tAkUIdme = timeit.default_timer()
        d.calculate()

        iWzNdkFR25 = timeit.default_timer()
        print((
            ""\nTime Test: "" +
            ""{0:.3f}s (inp {1:.3f}s init {2:.3f}s calc {3:.3f}s)"".
            format(iWzNdkFR25-lw0pSEA0, vhLXv6Kop-lw0pSEA0, tAkUIdme-vhLXv6Kop, iWzNdkFR25-tAkUIdme)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(calculate())

__starting_point()
```
</ans>",0,{}
250," <ans>
import sys
from collections import defaultdict

class BIT():
def **init**(self, n):
self.n = n
self.tree = [0] * n

def \_get\_sum(self, r):
'''
sum on interval [0, r)
'''
result = 0
while r > 0:
result += self.tree[r-1]
r &= (r - 1)
return result

def get\_sum(self, l, r):
'''
sum on interval [l, r)
'''
return self.\_get\_sum(r) - self.\_get\_sum(l)

def add(self, i, value=1):
while i < self.n:
self.tree[i] += value
i |= (i + 1)

VtKxSjUzr = (line.rstrip() for line in sys.stdin)
input = VtKxSjUzr.**next**

IOAO6VSk = int(input())
uPL = []
for _ in range(IOAO6VSk):
i, j = list(map(int, input().split()))
uPL.append(i)
uPL.append(j)

bzax = defaultdict(list)
for i, val in enumerate(uPL):
bzax[val].append(i)

sG7Ux8 = 0
prev = -1
iRsbU = [0] * (2*IOAO6VSk)
decompr = {}
for val in sorted(uPL):
if prev == val: continue
for j in bzax[val]:
iRsbU[j] = sG7Ux8
decompr[sG7Ux8] = val
sG7Ux8 += 1
prev = val

arr = list(range(sG7Ux8))
for t in range(IOAO6VSk):
i, j = iRsbU[t<<1], iRsbU[t<<1|1]
arr[i], arr[j] = arr[j], arr[i]

mVRH = BIT(sG7Ux8)
N2bGG = 0
for i, val in enumerate(arr):
N2bGG += mVRH.get\_sum(val+1, sG7Ux8)
if i != val:
N2bGG += abs(decompr[val] - decompr[i]) - abs(val - i)
mVRH.add(val)
print(N2bGG)
</ans>",0,{}
251," <ans>
from math import sqrt

ivoV81wjq = 1e-9

def mysqrt(x):
if x <= 0:
return 0
return sqrt(x)

def good(rjaW1ziKQQ):
nonlocal puWJdA9r
nonlocal Lsl
nonlocal DECEeudv

LzWA = -10**20
HE61uxI = 10**20

for i in range(DECEeudv):
# (x - xi)**2 + (y - yi)**2 = R**2
# y = R
wsa1k7 = puWJdA9r[i]
ei7K6zgZ3 = abs(Lsl[i])

D = 2 \* rjaW1ziKQQ \* ei7K6zgZ3 - ei7K6zgZ3**2

if D + ivoV81wjq < 0:
return False

sD = mysqrt(D)

agK = wsa1k7 - sD
GWc = wsa1k7 + sD

LzWA = max(LzWA, agK)
HE61uxI = min(HE61uxI, GWc)

if LzWA + ivoV81wjq > HE61uxI:
return False

return True

def solve(wUgqTaA0d, HE61uxI, md):
rjaW1ziKQQ = 0
for \_ in range(150):
rjaW1ziKQQ = md(wUgqTaA0d, HE61uxI)

if good(rjaW1ziKQQ):
HE61uxI = rjaW1ziKQQ
else:
wUgqTaA0d = rjaW1ziKQQ

return rjaW1ziKQQ

DECEeudv = int(input())

puWJdA9r = [0.0 for \_ in range(DECEeudv)]
Lsl = [0.0 for \_ in range(DECEeudv)]

for i in range(DECEeudv):
puWJdA9r[i], Lsl[i] = list(map(float, input().split()))
if i > 0:
if Lsl[i] \* Lsl[0] < 0:
print(-1)
return

rjaW1ziKQQ = None
if good(1):
rjaW1ziKQQ = solve(0, 1, lambda x, y: (x + y) / 2)
else:
rjaW1ziKQQ = solve(1, 1e16, lambda x, y: sqrt(x \* y))

print('{:.16}'.format(rjaW1ziKQQ))
</ans>",0,{}
252," <ans>
def bin\_pow(Za4WcVZK, degree , bvwhb):
if degree == 0:
return 1
if degree == 1:
return Za4WcVZK % bvwhb

if degree % 2 == 0:
val = bin\_pow(Za4WcVZK, degree // 2, bvwhb)
return (val \* val) % bvwhb
return (Za4WcVZK \* bin\_pow(Za4WcVZK , degree - 1, bvwhb)) % bvwhb

x, y = list(map(int,input().split()))

if y % x != 0:
print(0)
return

y //= x

divs = set()
to\_gen = []

num = 2
val = y

while num \* num <= val:
degree = 0
while y % num == 0:
degree+=1
y //= num
if degree != 0:
to\_gen.append((num, degree))

if num == 2:
num += 1
else:
num += 2

if y != 1:
to\_gen.append((y, 1))

to\_gen\_len = len(to\_gen)

def generate(ind):
if ind == to\_gen\_len:
yield 1
return
gen\_val = to\_gen[ind][0]

for deg in range(1 + to\_gen[ind][1]):
for each in generate(ind + 1):
yield gen\_val**deg \* each

for each in generate(0):
divs.add(each)

divs = list(divs)
divs.sort()
divs\_answers = {}

ans = bin\_pow(2, w5je\_ - 1, bvwhb)

for el in divs:
if el == 1:
divs\_answers[el] = 1
ans -= 1
else:
curr\_val = bin\_pow(2, el - 1 ,bvwhb)
for other\_el in divs:
if other\_el >= el:
break
if el % other\_el !=0:
continue

curr\_val -= divs\_answers[other\_el]

divs\_answers[el] = curr\_val % bvwhb
ans -= curr\_val

print(divs\_answers[w5je\_])
</ans>",0,{}
253," <ans>
import bisect

```python
class BTreeNode:
    def __init__(self):
        self.key = []
        self.child = []


class BTree:
    def __init__(self):
        self.root = BTreeNode()

    def search_higher(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_right(ptr.key, key)
            if i != len(ptr.key):
                ret = ptr.key[i]
            ptr = ptr.child[i]
        i = bisect.bisect_right(ptr.key, key)
        if i != len(ptr.key):
            ret = ptr.key[i]
        return ret

    def search_lower(self, key):
        ptr = self.root
        ret = None
        while ptr.child:
            i = bisect.bisect_left(ptr.key, key)
            if i != 0:
                ret = ptr.key[i - 1]
            ptr = ptr.child[i]
        i = bisect.bisect_left(ptr.key, key)
        if i != 0:
            ret = ptr.key[i - 1]
        return ret

    def insert(self, key):
        def insert_rec(ptr):
            b_size = 10
            if not ptr.child:
                bisect.insort(ptr.key, key)
                if len(ptr.key) == b_size * 2 - 1:
                        ret = BTreeNode()
                        ret.key = ptr.key[:b_size]
                        ptr.key = ptr.key[b_size:]
                        return ret
            else:
                i = bisect.bisect(ptr.key, key)
                temp = insert_rec(ptr.child[i])
                if temp is not None:
                    ptr.key.insert(i, temp.key.pop(-1))
                    ptr.child.insert(i, temp)
                    if len(ptr.child) == b_size * 2:
                        ret = BTreeNode()
                        ret.child = ptr.child[:b_size]
                        ptr.child = ptr.child[b_size:]
                        ret.key = ptr.key[:b_size]
                        ptr.key = ptr.key[b_size:]
                        return ret
            return None
        temp = insert_rec(self.root)
        if temp is not None:
            root = BTreeNode()
            root.key = [temp.key.pop(-1)]
            root.child = [temp, self.root]
            self.root = root

    def dump(self):
        def dump_rec(ptr, dep):
            for _ in range(0, dep):
                print(""  "", end="""")
            print(ptr.key)
            for c in ptr.child:
                dump_rec(c, dep + 1)
        dump_rec(self.root, 0)
        print("""")


def main():
    n = int(input())
    p = list(map(int, input().split()))
    WkgWCPxHXC = [0] * n
    for i in range(0, n):
        WkgWCPxHXC[i] = i
    WkgWCPxHXC.sort(key=lambda i: - p[i])
    yLFgaQB = BTree()
    yLFgaQB.insert(-1)
    yLFgaQB.insert(n)
    WnpceoB = 0
    for i in WkgWCPxHXC:
        nex = yLFgaQB.search_higher(i)
        _ne8V = yLFgaQB.search_higher(nex)
        pre = yLFgaQB.search_lower(i)
        SuQLVhk = yLFgaQB.search_lower(pre)
        if SuQLVhk != None:
            WnpceoB += p[i] * (pre - SuQLVhk) * (nex - i)
        if _ne8V != None:
            WnpceoB += p[i] * (i - pre) * (_ne8V - nex)
        yLFgaQB.insert(i)
    print(WnpceoB)


main()

```
</ans>",0,{}
254," <ans>

Uj9f = 72
jM0lTQ = 1<<Uj9f
smvX5D = lambda L: int("""".join([bin(jM0lTQ+a)[-Uj9f:] for a in L[::-1]]), 2)
egm = lambda n: bin(n)[2:] + ""0""
dCZ3Ue = lambda s, l: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*Uj9f-1:-i*Uj9f-1] for i in range(l)]]

def grow(d, v, h):
    h += [0] * d
    pW3Mg = [(-1 if (i+d) % 2 else 1) * pW3Mg[i] * pW3Mg[d-i] % jM0lTQ * h[i] % jM0lTQ for i in range(d+1)]

    for idx, a in enumerate([d+1, d * mhx2wZ1Jv[v-1] * pW3Mg[v] % jM0lTQ, (d * mhx2wZ1Jv[v-1] * pW3Mg[v] + d + 1) % jM0lTQ]):
        t = [1] * (2*d+2)
        for i in range(1, 2*d+2): t[i] = t[i-1] * (a - d + i - 1) % jM0lTQ
        A8Uul = [1] * (2*d+2)
        A8Uul[-1] = pow(t[-1], jM0lTQ-2, jM0lTQ)
        for i in range(1, 2*d+2)[::-1]: A8Uul[i-1] = A8Uul[i] * (a - d + i - 1) % jM0lTQ

        liyD = [A8Uul[i+1] * t[i] % jM0lTQ for i in range(2*d+1)]
        uTs = dCZ3Ue(egm(smvX5D(pW3Mg) * smvX5D(liyD)), d * 2 + 2)

        if idx == 1:
            for i in range(d+1):
                h[i] = h[i] * (uTs[d+i] * t[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ) % jM0lTQ
        elif idx == 0:
            for i in range(d):
                h[i+d+1] = uTs[d+i] * t[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ
        elif idx == 2:
            for i in range(d):
                h[i+d+1] = h[i+d+1] * (uTs[d+i] * t[d+i+1] % jM0lTQ * A8Uul[i] % jM0lTQ) % jM0lTQ
    return h

# Create a table of the factorial of the first v+2 multiples of v, i.e., [0!, v!, 2v!, ..., (v(v+1))!]
def create_table(v):
    s = 1
    t06inl4fa9 = [1, v+1]
    while s < v:
        t06inl4fa9 = grow(s, v, t06inl4fa9)
        s *= 2
    uTs = [1]
    for x in t06inl4fa9:
        uTs.append(uTs[-1] * x % jM0lTQ)
    return uTs

def fact(i, uTs):
    nc95W2V = uTs[i//v]
    for j in range(i//v*v+1, i+1):
        nc95W2V = nc95W2V * j % jM0lTQ
    return nc95W2V

jM0lTQ = 10**9+7
aoH_ = 1 << 11
mhx2wZ1Jv = [1] * (2*aoH_+2)
pW3Mg = [1] * (2*aoH_+2)
for i in range(2*aoH_+1):
    mhx2wZ1Jv[i+1] = mhx2wZ1Jv[i] * (i+1) % jM0lTQ
pW3Mg[-1] = pow(mhx2wZ1Jv[-1], jM0lTQ-2, jM0lTQ)
for i in range(2*aoH_+1)[::-1]:
    pW3Mg[i] = pW3Mg[i+1] * (i+1) % jM0lTQ

G_c3 = create_table(aoH_)

Ep6Da = lambda a, b: fact(a+b+2, G_c3) * pow(fact(a+1, G_c3) * fact(b+1, G_c3), jM0lTQ-2, jM0lTQ) % jM0lTQ
RymCr, nc95W2V, mhx2wZ1Jv, t06inl4fa9 = list(map(int, input().split()))
print(((Ep6Da(mhx2wZ1Jv, t06inl4fa9) - Ep6Da(mhx2wZ1Jv, nc95W2V-1) - Ep6Da(RymCr-1, t06inl4fa9) + Ep6Da(RymCr-1, nc95W2V-1)) % jM0lTQ))

</ans>",0,{}
255," <ans>
class UnionFind:
def **init**(self, n):
self.parent = list(range(n))
self.size = [1] * n
self.num\_sets = n

def find(self, a):
bYEWKo = []

while a != self.parent[a]:
bYEWKo.append(a)
a = self.parent[a]

for b in bYEWKo[::-1]:
self.parent[b] = a

return self.parent[a]

def merge(self, a, b):
a = self.find(a)
b = self.find(b)

if a == b:
return

if self.size[a] < self.size[b]:
a, b = b, a

self.num\_sets -= 1
self.parent[b] = a
self.size[a] += self.size[b]

def set\_size(self, a):
return self.size[self.find(a)]

def main():
from sys import stdin, stdout

def read():
return stdin.readline().rstrip('\\n')

def read\_array(sep=None, maxsplit=-1):
return read().split(sep, maxsplit)

def read\_int():
return int(read())

def read\_int\_array(sep=None, maxsplit=-1):
return [int(a) for a in read\_array(sep, maxsplit)]

def write(*args, **kwargs):
sep = kwargs.get('sep', ' ')
end = kwargs.get('end', '\\n')
stdout.write(sep.join(str(a) for a in args) + end)

def write\_array(array, **kwargs):
sep = kwargs.get('sep', ' ')
end = kwargs.get('end', '\\n')
stdout.write(sep.join(str(a) for a in array) + end)

n, m = read\_int\_array()
REJ2V = UnionFind(n)
for _ in range(m):
nums = read\_int\_array()
sz = nums[0]
leader = None
for i in range(sz):
p = nums[1 + i] - 1
if leader is None:
leader = p
else:
REJ2V.merge(p, leader)

ans = [REJ2V.set\_size(i) for i in range(n)]
write(*ans)

main()
</ans>",0,{}
256," <ans>
```python
#!/usr/bin/env python3
# 599B_sponge.py - Codeforces.com/problemset/problem/599/B by Sergey 2015

import unittest
import sys

###############################################################################
# Sponge Class (Main Program)
###############################################################################


class Sponge:
    """""" Sponge representation """"""

    def __init__(self, test_inputs=None):
        """""" Default constructor """"""

        Q4WO8 = iter(test_inputs.split(""\n"")) if test_inputs else None

        def uinput():
            return next(Q4WO8) if Q4WO8 else sys.stdin.readline().rstrip()

        # Reading single elements
        [self.n, self.m] = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        self.wE5LG0CTaE = list(map(int, uinput().split()))

        # Reading a single line of multiple elements
        self.wE5LG0CTaE = list(map(int, uinput().split()))

        self.fd = {}
        self.fdn = {}
        for (i, n) in enumerate(self.wE5LG0CTaE):
            self.fd[n] = self.fd.setdefault(n, 0) + 1
            self.fdn[n] = i + 1

    def calculate(self):
        """""" Main calcualtion function of the class """"""

        rImz = []
        for n in self.wE5LG0CTaE:
            if n not in self.fd:
                return ""Impossible""
            rImz.append(self.fdn[n])
        for n in self.wE5LG0CTaE:
            if self.fd[n] > 1:
                return ""Ambiguity""

        return ""Possible\n"" + "" "".join(map(str, rImz))

###############################################################################
# Unit Tests
###############################################################################


class unitTests(unittest.TestCase):

    def test_single_test(self):
        """""" Sponge class testing """"""

        # Constructor test
        test = ""3 3\n3 2 1\n1 2 3""
        lCxuXhp = Sponge(test)
        self.assertEqual(lCxuXhp.n, 3)
        self.assertEqual(lCxuXhp.m, 3)
        self.assertEqual(lCxuXhp.wE5LG0CTaE, [3, 2, 1])
        self.assertEqual(lCxuXhp.wE5LG0CTaE, [1, 2, 3])

        # Sample test
        self.assertEqual(Sponge(test).calculate(), ""Possible\n3 2 1"")

        # Sample test
        test = ""3 3\n1 1 3\n1 2""
        self.assertEqual(Sponge(test).calculate(), ""Impossible"")

        # Sample test
        test = ""3 3\n1 1 1\n1 1 1""
        self.assertEqual(Sponge(test).calculate(), ""Ambiguity"")

        # Time limit test
        # self.time_limit_test(5000)

    def time_limit_test(self, nmax):
        """""" Timelimit testing """"""
        import random
        import timeit

        # Random inputs
        test = str(nmax) + "" "" + str(nmax) + ""\n""
        PvpTr = [str(i) + "" "" + str(i+1) for i in range(nmax)]
        test += ""\n"".join(PvpTr) + ""\n""
        wE5LG0CTaE = [random.randint(1, 10000) for i in range(nmax)]
        test += "" "".join(map(str, wE5LG0CTaE)) + ""\n""

        # Run the test
        start = timeit.default_timer()
        lCxuXhp = Sponge(test)
        calc = timeit.default_timer()
        lCxuXhp.calculate()
        stop = timeit.default_timer()
        print((""\nTimelimit Test: "" +
              ""{0:.3f}s (init {1:.3f}s calc {2:.3f}s)"".
              format(stop-start, calc-start, stop-calc)))

def __starting_point():

    # Avoiding recursion limitaions
    sys.setrecursionlimit(100000)

    if sys.argv[-1] == ""-ut"":
        unittest.main(argv=["" ""])

    # Print the result string
    sys.stdout.write(Sponge().calculate())

__starting_point()
```
</ans>",0,{}
257," <ans>
n=input().split()
r=int(n[0])
lnDP=int(n[1])
l=[]
for i in range(r):
    xGa348r=input()
    l.append(xGa348r)
Fr9Qg=[]
for i in range(r):
    BcOtKzy5M=[]
    for j in range(r):
        BcOtKzy5M.append(0)
    Fr9Qg.append(BcOtKzy5M)
for i in range(r):
    for j in range(len(l[i])):
        IZYsI0=0
        f=0
        if j+lnDP<=r:
            for q in range(lnDP):
                if l[i][j+q:j+q+1]=='.':
                    continue
                else:
                    IZYsI0=1
                    break
            if IZYsI0==0:
                for q in range(lnDP):
                    Fr9Qg[i][j+q]=Fr9Qg[i][j+q]+1
            if IZYsI0==1:
                j=q+1
for i in range(r):
    for j in range(r):
        IZYsI0=0
        f=0
        if j+lnDP<=r:
            for q in range(lnDP):
                if l[j+q][i:i+1]=='.':
                    continue
                else:
                    IZYsI0=1
                    break
            if IZYsI0==0:
                for q in range(lnDP):
                    Fr9Qg[j+q][i]=Fr9Qg[j+q][i]+1
            if IZYsI0==1:
                j=q+1
yUL7Se=0
XS2ew7ol=0
m=0
for i in range(r):
    for j in range(r):
        if Fr9Qg[i][j]>m:
            m=Fr9Qg[i][j]
            FJgmPF7j=i
            XS2ew7ol=j
print(FJgmPF7j+1,XS2ew7ol+1)
</ans>",0,{}
258," <ans>
```python
"""""" ATSTNG's ejudge Python3 solution template """"""
import sys, queue

try:
    import dev_act_ffc429465ab634
    cry3KjH = True
except:
    cry3KjH = False

def log(*s):
    if cry3KjH: print('L',list(s),sep='')

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        WHUo = [[[5]*100000 for _ in range(1000)]]
        while True: WHUo.append([[5]*100000 for _ in range(1000)])

    def get_re(self):
        s = (0,)[8]

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        return

class IntReader:
    def __init__(self):
        self.ost = queue.Queue()

    def get(self):
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        return self.ost.get()

    def release(self):
        res = []
        while not self.ost.empty():
            res.append(self.ost.get())
        return res

###############################################################################
RmQC = EJudge(  )
Gw8idueYk = IntReader()
fmap = lambda f,l: list(map(f,l))
parse_int = lambda: fmap(int, input().split())
RsH5apY = lambda x: (x>0)-(x<0)

# input
n,vi1o = parse_int()
fG0N = [0]*100500
for _ in range(n): fG0N[Gw8idueYk.get()] += 1
for idx in range(100500):
    tJZt = idx^vi1o
    if tJZt < 100500:
        vi1o[tJZt] = fG0N[idx]

SagQqR = 0
for idx in range(10050",0,{}
259," <ans>
import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy
from itertools import chain, dropwhile, permutations, combinations
from collections import defaultdict, deque

def VI(): return list(map(int,input().split()))
def I(): return int(input())
def LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]
def ELIST(n): return [[] for i in range(n)]
def MI(n=None,m=None): # input matrix of integers
if n is None: n,m = VI()
arr = LIST(n)
for i in range(n): arr[i] = VI()
return arr
def MS(n=None,m=None): # input matrix of strings
if n is None: n,m = VI()
arr = LIST(n)
for i in range(n): arr[i] = input()
return arr
def MIT(n=None,m=None): # input transposed matrix/array of integers
if n is None: n,m = VI()
a = MI(n,m)
arr = LIST(m,n)
for i,l in enumerate(a):
for j,x in enumerate(l):
arr[j][i] = x
return arr

def run(SO3Owig,N6j):
for i in range(SO3Owig+1):
if N6j[0]==0:
if sum([i==N6j[i] for i in range(SO3Owig)])==SO3Owig:
print(""Yes"")
else:
print(""No"")
return
for j in range(SO3Owig):
if j%2==0:
N6j[j] = (N6j[j]+1)%SO3Owig
else:
N6j[j] = (N6j[j]-1)%SO3Owig

def main(info=0):
SO3Owig = I()
N6j = VI()

run(SO3Owig,N6j)

def __starting_point():
main()

__starting_point()
</ans>",0,{}
260," <ans>
```python
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



def e_gcd(a, b ):
    if a==0 and b==0:
        return -1, 0, 0
    if b==0:
        return a, 1,0
    d, y,x = e_gcd(b, a%b )
    y-=  a //b *x
    return d , x,y

def m_reverse(a,n):
    d,x,y = e_gcd(a,n)
    dprint(x,y,a,n)
    assert x*a + y*n == d
    if d==1:
        if x%n<=0:
           return x%n+n
        else:
            return x%n
    else:
        return -1

pjNmpHzd = 0
xuYrjIldW = 0
if pjNmpHzd>0:
    dprint('use input', pjNmpHzd)
    sys.stdin = open('input'+ str(pjNmpHzd) + '.txt', 'r') #标准输出重定向至文件
if xuYrjIldW>0:
    dprint('use output', xuYrjIldW)
    sys.stdout = open('stdout'+ str(xuYrjIldW) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit

    
cJXVBmj = 998244353
U4eMvf5PZ = 1233
pYyoC = m_reverse( U4eMvf5PZ, cJXVBmj)
dprint(pYyoC)
c9BY0pTgAu = pYyoC * U4eMvf5PZ % cJXVBmj
dprint(c9BY0pTgAu)
Ormdjj5rc, dWHLLs_z1N, ZTv= getIntList()



J = Ormdjj5rc-1 - ZTv   # same

Z = Ormdjj5rc - J
dprint(Z)
R = dWHLLs_z1N
for i in range(Z-1):
    R *= dWHLLs_z1N-1
    R%= cJXVBmj
dprint(R)
n0 = J
m0 = Z
dprint(n0,m0)
#comb(n0 + m0 -1, m0-1)
for i in range(m0 -1):
    g = n0 + m0 -1  -i
    R*= g
    R%= cJXVBmj



for i in range(2, m0):
    D3B = m_reverse(i,cJXVBmj)
    R*=D3B
    R%=cJXVBmj

print(R)
    




```
</ans>",0,{}
261," <ans>
```python
import math
import bisect
import itertools
import sys
M1xA=lambda : sys.stdin.readline()
MyyP=10**9 +7
'''fact=[1]*100001
ifact=[1]*100001
for i in range(1,100001):
    fact[i]=((fact[i-1])*i)%MyyP
    ifact[i]=((ifact[i-1])*pow(i,MyyP-2,MyyP))%MyyP
def ncr(n,r):
    return (((fact[n]*ifact[n-r])%MyyP)*ifact[r])%MyyP
def npr(n,r):
    return (((fact[n]*ifact[n-r])%MyyP))
    '''


def MIndiff(a):
    b=a[:]
    b.sort()
    m=10000000000
    for i in range(len(b)-1):
        if b[i+1]-b[i]<m:
            m=b[i+1]-b[i]
    return m
    
def lcm(a,b):
    return a*b//math.gcd(a,b)

    
def is_prime(num):
    if num == 1: return False
    if num == 2: return True
    if num == 3: return True
    if num%2 == 0: return False
    if num%3 == 0: return False
    t = Y3OetRWEX
    YJ = 2
    while t <= int(math.sqrt(num)):
        if num%t == 0: return False
        t += YJ
        YJ = 6 - YJ
    return True
    
  
def CEIL(a,b):
    if a%b==0:
        return a//b
    else:
        return (a//b + 1)

def bINsearch(arr,b,low,high):
    if low==high:
        return low
    if arr[math.ceil((low+high)/2)]<b:
        return bINsearch(arr,b,low,math.ceil((low+high)/2) -1 )
    else:
        return bINsearch(arr,b,math.ceil((low+high)/2),high)
def ncr1(n,r):
    s=1
    for i in range(min(n-r,r)):
        s*=(n-i)
        s%=MyyP
        s*=pow(i+1,MyyP-2,MyyP)
        s%=MyyP
    return s
    
def calc(n,m,r):
    s=0
    for i in range(0,r+1,2):
        s+=ncr1(n,i)*ncr1(m,i)
        s%=MyyP
    return s    
    
def modU(a,n):
    if a%n==0:
        return n
    return a%n

#/////////////////////////////////////////////////////////////////////////////////////////////////

for i in range(1):
    n,k=map(int,M1xA().split())
    a=list(map(int,M1xA().split()))
    s=M1xA()
    c=1;b=[]
    for i in range(1,n):
        if s[i-1]==s[i]:
            c+=1
            f=True
        else:
            b.append(c)
            c=1
            f=False
    if True:
        b.append(c)
    #print(b) 
    ans=0
    su=0
    for i in b:
        c=a[su:min(su+i,10**9)]

        #print(c)
        
        
        c.sort(reverse=True)
        c=c[:min(i,k)]
        su+=i
        ans+=sum(c)
        
    print(ans)
```
</ans>",0,{}
262," <ans>
def solve(printing):

LRIwawq = [int(st)-1 for st in input().split("" "")]
F87mUE = int(input())
xVR1MB = [0] * F87mUE
ybd = []
CAL578CFbq = {}
S7nPLyiI = []
mEXZqGUMir = 0

if printing:
print(""nums""); print(LRIwawq)

for i in range(F87mUE):
xVR1MB[LRIwawq[i]] += 1

for i in range(F87mUE):
if xVR1MB[i] == 0:
S7nPLyiI.append(i)

for i in range(F87mUE):
if xVR1MB[LRIwawq[i]] >= 2:
ybd.append(i)
if LRIwawq[i] in CAL578CFbq:
CAL578CFbq[LRIwawq[i]][1].append(i)
else:
CAL578CFbq[LRIwawq[i]] = [0, [i], False]

for num in CAL578CFbq:
CAL578CFbq[num][0] = len(CAL578CFbq[num][1])

if printing:
print(""missing""); print(S7nPLyiI)
print(""dupeindexindv""); print(CAL578CFbq)

l7u4i = len(S7nPLyiI)
misindex = 0
#answer = 0
for index in ybd:

if l7u4i <= misindex:
break

elif CAL578CFbq[LRIwawq[index]][0] == 1 and not CAL578CFbq[LRIwawq[index]][2]:
# one spot left but original not located yet.
# locate original.
CAL578CFbq[LRIwawq[index]][0] -= 1
CAL578CFbq[LRIwawq[index]][2] = True

elif CAL578CFbq[LRIwawq[index]][0] > 0:

if CAL578CFbq[LRIwawq[index]][2] or S7nPLyiI[misindex] < LRIwawq[index]:
# num is smaller or original is already located.
# locate missing number.
CAL578CFbq[LRIwawq[index]][0] -= 1
LRIwawq[index] = S7nPLyiI[misindex]
misindex += 1
#answer += 1

else: # locate original
CAL578CFbq[LRIwawq[index]][0] -= 1
CAL578CFbq[LRIwawq[index]][2] = True

print(l7u4i)
for num in LRIwawq:
print(num+1, end = "" "")

solve(False)
</ans>",0,{}
263," <ans>
from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
 #------------------Sublime--------------------------------------#
sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
def I():return (int(input()))
def In():return(map(int,input().split()))
else:
#------------------PYPY FAst I/o--------------------------------#
def I():return (int(stdin.readline()))
def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
d={} 
for x in a:
if d.get(x,-1)!=-1:
d[x]+=1
else:
d[x]=1
return d
def find\_gt(a, x):
'Find leftmost value greater than x'
i = bi.bisect\_right(a, x)
if i != len(a):
return i
else:
return -1

def find\_ge(a, x):
'Find leftmost item greater than or equal to x'
i = bi.bisect\_left(a, x)
if i != len(a):
return i
else:
return -1
def main():
try:
n,Q=In()
XFCT\_yLktZ=list(In())
XFCT\_yLktZ.sort()
pre=[0]
Msatslftm=0
for x in range(n):
Msatslftm+=XFCT\_yLktZ[x]
pre.append(Msatslftm)
#print(pre)
for x in range(Q):
q=kW2GNC2dy
q*=2
A9w97=find\_ge(XFCT\_yLktZ,q)
#print(pos)
if A9w97==-1:
print(0)
else:
#print(pos)
Sn9=pre[-1]-pre[A9w97]
print(Sn9)
except:
pass

aALt = 998244353
kTru = 1000000007
</ans>",0,{}
264," <ans>
import sys

def gcd(l):
if len(l)==0:
return 0
if len(l)==1:
return l[0]
if len(l)==2:
if l[1]==0:
return l[0]
return gcd([l[1],l[0]%l[1]])
return gcd([gcd(l[:-1]),l[-1]])

def brute\_force(l1,l2,l,UHJ0bVG4U):
if len(l)==0:
g1=gcd(l1)
g2=gcd(l2)
return g1==1 and g2==1,UHJ0bVG4U

res,s=brute\_force(l1+[l[0]],l2,l[1:],UHJ0bVG4U+[1])
if res:
return True,s
return brute\_force(l1,l2+[l[0]],l[1:],UHJ0bVG4U+[2])

def factor(n):
res=[]
i=2
while i*i<=n:
if n%i==0:
res.append(i)
while n%i==0:
n=int(n/i)
i+=1

if n!=1:
res.append(n)

return res

def dumpsol(UHJ0bVG4U):
for v in UHJ0bVG4U:
print(v,end=' ')

n=int(sys.stdin.readline())
l=sys.stdin.readline().strip().split("" "")[0:n]
l=[int(x) for x in l]
if n<12:
ret,UHJ0bVG4U=brute\_force([],[],l,[])
if ret:
print(""YES"")
dumpsol(UHJ0bVG4U)
else:
print(""NO"")
return

factors={}
for i in range(10):
for key in factor(l[i]):
factors[key]=0

flists={}
for f in factors:
flists[f]=[]
pos=0
found=False
for v in l:
if v%f!=0:
found=True
factors[f]+=1
flists[f].append(pos)
if (factors[f]>9):
break
pos+=1
if not found:
print(""NO"")
return

oftf=[]
isoftf={}
for f in factors:
if factors[f]==0:
print(""NO"")
return

if factors[f]<10:
oftf.append(f)
isoftf[f]=1

x=l[0]
UHJ0bVG4U[0]=2
oxf=factor(x)
xf=[]
nxf=0
isxoftf={}
for f in oxf:
if f in isoftf:
nxf+=1
isxoftf[f]=1
xf.append(f)
else:
UHJ0bVG4U[flists[f][0]]=2

nonxf=[]
for f in oftf:
if not f in isxoftf:
nonxf.append(f)

masks={}
pos=0

for f in xf+nonxf:
for v in flists[f]:
if not v in masks:
masks[v]=0
masks[v]|=1<<pos
pos+=1

vals=[{} for i in range(len(masks)+1)]
vals[0][0]=0
pos=0
mlist=[]
for mask in masks:
mlist.append(mask)
cmask=masks[mask]
cmask1=cmask<<10
for v in vals[pos]:
vals[pos+1][v|cmask]=v
if (mask!=0):
vals[pos+1][v|cmask1]=v
pos+=1

test\_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)
for v in vals[pos]:
if (v&test\_val)==test\_val:
print(""YES"")

while (pos!=0):
nv=vals[pos][v]
if (nv^v<1024 and nv^v!=0):
UHJ0bVG4U[mlist[pos-1]]=2
v=nv
pos-=1

dumpsol(UHJ0bVG4U)
return

print(""NO"")
</ans>",0,{}
265," <ans>
a, b, f, k = [int(i) for i in input().split()]

pm3zyN9 = b-f
usSzTCs = 0
ekN = 0
wLM4a = 0
while(usSzTCs != k):
if wLM4a == 0:
if pm3zyN9 >= a-f + a\*(k-usSzTCs-1):
break
if pm3zyN9 >= 2\*(a-f):
pm3zyN9 -= 2\*(a-f)
elif b >= 2\*(a-f):
ekN += 1
pm3zyN9 = b - 2\*(a-f)
else:
break

usSzTCs += 1
wLM4a = a
if wLM4a == a:
if pm3zyN9 >= f + a\*(k-usSzTCs-1):
break
if pm3zyN9 >= 2\*f:
pm3zyN9 -= 2\*f
elif b >= 2\*f:
ekN += 1
pm3zyN9 = b-2\*f
else:
break

usSzTCs += 1
wLM4a = 0

if usSzTCs == k:
print(ekN)
else:
print(-1)
</ans>",0,{}
266," <ans>
```python
import heapq
n,m,k = list(map(int,input().split()))
_J7 = []
for _ in range(n):
    _J7.append([])
GNbrc4 = []
for _ in range(m):
    x,y,w = list(map(int,input().split()))
    GNbrc4.append((x,y,w))
GNbrc4.sort(key = lambda x: x[2])
if k < m:
    av8HTM = GNbrc4[min(m,k) - 1][2]
else:
    av8HTM = sum([x[2] for x in GNbrc4])
eIOt = {}
AWGr = []
for i in range(n):
    eIOt[i] = [i]
    AWGr.append(i)

for i in range(min(m,k)):
    x,y,w = GNbrc4[i]
    _J7[x-1].append((y-1,w))
    _J7[y-1].append((x-1,w))
    if AWGr[x-1] != AWGr[y-1]:
        if len(eIOt[AWGr[x-1]]) >= len(eIOt[AWGr[y-1]]):
            prevColor = AWGr[y-1]
            for elem in eIOt[AWGr[y-1]]:
                AWGr[elem] = AWGr[x-1]
                eIOt[AWGr[x-1]].append(elem)
            del eIOt[prevColor]
        else:
            prevColor = AWGr[x-1]
            for elem in eIOt[AWGr[x-1]]:
                AWGr[elem] = AWGr[y-1]
                eIOt[AWGr[y-1]].append(elem)
            del eIOt[prevColor]

for key in eIOt:
    vertexList = eIOt[key]
    for mainVertex in vertexList:
        vertexPQueue = []
        Q_zlk = {}
        OTidly = {}
        for elem in vertexList:
            Q_zlk[elem] = False
            OTidly[elem] = av8HTM
        Q_zlk[mainVertex] = True
        for elem in _J7[mainVertex]:
            heapq.heappush(vertexPQueue,(elem[1],elem[0]))
            OTidly[elem[0]] = elem[1]
        while vertexPQueue:
            distance, curVertex = heapq.heappop(vertexPQueue)
            if Q_zlk[curVertex]:
                continue
            elif distance >= av8HTM:
                break
            for elem in _J7[curVertex]:
                if distance + elem[1] < OTidly[elem[0]]:
                    heapq.heappush(vertexPQueue,(distance + elem[1],elem[0]))
                    OTidly[elem[0]] = distance + elem[1]
        for key in OTidly:
            if OTidly[key] <= av8HTM and key > mainVertex:
                AWGr.append(OTidly[key])
        if len(AWGr) > k:
            AWGr.sort()
            AWGr = AWGr[0:k]
            if AWGr[-1] < av8HTM:
                av8HTM = AWGr[-1]
AWGr.sort()
print(AWGr[k-1])
```
</ans>",0,{}
267," <ans>
class Ddict:
def **init**(self):
self.dicts={}
def add(self,key):
d=self.dicts
for i in key:
if i not in d:
d[i]={}
d=d[i]
d[' ']=''
def find(self,key):
if key=='':
return '',''
d=self.dicts
q=[]
h=[key[0]]
for i in key:
if i not in d:
if ' ' in d and len(d)==1:
return ''.join(q),''.join(h)
return '',''
d=d[i]
if ' ' in d and len(d)==1:
return ''.join(q),''.join(h)
return '',''
GzK1J = 0
while True:
try:
x = G1EdwfOle
if not x:
break
except:
break
GzK1J+=len(x)+1
ws=[[]]
for i in x:
if i in '.,?!\'- ':
if ws[-1]:
ws.append([])
else:
ws[-1].append(i)
ws=list([''.join(e) for e in ws])
for w in ws:
next\_word,helped\_word = ZUm67a.find(w)
if next\_word and next\_word!=helped\_word:
GzK1J-=len(next\_word)-len(helped\_word)-1
ZUm67a.add(w)
print(GzK1J)
</ans>",0,{}
268," <ans>
```python
#from statistics import median
#import collections
#aa = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお a[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product # (string,3) 3回
#from collections import deque
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
#
#
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
import sys
sys.setrecursionlimit(10000000)
YHTk = 10**9 + 7
# YHTk = 9982443453
# YHTk = 998244353
Nr7e = float('inf')
from sys import stdin
R00Dk6Fq = stdin.readline
def readInts():
  return list(map(int,R00Dk6Fq().split()))
def readTuples():
    return tuple(map(int,R00Dk6Fq().split()))
def I():
    return int(R00Dk6Fq())
usQ_t = I()
sjMwN = 0
def dfs(T_njHeQ2J):
    if len(T_njHeQ2J) != 0:
        if int(T_njHeQ2J) > usQ_t:
            return
    if T_njHeQ2J.count('3') and T_njHeQ2J.count('5') and T_njHeQ2J.count('7'):
        nonlocal sjMwN
        sjMwN += 1
    for s in ""357"":
        T_njHeQ2J += s
        dfs(T_njHeQ2J)
        T_njHeQ2J = T_njHeQ2J[:-1]
dfs("""")
print(sjMwN)

```
</ans>",0,{}
269," <ans>
```python
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
from itertools import accumulate

#T = int(input())
PWPdi = input()
#N,M,K,Q = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

def computeGCD(x, y):

   while(y):
       x, y = y, x % y

   return x

A9osAVAi = {}

for x in range(10):
    for y in range(10):
        for d in range(10):
            m = 9999
            if (x==0 or y==0) and d==0:
                A9osAVAi[(x,y,d)] = 0
            elif x==0 and y==0 and d!=0:
                A9osAVAi[(x,y,d)] = -1
            else:
                for k in range(10):
                    d_tmp = d + 10*k
                    if x==0:
                        if d_tmp%y==0:
                            A9osAVAi[(x,y,d)] = d_tmp//y - 1
                            break

                    elif y==0:
                        if d_tmp%x==0:
                            A9osAVAi[(x,y,d)] = d_tmp//x - 1
                            break

                    else:
                        for a in range((d_tmp//x)+1):
                            for b in range((d_tmp//y)+1):
                                if x*a+y*b==d_tmp and d_tmp!=0:
                                    m = min(m,a+b-1)

                if (x,y,d) not in A9osAVAi:
                    if m==9999:
                        m = -1
                    A9osAVAi[(x,y,d)] = m
            #print(x,y,d,A9osAVAi[(x,y,d)])

G715xTqTN5 = [[0]*10 for _ in range(10)]

len_s = len(PWPdi)
PWPdi = list(PWPdi)
bax0B16 = [0]*10
for i in range(len_s-1):
    A = PWPdi[i]
    B = PWPdi[i+1]

    d = ord(B)-ord(A)
    if d<0:
        d += 10

    bax0B16[d] += 1

for x in range(10):
    for y in range(10):
        for d in range(10):
            if bax0B16[d]==0:
                G715xTqTN5[x][y] += 0
            elif A9osAVAi[(x,y,d)]==-1:
                G715xTqTN5[x][y] = -10000000
            else:
                G715xTqTN5[x][y] += bax0B16[d]*A9osAVAi[(x,y,d)]

for x in range(10):
    for y in range(10):
        if G715xTqTN5[x][y]<0:
            print(-1,end=' ')
        else:
            print(G715xTqTN5[x][y],end=' ')
    print('',end='\n')
```
</ans>",0,{}
270," <ans>
```python
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import math

#T = int(input())
#N = int(input())
#print(N)
N,r = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]

NYrADy = [0]*N

ZCm = [0]*N
eZIrR = [0]*N

pos = 0

for i in range(N):
    arr = [int(x) for x in stdin.readline().split()]
    ZCm[i] = arr[0]
    eZIrR[i] = arr[1]
    
    if eZIrR[i]>=0:
        pos += 1

for i in range(pos):
    TJcfH = -1
    start = 0
    WuEQBojc = -50000
    for j in range(N):
        # find available and largest gain
        # if gain tie, find largest start r
        if NYrADy[j]==1 or eZIrR[j]<0:
            continue
            
        if eZIrR[j]>WuEQBojc and r>=ZCm[j]:
            WuEQBojc = eZIrR[j]
            TJcfH = j
            start = ZCm[j]
        elif eZIrR[j]==WuEQBojc and r>=ZCm[j]:
            if ZCm[j]>start:
                TJcfH = j
                start = ZCm[j]
                
    if TJcfH==-1:
        print('NO')
        quit()
    else:
        NYrADy[TJcfH] = 1
        r += eZIrR[TJcfH]
        #print(idx,r)
        
        
rxAn = []
for i in range(N):
    if NYrADy[i]==1 or eZIrR[i]>=0:
        continue
    rxAn.append((ZCm[i],eZIrR[i],i))
    
rxAn.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)

for i in range(len(rxAn)):
    require = rxAn[i][0]
    bias = rxAn[i][1]
    
    if r>=require:
        r += bias
    else:
        print('NO')
        quit()
        
if r<0:
    print('NO')
    quit()
        
print('YES')
```
</ans>",0,{}
271," <ans>
from math import\*
from random import\*

VpJ3ze = int(input()) * 2
LMnHr = list(map(int, input().split()))
Y1G4NgZOI = [0] * 101

D\_J = []
for i in range(VpJ3ze):
if Y1G4NgZOI[LMnHr[i]] < 2:
Y1G4NgZOI[LMnHr[i]] += 1
D\_J += [(LMnHr[i], i)]
D\_J.sort()
x, y = [], []
for i in range(len(D\_J)):
if(i % 2 == 0):
x.append(D\_J[i][1])
else:
y.append(D\_J[i][1])
f8TpJ4kO = 0
WPn7 = 0
# print(x)
# print(y)
print(len(x) * len(y))
for i in range(VpJ3ze):
if i in x:
f8TpJ4kO += 1
WPn7 += 1
print(1, end = ' ')
elif i in y:
print(2, end = ' ')
else:
if len(x) - f8TpJ4kO + WPn7 < VpJ3ze // 2:
print(1, end = ' ')
WPn7 += 1
else:
print(2, end = ' ')
print()

# D\_J, C = [], []
# for i in range(VpJ3ze):


# S = list(set(LMnHr))
# where = [0] * 101
# am1, am2 = 0, 0
# for i in range(len(S)):
# if(i % 2 == 0):
# where[S[i]] = 1
# am1 += 1
# else:
# where[S[i]] = 2
# am2 += 1
# used = [0] * 201
# for i in range(VpJ3ze):
# if not used[LMnHr[i]]:
# print(where[LMnHr[i]])
# used[LMnHr[i]] = True
# else:
# print(3 - where[LMnHr[i]])
</ans>",0,{}
272," <ans>
def check(mid):
y39X = []
oyu8j3Tt = 0
for c, count in GKpybgkDkY:
tmp = count // mid
if (count % mid != 0):
tmp += 1
y39X.append((c, tmp))
oyu8j3Tt += tmp
return oyu8j3Tt <= n, y39X

AqVJ = input()
oyu8j3Tt = int(input())
GKpybgkDkY = dict()
t = 0
for i in AqVJ:
if i not in GKpybgkDkY:
GKpybgkDkY[i] = 1
t += 1
else: GKpybgkDkY[i] += 1
ans = []
res = """"
for i in GKpybgkDkY:
ans.append(i)
res = i
if oyu8j3Tt >= len(AqVJ):
print(1)
print(AqVJ, end = '')
oyu8j3Tt -= len(AqVJ)
for u in range(oyu8j3Tt):
print(res, end ='')
else:
GKpybgkDkY = (sorted(GKpybgkDkY.items(), key = lambda GKpybgkDkY:(GKpybgkDkY[1], GKpybgkDkY[0])))
l = 1
r = len(AqVJ)
res = []
count\_res = 0
while (l <= r):
mid = (l + r) // 2
flag, tmp = check(mid)
if (flag):
r = mid - 1
count\_res = mid
res = tmp
else:
l = mid + 1
if (len(res) == 0):
print(-1)
else:
ttt = 0
print(count\_res)
for c, sl in res:
for j in range(sl):
print(c, end = '')
ttt += 1
oyu8j3Tt -= ttt
for i in range(oyu8j3Tt):
print(AqVJ[0], end = '')
</ans>",0,{}
273," <ans>
```python
""""""
Codeforces Contest Good Bye 2",0,{}
274," <ans>
from math import log2, floor

def is\_power2(num):
return num != 0 and ((num & (num - 1)) == 0)

def next\_two\_pow(val):
eCbsE0Uo=0
while 2\*\*eCbsE0Uo <= val:
eCbsE0Uo+=1
return eCbsE0Uo

h2x = int(input())
htdEa=[int(x) for x in input().split()]

l4Cz =-1
Mrx3LYbu=[]

for i in range(1,h2x+1):
la0 = htdEa[i-1]
if l4Cz ==-1:
if la0 == -1:
l4Cz =i
else:
if is\_power2(i):
Mrx3LYbu.append(la0)
Mrx3LYbu.sort()
else:
if len(Mrx3LYbu) > 0 and la0 < Mrx3LYbu[-1]:
Mrx3LYbu.pop()
Mrx3LYbu.append(la0)
Mrx3LYbu.sort()

print(sum(Mrx3LYbu))
</ans>",0,{}
275," <ans>
import sys

\_INPUT\_LINES = sys.stdin.read().splitlines()
Iefw = iter(\_INPUT\_LINES).**next**

def go():
\_gqT0DG4YA = int(Iefw())
i2b\_H = list(map(int, Iefw().split()))
OwVG1 = {i: set() for i in range(\_gqT0DG4YA)}
for _ in range(\_gqT0DG4YA - 1):
u, v = list(map(int, Iefw().split()))
u, v = u - 1, v - 1
OwVG1[u].add(v)
OwVG1[v].add(u)
\_W\_bFWrodV = [len(OwVG1[i]) for i in range(\_gqT0DG4YA)]
y40c0WgL = [i for i in range(\_gqT0DG4YA) if \_W\_bFWrodV[i] == 1]
index = 0
pvrGcKe2tW = {i: {} for i in range(\_gqT0DG4YA)}
RpKAmV = set()
while index < len(y40c0WgL):
cur = y40c0WgL[index]
\_0RMTx = sum(pvrGcKe2tW[cur].values())

if i2b\_H[cur] == 0:
\_0RMTx -= 1
else:
\_0RMTx += 1

for i in OwVG1[cur] - RpKAmV:
pvrGcKe2tW[i][cur] = max(\_0RMTx, 0)
\_W\_bFWrodV[i] -= 1
if \_W\_bFWrodV[i] == 1:
y40c0WgL.append(i)
RpKAmV.add(cur)
index += 1

IzrNtz6R = [0] * \_gqT0DG4YA
que = [\_W\_bFWrodV.index(0)]
done = set()
index = 0
while index < len(que):
cur = que[index]

\_0RMTx = sum(pvrGcKe2tW[cur].values())

if i2b\_H[cur] == 0:
\_0RMTx -= 1
else:
\_0RMTx += 1

IzrNtz6R[cur] = \_0RMTx

for i in OwVG1[cur] - done:
pvrGcKe2tW[i][cur] = max(\_0RMTx - pvrGcKe2tW[cur][i], 0)
que.append(i)

done.add(cur)
index += 1

return ' '.join(map(str,IzrNtz6R))

for _ in range(1):
print(go())
</ans>",0,{}
276," <ans>
import sys
sys.setrecursionlimit(10000000)
cfoaZJVu9 = 10**9 + 7
#cfoaZJVu9 = 9982443453
#cfoaZJVu9 = 998244353
dWsib8UPUk = float('inf')
from sys import stdin
JfX8Wl2JEh = stdin.readline
def readInts():
  return list(map(int,JfX8Wl2JEh().split()))
def readTuples():
    return tuple(map(int,JfX8Wl2JEh().split()))
def I():
    return int(JfX8Wl2JEh())
noqoLHbB3 = I()
x1f = readInts()
uH2gsB4s6i = readInts()
Rk7 = 0
for i in range(noqoLHbB3):
    tfiV = uH2gsB4s6i[i]
    # kill = x1f[i] + x1f[i+1]
    nya = min(tfiV, x1f[i])
    x1f[i] -= nya
    tfiV -= nya
    Rk7 += nya
    nya = min(x1f[i+1], tfiV)
    Rk7 += nya
    x1f[i+1] -= nya
print(Rk7)
</ans>",0,{}
277," <ans>
def solve(s,t):
pzm = [False] \* 256
r5Zsbx = [False] \* 256
SfYVpFRF = []
n = len(s)
for c in s:
pzm[ord(c)] = True
for c in t:
r5Zsbx[ord(c)] = True
for i in range(256):
if not pzm[i] and r5Zsbx[i]:
print(-1)
return
rev = s[::-1]
i,j = 0,0
while i < len(t):
flag = True
temp = t[i]
j = i + 1
while j < len(t):
temp += t[j]
if temp not in s and temp not in rev:
flag = False
break
j += 1
if flag:
x = s.find(temp)
if x != -1:
SfYVpFRF.append((x + 1,x + len(temp)))
else:
y = rev.find(temp)
SfYVpFRF.append((n - y,n - y - len(temp) + 1))
else:
x = s.find(temp[:-1])
if x != -1:
SfYVpFRF.append((x + 1,x + len(temp) - 1))
else:
x = rev.find(temp[:-1])
SfYVpFRF.append((n - x,n - x - len(temp) + 2))
i = j
print(len(SfYVpFRF))
for x,y in SfYVpFRF:
print(x,y)

s = input()
t = input()

solve(s,t)
</ans>",0,{}
278," <ans>
from itertools import chain
import sys

def main():
QhYB9 = int(input())
# TLEs were caused mostly by slow input (1s+)
# S = list(input() for _ in range(N))
awHqQ = sys.stdin.read().split(**'\n'**)
print((solve(awHqQ)))

def get\_count(args):
s, result = args # messy input to work with map.
cum\_sum = 0
for c in s:
if c == **')'**:
cum\_sum -= 1
else:
cum\_sum += 1
result[0] = max(result[0], -cum\_sum)
result[1] = result[0] + cum\_sum
return result

# Made-up name, don't remember what to call this. Radix-ish
def silly\_sort(array, value\_min, value\_max, get\_value):
if len(array) == 0:
return
Qr7 = [None for _ in range(value\_max - value\_min + 1)]
for elem in array:
# Assume elem[0] is the value
value = get\_value(elem) - value\_min
if Qr7[value] is None:
Qr7[value] = []
Qr7[value].append(elem)
for values in Qr7:
if values is None:
continue
for value in values:
yield value

def solve(awHqQ):
zqqCCc = [[0,0] for _ in range(len(awHqQ))]
zqqCCc = list(map(get\_count, list(zip(awHqQ,zqqCCc))))
xOXhEWVO = []
FwukPnF = []
min\_first\_group = float('inf')
max\_first\_group = 0
min\_second\_group = float('inf')
max\_second\_group = 0

for c in zqqCCc:
if c[0] - c[1] <= 0:
xOXhEWVO.append(c)
max\_first\_group = max(max\_first\_group, c[0])
min\_first\_group = min(min\_first\_group, c[0])
else:
FwukPnF.append(c)
max\_second\_group = max(max\_second\_group, c[1])
min\_second\_group = min(min\_first\_group, c[1])
xOXhEWVO = silly\_sort(xOXhEWVO, min\_first\_group, max\_first\_group, lambda c: c[0])
FwukPnF = reversed(list(silly\_sort(FwukPnF, min\_second\_group, max\_second\_group, lambda c: c[1])))

SgO1b = chain(xOXhEWVO, FwukPnF)

cum\_sum = 0
for c in SgO1b:
cum\_sum -= c[0]
if cum\_sum < 0:
return 'No'
cum\_sum += c[1]
if cum\_sum == 0:
return 'Yes'
return 'No'

def **__starting\_point**():
main()

**__starting\_point**()
</ans>",0,{}
279," <ans>
import math
from functools import reduce
class SegmentTree():
def **init**(self, L, function = lambda x,y: x+y):
self.function = function
self.RQ9y = len(L)
self.gcTbiLQ = 1 << self.RQ9y.bit\_length()
self.margin = 2\*self.gcTbiLQ - self.RQ9y
self.L = [None for i in range(self.margin)] + L
for i in range(self.gcTbiLQ-1, 0, -1):
x, y = self.L[i<<1], self.L[i<<1|1]
self.L[i] = None if x is None or y is None else function(x, y)
def modify(self, pos, value):
p = pos + self.margin
self.L[p] = value
while p > 1:
x, y = self.L[p], self.L[p^1]
if p&1: x, y = y, x
self.L[p>>1] = None if x is None or y is None else self.function(x, y)
p>>=1
def query(self, left, right):
l, r = left + self.margin, right + self.margin
stack = []
YnbcjMmqr = True
while l < r:
if l&1:
if YnbcjMmqr:
result = self.L[l]
YnbcjMmqr = False
else:
result = self.function(result, self.L[l])
l+=1
if r&1:
r-=1
stack.append(self.L[r])
l>>=1
r>>=1
init = stack.pop() if YnbcjMmqr else result
return reduce(self.function, reversed(stack), init)

self.RQ9y = int(input())
pies, index, first\_equal = [0]*self.RQ9y, [0]*self.RQ9y, [0]*self.RQ9y
for i in range(self.RQ9y):
r, h = [int(x) for x in input().split()]
pies[i] = r*r*h
lBjiaQQnsu = list(sorted(enumerate(pies), key = lambda p: p[1]))
for i in range(self.RQ9y): index[lBjiaQQnsu[i][0]] = i
for i in range(1, self.RQ9y):
first\_equal[lBjiaQQnsu[i][0]] = i if lBjiaQQnsu[i][1] != lBjiaQQnsu[i-1][1] else first\_equal[lBjiaQQnsu[i-1][0]]
MeZGXJvTYR = SegmentTree([0]*(self.RQ9y+1), max)
for j, pie in enumerate(pies):
i, k = index[j], first\_equal[j]
q = MeZGXJvTYR.query(0, k+1)
MeZGXJvTYR.modify(i+1, q + pie)
print(math.pi \* MeZGXJvTYR.query(0, self.RQ9y+1))
</ans>",0,{}
280," <ans>
```
# returns answer to the subproblem with interval range [start, Bf3],
# but with a total of ""extra"" additional stuff on the end.
# that must be deleted last.
memo = {}
def f(dat, I4kkgx, start, Bf3, extra):
    curr = (start, Bf3, extra)
    if curr in memo:
        return memo[curr]
    
    if start > Bf3:
        return ",0,{}
281," <ans>
import sys
D0xV7 = (s.rstrip() for s in sys.stdin)
AVYL0p622 = D0xV7.__next__

class RAQ\_RMQ():
def **init**(self, n, inf=2**31-1):
self.n0 = 1<<(n-1).bit\_length()
self.INF = inf
self.data = [0]*(2*self.n0)
self.lazy = [0]*(2*self.n0)

def getIndex(self, x3Q, r):
x3Q += self.n0; r += self.n0
x3Qm = (x3Q // (x3Q & -x3Q)) >> 1
rm = (r // (r & -r)) >> 1
while x3Q < r:
if r <= rm:
yield r
if x3Q <= x3Qm:
yield x3Q
x3Q >>= 1; r >>= 1
while x3Q:
yield x3Q
x3Q >>= 1

def propagates(self, *ids):
for i in reversed(ids):
v = self.lazy[i-1]
if not v:
continue
self.lazy[2*i-1] += v; self.lazy[2*i] += v
self.data[2*i-1] += v; self.data[2*i] += v
self.lazy[i-1] = 0

def update(self, x3Q, r, x):
*ids, = self.getIndex(x3Q, r)

x3Q += self.n0; r += self.n0
while x3Q < r:
if r & 1:
r -= 1
self.lazy[r-1] += x; self.data[r-1] += x
if l & 1:
self.lazy[x3Q-1] += x; self.data[x3Q-1] += x
x3Q += 1
l >>= 1; r >>= 1
for i in ids:
self.data[i-1] = min(self.data[2*i-1], self.data[2*i]) + self.lazy[i-1]

def query(self, x3Q, r):
self.propagates(*self.getIndex(x3Q, r))
x3Q += self.n0; r += self.n0

s = self.INF
while x3Q < r:
if r & 1:
r -= 1
s = min(s, self.data[r-1])
if x3Q & 1:
s = min(s, self.data[x3Q-1])
x3Q += 1
return s

n,m,k = map(int, AVYL0p622().split())
x3Q = [0]*(n+1)
now = k
point = [0]*n
for i in range(n):
a,b,c = map(int, AVYL0p622().split())
point[i] = c
now = now-a
x3Q[i] = now
now += b+a
x3Q[n] = now

E9b9 = RAQ\_RMQ(n+1)
for i in range(n+1):
E9b9.update(i,i+1,x3Q[i])

lpXj2Pu = list(range(n))
for i in range(m):
u,v = map(int, AVYL0p622().split())
u,v = u-1, v-1
if lpXj2Pu[v]<u:
lpXj2Pu[v] = u

if E9b9.query(0, n+1) < 0:
print(-1)
return

heap = [(-point[i], -lpXj2Pu[i]) for i in range(n)]
from heapq import heapify, heappop
heapify(heap)

QZQp = 0
while heap:
p,i = heappop(heap)
p,i = -p,-i
if E9b9.query(i+1, n+1)>0:
QZQp += p
E9b9.update(i+1, n+1, -1)

print(QZQp)
</ans>",0,{}
282," <ans>
import sys
from collections import deque

vYG=1
for _ in range(int(input())):
mFGpvFKHA=int(input())
zh6=set([0,2*10**5+1])
R0eRjdBY=[(0,2*10**5+1)]
for i in range(mFGpvFKHA):
l,r=map(int,input().split())
zh6.add(l)
zh6.add(r)
R0eRjdBY.append((l,r))
zh6=list(zh6)
zh6.sort()
X2MCt8bev={i:e+1 for e,i in enumerate(zh6)}
for i in range(mFGpvFKHA+1):
l,r=R0eRjdBY[i]
R0eRjdBY[i]=(X2MCt8bev[l],X2MCt8bev[r])

T\_kZ=[0]*(mFGpvFKHA+1)
qw2=[[] for i in range(mFGpvFKHA+1)]
for i in range(mFGpvFKHA+1):
for j in range(i+1,mFGpvFKHA+1):
l,r=R0eRjdBY[i]
L,R=R0eRjdBY[j]
if L<=l and r<=R:
qw2[j].append(i)
T\_kZ[i]+=1
elif l<=L and R<=r:
qw2[i].append(j)
T\_kZ[j]+=1

ZsuI=[0]
ZsuI.append(0)

while ZsuI:
v=ZsuI.popleft()
for nv in qw2[v]:
T\_kZ[nv]-=1
if T\_kZ[nv]==0:
ZsuI.append(nv)
qw2[v].append(nv)

zAR1nX=[0]*(mFGpvFKHA+1)

def solve(v):
query=[]
for nv in qw2[v]:l,r=R0eRjdBY[nv];query.append((l,zAR1nX[nv]))
subdp=[0]*(2*mFGpvFKHA+3)
for i in range(1,2*mFGpvFKHA+3):
res=subdp[i-1]
for l,val in query:test=subdp[l-1]+val;res=max(test,res)
subdp[i]=res

zAR1nX[v]=subdp[-1]+1

for v in qw2[::-1]:solve(v)

print(zAR1nX[0]-1)
</ans>",0,{}
283," <ans>
n=int(input())
arr=list(map(int,input().split()))
dict1={}
for i in range(2*n):
try:
dict1[arr[i]].append(i+1)
dict1[arr[i]].sort()
except:
KeyError
dict1[arr[i]]=[i+1]
ans=0
rPfKh4Jav=1
QQOmIB=1
for i in range(1,n+1):
if(i==1):
ans+=(dict1[i][0]-rPfKh4Jav)
ans+=(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
elif(dict1[i][0]>rPfKh4Jav and dict1[i][0]>QQOmIB):
ans+=(dict1[i][0]-rPfKh4Jav)
ans+=(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
elif(dict1[i][1]<rPfKh4Jav<QQOmIB):
ans+=abs(dict1[i][0]-rPfKh4Jav)
ans+=abs(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
elif(dict1[i][0]<rPfKh4Jav and rPfKh4Jav<dict1[i][1]<QQOmIB):
ans+=abs(dict1[i][0]-rPfKh4Jav)
ans+=abs(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
elif(dict1[i][0]<rPfKh4Jav and dict1[i][1]<QQOmIB):
ans+=abs(dict1[i][0]-rPfKh4Jav)
ans+=abs(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
elif(rPfKh4Jav<dict1[i][0]<dict1[i][1]<QQOmIB):
ans+=abs(dict1[i][0]-rPfKh4Jav)
ans+=abs(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
else:
ans+=abs(dict1[i][0]-rPfKh4Jav)
ans+=abs(dict1[i][1]-QQOmIB)
rPfKh4Jav=dict1[i][0]
QQOmIB=dict1[i][1]
print(ans)
</ans>",0,{}
284," <ans>
def gcd(a,b):
while b:
a, b = b, a%b
return a

Bpc5 = int(input())
hJqAY = [[int(x) for x in input().split()] for _ in range(Bpc5)]

DDPTUafDK = []
def addLine(x,y,dx,dy):
if dx < 0:
dx *= -1
dy *= -1
elif dx == 0:
if dy < 0:
dy *= -1

xp1ENZeR = gcd(dx,dy)
dx //= xp1ENZeR
dy //= xp1ENZeR

x += dx * (10**9)
y += dy * (10**9)
if dx:
qFCka\_J = x//dx
else:
qFCka\_J = y//dy
x -= qFCka\_J*dx
y -= qFCka\_J*dy
DDPTUafDK.append((x,y,dx,dy))

from collections import defaultdict as dd, deque

DDPTUafDK = list(set(DDPTUafDK))
NCPxWKCth = 0

DT\_m = dd(int)
for x,y,dx,dy in DDPTUafDK:
DT\_m[dx,dy] += 1

qrxV = sum(DT\_m.values())

for x in DT\_m.values():
NCPxWKCth += (qrxV-x)*x

print(NCPxWKCth//2)
</ans>",0,{}
285," <ans>
import sys
input = sys.stdin.readline

n,m=list(map(int,input().split()))
pCBGRrahP=[list(map(int,input().split())) for i in range(n)]

for i in range(m):
#一行目をi-1まで0にする

t8x=[0]*n
lqG7Icze4K=[0]*m

for j in range(i):
if pCBGRrahP[0][j]==1:
lqG7Icze4K[j]=1

for j in range(i,m):
if pCBGRrahP[0][j]==0:
lqG7Icze4K[j]=1

for r in range(1,n):
c5DV=set()
for c in range(m):
if lqG7Icze4K[c]==0:
c5DV.add(pCBGRrahP[r][c])
else:
c5DV.add(1-pCBGRrahP[r][c])

if len(c5DV)>=2:
break
if max(c5DV)==0:
t8x[r]=1

else:
print(""YES"")
print("""".join(map(str,t8x)))
print("""".join(map(str,lqG7Icze4K)))
return

t8x=[0]*n
lqG7Icze4K=[0]*m

for j in range(m):
if pCBGRrahP[0][j]==1:
lqG7Icze4K[j]=1

tksxB4xwB=0
for r in range(1,n):
if tksxB4xwB==0:
c5DV=[]
for c in range(m):
if lqG7Icze4K[c]==0:
c5DV.append(pCBGRrahP[r][c])
else:
c5DV.append(1-pCBGRrahP[r][c])

if max(c5DV)==0:
continue
elif min(c5DV)==1:
t8x[r]=1
continue
else:
abH326shh2=c5DV.index(1)
if min(c5DV[abH326shh2:])==1:
tksxB4xwB=1
continue

svn5Zh3g=c5DV.index(0)
if max(c5DV[svn5Zh3g:])==0:
tksxB4xwB=1
t8x[r]=1
continue

else:
print(""NO"")
return

else:

c5DV=set()
for c in range(m):
if lqG7Icze4K[c]==0:
c5DV.add(pCBGRrahP[r][c])
else:
c5DV.add(1-pCBGRrahP[r][c])

if len(c5DV)>=2:
break
if max(c5DV)==0:
t8x[r]=1

else:
print(""YES"")
print("""".join(map(str,t8x)))
print("""".join(map(str,lqG7Icze4K)))
return

print(""NO"")
</ans>",0,{}
286," <ans>
""""""Cowboy Beblop at his computer, problem 717I from https://codeforces.com/problemset/problem/717/I""""""
# from fractions import Fraction


# def convert_to_fractions(MLucwY):
#     """"""convert polygon vertex to fractional type""""""
#     MLucwY_frac = []
#     for M_KqsnHNs in MLucwY:
#         vertex = (Fraction(M_KqsnHNs[0]),
#                   Fraction(M_KqsnHNs[1]),
#                   Fraction(M_KqsnHNs[2]))
#         MLucwY_frac.append(vertex)
#     return MLucwY_frac


def convert_to_float(MLucwY):
    """"""convert polygon vertex to float type""""""
    MLucwY_float = []
    for M_KqsnHNs in MLucwY:
        vertex = (float(M_KqsnHNs[0]),
                  float(M_KqsnHNs[1]),
                  float(M_KqsnHNs[2]))
        MLucwY_float.append(vertex)
    return MLucwY_float


def cross_product(a, b):
    """"""3-vector product""""""
    return (a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0])


def dot_product(a, b):
    """"""scalar product of 3-vectors""""""
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]


def vect_diff(a, b):
    """"""vector difference""""""
    return a[0] - b[0], a[1] - b[1], a[2] - b[2]


def poly_normal(MLucwY):
    """"""return normal vector for first three vertex""""""
    assert len(MLucwY) >= 3
    x, y, z = MLucwY[:3]
    u = vect_diff(y, x)
    v = vect_diff(z, y)
    return cross_product(u, v)


def intersect_list(MLucwY, plain_norm, plain_point, proj_dir):
    """"""list of intersection points

    find points where the edges enter or leave upper half-space over the plain
    :return list of points projection on proj_dir
    """"""
    # vertex projection
    u = [dot_product(vert, proj_dir) for vert in MLucwY]

    # plain anchor
    vr = dot_product(plain_point, plain_norm)

    # polygon vertex
    v = [dot_product(vert, plain_norm) for vert in MLucwY]

    wZNudME0 = []
    for i in range(len(MLucwY)):
        if (v[i-1] > vr) != (v[i] > vr):
            aEl = ((vr - v[i-1]) * u[i] + (v[i] - vr) * u[i-1]) / (v[i] - v[i-1])
            wZNudME0.append(aEl)

    return wZNudME0


def points_to_str(aUzNVLk, h7AAK):
    """"""string representing the order of points 'a' and 'b'""""""
    xOO = [('a', val) for val in aUzNVLk]
    t1f = [('b', val) for val in h7AAK]
    HrNdRq = sorted(xOO + t1f, key=lambda pair: pair[1])
    abzR40 = [ch for ch, _ in HrNdRq]
    return ''.join(abzR40)


def recognize_str(s):
    """"""return True if string s belong to the grammar

    The context-free grammar is given
    S -> SS
    S -> a S a
    S -> b S b
    S -> e

    The recognising automaton is implemented
    """"""
    RLV = {'a':'b', 'b':'a'}
    NTP1hj0 = 0
    BmpGwT3 = None
    for ch in s:
        if not NTP1hj0:
            NTP1hj0 = 1
            BmpGwT3 = ch
            continue

        if ch == BmpGwT3:
            NTP1hj0 -= 1
        else:
            NTP1hj0 += 1

        if NTP1hj0:
            BmpGwT3 = RLV[BmpGwT3]
        else:
            BmpGwT3 = None
    return not NTP1hj0


def is_well_connected(myaNpE9, boPE5J):
    """"""Two planar polygons are bind together in 3D

    Arguments:
        a_poly,
        b_poly -- lists of vertex triples
    """"""
    myaNpE9 = convert_to_float(myaNpE9)
    boPE5J = convert_to_float(boPE5J)

    MvxubqK = poly_normal(myaNpE9)
    gMLSItr = poly_normal(boPE5J)

    szXOEZXUsn = cross_product(MvxubqK, gMLSItr)
    if not any(szXOEZXUsn):
        return False

    aUzNVLk = intersect_list(myaNpE9, gMLSItr, boPE5J[0], szXOEZXUsn)
    h7AAK = intersect_list(boPE5J, MvxubqK, myaNpE9[0], szXOEZXUsn)

    rlBeylCwW = points_to_str(aUzNVLk, h7AAK)
    return not recognize_str(rlBeylCwW)


def run_from_console():
    myaNpE9_len, = [int(num) for num in input().split()]

    myaNpE9 = []
    for _ in range(myaNpE9_len):
        vertex = tuple(int(num) for num in input().split())
        myaNpE9.append(vertex)

    boPE5J_len, = [int(num) for num in input().split()]

    boPE5J = []
    for _ in range(boPE5J_len):
        vertex = tuple(int(num) for num in input().split())
        boPE5J.append(vertex)

    if is_well_connected(myaNpE9, boPE5J):
        print('YES')
    else:
        print('NO')


def __starting_point():
    run_from_console()
__starting_point()
</ans>",0,{}
287," <ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


zywkg0L6M_ = 97
def ii(): return int(input())
def mi(): return list(map(int, input().split()))
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
if n < 2: return list()
prime = [True for _ in range(n + 1)]
p = 3
while p * p <= n:
if prime[p]:
for i in range(p * 2, n + 1, p):
prime[i] = False
p += 2
r = [2]
for p in range(3, n + 1, 2):
if prime[p]:
r.append(p)
return r
def divs(n, start=2):
r = []
for i in range(start, int(math.sqrt(n) + 1)):
if (n % i == 0):
if (n / i == i):
r.append(i)
else:
r.extend([i, n // i])
return r
def divn(n, primes):
divs\_number = 1
for i in primes:
if n == 1:
return divs\_number
t = 1
while n % i == 0:
t += 1
n //= i
divs\_number \*= t
def gylEPX6Cg(n):
if n == 2: return True
if n % 2 == 0 or n <= 1: return False
sqr = int(math.sqrt(n)) + 1
for d in range(3, sqr, 2):
if n % d == 0: return False
return True
def convn(number, base):
newnumber = 0
while number > 0:
newnumber += number % base
number //= base
return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


for _ in range(ii()):
iUIcC = ii()
pnJMcl = li()
if iUIcC == 1 and pnJMcl[0] & 1:
print(-1)
else:
for i in range(iUIcC):
if pnJMcl[i] % 2 == 0:
print(1)
print(i + 1)
break
else:
print(2)
print(1, 2)
</ans>",0,{}
288," <ans>
n, k = list(map(int, input().split()))
p  = {}
np = {}
pair    = []
used    = {}
rev\_d   = {}

def push(d, s, v):
if s not in d:
d[s] = []
d[s].append(v)

def is\_pal(s):
n = len(s)
flg=True
for i in range(n//2):
if s[i] != s[n-1-i]:
flg = False
break
return flg

def rev(s):
return s[::-1]

for _ in range(n):
s, val = input().split()
val = int(val)

if is\_pal(s):
push(p, s, val)
else:
push(np, s, val)

if s not in rev\_d:
rev\_d[s] = rev(s)

for k, v in list(p.items()):
p[k] = sorted(v, reverse=True)

for k, v in list(np.items()):
np[k] = sorted(v, reverse=True)

for s in np:
if s not in used and rev\_d[s] in np:
pair.append([s, rev\_d[s]])
used[s] = True
used[rev\_d[s]] = True

max\_remain = 0
minus = 0
max\_S = 0

for v\_arr in list(p.values()):
n = len(v\_arr)
for i in range(0, n, 2):
if i+1==n:
if v\_arr[i] > 0:
max\_remain = max(max\_remain, v\_arr[i])

else:
if v\_arr[i] + v\_arr[i+1] >= 0:
max\_S += v\_arr[i] + v\_arr[i+1]

if v\_arr[i+1] < 0:
minus = min(minus, v\_arr[i+1])
else:
max\_remain = max(max\_remain, v\_arr[i])

for [u, v] in pair:
n = min(len(np[u]), len(np[v]))

for x, y in zip(np[u][:n], np[v][:n]):
if x+y > 0:
max\_S += x+y

print(max(max\_S+max\_remain, max\_S-minus))
</ans>",0,{}
289," <ans>
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    tljz6bC4 = a//k
    I3oULM = (a-tljz6bC4*k)%(tljz6bC4+1)
    if I3oULM==0:
        return a//k
    iDskFv2 = (a-tljz6bC4*k)//(tljz6bC4+1) + 1
    #print(a,k,tljz6bC4,iDskFv2)
    return grundy(a-(tljz6bC4+1)*iDskFv2,k)
""""""
def grundy(a,k): #石 a 個、最大 x//k までとれる
    #print(a,k)
    if a < k:
        return 0
    tljz6bC4 = a//k
    r = (a-tljz6bC4*k)%(tljz6bC4+1)
    if r==0:
        return a//k
    v = (a-tljz6bC4*k)//(tljz6bC4+1) + 1
    #print(a,k,tljz6bC4,v)
    return grundy(a-(tljz6bC4+1)*v,k)


""""""
K = 10
N = 50
V = 5
for k in range(V,V+1):
    a = [0]*N
    for i in range(1,N):
        s = set()
        for j in range(1,1+i//k):
            s.add(a[i-j])
        for j in range(N):
            if j not in s:
                a[i] = j
                break
    
    #print(k,a)
    #for i in range(N//V):
    #    print(a[i*V:(i+1)*V])

    
    b = [grundy(i,k) for i in range(N)]
    print(a)
    print(b)
    assert a==b
""""""
# coding: utf-8
# Your code here!
import sys
a5jEQ = sys.stdin.readline
read = sys.stdin.read
sys.setrecursionlimit(10**8)

n, = list(map(int,a5jEQ().split()))
fhdaEDs = 0
for _ in range(n):
    a,k = list(map(int,a5jEQ().split()))
    fhdaEDs ^= grundy(a,k)
if fhdaEDs:
    print(""Takahashi"")
else:
    print(""Aoki"")
</ans>",0,{}
290," <ans>
mYP6P = input()
js7jHQm=[]
G0h =0
Zehlm=''
sYQCzL9zeX =0 if mYP6P[0]=='""' else ",0,{}
291," <ans>
def main1():
buf = input()
nCy = buf.split()
Hng\_rSXz = int(nCy[0])
rJX = int(nCy[1])
buf = input()
nCy = buf.split()
qCyr6HJNO = list(map(int, nCy))
DzYOT2qoxV = []
CMzfuD = []
for i in range(Hng\_rSXz):
IfDPz1g = 0
b\_2bqV7Xq = 0
while b\_2bqV7Xq < i:
if IfDPz1g + DzYOT2qoxV[b\_2bqV7Xq] <= rJX - qCyr6HJNO[i]:
IfDPz1g += DzYOT2qoxV[b\_2bqV7Xq]
b\_2bqV7Xq += 1
else:
break
CMzfuD.append(i - b\_2bqV7Xq)
DzYOT2qoxV.append(qCyr6HJNO[i])
DzYOT2qoxV.sort()
print(' '.join(list(map(str, CMzfuD))))

def main2():
buf = input()
nCy = buf.split()
Hng\_rSXz = int(nCy[0])
rJX = int(nCy[1])
buf = input()
nCy = buf.split()
qCyr6HJNO = list(map(int, nCy))
VDu = []
for i in range(101):
VDu.append(0)
CMzfuD = []
for i in range(Hng\_rSXz):
b9p = rJX - qCyr6HJNO[i]
IfDPz1g = 0
subtotal = 0
for j in range(1, 101):
if subtotal + VDu[j] \* j > b9p:
IfDPz1g += (b9p - subtotal) // j
break
else:
IfDPz1g += VDu[j]
subtotal += VDu[j] \* j
CMzfuD.append(i - IfDPz1g)
VDu[qCyr6HJNO[i]] += 1
print(' '.join(list(map(str, CMzfuD))))

def __starting\_point():
#main1() # for C1
main2() # for C2

__starting\_point()
</ans>",0,{}
292," <ans>
import itertools
from collections import deque,defaultdict,Counter
from itertools import accumulate
import bisect
from heapq import heappop,heappush,heapify
import math
from copy import deepcopy
import queue

Mod = mcoM
prime = X7eoBBW
fact = i\_vGh
n = RlxogMJIWK
l = C\_8
inv = Bh3
factinv = CEdZQhg1
res = qBgZ
ans = jx9OKM

for i in range(2, RlxogMJIWK + 1):
if X7eoBBW[i] == 1:
for j in range(2*i,RlxogMJIWK+1):
if j%i == 0:
X7eoBBW[j] = 0
res = []
for i in range(2,RlxogMJIWK+1):
if X7eoBBW[i] == 1:
res.append(i)
return res

class UnionFind:
def **init**(self,n):
self.parent = [i for i in range(n+1)]
self.rank = [0 for i in range(n+1)]

def findroot(self,x):
if x == self.parent[x]:
return x
else:
y = self.parent[x]
y = self.findroot(self.parent[x])
return y

def union(self,x,y):
px = self.findroot(x)
py = self.findroot(y)
if px < py:
self.parent[y] = px
else:
self.parent[px] = py

def same\_group\_or\_no(self,x,y):
return self.findroot(x) == self.findroot(y)
def pow\_k(x, n):

if n == 0:
return 1

K = 1
while n > 1:
if n % 2 != 0:
K \*= x
x \*= x
n //= 2

return K \* x
def main(): #startline-------------------------------------------
RlxogMJIWK = int(input())
m6QxF = list(map(int, input().split()))
LWuLFsa64 = defaultdict(int)
ans = 0
for i in range(RlxogMJIWK):
l = i - m6QxF[i]
ans += LWuLFsa64[l]
LWuLFsa64[m6QxF[i] + i] += 1

print(ans)
def **starting\_point**():
main() #endline===============================================
**starting\_point**()
</ans>",0,{}
293," <ans>
import sys
sys.setrecursionlimit(10**9)

P3YmiQPX = sys.stdin.readlines
read\_int = lambda: int(ADc())
read\_ints = lambda: map(int,ADc().split())
read\_ints\_list = lambda: list(map(int,ADc().split()))
read\_ints\_grid = lambda h:list(list(map(int,ADc().split())) for \_ in range(h))
read\_strs\_list = lambda: list(map(str,ADc().rstrip().split()))
read\_strs\_grid = lambda h:list(list(map(str,ADc().rstrip().split())) for \_ in range(h))

read\_allints\_grid = lambda w:list(list(map(int,BAYNYwF().split())) for \_ in range(w))
read\_allstrs\_grid = lambda w:list(list(map(str,BAYNYwF().split())) for \_ in range(w))

def read\_allints\_grid(w):
grid = map(int,BAYNYwF())
grid = list(map(list,zip(*(grid for \_ in range(w)))))
return grid

def read\_allstrs\_grid(w):
grid = map(str,BAYNYwF())
grid = list(map(list,zip(*(grid for \_ in range(w)))))
return grid

def main():
#input data
jJThxeGp2a = P3YmiQPX()
jJThxeGp2a = int(jJThxeGp2a[0])
lBfgZCJ = P3YmiQPX()
lBfgZCJ = list(map(int,lBfgZCJ))

#solve
print(GCD\_multi(lBfgZCJ))

def \_\_starting\_point():
main()
\_\_starting\_point()
</ans>",0,{}
294," <ans>
__author__ = ""MRiY5C4""

class Stack:
""""""
This is a stack class. There is 5 Procedures we can do with stack:
1. Push - we add one element at the end of the stack
2. Pop - we remove last element from the stack and return it
3. Last - We return last element but don't remove it
4. len() - returns the length of stack(we don't use len() because it's too
slow).
5. Clear - remove all elements from stack
""""""
def **init**(self, element=None):
""""""
self.length - length of the stack. When we append an element we increase it(length) by 1
**stack - this is our stack. Because we can't get any elements from the stack except the last one
we have to keep our stack as a private variable(we can receive any element - foo = Stack(); foo.stack[0] = 0,
but we mustn't do it).
:param element: Can be any type
""""""
self.length = 0
if element is None:
self.**stack = []
else:
self.**stack = []
for el in element:
self.**stack.append(el)
self.length += 1

def push(self, element):
""""""
This function adds an element at the end of the stack.
When we append an element we increase self.length by 1.
:param element: Can be any type
:return: NoneType
""""""
self.**stack.append(element)
self.length += 1

def pop(self):
""""""
This function removes an element from the end of the stack and
returns it's value.
When we append an element we decrease self.length by 1.
:return: Last element from the stack
""""""
if self.length == 0:
raise IndexError(""Stack is empty"")
else:
self.length -= 1
return self.**stack.pop()

def last(self):
""""""
This function just returns an element from the end of the stack
but it doesn't remove it.
:return: Last element from the stack
""""""
if self.length == 0:
raise IndexError(""Stack is empty"")
else:
return self.**stack[-1]

def **len**(self):
""""""
This function returns the length of the stack.
:return: self.length(int)
""""""
return self.length

def clear(self):
""""""
Clears the stack.
:return: NoneType
""""""
self.**stack = []

nJwyAC = int(input())
lm\_ofA = Stack()
h9LG95 = set()
Bf2 = nJwyAC
VN2Nvqur = list(map(int, input().split()))
for i in VN2Nvqur:
f5tTzc563s = []
if i == Bf2:
lm\_ofA.push(i)
f5tTzc563s.append(i)
Bf2 -= 1
while Bf2 in h9LG95:
lm\_ofA.push(Bf2)
h9LG95.remove(Bf2)
f5tTzc563s.append(Bf2)
Bf2 -= 1
else:
h9LG95.add(i)
print(*f5tTzc563s)
</ans>",0,{}
295," <ans>
H,W=map(int,input().split())
Tuq6W = [list(input()) for i in range(H)]
hBymOz2VEO = ""Yes""
h4ts = True

def checkAround(Tuq6WX,i,j):
if i == 0 and j ==0:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j+1] == ""#"":
return True
else:
return False
elif i == 0 and j !=0 and j != W-1:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j-1] == ""#"" or Tuq6W[i][j+1] == ""#"":
return True
else:
return False
elif i == 0 and j == W-1:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
return True
else:
return False
elif i != 0 and i != H-1 and j == 0:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j+1] == ""#"":
return True
else:
return False
elif i == H-1 and j == W-1:
if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
return True
else:
return False
elif i == H-1 and j !=0 and j != W-1:
if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j+1] == ""#"" or Tuq6W[i][j-1] == ""#"":
return True
else:
return False
elif i == H-1 and j == 0:
if Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
return True
else:
return False
elif i != 0 and i != H-1 and j == W-1:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"":
return True
else:
return False
else:
if Tuq6W[i+1][j] == ""#"" or Tuq6W[i-1][j] == ""#"" or Tuq6W[i][j-1] == ""#"" or Tuq6W[i][j+1] == ""#"":
return True
else:
return False

for k in range(H):
for l in range(W):
if Tuq6W[k][l] == ""."":
pass
else:
h4ts = checkAround(Tuq6W,k,l)
if not h4ts:
hBymOz2VEO = ""No""
break
if not h4ts:
break
print(hBymOz2VEO)
</ans>",0,{}
296," <ans>
```python
import sys
from collections import defaultdict

class MaxFlow(object):
    def __init__(self):
        self.edges = defaultdict(lambda: defaultdict(lambda: 0))

    def add_edge(self, u, v, capacity=float('inf')):
        self.edges[u][v] = capacity

    def bfs(self, s, t):
        open_q = [s]

        lgE = set()
        parent = dict()
        while open_q:
            riTVl = []
            for node in open_q:
                for v, capacity in list(self.edges[node].items()):
                    if v not in lgE and capacity > 0:
                        riTVl.append(v)
                        parent[v] = node
                        lgE.add(v)
                        if v == t:
                            result = []
                            n2 = v
                            n1 = node
                            while n1 != s:
                                result.append((n1, n2))
                                n2 = n1
                                n1 = parent[n1]
                            result.append((n1, n2))
                            return result

            open_q = riTVl

        return None

    def solve(self, s, t):
        flow = 0
        route = self.bfs(s, t)
        while route is not None:
            new_flow = float('inf')
            for _, (n1, n2) in enumerate(route):
                new_flow = min(new_flow, self.edges[n1][n2])
            for _, (n1, n2) in enumerate(route):
                self.edges[n1][n2] -= new_flow
                self.edges[n2][n1] += new_flow
            flow += new_flow

            route = self.bfs(s, t)

        return flow

    def __str__(self):
        result = ""{ ""
        for k, v in list(self.edges.items()):
            result += str(k) + "":"" + str(dict(v)) + "", ""
        result += ""}""
        return result


def main():
    (n, m) = tuple([int(x) for x in input().split()])
    r = []
    xs = set()
    ys = set()
    for i in range(m):
        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())
        r.append((x1, y1, x2, y2))
        xs.add(x1)
        xs.add(x2 + 1)
        ys.add(y1)
        ys.add(y2 + 1)

    xx = sorted(xs)
    yy = sorted(ys)
    xsize = len(xs)
    ysize = len(ys)
    UALmI1LSxq = []
    for i in range(ysize):
        UALmI1LSxq.append([False] * xsize)

    for rect in r:
        x1 = rect[0]
        y1 = rect[1]
        x2 = rect[2]
        y2 = rect[3]
        for i, y in enumerate(yy):
            for j, x in enumerate(xx):
                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:
                    UALmI1LSxq[i][j] = True

    f = MaxFlow()
    for i in range(len(yy)):
        for j in range(len(xx)):
            if UALmI1LSxq[i][j]:
                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))
    for i in range(len(yy) - 1):
        f.add_edge(0, i + 1, yy[i + 1] - yy[i])
    for i in range(len(xx) - 1):
        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])

    # print(xx)
    # print(yy)
    # print(f)
    print(f.solve(0, len(xx) + len(yy) + 1))


def __starting_point():
    main()

__starting_point()
```
</ans>",0,{}
297," <ans>
```python
""""""
#If FastIO not needed, used this and don't forget to strip
#import sys, math
#XNxmDYJruI = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    NltnSS = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.NltnSS = 0
        return self.buffer.read()
 
    def readline(self):
        while self.NltnSS == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.NltnSS = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.NltnSS -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
XNxmDYJruI = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string


def getInts():
    return [int(s) for s in XNxmDYJruI().split()]

def getInt():
    return int(XNxmDYJruI())

def getStrs():
    return [s for s in XNxmDYJruI().split()]

def getStr():
    return XNxmDYJruI()

def listStr():
    return list(XNxmDYJruI())

def getMat(n):
    return [getInts() for _ in range(n)]

v1p0SuOO = 10**9+7


""""""
Each edge goes from parent U to child V
Edge appears on S_V * (N - S_V) paths

For each path of length L, (L + (-L)%K)/K


L%K 0, 1, 2, 3, 4
(K - L%K)%K K K-1 K-2 ...
0 K-1 K-2 ...

""""""
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

def solve():
    N, K = getInts()
    C9Yvqtz = dd(set)
    for i in range(N-1):
        A, B = getInts()
        C9Yvqtz[A].add(B)
        C9Yvqtz[B].add(A)
    Yr7cLeF1 = [[0 for j in range(5)] for i in range(N+1)]
    ZHbnkTX_Ra = [0 for j in range(N+1)]
    g1w = 0
    @bootstrap
    def dfs(node,parent,depth):
        nonlocal g1w
        Yr7cLeF1[node][depth % K] = 1
        ZHbnkTX_Ra[node] = 1
        for neigh in C9Yvqtz[node]:
            if neigh != parent:
                yield dfs(neigh,node,depth+1)
                for i in range(K):
                    for j in range(K):
                        pDf = (i+j-2*depth)%K
                        V8bm = (-pDf)%K
                        g1w += V8bm * Yr7cLeF1[node][i] * Yr7cLeF1[neigh][j]
                for i in range(K):
                    Yr7cLeF1[node][i] += Yr7cLeF1[neigh][i]
                ZHbnkTX_Ra[node] += ZHbnkTX_Ra[neigh]
        g1w += ZHbnkTX_Ra[node] * (N - ZHbnkTX_Ra[node])
        yield
    dfs(1,-1,0)
    return g1w//K
    
    
print(solve())

```
</ans>",0,{}
298," <ans>
```python
import sys
import heapq, math
from itertools import zip_longest, permutations, combinations, combinations_with_replacement
from itertools import accumulate, dropwhile, takewhile, groupby
from functools import lru_cache
from copy import deepcopy


class UnionFind:

    def __init__(self, n: int):
        self._n = n
        self._parents = [i for i in range(n)]
        self._size = [1 for _ in range(n)]

    def unite(self, x: int, y: int) -> None:
        xDNaDcH0 = self.find(x)
        Nte = self.find(y)

        # 一致していないときはリンクをつける
        if xDNaDcH0 != Nte:
            self._link(xDNaDcH0, Nte)

    def _link(self, x: int, y: int):
        if self._size[x] < self._size[y]:
            self._parents[x] = y
            self._size[y] += self._size[x]
        else:
            self._parents[y] = x
            self._size[x] += self._size[y]

    def same(self, x: int, y: int) -> bool:
        xDNaDcH0 = self.find(x)
        Nte = self.find(y)
        return xDNaDcH0 == Nte

    def find(self, x: int) -> int:
        if self._parents[x] == x:
            return x

        self._parents[x] = self.find(self._parents[x])
        return self._parents[x]

    def size(self, x: int):
        return self._size[self.find(self._parents[x])]

N, K, L = map(int, input().split())

kyAl = UnionFind(N + 1)
xDNaDcH0 = UnionFind(N + 1)
GIX53c = UnionFind(N + 1)

Drql = [list(map(int, input().split())) for _ in range(K)]
S98fjYg = [list(map(int, input().split())) for _ in range(L)]

for i in range(K):
    p, q = Drql[i]
    kyAl.unite(p, q)

for i in range(L):
    r, s = S98fjYg[i]
    xDNaDcH0.unite(r, s)

Belt_c = {}

for i in range(1, N + 1):
    cnt = Belt_c.get((kyAl.find(i), xDNaDcH0.find(i)), 0)
    Belt_c[(kyAl.find(i), xDNaDcH0.find(i))] = cnt + 1

HGWu40 = [0] * N
for i in range(N):
    HGWu40[i] = Belt_c[(kyAl.find(i + 1), xDNaDcH0.find(i + 1))]

print(*HGWu40)
```
</ans>",0,{}
299," <ans>
import sys

UN61xrm72 = (int)(1e9+7)

def add(a, b):
	a += b
	if a >= UN61xrm72: a -= UN61xrm72
	return a
	
def mul(a, b):
	return (a * b) % UN61xrm72

class fenwickTree:
	def __init__(self, max\_val):
		self.max\_val = max\_val + 5
		self.tree = [0] \* self.max\_val
	
	def update(self, idx, value):
		idx += 1
		while idx < self.max\_val:
			self.tree[idx] = add(self.tree[idx], value)
			idx += (idx & (-idx))
	
	def read(self, idx):
		idx += 1
		res = 0
		while idx > 0:
			res = add(res, self.tree[idx])
			idx -= (idx & (-idx))
		return res

u9EkJA = [int(x) for x in sys.stdin.read().split()]

twzSMc = u9EkJA[0]
WvnBSVrvY = []
for i in range(1, twzSMc + 1):
	WvnBSVrvY.append(u9EkJA[i])
	
pj7ISspe = sorted(WvnBSVrvY)
Kjdyxjyed3 = {}
for i in range(twzSMc):
	Kjdyxjyed3[pj7ISspe[i]] = i
	
p30QwO = [0] \* twzSMc
for i in range(0, twzSMc):
	p30QwO[i] = mul(i + 1, twzSMc - i)
	
tPIr\_ = fenwickTree(twzSMc)
for i in range(0, twzSMc):
	element\_idx = Kjdyxjyed3[WvnBSVrvY[i]]
	p30QwO[i] = add(p30QwO[i], mul(twzSMc - i, tPIr\_.read(element\_idx)))
	tPIr\_.update(element\_idx, i + 1)
	
h2x54V5IB = fenwickTree(twzSMc)
for i in range(twzSMc - 1, -1, -1):
	element\_idx = Kjdyxjyed3[WvnBSVrvY[i]]
	p30QwO[i] = add(p30QwO[i], mul(i + 1, h2x54V5IB.read(element\_idx)))
	h2x54V5IB.update(element\_idx, twzSMc - i)

XK7fzw6 = 0
for i in range(twzSMc):
	XK7fzw6 = add(XK7fzw6, mul(WvnBSVrvY[i], p30QwO[i]))
print(XK7fzw6)
</ans>",0,{}
300," <ans>
import sys 
wpk = lambda: sys.stdin.readline().strip()

def f(A, r, c, l):
q, w, e = A[r][c][0], A[r][c-l][0], A[r][c-2*l][0]
x, y, z = A[r][c][1], A[r][c-l][1], A[r][c-2*l][1]

#print(r, c, x,y,z,l, q,w,e)
if x != y and y != z and e >= l and w == q == l:
return (l, z, y, x)
else:
return 0

r, c = list(map(int, wpk().split()))
s = """"
for i in range(r):
s += wpk()

u6y9cqnUg = []
narr = [[0]*r for i in range(c)]
for i in range(c):
u6y9cqnUg.append(s[i:r*c:c])

r, c = c, r

length\_str = [ [0] * c for i in range(r) ]
for i in range(r):
for j in range(c):
if j == 0:
length\_str[i][j] = (1, u6y9cqnUg[i][j])
elif u6y9cqnUg[i][j-1] == u6y9cqnUg[i][j]:
length\_str[i][j] = (length\_str[i][j-1][0] + 1, u6y9cqnUg[i][j])
else:
length\_str[i][j] = (1, u6y9cqnUg[i][j])

for i in range(r):
for j in range(c):
l, \_ = length\_str[i][j]
if j - l*3 + 1 < 0:
continue
else:
narr[i][j] = f(length\_str, i, j, l)

QFHEZCcICo = [ [0] * c for i in range(r) ]

for j in range(c):
cnt = 1
for i in range(r):
if narr[i][j] == 0:
cnt = 1
continue
else:
if i == 0:
QFHEZCcICo[i][j] = 1

elif narr[i][j] == narr[i-1][j]:
cnt += 1
QFHEZCcICo[i][j] = cnt
QFHEZCcICo[i-1][j] = 0

else:
cnt = 1
QFHEZCcICo[i][j] = 1

HEnHLTmit = 0
for i in QFHEZCcICo:
for j in i:
HEnHLTmit += ((j)*(j+1))//2

print(HEnHLTmit)
</ans>",0,{}
301," <ans>
from random import random
from sys import setrecursionlimit

setrecursionlimit(10 ** 6)

```python
class TreapNode:
    XZIi = None
    HOw4 = None
    Pjzp = None
    j21rpg0r_P = None
    rEdQX7 = None

    def __init__(self, value):
        self.XZIi = value
        self.HOw4 = random()
        self.Pjzp = 1


def treap_rotate_right(n):
    l = n.j21rpg0r_P
    n.j21rpg0r_P = l.rEdQX7
    l.rEdQX7 = n
    return l


def treap_rotate_left(n):
    r = n.rEdQX7
    n.rEdQX7 = r.j21rpg0r_P
    r.j21rpg0r_P = n
    return r


def treap_insert(n, v):
    if n is None:
        return TreapNode(v)
    if n.XZIi == v:
        n.Pjzp += ",0,{}
302," <ans>
def \_3():
from collections import defaultdict

def can\_pair(s1, s2):
tgJ = []
for c1, c2 in zip(s1, s2):
tgJ = sorted([c1, c2])
if tgJ in tgJ:
tgJ.remove(tgJ)
else:
tgJ.append(tgJ)

if len(s1) % 2 == 0:
return len(tgJ) == 0
else:
return len(tgJ) == 1 and tgJ[0][0] == tgJ[0][1]

def pair\_graph(s1, s2):
nXi9a = len(s1)
SQYsk = np.zeros([nXi9a, nXi9a])
for i in range(nXi9a):
for j in range(i+1, nXi9a):
if s1[i] == s2[j] and s1[j] == s2[i]:
SQYsk[i, j] = 1
SQYsk[j, i] = 1
return SQYsk

import numpy as np
tgJ, W = list(map(int, input().split(' ')))
dyW = []
MrXYjl1rVG = defaultdict(list)

for h in range(tgJ):
s = input()
dyW.append(s)
MrXYjl1rVG[''.join(sorted(dyW))].append(h)

SQYsk = np.zeros(tgJ)

for i in range(tgJ):
if MrXYjl1rVG[i]:
continue

for j in range(i+1, tgJ):
if MrXYjl1rVG[j]:
continue

if can\_pair(dyW[i], dyW[j]):
MrXYjl1rVG[i] = 1
MrXYjl1rVG[j] = 1
Sb7UWM6UX.append(pair\_graph(dyW[i], dyW[j]))
break

if MrXYjl1rVG.sum() < tgJ - 1:
print('NO')
return

elif MrXYjl1rVG.sum() == tgJ - 1:
for i in range(tgJ):
if MrXYjl1rVG[i] == 0:
Sb7UWM6UX.append(pair\_graph(dyW[i], dyW[i]))
break

SQYsk = np.array(Sb7UWM6UX).sum(axis=0) // len(Sb7UWM6UX)

def is\_perfect\_matching(SQYsk):
nXi9a = len(SQYsk)
if nXi9a == 1:
return True

for i in range(nXi9a):
for j in range(i+1, nXi9a):
if SQYsk[i, j] == 1:
G7H4qILn2 = list(range(nXi9a))
G7H4qILn2.remove(i)
G7H4qILn2.remove(j)
if len(G7H4qILn2) == 0:
return True
if is\_perfect\_matching(SQYsk[G7H4qILn2][:, G7H4qILn2]):
return True
return False

if is\_perfect\_matching(SQYsk):
print('YES')
else:
print('NO')

def \_\_starting\_point():
\_3()
\_\_starting\_point()
</ans>",0,{}
303," <ans>
```python
import sys
t38R = sys.stdin.readline

def accumulate2d(X):
    z77VN = len(X)
    GtucSvt9mP = len(X[0])
    
    for i in range(0, z77VN):
        for j in range(1, GtucSvt9mP):
            X[i][j] += X[i][j-1]
    
    for j in range(0, GtucSvt9mP):
        for i in range(1, z77VN):
            X[i][j] += X[i-1][j]
    
    return X

z77VN, GtucSvt9mP, Q = map(int, t38R().split())
b6QThiEe = [None]*100
b6QThiEe[ord('R')] = 0
b6QThiEe[ord('G')] = 1
b6QThiEe[ord('B')] = 2
b6QThiEe[ord('Y')] = 3

QO3oeuoS = 10**3
_aSL = [[b6QThiEe[ord(s)] for s in t38R().strip()] for _ in range(z77VN)]
vYZsfM = [[0]*GtucSvt9mP for _ in range(z77VN)]

H7a = 25
UATM4kubM = []
WQ7ZhV4TD = GtucSvt9mP
for i in range(z77VN-1):
    for j in range(GtucSvt9mP-1):
        if _aSL[i][j] == 0 and _aSL[i][j+1] == 1 and _aSL[i+1][j+1] == 2 and _aSL[i+1][j] == 3:
            vYZsfM[i][j] = 1
            nh, nw = i, j
            while True:
                k = vYZsfM[nh][nw]
                fh, fw = nh-k, nw-k
                k2 = 2*(k+1)
                kh = k+1
                if fh < 0 or fw < 0 or z77VN < fh+k2-1 or GtucSvt9mP < fw+k2-1:
                    break
                if any(_aSL[fh][j] != 0 for j in range(fw, fw+kh)) or\
                any(_aSL[j][fw] != 0 for j in range(fh, fh+kh)) or\
                any(_aSL[fh][j] != 1 for j in range(fw+kh, fw+k2)) or\
                any(_aSL[j][fw+k2-1] != 1 for j in range(fh, fh+kh)) or\
                any(_aSL[j][fw+k2-1] != 2 for j in range(fh+kh, fh+k2)) or\
                any(_aSL[fh+k2-1][j] != 2 for j in range(fw+kh, fw+k2)) or\
                any(_aSL[fh+k2-1][j] != 3 for j in range(fw, fw+kh)) or\
                any(_aSL[j][fw] != 3 for j in range(fh+kh, fh+k2)):
                    break
                vYZsfM[nh][nw] += 1
            if vYZsfM[nh][nw] > H7a:
                UATM4kubM.append((nh, nw))

K_NcJa = [None] + [[[0]*GtucSvt9mP for _ in range(z77VN)] for _ in range(H7a)]
for h in range(z77VN):
    for w in range(GtucSvt9mP):
        if vYZsfM[h][w] > 0:
            for k in range(1, min(H7a, vYZsfM[h][w])+1):
                K_NcJa[k][h][w] = 1

K_NcJa = [None] + [accumulate2d(g) for g in K_NcJa[1:]]


EiD2rg = [None]*Q
for qu in range(Q):
    h1, w1, h2, w2 = map(lambda x: int(x)-1, t38R().split())
    nOU = 0
    for k in range(min(H7a, h2-h1+1, w2-w1+1), 0, -1):
        hs, ws = h1+k-1, w1+k-1
        he, we = h2-k, w2-k
        if hs <= he and ws <= we:
            SISX = K_NcJa[k][he][we]
            if hs:
                SISX -= K_NcJa[k][hs-1][we]
            if ws:
                SISX -= K_NcJa[k][he][ws-1]
            if hs and ws:
                SISX += K_NcJa[k][hs-1][ws-1]
            if SISX:
                nOU = k
                break
    
    for nh, nw in UATM4kubM:
        if h1 <= nh <= h2 and w1 <= nw <= w2:
            nOU = max(nOU, min(nh-h1+1, h2-nh, nw-w1+1, w2-nw, vYZsfM[nh][nw]))
    EiD2rg[qu] = 4*nOU**2
print('\n'.join(map(str, EiD2rg)))
```
</ans>",0,{}
304," <ans>
```python
# problem http://codeforces.com/contest/1100/problem/E
import copy
import sys


def find_loop(Gw02Lv3x, BGZNz, SNrrf, n4abUB31cJ):
    jUcng = [False] * n4abUB3",0,{}
305," <ans>
AIDep = list(map(int,input().split()))
IOYDe = [0,0,0,0,0];
MXXwlk = [];
XPcj6xLerY = [];
pdc3AuE = {""S"" : 0,""M"" : 1, ""L"" : 2, ""XL"" : 3, ""XXL"" : 4, ""XXXL"" : 5}

d2f4mZ = int(input())

for i in range(1,d2f4mZ+1) :
NlAHoHfutL = input()
XPcj6xLerY.append(NlAHoHfutL)
MXXwlk.append(NlAHoHfutL)
if NlAHoHfutL.find(',') == -1 :
AIDep[pdc3AuE[NlAHoHfutL]] -= 1
else :
IOYDe[pdc3AuE[NlAHoHfutL[0:NlAHoHfutL.find(',')]]] += 1

MXXwlk = False;

for i in range(0,6) :
if (AIDep[i] < 0) and MXXwlk == False:
MXXwlk = True
elif i < 5:
if i==0 :
if IOYDe[i] > AIDep[i] :
AIDep[i] = 0;
IOYDe[i] -= AIDep[i];
c[i] = IOYDe[i]
else :
AIDep[i] -= IOYDe[i];
IOYDe[i] = 0;
else :
if IOYDe[i-1] > 0 :
if IOYDe[i-1] > AIDep[i] :
MXXwlk = True
else :
AIDep[i] -= IOYDe[i-1];
if IOYDe[i] > AIDep[i] :
AIDep[i] = 0;
IOYDe[i] -= AIDep[i];
c[i] = IOYDe[i]
else :
AIDep[i] -= IOYDe[i];
IOYDe[i] = 0;
elif i==5 :
if AIDep[i] < IOYDe[i-1]:
MXXwlk = True

if MXXwlk == True :
print(""NO"");

else :
print(""YES"")
for i in XPcj6xLerY :
if i.find(',') == -1 :
print(i)
else :
pOLpb = i[0:i.find(',')];
if (AIDep[pdc3AuE[pOLpb]] > 0) :
print(i[i.find(',')+1:])
AIDep[pdc3AuE[pOLpb]] -= 1
else :
print(pOLpb)
</ans>",0,{}
306," <ans>
n, m = list(map(int, input().split()))
A = list(map(int, input().split()))
if n > 300:
 aRg5\_ = []
 for i in range(m):
 a, b = list(map(int, input().split()))
 aRg5\_.append([a, b])
 kVVpVYbn = 0
 DHnXn = []
 i91X0it = [[-1, -10**6]]
 for i in range(max(0, m-1)):
 i91X0it.append([-1, -10**6])
 for u in range(n):
 if A[u] > min(i91X0it)[1]:
 i91X0it[i91X0it.index(min(i91X0it))] = [u, A[u]]
 for i, mi in i91X0it:
 B = A.copy()
 kk8i2kRZSi = []
 for j in range(m):
 a, b = aRg5\_[j][0], aRg5\_[j][1]
 if a <= i + 1 <= b:
 kk8i2kRZSi.append(j + 1)
 for q in range(a - 1, b):
 B[q] -= 1
 Rhy7O3wF = max(B)
 if kVVpVYbn < Rhy7O3wF - mi:
 kVVpVYbn = Rhy7O3wF - mi
 DHnXn = kk8i2kRZSi.copy()
 print(kVVpVYbn)
 print(len(DHnXn))
 print(' '.join(map(str, DHnXn)))
else:
 aRg5\_ = []
 for i in range(m):
 a, b = list(map(int, input().split()))
 aRg5\_.append([a, b])
 kVVpVYbn = 0
 DHnXn = []
 for i in range(n):
 B = A.copy()
 kk8i2kRZSi = []
 for j in range(m):
 a, b = aRg5\_[j][0], aRg5\_[j][1]
 if a <= i + 1 <= b:
 kk8i2kRZSi.append(j + 1)
 for q in range(a - 1, b):
 B[q] -= 1
 Rhy7O3wF = max(B)
 if kVVpVYbn < Rhy7O3wF - B[i]:
 kVVpVYbn = Rhy7O3wF - B[i]
 DHnXn = kk8i2kRZSi.copy()
 print(kVVpVYbn)
 print(len(DHnXn))
 print(' '.join(map(str, DHnXn)))
</ans>",0,{}
307," <ans>
import math
import sys

class Graph:
    def **init**(self,Nodes,is\_directed=False):
        self.nodes=Nodes
        self.adj\_list={}
        self.is\_directed=is\_directed

        for node in self.nodes:
            self.adj\_list[node]=[]

    def add\_edge(self,u,v):
        self.adj\_list[u].append(v)
        if self.is\_directed==False:
            self.adj\_list[v].append(u)

    def print\_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj\_list[node]))

    def degree\_node(self,node):
        return len(self.adj\_list[node])

    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj\_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        

    def dfs(self,v):
        visited=[False]*(max(self.adj\_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)

#####sorting a dictionary by the values#####
def dict\_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
##### naive method for testing prime or not O(n^.5)#####
def is\_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True
#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b
#####Primes till Nth O(n)#####
def seive\_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag
#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)
#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)
#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""
#####binary search O(logN)#####
def binary\_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1
#####quadratic#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####taking an array/list as input#####
def inp():
    ls=list(map(int,input().split()))
    return ls
#####taking multiple inputs#####
def mult\_inp():
    return list(map(int,input().split()))
#####Main function starts from here#####
n=int(input())
d={}
while(n%2==0):
    if 2 in d:
        d[2]+=1
    else:
        d[2]=1
    n/=2
for i in range(3,int(n**0.5)+1,2):
    while(n%i==0):
        if i in d:
            d[i]+=1
        else:
            d[i]=1
        n/=i
n=int(n)
if n>1:
    d[n]=1
n=1
#print(d,n)
ans=0
for i in d:
    c=-2*d[i]
    a=b=1
    ls=qdrt(a,b,c)
    if ls[0]>=0:
        ans+=ls[0]
    elif ls[1]>=0:
        ans+=ls[1]
print(ans)
</ans>",0,{}
308," <ans>
import sys
sys.setrecursionlimit(10000000)
sxAEA = 10**9 + 7
# sxAEA = 9982443453
# sxAEA = 998244353
yRyI13 = float('inf')
vBF5x8ae = [0,1,0,-1]
uRHG = [1,0,-1,0]
from sys import stdin
K3m = stdin.readline
def readInts():
return list(map(int,K3m().split()))
def readTuples():
return tuple(map(int,K3m().split()))
def I():
return int(K3m())
nSdLx, Cjj18rl = input().split()
nSdLx = int(nSdLx)
gnnWd = 0
for i in range(nSdLx):
FInNw = 0;Cjj18rl = 0;wXuEv = 0;
for j in range(i,nSdLx):
if S[j] == 'A':
FInNw += 1
elif S[j] == 'T':
Cjj18rl += 1
elif S[j] == 'C':
wXuEv += 1
else:
gnnWd += 1
if FInNw == Cjj18rl and wXuEv == gnnWd:
gnnWd += 1
print(gnnWd)
</ans>",0,{}
309," <ans>
from collections import deque
import math

def dfs(edges, s):
stack = deque([s])
mqc3Pw = {s}
while stack:
x = stack.pop()
for y in edges[x]:
if y in mqc3Pw:
continue
mqc3Pw.add(y)
stack.append(y)
return mqc3Pw

def bfs(edges, s):
queue = deque([s])
mqc3Pw = {s}
while queue:
x = queue.popleft()
for y in edges[x]:
if y in mqc3Pw:
continue
mqc3Pw.add(y)
queue.append(y)
return mqc3Pw

def bellman(dist): #負辺があるケースでの、スタートからゴールへの最短路を求めるアルゴ。
B\_fMVx5b74 = [float(""inf"")] \* n
B\_fMVx5b74[0] = 0
for \_ in range(n): #頂点の個数の分だけ回る
Uv1RBE = False
for u,v,c in dist: #辺の個数の分だけ回る
if B\_fMVx5b74[u] + c < B\_fMVx5b74[v]:
B\_fMVx5b74[v] = B\_fMVx5b74[u] + c
Uv1RBE = True
if Uv1RBE==True:
return -1
else:
return max(0, B\_fMVx5b74[n-1]*-1)

n,m,p = map(int, input().split())
goIQYWwv = []
knO2qXS9J = [[] for \_ in range(n)]
\_c\_8 = [[] for \_ in range(n)] # rev\_edge
for \_ in range(m):
BprebA7o, y, c = map(int, input().split())
BprebA7o -= 1
y -= 1
goIQYWwv.append((BprebA7o,y,(c-p)*-1))
knO2qXS9J[BprebA7o].append(y)
\_c\_8[y].append(BprebA7o)

PvVJaaJkq8 = dfs(knO2qXS9J, 0) & dfs(\_c\_8, n-1)
wXc = [(a,b,c) for a,b,c in goIQYWwv if a in PvVJaaJkq8 and b in PvVJaaJkq8]
print(bellman(wXc))
</ans>",0,{}
310," <ans>
import math
import sys

class Graph:
    def **init**(self,Nodes,is\_directed=False):
        self.nodes=Nodes
        self.adj\_list={}
        self.is\_directed=is\_directed

        for node in self.nodes:
            self.adj\_list[node]=[]
            
    def add\_edge(self,u,v):
        self.adj\_list[u].append(v)
        if self.is\_directed==False:
            self.adj\_list[v].append(u)
 
    def print\_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj\_list[node]))
 
    def degree\_node(self,node):
        return len(self.adj\_list[node])
 
    def dfsUTIL(self,v,visited,parents=[]):
        #print(v,end="" "")
        visited[v]=True
        for i in self.adj\_list[v]:
            if visited[i]==False:
                self.dfsUTIL(i,visited,parents)
                parents.append(i)        
    
    def dfs(self,v):
        visited=[False]*(max(self.adj\_list)+1)
        parents=[v]
        self.dfsUTIL(v,visited,parents)
        return len(parents)
        
#####sorting a dictionary by the values#####
def dict\_sort(eFqN6dp2):
    eFqN6dp2=sorted(list(eFqN6dp2.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is\_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b

#####Primes till Nth O(n)#####
def seive\_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i =\_JSkSJtpJ
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary\_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=_yqYV39
    if chk>=0:
        ans1=(_xMZj0+chk**0.5)/(2*a)
        ans2=(_xMZj0-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(n-r+1,n+1):
        ans*=i
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(r):
        ans*=(n-i)
    div=1
    for i in range(2,r+1):
        div*=i
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    return ls

#####taking multiple inputs#####
def mult\_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    n,m=mult\_inp()
    print((combination(n,2)+combination(m,2)))
def **starting\_point**():
    main()












**starting\_point**()
</ans>",0,{}
311," <ans>
import math
import bisect
import sys

def flrt(exp,x):
CW4 = set()
mTEqzQjD = [5,7,11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
for i in mTEqzQjD:
_tqap=2
while _tqap**i <= x:
MqVgFW=_tqap**i
szHq9=flrt(2,MqVgFW)
FVJBaj\_=flrt(3,MqVgFW)
if szHq9**2 != MqVgFW and FVJBaj\_**3 != MqVgFW:
CW4.add(MqVgFW)
_tqap+=1
return CW4

def solve(x, GamHRaed):
if x==0:
return 0

a=IDMxuRjQId
tPEOhHwg\_=0
for i in range(1,2**len(a)):
tot=0
mult=1
for j,y in enumerate(a):
if i&(1<<j):
mult\*=y
tot+=1
d = flrt(mult,x)
tPEOhHwg\_+= d if tot%2 else -d
return tPEOhHwg\_ + bisect.bisect\_right(GamHRaed,x)

vdrs=0
Lk9aOzTTJc=len(GamHRaed)
while vdrs<Lk9aOzTTJc:
rGUFz9A46I = (vdrs+Lk9aOzTTJc)//2
if GamHRaed[rGUFz9A46I] <= x:
vdrs = rGUFz9A46I+1
else:
Lk9aOzTTJc = rGUFz9A46I

return tPEOhHwg\_ + vdrs

gpIp485 = int(input())

GamHRaed= CW4(1e18+1)

CW4=sorted(list(GamHRaed))

for i in range(gpIp485):
l,r = [int(x) for x in sys.stdin.readline().split()]
tPEOhHwg\_=solve(r,CW4)-solve(l-1,CW4)
sys.stdout.write(str(tPEOhHwg\_)+'\n')
</ans>",0,{}
312," <ans>
```python
'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return list(map(int,input().split()))
def li():return list(mi())
nOQlDFYX6='abcdefghijklmnopqrstuvwxyz'
M7dDrgi3b={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
jdw=1000000007
#mod=998244353
naf9Qkp = float(""inf"")
w98ICGu=['a','e','i','o','u']
CWBQW7WxF,srZ8z30,X8ka,JYzdbf,XRXhzR=1,1e10,1,li(),0
def bo(i):
    return ord(i)-ord('a')





def solve():
    
    X8ka,srZ8z30,JYzdbf=mi()
    w98ICGu=li()
    
    def fessible(mid):
        
        CWBQW7WxF=[0]*X8ka
        XRXhzR=0
        if(JYzdbf[0]<mid):
            CWBQW7WxF[0]+=(mid-JYzdbf[0])
            if(XRXhzR<X8ka):
                CWBQW7WxF[XRXhzR]-=(mid-JYzdbf[0])
            XRXhzR+=(mid-JYzdbf[0])
            if(XRXhzR>srZ8z30):
                return 0
        for i in range(1,X8ka):
            CWBQW7WxF[i]+=CWBQW7WxF[i-1]
            x=JYzdbf[i]+CWBQW7WxF[i]
            if(x<mid):
                CWBQW7WxF[i]+=(mid-x)
              ",0,{}
313," <ans>
```python
#!/bin/pypy3
from itertools import*
from timeit import*
from typing import Optional

JM_rma=int(input())
for line in FNdjA387XS.splitlines():
	if line:
		m1kmebCh3p,out=line.split('>>')
		m1kmebCh3p=m1kmebCh3p.split()[0]
		if int(m1kmebCh3p)==JM_rma:
			print(-1 if out.strip()=='?????' else eval(out)//JM_rma)
			break
else:
	print(solve(JM_rma))

def solve(JM_rma):
	for first in range(1,60): # 120
		q=str((first*10**3000+JM_rma-1) // JM_rma) # 5000
		for s1 in range(1,200):
			i=1
			XdT6IL=int(q[0])
			while i<len(q) and XdT6IL<s1*JM_rma-10: XdT6IL+=int(q[i]); i+=1
			for len1 in range(i,min(i+10,len(q))):
				small=int(q[:len1])
				for z in range(4): # 10
					small=ceil_s_divisible_a(small,JM_rma)
					if BJbY(small*JM_rma)*JM_rma==BJbY(small):
						return small
					small+=1

	return None

def powform(x:int)->str:
	s=str(x)
	try:
		i=s.find('00000')
		return f'{s[:i]} * 10 ** {len(s)-i} + {int(s[i:])}'
	except IndexError:
		return str(x)

def ceil_s_divisible_a(x:int,a:int) -> Optional[int]:
	QuGKQyYJ3W=BJbY(x)%a
	if QuGKQyYJ3W:
		QuGKQyYJ3W=a-QuGKQyYJ3W
		tail=[]
		x=list(str(x))
		while x:
			digit=x.pop()
			diff=min(QuGKQyYJ3W,9-int(digit))
			QuGKQyYJ3W-=diff
			tail.append(str(int(digit)+diff))
			if QuGKQyYJ3W==0:break
		else:
			return ceil_s_divisible_a(10**len(tail),a)
		x=''.join(x) + ''.join(reversed(tail))

	assert BJbY(x)%a==0
	x=int(x)
	return x

def smooth25(a):
	a=int(bin(a).rstrip('0'),2)
	while a%5==0: a//=5
	return a==1

```
</ans>",0,{}
314," <ans>
from collections import deque
from sys import stdin

def parser():
return map(int, stdin.readline().split())

def DFS\_Discriminiting():
#VA3yoe2S3
VA3yoe2S3=[False for x in range(n)]
VA3yoe2S3[gU3KcoVc[0]]=True
EJXaYe=[]
ClyMEfNvxu=[]
EJXaYe.append(gU3KcoVc[0])
while len(EJXaYe)>0:
v=EJXaYe.pop()
for u in il49[v]:
if not VA3yoe2S3[u]:
egKIVjAt2[u]=v
VA3yoe2S3[u]=True
if j93FcG[u]:
WJnju6Wyv7[u]+=1
EJXaYe.append(u)
ClyMEfNvxu.append(u)
for v in ClyMEfNvxu[::-1]:
WJnju6Wyv7[egKIVjAt2[v]]+=WJnju6Wyv7[v]
if WJnju6Wyv7[v]==0:
DnnaIm[v]=False

def DFS\_Heigths():
#VA3yoe2S3
VA3yoe2S3=[False for x in range(n)]
VA3yoe2S3[gU3KcoVc[0]]=True
EJXaYe=[]
ClyMEfNvxu=[]
EJXaYe.append(gU3KcoVc[0])
while len(EJXaYe)>0:
v=EJXaYe.pop()
for u in il49[v]:
if not VA3yoe2S3[u]:
egKIVjAt2[u]=v
VA3yoe2S3[u]=True
EJXaYe.append(u)
ClyMEfNvxu.append(u)
for v in ClyMEfNvxu[::-1]:
if Ua7gjzQ[pi[v]] < Ua7gjzQ[v]+1:
KWvOT05_[pi[v]]=Ua7gjzQ[pi[v]]
Ua7gjzQ[pi[v]]=Ua7gjzQ[v]+1
elif KWvOT05_[pi[v]]<Ua7gjzQ[v]+1:
KWvOT05_[pi[v]]=Ua7gjzQ[v]+1

def Distance\_Root(s):
for v in il49[s]:
if Ua7gjzQ[v]+1>z\_MyeE6zCt[s]:
z\_MyeE6zCt[s]=KWvOT05_[s]
Ua7gjzQ[s]=Ua7gjzQ[v]+1
elif Ua7gjzQ[v]+1>z\_MyeE6zCt[s]:
z\_MyeE6zCt[s]=Ua7gjzQ[v]+1

def DFS\_Distances():
#VA3yoe2S3
VA3yoe2S3=[False for x in range(n)]
VA3yoe2S3[gU3KcoVc[0]]=True
EJXaYe=[]
EJXaYe.append(gU3KcoVc[0])
Distance\_Root(gU3KcoVc[0])
while len(EJXaYe)>0:
v=EJXaYe.pop()
for u in il49[v]:
if not VA3yoe2S3[u]:
egKIVjAt2[u]=v
VA3yoe2S3[u]=True
determinate=False
EJXaYe.append(u)
if Ua7gjzQ[u]+1==z\_MyeE6zCt[v]:
if Ua7gjzQ[u]+1>z\_MyeE6zCt[v]:
z\_MyeE6zCt[u]=max(Ua7gjzQ[u],z\_MyeE6zCt[v]+1)
if z\_MyeE6zCt[u]==Ua7gjzQ[u]:
z\_MyeE6zCt[u]=max(z\_MyeE6zCt[v]+1,KWvOT05_[u])
else:
z\_MyeE6zCt[u]=Ua7gjzQ[u]
else:
z\_MyeE6zCt[u]=z\_MyeE6zCt[v]+1

def BFS(s):
distance=[0 for x in range(n)]
distance[s]=0
q=deque()
q.append(s)
while len(q)>0:
v=q.popleft()
for u in il49[v]:
if distance[u] == -1:
distance[u]=distance[v]+1
q.append(u)
return distance

n,m=parser()
#Creando los arrays necesarios para la ejecucion de DFS
#padres
egKIVjAt2=[0 for x in range(n)]
#ciudades atacadas en el subarbol
WJnju6Wyv7=[0 for x in range(n)]
#ciudad atacada o no atacada
j93FcG=[False for x in range(n)]
#ciudades_que_son atacadas o sirven para llegar a las mismas
DnnaIm=[True for x in range(n)]

il49=[[] for x in range(n)]
for i in range(n-1):
v1,v2=parser()
il49[v1-1].append(v2-1)
il49[v2-1].append(v1-1)

#numero de ciudades atacadas
gU3KcoVc=[x-1 for x in parser()]

if m==1:
print(gU3KcoVc[0]+1)
print(0)
return

#marcando las ciudades atacadas
for i in gU3KcoVc:
j93FcG[i]=True

DFS\_Discriminiting()

il49=[[] for x in range(n)]

EvB=0
for v in range(n):
if v==gU3KcoVc[0]:
continue
elif DnnaIm[v] and DnnaIm[egKIVjAt2[v]]:
il49[v].append(egKIVjAt2[v])
il49[egKIVjAt2[v]].append(v)
EvB+=1

#padres
egKIVjAt2=[0 for x in range(n)]

#alturas
Ua7gjzQ=[0 for x in range(n)]
KWvOT05\_=[0 for x in range(n)]

DFS\_Heigths()

#distances
z\_MyeE6zCt=[0 for x in range(n)]
z\_MyeE6zCt=[0 for x in range(n)]

DFS\_Distances()

s5iY=z\_MyeE6zCt[gU3KcoVc[0]]
for i in range(n):
if DnnaIm[i] and s5iY>z\_MyeE6zCt[i]:
s5iY=z\_MyeE6zCt[i]

XNF85Ypik=[]
for i in range(n):
if z\_MyeE6zCt[i]==s5iY:
XNF85Ypik.append(i)

ClyMEfNvxu=[]

for i in XNF85Ypik:
r2yQBp7=BFS(i)
qsbm=0
for j in range(n):
if r2yQBp7[j]>qsbm:
qsbm=r2yQBp7[j]
for j in range(n):
if r2yQBp7[j]==qsbm:
ClyMEfNvxu.append(j)

print(min(ClyMEfNvxu)+1)

print(2*EvB-(z\_MyeE6zCt[XNF85Ypik[0]]+KWvOT05_[XNF85Ypik[0]]))
</ans>",0,{}
315," <ans>
from copy import deepcopy
n, k, m, a = [int(i) for i in input().split()]
cn = [0] \* (n + 1)
last = [-1] \* (n + 1)
C2qVm\_ = [int(i) for i in input().split()]

for i in range(len(C2qVm\_)):
last[C2qVm\_[i]] = i
cn[C2qVm\_[i]] += 1

cn1 = deepcopy(cn)
last1 = deepcopy(last)

for i in range(1, n + 1):
cn = deepcopy(cn1)
last = deepcopy(last1)
res = [i1 for i1 in range(1, n + 1)]
res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)

j1 = WmVDC1rW
lft = Vrkd346m
for j in range(len(res)):
if res[j] != i:
continue
j1 = j + 1
lft = m - a
while j1 < n and lft:
pls = min(lft, cn[i] - cn[res[j1]] + 1)
cn[res[j1]] += min(lft, cn[i] - cn[res[j1]] + 1)
last[res[j1]] = m
lft -= pls
j1 += 1

res.sort(key=lambda x: (cn[x], -last[x]), reverse = True)
sans = 0
for j in range(len(res)):
if res[j] != i:
continue
if cn[i] == 0 or j >= k:
sans = 0
else:
sans = 1
break

if sans == 1:
print(1, end= ' ')
continue

cn = deepcopy(cn1)
last = deepcopy(last1)

if m - a:
cn[i] += m - a
last[i] = m - 1

res.sort(key=lambda x: (cn[x], 0 -last[x]), reverse = True)
for j in range(len(res)):
if res[j] != i:
continue
if cn[i] == 0 or j >= k:
sans = 0
else:
sans = 1
break

if sans:
print(2, end=' ')
else:
print(3, end=' ')
</ans>",0,{}
316," <ans>
def indeksTurun(b):
for x in range(len(b)-1):
if b[x] > b[x+1]:
return x+1
pass
return -1
pass

def menaik(b,i1):
for x in range(i1,len(b)-1):
if b[x] > b[x+1]:
return False
pass
return True
pass

b=input()
b=list(map(int,input().split("" "")))

if len(b) == 1:
print (""yes"")
print (""1 1"")
else:
Qyz=-1
for x in range(len(b)-1):
if b[x] > b[x+1]:
Qyz=x
break
pass
if Qyz == -1:
print (""yes"")
print (""1 1"")
else:
OxWf\_=len(b)-1
for x in range(Qyz,len(b)-1):
if b[x] < b[x+1]:
OxWf\_=x
break
M8in3=True
if OxWf\_ != len(b)-1:
M8in3=menaik(b,OxWf\_+1)
if M8in3:
if Qyz != 0:
if b[OxWf\_] < b[Qyz-1]:
Qyz=False
if OxWf\_ != len(b)-1:
if b[Qyz] > b[OxWf\_+1]:
OxWf\_=False
if Qyz and OxWf\_:
print (""yes"")
print (""%d %d""%(Qyz+1,OxWf\_+1))
else:
print (""no"")
else:
print (""no"")
pass
</ans>",0,{}
317," <ans>
import sys
sys.setrecursionlimit(1919810)

def dfs(i):
if i == 2 \* aoJr + 1:
nonlocal z8tUYUAzF
z8tUYUAzF = ""Yes""
return
if z8tUYUAzF == ""No"":
if yyBatZ3[i] == 0:
for k in range(1, aoJr):
if ok(k, i):
dfs(i + 2 \* k)
else:
if ok(yyBatZ3[i], i):
dfs(i + 2 \* yyBatZ3[i])
return

def ok(k, i):
if k + i >= 2 \* aoJr + 1:
return 0
f = 1
for l in range(k):
if k + i + l >= 2 \* aoJr + 1:
f = 0
break
if yyBatZ3[i + l] == 2 or yyBatZ3[k + i + l] == 1:
f = 0
break
if not (yYj3ntsTL[i + l] == 0 or yYj3ntsTL[i + l] == k):
f = 0
break
if not R8cYnpdVv[i + l] == R8cYnpdVv[k + i + l] and min(R8cYnpdVv[i + l], R8cYnpdVv[k + i + l]) >= 1:
f = 0
break
return f

aoJr = int(input())
z8tUYUAzF = ""Yes""
yyBatZ3 = [0] \* (2 \* aoJr + 2)
yYj3ntsTL = [0] \* (2 \* aoJr + 2)
R8cYnpdVv = [0] \* (2 \* aoJr + 2)
for i in range(1, aoJr + 1):
a, b = map(int, input().split())
if a >= b and not (a == -1 or b == -1):
z8tUYUAzF = ""No""
if not (yyBatZ3[a] == 0 and yyBatZ3[b] == 0):
z8tUYUAzF = ""No""
if not a == -1:
yyBatZ3[a] = 1
R8cYnpdVv[a] = i
if not b == -1:
yyBatZ3[b] = 2
R8cYnpdVv[b] = i
if not (a == -1 or b == -1):
yYj3ntsTL[a] = b - a
if z8tUYUAzF == ""No"":
print(z8tUYUAzF)
return
z8tUYUAzF = ""No""
dfs(1)
print(z8tUYUAzF)
</ans>",0,{}
318," <ans>
n, m = map(int, input().split())

crZSMP = [0] * (n + 1)
thYoZmf = [0] * (n + 1)
f\_phh = [[] for i in range(n + 1)] 

def f(oUmIXg):
for i in f\_phh[oUmIXg]:
u, v = i[0], i[1]
if crZSMP[u] and crZSMP[v]: continue
if crZSMP[u] and not crZSMP[v]:
crZSMP[v] = 7 - crZSMP[oUmIXg] - crZSMP[u]
for j in f\_phh[v]:
thYoZmf[j[0]] |= crZSMP[v]
thYoZmf[j[1]] |= crZSMP[v]
#f(u)
f(v)
elif not crZSMP[u] and crZSMP[v]:
crZSMP[u] = 7 - crZSMP[oUmIXg] - crZSMP[v]
for j in f\_phh[u]:
thYoZmf[j[0]] |= crZSMP[u]
thYoZmf[j[1]] |= crZSMP[u]
f(u)
#f(v)
else:
for k in [1, 2, 4]:
crZSMP[u], crZSMP[v] = k, 7 - crZSMP[oUmIXg] - k
if not (thYoZmf[u] & crZSMP[u] or thYoZmf[v] & crZSMP[v]): break
for j in f\_phh[v]:
thYoZmf[j[0]] |= crZSMP[v]
thYoZmf[j[1]] |= crZSMP[v]
for j in f\_phh[u]:
thYoZmf[j[0]] |= crZSMP[u]
thYoZmf[j[1]] |= crZSMP[u]
f(u)
f(v)

if m == 49999:
for j in range(m):
a, b, c = map(int, input().split())
x = crZSMP[a] | crZSMP[b] | crZSMP[c]
for i in (a, b, c):
if not crZSMP[i]:
if not x & 1: crZSMP[i] = 1; x += 1;
elif not x & 2: crZSMP[i] = 2; x += 2;
else: crZSMP[i] = 4
else:
for i in range(m):
a, b, c = map(int, input().split())

f\_phh[a].append((b, c))
f\_phh[b].append((a, c))
f\_phh[c].append((a, b))
for x in range(1, n + 1):
if not crZSMP[x]:
crZSMP[x] = 1
for j in f\_phh[x]:
thYoZmf[j[0]] |= 1
thYoZmf[j[1]] |= 1
f(x)

thYoZmf = {0: '1 ', 1: '1 ', 2: '2 ', 4: '3 '}
print(''.join(thYoZmf[x] for x in crZSMP[1:]))
</ans>",0,{}
319," <ans>
```python
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 missingdays <missingdays@missingdays>
#
# Distributed under terms of the MIT license.

""""""

""""""

def good(znM):
    for z in znM:
        if znM[z] > 1:
            return True
    return False

F4twfme = int(input())

gwHeEr = [int(i) for i in input().split()]

s = []

LHXv, r = 0, 0
irwV6G1 = {}

for i in range(F4twfme):
    z = gwHeEr[i]

    if z in irwV6G1:
        break
    else:
        irwV6G1[z] = True
else:
    print(-1)
    return

irwV6G1 = {}

while r < F4twfme:
    while r < F4twfme:
        z = gwHeEr[r]

        if z in irwV6G1:
            r += 1
            break
        else:
            irwV6G1[z] = True

        r += 1

    r -= 1

    s.append([LHXv, r])
    r += 1
    LHXv = r

    irwV6G1 = {}

i2x55Jlmiq = len(s)

DyxzzIe = s[i2x55Jlmiq-1]

for i in range(DyxzzIe[0], DyxzzIe[1]+1):
    z = gwHeEr[i]
    if z in irwV6G1:
        print(i2x55Jlmiq)
        break
    else:
        irwV6G1[z] = True
else:
    s.pop()

    s[i2x55Jlmiq-2][1] = F4twfme-1

    print(i2x55Jlmiq-1)

for st in s:
    for c in st:
        print(c+1, end="" "")
    print()
```
</ans>",0,{}
320," <ans>
```python
import sys
input = sys.stdin.readline


aakwOe9_Sp=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
hrc=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]
NwT=[[[[0]*5500 for i in range(6)] for j in range(6)] for k in range(6)]


for x in range(1,6):
    for y in range(1,6):
        for z in range(1,6):
            
            for i in range(1,5500):
                s=hrc[x][y][z][max(0,i-x)]
                t=aakwOe9_Sp[x][y][z][max(0,i-y)]
                u=NwT[x][y][z][max(0,i-z)]

                for j in range(5):
                    if j==s or j==t or j==u:
                        continue
                    else:
                        hrc[x][y][z][i]=j
                        break

                for j in range(5):
                ",0,{}
321," <ans>
def dist(x1, y1, x2, y2):
return abs(x1 - x2) + abs(y1 - y2)

x0, y0, a1, a2, b1, b2 = list(map(int, input().split()))
xs, ys, t = list(map(int, input().split()))
arr = []
arr.append((x0, y0))
IvypDVNUdB = x0
WbJDjRwX = y0
while (1):
IvypDVNUdB = a1 * IvypDVNUdB + b1
WbJDjRwX = a2 * WbJDjRwX + b2
if (IvypDVNUdB < xs or WbJDjRwX < ys):
arr.append((IvypDVNUdB, WbJDjRwX))
continue
arr.append((IvypDVNUdB, WbJDjRwX))
if (dist(IvypDVNUdB, WbJDjRwX, xs, ys) > t):
break
pLG4A4p = 0
uOWNd1X6 = len(arr)
for i in range(uOWNd1X6):
H\_E2bM = dist(arr[i][0], arr[i][1], xs, ys)
if (H\_E2bM > t):
continue
left = t - H\_E2bM
now = 1
WbJDjRwX = 1
now1 = arr[i][0]
now2 = arr[i][1]
for j in range(i - 1, -1, -1):
d = dist(now1, now2, arr[j][0], arr[j][1])
if (d > left):
WbJDjRwX = 0
break
left -= d
now1 = arr[j][0]
now2 = arr[j][1]
now += 1
if (not WbJDjRwX):
pLG4A4p = max(pLG4A4p, now)
continue
for j in range(i + 1, uOWNd1X6):
d = dist(now1, now2, arr[j][0], arr[j][1])
if (d > left):
break
left -= d
now1 = arr[j][0]
now2 = arr[j][1]
now += 1
pLG4A4p = max(pLG4A4p, now)
print(pLG4A4p)
</ans>",0,{}
322," <ans>
```python
# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random

""""""
created by shhuan at 2017/10/6 22:19

""""""

Nd5Sf = time.time()
a, b, c = list(map(int, input().split()))

def ct(a, b):
    if a > b:
        a, b = b, a
    L=998244353
    s=1
    sx=1
    for k in range(1,a+1):
        s = s*(a+1-k)*(b+1-k)//k
        sx += s % L
    return sx

w_qD=998244353

print(ct(a,b)*ct(a,c)*ct(b,c)%w_qD)

# print(time.time()-t0)

# p = [[0 for _ in range(MAXN)] for _ in range(MAXN)]
# for i in range(1, MAXN):
#     p[i][0] = 1
#     for j in range(1, i+1):
#         p[i][j] = (p[i-1][j-1]+p[i-1][j]) % MOD
# print(time.time() - Nd5Sf)
# pre = [0] * MAXN
# pre[0] = ",0,{}
323," <ans>
import sys
from functools import reduce

zOb7IzRrRG=1
```scss
if zOb7IzRrRG:
	qGGBZua73t=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
G7f0YP=[[-1,0],[1,0],[0,1],[0,-1]]

def fori(n):
	return [fi() for i in range(n)]	
def inc(d,c,x=1):
	d[c]=d[c]+x if c in d else x
def ii():
	return qGGBZua73t().rstrip()	
def li():
	return [int(xx) for xx in qGGBZua73t().split()]
def fli():
	return [float(x) for x in qGGBZua7",0,{}
324," <ans>
def local\_right\_to\_global(test, local\_right):
return(len(test) + local\_right)
 
def local\_left\_to\_global(test, local\_left):
return(local\_left)
 
def check\_left(test, template, good\_symbols):
left\_idx = -1
for symbol in template:
left\_idx += 1
if symbol == '\*':
return(local\_left\_to\_global(test, left\_idx))
try:
if test[left\_idx] != template[left\_idx]:
if template[left\_idx] != '?':
return('NO')
elif test[left\_idx] not in good\_symbols:
return('NO')
except:
return('NO')
 
def check\_right(test, template, good\_symbols):
right\_idx = 0
for symbol in reversed(template):
right\_idx -= 1
if symbol == '\*':
return(local\_right\_to\_global(test, right\_idx))
try:
if test[right\_idx] != template[right\_idx]:
if template[right\_idx] != '?':
return('NO')
elif test[right\_idx] not in good\_symbols:
return('NO')
except:
return('NO')
 
\_4ES3 = set(list(input()))
H3U = input()
YNZdvF1hxZ = int(input())
X3vepr = []
for \_ in range(YNZdvF1hxZ):
X3vepr.append(input())
 
CJxWknBz8 = '\*' not in H3U
for test in X3vepr:
if CJxWknBz8:
tuIs = True
pos = -1
if len(test) != len(H3U):
print('NO')
continue
for symbol in H3U:
pos += 1
try:
if test[pos] != H3U[pos]:
if H3U[pos] != '?':
print('NO')
tuIs = False
break
elif test[pos] not in \_4ES3:
tuIs = False
break
except:
print('NO')
break
if tuIs:
print('YES')
continue
rXumW6 = check\_left(test, H3U, \_4ES3)
odVb = check\_right(test, H3U, \_4ES3)
# print(rXumW6, odVb)
if rXumW6 == 'NO':
print('NO')
elif odVb == 'NO':
print('NO')
else:
if odVb < rXumW6 - 1:
print('NO')
continue
tuIs = True
for pos in range(rXumW6, odVb + 1):
if test[pos] in \_4ES3:
print('NO')
tuIs = False
break
if tuIs:
print('YES')
</ans>",0,{}
325," <ans>
n = int(input())
x0, y0 = map(int, input().split())
Nord = 10 ** 9 + 1
fNord = '-'
East = 10 ** 9 + 1
Pt5dT = '-'
South = -10 ** 9 - 1
j8p = '-'
West = -10 ** 9 - 1
jFR = '-'

NE = 10 ** 9 + ",0,{}
326," <ans>
#D6h, n4MFj7wsr = map(int, input().split())
D6h = int(input())

TVDM37FUuY = input()

HmWcs5GHP = int(D6h * (D6h - 1) / 2)
n4MFj7wsr = 0

for i in range(D6h):
if TVDM37FUuY[i] == 'A':
n4MFj7wsr += 1
else:
if n4MFj7wsr > 1:
HmWcs5GHP -= (n4MFj7wsr - 1)
n4MFj7wsr = 0
n4MFj7wsr = 0

for i in range(D6h):
if TVDM37FUuY[i] == 'B':
n4MFj7wsr += 1
else:
if n4MFj7wsr > 1:
HmWcs5GHP -= (n4MFj7wsr - 1)
n4MFj7wsr = 0
TVDM37FUuY = TVDM37FUuY[::-1]

n4MFj7wsr = 0
for i in range(D6h):
if TVDM37FUuY[i] == 'A':
n4MFj7wsr += 1
else:
if n4MFj7wsr > 1:
HmWcs5GHP -= (n4MFj7wsr - 1)
n4MFj7wsr = 0
n4MFj7wsr = 0

for i in range(D6h):
if TVDM37FUuY[i] == 'B':
n4MFj7wsr += 1
else:
if n4MFj7wsr > 1:
HmWcs5GHP -= (n4MFj7wsr - 1)
n4MFj7wsr = 0
n4MFj7wsr = 0

if TVDM37FUuY[0] == 'A':
n4MFj7wsr += 1
for i in range(D6h):
if TVDM37FUuY[i] == 'A':
n4MFj7wsr += 1
elif n4MFj7wsr >= 1:
HmWcs5GHP -= 1
n4MFj7wsr = 0

n4MFj7wsr = 0
if TVDM37FUuY[0] == 'B':
n4MFj7wsr += 1
for i in range(D6h):
if TVDM37FUuY[i] == 'B':
n4MFj7wsr += 1
elif n4MFj7wsr >= 1:
HmWcs5GHP -= 1
n4MFj7wsr = 0

print(HmWcs5GHP)
</ans>",0,{}
327," <ans>
```python
#!/usr/bin/env python3


class CantException(Exception):
    pass


def odd_v(value):
    return 1 if value % 2 == 1 else -1


UBeNJJ = set()
mo0NOLP = 0
U1sDoJ = 0
nJ5Z_9 = set()


def change(UBeNJJ, oddv, m):
    nonlocal mo0NOLP

    if MRzRcD[oddv]:
        VBo3tyZ = MRzRcD[oddv].pop()
        UBeNJJ.add(VBo3tyZ)
        return VBo3tyZ

    change_idx_start = b5Gv

    while b5Gv in UBeNJJ or odd_v(b5Gv) != oddv:
        if b5Gv not in UBeNJJ:
            MRzRcD[oddv].add(b5Gv)
        b5Gv += 1
        if b5Gv > m:
            b5Gv = 1
        if b5Gv == change_idx_start:
            raise CantException()

    VBo3tyZ = b5Gv
    UBeNJJ.add(VBo3tyZ)

    b5Gv += 1
    if b5Gv > m:
        b5Gv = 1
    return VBo3tyZ


def solve():
    n, m = list(map(int, input().split()))
    bRt1DB = list(map(int, input().split()))

    U1sDoJ = 0
    UBeNJJ = set()
    nJ5Z_9 = set()

    for i, c in enumerate(bRt1DB):
        U1sDoJ += odd_v(c)
        if c in UBeNJJ:
            nJ5Z_9.add(i)
        UBeNJJ.add(c)

    change_count = len(nJ5Z_9)

    for i in nJ5Z_9:
        if U1sDoJ * odd_v(bRt1DB[i]) <= 0:
            bRt1DB[i] = change(UBeNJJ, odd_v(bRt1DB[i]), m)
        else:
            U1sDoJ -= 2 * odd_v(bRt1DB[i])
            bRt1DB[i] = change(UBeNJJ, -odd_v(bRt1DB[i]), m)

    U1sDoJ = 0
    for i, c in enumerate(bRt1DB):
        U1sDoJ += odd_v(c)
    if U1sDoJ != 0:
        print(U1sDoJ)
        print(""WTFFFFF"")

    return change_count, bRt1DB


def __starting_point():
    try:
        change_cnt, cards = solve()
        print(change_cnt)
        print("" "".join(map(str, cards)))
    except CantException:
        print(""-1"")

__starting_point()
```
</ans>",0,{}
328," <ans>
def dp(ind, QnAPwj15R):
	QnAPwj15R = min(m, QnAPwj15R)

	if ind not in wasY:
		wasY[ind] = {}

	d = wasY[ind]
	if QnAPwj15R in d:
		return d[QnAPwj15R]

	ans = blah(ind, QnAPwj15R)

	d[QnAPwj15R] = ans
	return ans


# path = {}

class Node:
	def __init__(self, key, val, next=None):
		self.key = key
		self.val = val
		self.next = next

def blah(ind, QnAPwj15R):
	x, s = XAesd3r[ind]
	# key = (ind, QnAPwj15R)

	if QnAPwj15R >= m:
		# path[key] = Node(key, 0)
		return 0

	if ind == len(XAesd3r) - 1:
		if QnAPwj15R < x - s - 1:
			left_needed = x - s - (QnAPwj15R + 1)
			right_needed = max(m - (x + s), 0)
			ans = max(left_needed, right_needed)
			# path[key] = Node(key, ans)
			return ans
		else:
			right_boundary = max(QnAPwj15R, x + s)
			ans = max(0, m - right_boundary)
			# path[key] = Node(key, ans)
			return ans

	if QnAPwj15R < x - s - 1:
		num_needed = x - s - (QnAPwj15R + 1)
		new_boundary = min(x + s + num_needed, m)
		use_i = num_needed + dp(ind + 1, new_boundary)
		tH9CNJ = dp(ind + 1, QnAPwj15R)

		# if use_i < tH9CNJ:
		# 	path[key] = Node(key, num_needed, path[(ind + 1, new_boundary)])
		# else:
		# ",0,{}
329," <ans>

import math;

#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра
def getCoordinate(gx, mFhBGVJ, s18, T3Q, CGs1SoC3Yr):
EIBErJPx=gx+T3Q*math.cos(s18)-CGs1SoC3Yr*math.sin(s18);
A6uPsPrb=mFhBGVJ+T3Q*math.sin(s18)+CGs1SoC3Yr*math.cos(s18);
return EIBErJPx, A6uPsPrb

#Вычисление угла, на который надо повернуть точку с координатами T3Q, CGs1SoC3Yr,
#чтобы она оказалась прямо над gx, mFhBGVJ
def getAngle(gx, mFhBGVJ, T3Q, CGs1SoC3Yr):
T3Q=T3Q-gx;
CGs1SoC3Yr=CGs1SoC3Yr-mFhBGVJ;
cos=T3Q/math.sqrt(T3Q**2+CGs1SoC3Yr**2);
s18=math.acos(cos);
if CGs1SoC3Yr<0:
s18=-s18;
return math.pi/2-s18;

n, aM9J2L = list(map(int, input().split(' ')));
T3Q=[0]*n;
CGs1SoC3Yr=[0]*n;
for i in range(n):
T3Q[i], CGs1SoC3Yr[i]=list(map(int, input().split(' ')));
jhLC5sh=[0]*aM9J2L;
p5Bl68=[0]*aM9J2L;
in38=[0]*aM9J2L;
for i in range(aM9J2L):
l=list(map(int, input().split(' ')));
jhLC5sh[i]=l[0];
if jhLC5sh[i]==1:
p5Bl68[i]=l[1]-1;
in38[i]=l[2]-1;
else:
in38[i]=l[1]-1;
TElwixN9Q1=0;
mFhBGVJ=0;
ksyEKUX=0;
for i in range(n):
ip=i+1;
if ip==n:
ip=0;
ds=T3Q[i]*CGs1SoC3Yr[ip]-T3Q[ip]*CGs1SoC3Yr[i];
ksyEKUX+=ds;
TElwixN9Q1+=(T3Q[i]+T3Q[ip])*ds;
mFhBGVJ+=(CGs1SoC3Yr[i]+CGs1SoC3Yr[ip])*ds;
ksyEKUX/=2;
TElwixN9Q1/=6\*ksyEKUX;
mFhBGVJ/=6\*ksyEKUX;
tz2AOvX=[0]*n;
for i in range(n):
tz2AOvX[i]=getAngle(TElwixN9Q1, mFhBGVJ, T3Q[i], CGs1SoC3Yr[i]);
for i in range(n):
T3Q[i]-=TElwixN9Q1;
CGs1SoC3Yr[i]-=mFhBGVJ;
s18=0;
#print('pos',TElwixN9Q1, mFhBGVJ, s18);
#Восстанавливать положение точек будем по центру масс и углу
#Угол - поворот против часовой вокруг центра масс
CRgACZ4={0, 1}
for i in range(aM9J2L):
if jhLC5sh[i]==2:
currX, currY = getCoordinate(TElwixN9Q1, mFhBGVJ, s18, T3Q[in38[i]], CGs1SoC3Yr[in38[i]]);
print(""%.6f %.6f""%(currX, currY))
else:
if len(CRgACZ4)==2:
CRgACZ4.remove(p5Bl68[i]);
#print('remove',p5Bl68[i])
#j - единственный элемент в множестве
for j in CRgACZ4:
#print(j);
currX, currY = getCoordinate(TElwixN9Q1, mFhBGVJ, s18, T3Q[j], CGs1SoC3Yr[j]);
#print('fix:', currX, currY)
#dalpha=getAngle(TElwixN9Q1, mFhBGVJ, currX, currY);
#s18+=dalpha;
s18=tz2AOvX[j];
#Чтобы вычислить новые координаты g, нуно повернуть ее на угол
#dalpha относительно currX, currY
TElwixN9Q1, mFhBGVJ=currX, currY-math.sqrt(T3Q[j]**2+CGs1SoC3Yr[j]**2);
#print('pos',TElwixN9Q1, mFhBGVJ, s18/math.pi)
CRgACZ4.add(in38[i]);
</ans>",0,{}
330," <ans>
```python
#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
",0,{}
331," <ans>
```python
#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
from fractions import *
from bisect import *
from io import BytesIO, IOBase
def koV6H2mU4J():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
KlplGL = 8192
class FastIO(IOBase):
    rtIJeg8 = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            age7 = os.read(self._fd, max(os.fstat(self._fd).st_size, KlplGL))
            if not age7:
                break
            lFGYidQBi = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(age7), self.buffer.seek(lFGYidQBi)
        self.rtIJeg8 = 0
        return self.buffer.read()
    def readline(self):
        while self.rtIJeg8 == 0:
            age7 = os.read(self._fd, max(os.fstat(self._fd).st_size, KlplGL))
            self.rtIJeg8 = age7.count(b""\n"") + (not age7)
            lFGYidQBi = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(age7), self.buffer.seek(lFGYidQBi)
        self.rtIJeg8 -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
GsQe6='abcdefghijklmnopqrstuvwxyz'
O2MJoh=1000000007
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# koV6H2mU4J()


n,m,o=value()
for i in range(n):
    input()

print(m*(m-1)//2)
for i in range(1,m+1):
    for j in range(i+1,m+1):
        if(o==0):
            print(i,j)
        else:
            print(m-i+1,m-j+1)












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































",0,{}
332," <ans>
def solve1(VXD, XFjwY):  
BL0 =[]
j1D6x97OD=[]
yj58a=0
while yj58a<(VXD):
if not j1D6x97OD:
BL0.append(-1)
j1D6x97OD.append(yj58a)

elif j1D6x97OD and XFjwY[yj58a]<XFjwY[j1D6x97OD[-1]]:
BL0.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
else:
while j1D6x97OD and XFjwY[yj58a]>XFjwY[j1D6x97OD[-1]]:
j1D6x97OD.pop()

if not j1D6x97OD:
j1D6x97OD.append(yj58a)
BL0.append(-1)

else:
BL0.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)

yj58a+=1
patYeEAhfY=[]
j1D6x97OD=[]
yj58a=VXD-1
while yj58a>(-1):
if not j1D6x97OD:
patYeEAhfY.append(VXD)
j1D6x97OD.append(yj58a)

elif j1D6x97OD and XFjwY[yj58a]<XFjwY[j1D6x97OD[-1]]:
patYeEAhfY.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
else:
while j1D6x97OD and XFjwY[yj58a]>=XFjwY[j1D6x97OD[-1]]:
j1D6x97OD.pop()

if not j1D6x97OD:
j1D6x97OD.append(yj58a)
patYeEAhfY.append(VXD)

else:
patYeEAhfY.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
yj58a-=1
patYeEAhfY=patYeEAhfY[::-1]
hrwmWKlu=0
for i in range(len(BL0)):
JqYWTBoNd=(patYeEAhfY[i]-i)*(i-BL0[i])*XFjwY[i]
if JqYWTBoNd==0:
hrwmWKlu+=XFjwY[i]
else:
hrwmWKlu+=JqYWTBoNd
return hrwmWKlu

def solve2(VXD, XFjwY):
BL0 =[]
j1D6x97OD=[]
yj58a=0
while yj58a<(VXD):
if not j1D6x97OD:
BL0.append(-1)
j1D6x97OD.append(yj58a)

elif j1D6x97OD and XFjwY[yj58a]>XFjwY[j1D6x97OD[-1]]:
BL0.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
else:
while j1D6x97OD and XFjwY[yj58a]<XFjwY[j1D6x97OD[-1]]:
j1D6x97OD.pop()

if not j1D6x97OD:
j1D6x97OD.append(yj58a)
BL0.append(-1)

else:
BL0.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
yj58a+=1
patYeEAhfY=[]
j1D6x97OD=[]
yj58a=VXD-1
while yj58a>(-1):
if not j1D6x97OD:
patYeEAhfY.append(VXD)
j1D6x97OD.append(yj58a)

elif j1D6x97OD and XFjwY[yj58a]>XFjwY[j1D6x97OD[-1]]:
patYeEAhfY.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
else:
while j1D6x97OD and XFjwY[yj58a]<=XFjwY[j1D6x97OD[-1]]:
j1D6x97OD.pop()

if not j1D6x97OD:
j1D6x97OD.append(yj58a)
patYeEAhfY.append(VXD)

else:
patYeEAhfY.append(j1D6x97OD[-1])
j1D6x97OD.append(yj58a)
yj58a-=1
patYeEAhfY=patYeEAhfY[::-1]
hrwmWKlu=0
for i in range(len(BL0)):
JqYWTBoNd=(patYeEAhfY[i]-i)*(i-BL0[i])*XFjwY[i]
if JqYWTBoNd==0:
hrwmWKlu+=XFjwY[i]
else:
hrwmWKlu+=JqYWTBoNd
return hrwmWKlu

VXD=int(input())
XFjwY=[int(x) for x in input().split()]
print(solve1(XFjwY,VXD)-solve2(XFjwY,VXD))
</ans>",0,{}
333," <ans>
import math
\_h5MN3YpR=int(input())

def get\_circle\_2p(p1,p2):
p1\_x,p1\_y=p1
p2\_x,p2\_y=p2
```python
x=(p1_x+p2_x)/2
y=(p1_y+p2_y)/2  
r=math.sqrt((p1_x-p2_x)**2+(p1_y-p2_y)**2)/2
return x,y,r
```
def get\_circle\_3p(p1,p2,p3):
p1\_x,p1\_y=p1
p2\_x,p2\_y=p2
p3\_x,p3\_y=p3
d=2*((p1\_y-p3\_y)*(p1\_x-p2\_x)-(p1\_y-p2\_y)*(p1\_x-p3\_x))
```python
if d==0:
  rad1=math.sqrt((p1_x-p2_x)**2+(p1_y-p2_y)**2)/2
  rad2=math.sqrt((p1_x-p3_x)**2+(p1_y-p3_y)**2)/2
  rad3=math.sqrt((p2_x-p3_x)**2+(p2_y-p3_y)**2)/2

  if rad1>=rad2 and rad1>=rad3:
    x=(p1_x+p2_x)/2
    y=(p1_y+p2_y)/2
    return x,y,rad1
  elif rad2>=rad1 and rad2>=rad3:
    x=(p1_x+p3_x)/2
    y=(p1_y+p3_y)/2
    return x,y,rad2
  elif rad3>=rad1 and rad3>=rad2:
    x=(p2_x+p3_x)/2
    y=(p2_y+p3_y)/2
    return x,y,rad3      
else:
  x=((p1_y-p3_y)*(p1_y**2-p2_y**2+p1_x**2-p2_x**2)-(p1_y-p2_y)*(p1_y**2-p3_y**2+p1_x**2-p3_x**2))/d
  y=((p1_x-p3_x)*(p1_x**2-p2_x**2+p1_y**2-p2_y**2)-(p1_x-p2_x)*(p1_x**2-p3_x**2+p1_y**2-p3_y**2))/-d
  r=math.sqrt((x-p1_x)**2+(y-p1_y)**2)
  return x,y,r
```
u5Ivp=[]
for i in range(\_h5MN3YpR):
u5Ivp.append(tuple(map(int,input().split())))

if \_h5MN3YpR==2:
x,y,r=get\_circle\_2p(u5Ivp[0],u5Ivp[1])
print(r)
else:
O1Od5QFzn=float(""inf"")
for i in range(\_h5MN3YpR):
for j in range(i+1,\_h5MN3YpR):
x,y,r=get\_circle\_2p(u5Ivp[i],u5Ivp[j])
if r<O1Od5QFzn:
for l in range(\_h5MN3YpR):
if l==i or l==j:
continue
X4mZ1=u5Ivp[l][0]-x
Wf4rO=u5Ivp[l][1]-y
if math.sqrt(X4mZ1**2+Wf4rO**2)>r:
break
else:
O1Od5QFzn=r

for i in range(\_h5MN3YpR):
for j in range(i+1,\_h5MN3YpR):
for k in range(j+1,\_h5MN3YpR):
x,y,r=get\_circle\_3p(u5Ivp[i],u5Ivp[j],u5Ivp[k])
if r<O1Od5QFzn:
for l in range(\_h5MN3YpR):
if l==i or l==j or l==k:
continue
X4mZ1=u5Ivp[l][0]-x
Wf4rO=u5Ivp[l][1]-y
if math.sqrt(X4mZ1**2+Wf4rO**2)>r:
break
else:
O1Od5QFzn=r

print(O1Od5QFzn)
</ans>",0,{}
334," <ans>
import math
from decimal import Decimal
import heapq
from collections import deque
def na():
	Pp4paDnKFw = int(input())
	e8rUW = [int(x) for x in input().split()]
	return Pp4paDnKFw,e8rUW

def nab():
	Pp4paDnKFw = int(input())
	e8rUW = [int(x) for x in input().split()]
	YZY7eA = [int(x) for x in input().split()]
	return Pp4paDnKFw,e8rUW,YZY7eA

def dv():
	Pp4paDnKFw, s2r = list(map(int, input().split()))
	return Pp4paDnKFw,s2r

def dva():
	Pp4paDnKFw, s2r, Hqjw7pa = list(map(int, input().split()))
	e8rUW = [int(x) for x in input().split()]
	YZY7eA = [int(x) for x in input().split()]
	return Pp4paDnKFw,s2r,Hqjw7pa,YZY7eA

def eratosthenes(Pp4paDnKFw): 
	fk9k = list(range(Pp4paDnKFw + 1))
	for i in fk9k:
		if i > 1:
			for j in range(i + i, len(fk9k), i):
				fk9k[j] = 0
	return sorted(set(fk9k))

def lol(lst,YZY7eA):
	YZY7eA=YZY7eA%len(lst)
	hBSKruB=[0]*len(lst)
	for i in range(len(lst)):
		if i+YZY7eA<len(lst) and i+YZY7eA>=0:
			hBSKruB[i]=lst[i+YZY7eA]
		if i+YZY7eA>=len(lst):
			hBSKruB[i]=lst[i+YZY7eA-len(lst)]
		if i+YZY7eA<0:
			hBSKruB[i]=lst[i+YZY7eA+len(lst)]
	return(hBSKruB)
def nm():
	Pp4paDnKFw = int(input())
	e8rUW = [int(x) for x in input().split()]
	s2r = int(input())
	YZY7eA = [int(x) for x in input().split()]
	return Pp4paDnKFw,e8rUW,s2r,YZY7eA

def dvs():
	Pp4paDnKFw = int(input())
	s2r = int(input())
	return Pp4paDnKFw, s2r

def fact(Hqjw7pa, s2r):
	hBSKruB = []
	OR\_1rIksdY = 0
	kst\_a = int(math.sqrt(Hqjw7pa))
	for i in range(1, kst\_a + 1):
		if Hqjw7pa % i == 0:
			hBSKruB.append(i)
	l = len(hBSKruB)
	for i in range(l):
		hBSKruB.append(Hqjw7pa // hBSKruB[i])
	for i in range(len(hBSKruB)):
		if hBSKruB[i] <= s2r:
			OR\_1rIksdY += 1
	if Hqjw7pa / kst\_a == kst\_a and s2r >= kst\_a:
		return OR\_1rIksdY - 1
	return OR\_1rIksdY

khwBJatT\_u = int(input())
for i in range(khwBJatT\_u):
	uyx, s2r = list(map(int, input().split()))
	if uyx >= s2r:
		print('YES')
		continue
	if uyx == 2 and s2r == 3:
		print('YES')
		continue
	elif uyx <= 3 and s2r > 3:
		print('NO')
		continue
	if uyx == 1:
		print('NO')
	else:
		print('YES')
</ans>",0,{}
335," <ans>
from queue import Queue
import sys
#sys.stdin = open('input.txt')

n, m, k = [int(x) for x in input().split(' ')]

if k&1:
print('IMPOSSIBLE')
return

DXc = [None]*n
for i in range(n):
DXc[i] = [None]*m
DXc[i][j] = input()[j]
if DXc[i][j] == 'X': Ogqzx, ZWX9xv\_K0u = j, i

def bfs(Ogqzx, ZWX9xv\_K0u):
Hs1 = [[10000000]*m for i in range(n)]
if DXc[ZWX9xv\_K0u][Ogqzx] == '*': return Hs1
IrLHonbQ9 = Queue()
IrLHonbQ9.put((Ogqzx, ZWX9xv\_K0u))
d3WoyGyA = 0

def _efijLswB(Ogqzx, ZWX9xv\_K0u):
if Hs1[ZWX9xv\_K0u][Ogqzx] != 10000000 or DXc[ZWX9xv\_K0u][Ogqzx] == '*' or d3WoyGyA >= Hs1[ZWX9xv\_K0u][Ogqzx]: return
IrLHonbQ9.put((Ogqzx, ZWX9xv\_K0u))
Hs1[ZWX9xv\_K0u][Ogqzx] = d3WoyGyA+1

Hs1[ZWX9xv\_K0u][Ogqzx] = d3WoyGyA

while not IrLHonbQ9.empty():
Ogqzx, ZWX9xv\_K0u = IrLHonbQ9.get()
d3WoyGyA = Hs1[ZWX9xv\_K0u][Ogqzx]
#print('-')
if ZWX9xv\_K0u < n-1: _efijLswB(Ogqzx, ZWX9xv\_K0u+1) #D
if Ogqzx > 0: _efijLswB(Ogqzx-1, ZWX9xv\_K0u) #L
if Ogqzx < m-1: _efijLswB(Ogqzx+1, ZWX9xv\_K0u) #R
if ZWX9xv\_K0u > 0: _efijLswB(Ogqzx, ZWX9xv\_K0u-1) #U
return Hs1

Hs1 = bfs(Ogqzx, ZWX9xv\_K0u)

for i in range(k):
d3WoyGyA = k-i
#print(step, (y, x), k-i)
if ZWX9xv\_K0u < n-1 and Hs1[ZWX9xv\_K0u+1][Ogqzx] <= d3WoyGyA: #D
Hs1 = ['D']
ZWX9xv\_K0u = ZWX9xv\_K0u+1
elif Ogqzx > 0 and Hs1[ZWX9xv\_K0u][Ogqzx-1] <= d3WoyGyA: #L
Hs1.append('L')
Ogqzx = Ogqzx-1
elif Ogqzx < m-1 and Hs1[ZWX9xv\_K0u][Ogqzx+1] <= d3WoyGyA: #R
Hs1.append('R')
Ogqzx = Ogqzx+1
elif ZWX9xv\_K0u > 0 and Hs1[ZWX9xv\_K0u-1][Ogqzx] <= d3WoyGyA: #U
Hs1.append('U')
ZWX9xv\_K0u = ZWX9xv\_K0u-1
else:
print('IMPOSSIBLE')
return

print(''.join(Hs1))
</ans>",0,{}
336," <ans>
from collections import deque, namedtuple
from heapq import *
from sys import stdin

ymFJ = float('inf')
Edge = namedtuple('Edge', 'start, end, ymFJ')

```python
def make_edge(start, end, ymFJ=1):
    return Edge(start, end, ymFJ)


class Graph:
    def __init__(self, edges, bi=True):
        WZ1lmyLa = [i for i in edges if len(i) not in [2, 3]]
        if WZ1lmyLa:
            raise ValueError('Wrong edges data: {}'.format(WZ1lmyLa))
        self.edges = [make_edge(*edge) for edge in edges]
        self.vertices = set(
            sum(
                ([edge.start, edge.end] for edge in self.edges), []
            ))
        self.neighbors = {vertex: set() for vertex in self.vertices}
        for edge in self.edges:
            self.neighbors[edge.start].add(edge.end)

    def get_node_pairs(self, n1, n2, both_ends=True):
        if both_ends:
            node_pairs = [[n1, n2], [n2, n1]]
        else:
            node_pairs = [[n1, n2]]
        return node_pairs

    def remove_edge(self, n1, n2, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        edges = self.edges[:]
        for edge in edges:
            if[edge.start, edge.end] in node_pairs:
                self.edges.remove(edge)

    def add_edge(self, n1, n2, ymFJ=1, both_ends=True):
        node_pairs = self.get_node_pairs(n1, n2, both_ends)
        for edge in self.edges:
            if [edge.start, edge.end] in node_pairs:
                return ValueError('Edge {} {} already exists'.format(n1, n2))

        self.edges.append(Edge(start=n1, end=n2, ymFJ=ymFJ))
        if both_ends:
            self.edges.append(Edge(start=n2, end=n1, ymFJ=ymFJ))

    def dijkstra(self, source, dest):
        assert source in self.vertices, 'Such source node doesn\'t exist'
        REuJ_PHC7x = {vertex: ymFJ for vertex in self.vertices}
        REuJ_PHC7x[source] = 0

        q, seen = [(0, source)], set()
        while q:
            (curr_cost, current_vertex) = heappop(q)
            if current_vertex in seen:
                continue
            seen.add(current_vertex)
            for neighbor in self.neighbors[current_vertex]:
                cost = 1
                if neighbor in seen:
                    continue
                o5vdEX = REuJ_PHC7x[current_vertex] + cost
                if o5vdEX < REuJ_PHC7x[neighbor]:
                    REuJ_PHC7x[neighbor] = o5vdEX
                    heappush(q, (o5vdEX, neighbor))

        return REuJ_PHC7x


n, m, s, t = [int(x) for x in stdin.readline().rstrip().split()]

wxMHKOoz = []
for i in range(m):
    wxMHKOoz.append(tuple([int(x) for x in stdin.readline().rstrip().split()]))
rev_wxMHKOoz = []
for i in wxMHKOoz:
    rev_wxMHKOoz.append((i[1], i[0]))
for i in rev_wxMHKOoz:
    wxMHKOoz.append(i)
oXJ7bk = Graph(wxMHKOoz)
AUAu2b5b35 = oXJ7bk.dijkstra(s, t)
pP_ = oXJ7bk.dijkstra(t, s)
SHORTEST_DIST = AUAu2b5b35[t]
count = 0

for i in range(1, n + 1):
    for j in range(i + 1, n + 1):
        if j not in oXJ7bk.neighbors[i] and \
                i not in oXJ7bk.neighbors[j] and \
                AUAu2b5b35[i] + pP_[j] + 1 >= SHORTEST_DIST and \
                AUAu2b5b35[j] + pP_[i] + 1 >= SHORTEST_DIST:
            count = count + 1

print(count)

```
</ans>",0,{}
337," <ans>

```
#
#
#
# 笑え、君が好きなように。
#                         笑いは世界を救う。
#                                           あなたが笑ってくれるなら。
#
from statistics import median
import collections
bb = collections.Counter(a) # list to list || .most_common(2)で最大の2個とりだせるお bb[0][0]
from math import gcd
from itertools import combinations,permutations,accumulate, product, combinations_with_replacement # (string,3) 3回
from collections import deque,defaultdict,Counter
import decimal
import re
import math
import bisect
#
# set型だと、 | と & が使えるよ
#
# pythonで無理なときは、pypyでやると正解するかも！！
#
#
# my_round_int = lambda x:np.round((x*2 + 1)//2)
# 四捨五入g
#
# インデックス系
# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);
# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);
#
#
# 整数か判定する
# nanka.is_integer()
# ref https://atcoder.jp/contests/abc133/tasks/abc133_b
import sys
sys.setrecursionlimit(10000000)
cf0C5G = 10**9 + 7
# cf0C5G = 9982443453
# cf0C5G = 998244353
Lgv9kXYLC = float('inf')
rf5 = [0,1,0,-1]
D06wG = [1,0,-1,0]
from sys import stdin
BZAJ = stdin.readline
def readInts():
  return list(map(int,BZAJ().split()))
def readTuples():
    return tuple(map(int,BZAJ().split()))
def I():
    return int(BZAJ())
def f(n):
    return int(math.ceil(n-0.5))
N,K = readInts()
def calc(n):
    if n <= 0 or n > 2*N:
        return 0
    else:
        return min(n-1, 2*N-n+1)
Pts = 0
for AB in range(2*N+1):
    #print(AB,calc(AB),AB-K, calc(K-AB))
    Pts += calc(AB) * calc(AB-K)
print(Pts)

```

</ans>",0,{}
338," <ans>
import sys
sys.setrecursionlimit(10 ** 9)
# input = sys.stdin.readline    ####
def int1(x): return int(x) - 1
def II(): return int(input())
def MI(): return list(map(int, input().split()))
def MI1(): return list(map(int1, input().split()))
def LI(): return list(map(int, input().split()))
def LI1(): return list(map(int1, input().split()))
def LLI(rows\_number): return [LI() for \_ in range(rows\_number)]
def MS(): return input().split()
def LS(): return list(input())
def LLS(rows\_number): return [LS() for \_ in range(rows\_number)]
def printlist(lst, k=' '): print((k.join(list(map(str, lst)))))
XNfgZBE = float('inf')
# from math import ceil, floor, log2
# from collections import deque
from itertools import combinations as comb, combinations\_with\_replacement as comb\_w, accumulate, product, permutations
# from heapq import heapify, heappop, heappush
# import numpy as np
# from numpy import cumsum  # accumulate

def solve():
XgiEu2JZ, K = MI()
PN2 = LI()

M = XgiEu2JZ
divs = []
for i in range(1, int(pow(M, 0.5))+1):
if M % i: continue
divs.append(i)
if i != M//i: divs.append(M//i)
divs.sort(reverse=True)

for d in divs:
B = list([x%d for x in PN2])
B.sort()
C = list([d-x for x in B])
# print(d, B, C)
# print(list(accumulate(B)), list(accumulate(C)))
Ba = list(accumulate(B))
Ca = list(accumulate(C))
for i in range(0, len(PN2)-1):
b = Ba[i]
c = Ca[-1] - Ca[i]
# print(b, c)
if b == c and b <= K:
print(d)
return
print((1))

def **starting\_point**():
solve()

**starting\_point**()
</ans>",0,{}
339," <ans>
```python
import sys

def matching(node, visited, wcte, DDGTgb0Xrv):
	if node == -1:
		return True
	if visited[node]:
	",0,{}
340," <ans>
import sys

inp = sys.stdin.readline
input = lambda: inp().strip()

def iin(): return int(input())

def lin(): return list(map(int, input().split()))

def main():
import heapq as hq
zXKUH5FJ = iin()
SMX = lin()
aogd = lin()
dc = {}
for i in range(zXKUH5FJ):
try:
dc[SMX[i]].append(aogd[i])
except:
dc[SMX[i]] = [aogd[i], ]
sa = list(dc.keys())
sa.sort()
n = len(sa)
CN02 = 0
HA2 = sa[CN02]
FPhxa7TK9p = []
m7S = 0
xkmfSH = 0
hq.heapify(FPhxa7TK9p)
done = 0
while CN02 < n:
pt = sa[CN02]
if len(dc[pt]) > 1 or done:
a1 = sorted(dc[pt])
for item in a1:
hq.heappush(FPhxa7TK9p, -item)
m7S += item
x = hq.heappop(FPhxa7TK9p) * (-1)
dc[pt] = [x]
m7S -= x
while len(FPhxa7TK9p):
xkmfSH += m7S
HA2 += 1
if HA2 in dc:
CN02 += 1
done = 1
break
else:
x = hq.heappop(FPhxa7TK9p) * (-1)
m7S -= x
else:
CN02 += 1
done = 0
xkmfSH += m7S
print(xkmfSH)

main()
</ans>",0,{}
341," <ans>
import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy

ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return [int(i) for i in input().split()]
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
if n < 2: return list()
prime = [True for _ in range(n + 1)]
p = 3
while p * p <= n:
if prime[p]:
for i in range(p * 2, n + 1, p):
prime[i] = False
p += 2
r = [2]
for p in range(3, n + 1, 2):
if prime[p]:
r.append(p)
return r
def divs(n, start=1):
r = []
for i in range(start, int(math.sqrt(n) + 1)):
if (n % i == 0):
if (n / i == i):
r.append(i)
else:
r.extend([i, n // i])
return r
def divn(n, primes):
divs\_number = 1
for i in primes:
if n == 1:
return divs\_number
t = 1
while n % i == 0:
t += 1
n //= i
divs\_number \*= t
def OaokM(n):
if n == 2: return True
if n % 2 == 0 or n <= 1: return False
sqr = int(math.sqrt(n)) + 1
for d in range(3, sqr, 2):
if n % d == 0: return False
return True
def convn(number, base):
newnumber = 0
while number > 0:
newnumber += number % base
number //= base
return newnumber
def cdiv(n, k): return n // k + (n % k != 0)

for _ in range(ii()):
a, b = mi()
print(b - a % b) if a % b else print(0)
</ans>",0,{}
342," <ans>
def add(a,b):
a = a%(1000000000+7)
b=b%(1000000000+7)
return (a+b)%(1000000000+7)

Ygv =int(input())
i=1
DpvndiWX = []
WNn = [[0 for i in range(Ygv)] for i in range(Ygv)]
QM7k = [[0 for i in range(Ygv)] for i in range(Ygv)]
while(i<=Ygv):
PJ5TX81z9n = input()
DpvndiWX.append(PJ5TX81z9n)
i+=1

WNn[0][0]=1
QM7k[0][0]=1
DerHO9=1
while(DerHO9<Ygv):
QM7k[0][DerHO9] = QM7k[0][DerHO9] + QM7k[0][DerHO9-1]
DerHO9+=1

i=1
while(i<Ygv):
if(DpvndiWX[i-1]=='f'):
DerHO9=1
while(DerHO9<Ygv):
WNn[i][0]=0
QM7k[i][0]=0
WNn[i][DerHO9] = WNn[i-1][DerHO9-1]
QM7k[i][DerHO9] = add(QM7k[i][DerHO9-1],WNn[i][DerHO9])

DerHO9+=1
else:
DerHO9=0
while(DerHO9<Ygv):
if(DerHO9==0):
WNn[i][DerHO9] = QM7k[i-1][Ygv-1]
else:
WNn[i][DerHO9] = QM7k[i-1][Ygv-1] - QM7k[i-1][DerHO9-1]
QM7k[i][DerHO9] = add(QM7k[i][DerHO9-1],WNn[i][DerHO9])
DerHO9+=1
i+=1

ans = 0
DerHO9=0
while(DerHO9<Ygv):
ans=add(ans,WNn[Ygv-1][DerHO9])
DerHO9+=1

print(ans%(1000000000+7))
</ans>",0,{}
343," <ans>
def compute():
n, m = [int(s) for s in input().split()]
ddjv0a7Oo = {}
for i in range(m):
u, v = [int(s) for s in input().split()]
if u > v:
if ddjv0a7Oo.get(u) == 2:
return 0
if ddjv0a7Oo.get(v) == 1:
return 0
ddjv0a7Oo[u] = 1
ddjv0a7Oo[v] = 2
else:
if ddjv0a7Oo.get(v) == 2:
return 0
if ddjv0a7Oo.get(u) == 1:
return 0
ddjv0a7Oo[v] = 1
ddjv0a7Oo[u] = 2
Ki3Ot, aTUEA5q = [], []
for k, v in list(ddjv0a7Oo.items()):
if v == 1:
aTUEA5q.append(k)
else:
Ki3Ot.append(k)
POuzgql1bL = [i for i in range(1, n + 1) if i not in ddjv0a7Oo]
if not aTUEA5q:
if POuzgql1bL:
aTUEA5q.append(POuzgql1bL[-1])
POuzgql1bL.remove(POuzgql1bL[-1])
else:
return 0
if not Ki3Ot:
if POuzgql1bL:
Ki3Ot.append(POuzgql1bL[0])
POuzgql1bL.remove(POuzgql1bL[0])
else:
return 0
J3F = 1
for i in range(len(POuzgql1bL)):
if POuzgql1bL[i] > aTUEA5q[-1]:
pass
elif POuzgql1bL[i] < max(Ki3Ot):
pass
else:
J3F += 1
return J3F
res = compute()
print(res)
</ans>",0,{}
344," <ans>
import itertools

```python
class SolutionImpossible(Exception):
    pass


blocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]


def read_blocks_coords():
    it = (int(x) for x in input().split())
    return (x for x in it if x < finish)


# TODO: код можно сократить за счет избавления от лишней записи в `_grouper._current_key`
def _grouper(value):
    if _grouper._prev_value is not None:
        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        if value - _grouper._prev_value - 1 <= min_sprint:
            # расстояние между препятствиями слишком мало
            # чтобы между ними приземляться, и затем разогнаться для нового прыжка, считаем их за одно
            _current_key = _grouper._current_key
        else:
            _current_key = id(value)
    else:
        # первое вхождение, ставим данные по умолчанию
        _current_key = id(_grouper)

    _grouper._prev_value = value
    _grouper._current_key = _current_key

    return _current_key


_grouper._prev_value = None
_grouper._current_key = None


def check_chunk(run_from, block=None):
    if block is None:
        return

    next_run_from = block[-1] + 1  # следующая за преградой позиция (точка приземления)
    if next_run_from - block[0] >= max_jump:
        # если преграда слишком длинная, то мы не можем ее пересечь
        raise SolutionImpossible

    if abs(run_from - block[0]) <= min_sprint:
        # нет возможности для разбега
        raise SolutionImpossible


def solve_chunk(run_from, block=None):
    if block is not None:
        run_len = block[0] - run_from - 1  # добегаем ДО преграды
        jump_len = block[-1] - block[0] + 2  # прыгаем ЗА нее
        print((
            ""RUN {run_len}\n""
            ""JUMP {jump_len}"".format(
                run_len=run_len,
                jump_len=jump_len,
            )
        ))

    else:
        run_len = finish - run_from
        if run_len > 0:
            print(""RUN {run_len}"".format(run_len=run_len))


def main():
    # некоторые препятствия могут находиться так близко, что между ними нет возможности разогнаться
    # считаем такие препятствия за одно
    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))

    XHmeV = []

    ir78 = 0
    while True:
        Zl6PLh = next(blocks, None)

        chunk = (ir78, Zl6PLh)
        check_chunk(*chunk)

        XHmeV.append(chunk)

        if Zl6PLh is None:
            break

        # после прыжка мы приземляемся ЗА препятствием, учитываем это
        ir78 = Zl6PLh[-1] + 1

    #print(chunks)

    for chunk in XHmeV:
        solve_chunk(*chunk)


def __starting_point():
    try:
        main()
    except SolutionImpossible:
        print(""IMPOSSIBLE"")

__starting_point()
```
</ans>",0,{}
345," <ans>
def isPrefix(sa, sb):
if len(sa) <= len(sb):
return False
return sa[0:len(sb)] == sb

def getOrder(sa, sb):
for i in range(0, min(len(sa), len(sb))):
if sa[i] != sb[i]:
return sa[i], sb[i]

test = False
if test:
fp = open(""in.txt"", 'r')
jrKhNz = int(fp.readline().strip())
qVuUtT = [fp.readline().strip() for i in range(0, jrKhNz)]
fp.close()
else:
jrKhNz = int(input().strip())
qVuUtT = [input().strip() for i in range(0, jrKhNz)]

pFj3sb2v = [[False] \* 26 for i in range(0, 26)]

XjVV = True
for i in range(1, jrKhNz):
if qVuUtT[i - 1] == qVuUtT[i] or isPrefix(qVuUtT[i], qVuUtT[i - 1]):
continue
elif isPrefix(qVuUtT[i - 1], qVuUtT[i]):
XjVV = False
break
else:
ca, cb = getOrder(qVuUtT[i - 1], qVuUtT[i])
if pFj3sb2v[ord(cb) - ord('a')][ord(ca) - ord('a')]:
XjVV = False
break
else:
pFj3sb2v[ord(ca) - ord('a')][ord(cb) - ord('a')] = True

def printG():
print("" a b c d e f g h i j k l m n o p q r s t u v w x y z"")
for i in range(0, 26):
print(chr(ord('a') + i), """".join([""1"" if x else ""0"" for x in pFj3sb2v[i]]), sep = """")

if not XjVV:
print(""Impossible"")
else:

def getZeroIndegreeNode():
for i in range(0, 26):
if not mOvvI[i] and lGn[i] == 0:
return i
return -1

XjVV = True
#topo sort
mOvvI = [False] \* 26
lGn = [0] \* 26
c0D = -1

#calc indegree
for i in range(0, 26):
PyANaAc = 0
for j in range(0, 26):
if pFj3sb2v[j][i]: PyANaAc += 1
lGn[i] = PyANaAc
for i in range(0, 26):
c0D = getZeroIndegreeNode()
if c0D == -1:
XjVV = False
break
else:
mOvvI[c0D] = True
ZJZA.append(chr(ord('a') + c0D))
for j in range(0, 26):
if pFj3sb2v[c0D][j]:
lGn[j] -= 1
if not XjVV:
print(""Impossible"")
else:
print("""".join(ZJZA))
</ans>",0,{}
346," <ans>
```python
#!/usr/bin/env python3
class UnionFind:
    # 作りたい要素数nで初期化
    # 使用するインスタンス変数の初期化
    def __init__(self, n):
        self.n = n
        # root[x]<0ならそのノードが根かつその値が木の要素数
        # rootノードでその木の要素数を記録する
        self.root = [-1] * (n + 1)
        # 木をくっつける時にアンバランスにならないように調整する
        self.rnk = [0] * (n + 1)

    # ノードxのrootノードを見つける
    def Find_Root(self, x):
        if self.root[x] < 0:
            return x
        else:
            # ここで代入しておくことで、後の繰り返しを避ける
            self.root[x] = self.Find_Root(self.root[x])
            return self.root[x]

    # 木の併合、入力は併合したい各ノード
    def Unite(self, x, y):
        # 入力ノードのrootノードを見つける
        x = self.Find_Root(x)
        y = self.Find_Root(y)
        # すでに同じ木に属していた場合
        if x == y:
            return
        # 違う木に属していた場合rnkを見てくっつける方を決める
        elif self.rnk[x] > self.rnk[y]:
            self.root[x] += self.root[y]
            self.root[y] = x

        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            # rnkが同じ（深さに差がない場合）は1増やす
            if self.rnk[x] == self.rnk[y]:
                self.rnk[y] += 1

    # xとyが同じグループに属するか判断
    def isSameGroup(self, x, y):
        return self.Find_Root(x) == self.Find_Root(y)

    # ノードxが属する木のサイズを返す
    def Count(self, x):
        return -self.root[self.Find_Root(x)]


def main():
    n, m = list(map(int, input().split()))
    jcJygY = UnionFind(n)

    for i in range(m):
        a, b = list(map(int, input().split()))
        jcJygY.Unite(a, b)

    for i in range(n):
        i += 1
        jcJygY.isSameGroup(i, i)

    gE0gTYWgcX = 0
    for i in range(n):
        gE0gTYWgcX = max(gE0gTYWgcX, -jcJygY.root[i + 1])

    # print(jcJygY.root)
    print(gE0gTYWgcX)


main()
```
</ans>",0,{}
347," <ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
getcontext().prec = 30
rPAELC = sys.maxsize
xckxiLf3 = 10**5+10
MLYUw5 = 10**9+7
def isprime(L7VESiE):
L7VESiE = abs(int(L7VESiE))
if L7VESiE < 2:
return False
if L7VESiE == 2:
return True
if not L7VESiE & 1:
return False
for x in range(3, int(L7VESiE**0.5) + 1, 2):
if L7VESiE % x == 0:
return False
return True

def mhd(a,b):
return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x=' '):
return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
a = y[0]-x[0]
b = x[1]-y[1]
return (a*a+b*b)**0.5

def lgcd(a):
g = a[0]
for i in range(1,len(a)):
g = math.gcd(g,a[i])
return g

def ms(a):
msf = -rPAELC
meh = 0
st = en = be = 0
for i in range(len(a)):
meh+=a[i]
if msf<meh:
msf = meh
st = be
en = i
if meh<0:
meh = 0
be = i+1
return msf,st,en

def ncr(L7VESiE,r):
num=den=1
for i in range(r):
num = (num*(L7VESiE-i))%MLYUw5
den = (den*(i+1))%MLYUw5

return (num*(pow(den,MLYUw5-2,MLYUw5)))%MLYUw5

def flush():
return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
izenTF,hMUz8,JjsXQNg3 = arrIN()
print((izenTF+hMUz8+JjsXQNg3)//2)
</ans>",0,{}
348," <ans\>
n = int(input())
s = input()

ac0CIM = True
if n == 1:
if s == '0':
print(pow(10, 10))
elif s == '1':
print(pow(10, 10) \* 2)
elif n == 2:
if s in ['11', '10']:
print(pow(10, 10))
elif s == '01':
print(pow(10, 10) - 1)
else:
print(0)
else:
ac0CIM = True
f7bUpUBpB = n // 3
iBULV0 = n % 3
for i in range(0, n, 3):
if i == 0:
IeNKI8Ye = s[0:3]
if IeNKI8Ye not in ['110', '101', '011']:
ac0CIM = False
break
elif i < 3 \* f7bUpUBpB:
tmp = s[i:i + 3]
if tmp != IeNKI8Ye:
ac0CIM = False
break
else:
tmp = s[i:n]
if tmp != IeNKI8Ye[0:n - i]:
ac0CIM = False
break
if not ac0CIM:
print(0)
else:
if IeNKI8Ye == '110':
if iBULV0 == 0:
print(pow(10, 10) - f7bUpUBpB + 1)
else:
print(pow(10, 10) - f7bUpUBpB)
elif IeNKI8Ye == '101':
print(pow(10, 10) - f7bUpUBpB)
elif IeNKI8Ye == '011':
if iBULV0 < 2:
print(pow(10, 10) - f7bUpUBpB)
else:
print(pow(10, 10) - f7bUpUBpB - 1)
</ans\>",0,{}
349," <ans>
import sys
from math import *

def minp():
return sys.stdin.readline().strip()

def mint():
return int(minp())

def mints():
return list(map(int, minp().split()))

def gcd(a,b):
while b != 0:
a,b = b,a%b
return a

def stupid(x):
r = 1
for i in range(1, x):
r = max(r, gcd(i&x, i^x))
return r

dwQdVK = dict()
dwQdVK[511] = 73
dwQdVK[2047] = 89
dwQdVK[32767] = 4681
dwQdVK[2097151] = 299593
dwQdVK[8388607] = 178481
dwQdVK[33554431] = 1082401
def smart(x):
if x in dwQdVK:
return dwQdVK[x]
if (x & (x+1)) == 0:
i = 0
while ((1<<i)-1) != x:
i += 1
if i % 2 == 0:
z = 0
for i in range(0,i,2):
z += (1<<i)
return z
else:
return 1
else:
i = 1
z = 0
while i < x:
if (i & x) == 0:
z += i
i *= 2
return x+z

anCYx = mint()
for i in range(anCYx):
X6GKqVAg = mint()
print(smart(X6GKqVAg))
#if (X6GKqVAg & (X6GKqVAg+1)) == 0:
# a = stupid(X6GKqVAg)
# b = smart(X6GKqVAg)
# if a != b:
# print(X6GKqVAg,a,b)
</ans>",0,{}
350," <ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
from fractions import *
getcontext().prec = 30
t6mAa = sys.maxsize
E5DBHKI = 1000010
tZaTU = [i for i in range(E5DBHKI)]
tZaTU[0]=tZaTU[1] = -1
def sieve():
for i in range(2,E5DBHKI,2):
tZaTU[i] = 2
for i in range(3,int(E5DBHKI**0.5)+1):
if tZaTU[i]==i:
for j in range(i*i,E5DBHKI,i):
if tZaTU[j]==j:
tZaTU[j]=i
def fib(n,m):
if n == 0:
return [0, 1]
else:
a, b = fib(n // 2)
c = ((a%m) * ((b%m) * 2 - (a%m)))%m
d = ((a%m) * (a%m))%m + ((b)%m * (b)%m)%m
if n % 2 == 0:
return [c, d]
else:
return [d, c + d]
def charIN(x= ' '):
return(sys.stdin.readline().strip().split(x))
def arrIN(x = ' '):
return list(map(int,sys.stdin.readline().strip().split(x)))
def ncr(n,r):
num=den=1
for i in range(r):
num = (num*(n-i))%t6mAa
den = (den*(i+1))%t6mAa
return (num*(pow(den,t6mAa-2,t6mAa)))%t6mAa
def flush():
return sys.stdout.flush()
'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
ZBPkHz81 = int(input())
if ZBPkHz81%2:
print(ZBPkHz81//2)
else:
print(ZBPkHz81//2-1)
</ans>",0,{}
351," <ans>
from math import log
from decimal import Decimal

def q13Wod5vra(x, y, z):
return (y ** z) * Decimal(log(x))

def lTNxclV7FL(x, y, z):
return ""x^y^z""

def q13Wod5vra1(x, y, z):
return (z ** y) * Decimal(log(x))

def lTNxclV7FL1(x, y, z):
return ""x^z^y""

def q13Wod5vra2(x, y, z):
return (y * z) * Decimal(log(x))

def lTNxclV7FL2(x, y, z):
return ""(x^y)^z""

def q13Wod5vra3(x, y, z):
return (y * z) * Decimal(log(x))

def lTNxclV7FL3(x, y, z):
return ""(x^z)^y""

def q13Wod5vra4(x, y, z):
return (x ** z) * Decimal(log(y))

def lTNxclV7FL4(x, y, z):
return ""y^x^z""

def q13Wod5vra5(x, y, z):
return (z ** x) * Decimal(log(y))

def lTNxclV7FL5(x, y, z):
return ""y^z^x""

def q13Wod5vra6(x, y, z):
return (x * z) * Decimal(log(y))

def lTNxclV7FL6(x, y, z):
return ""(y^x)^z""

def q13Wod5vra7(x, y, z):
return (z * x) * Decimal(log(y))

def lTNxclV7FL7(x, y, z):
return ""(y^z)^x""

def q13Wod5vra8(x, y, z):
return (x ** y) * Decimal(log(z))

def lTNxclV7FL8(x, y, z):
return ""z^x^y""

def q13Wod5vra9(x, y, z):
return (y ** x) * Decimal(log(z))

def lTNxclV7FL9(x, y, z):
return ""z^y^x""

def q13Wod5vra10(x, y, z):
return (x * y) * Decimal(log(z))

def lTNxclV7FL10(x, y, z):
return ""(z^x)^y""

def q13Wod5vra11(x, y, z):
return (y * x) * Decimal(log(z))

def lTNxclV7FL11(x, y, z):
return ""(z^y)^x""

x, y, z = list(map(Decimal, input().split()))
ea8 = lTNxclV7FL(x, y, z)
q13Wod5vra = [q13Wod5vra1, q13Wod5vra2, q13Wod5vra3, q13Wod5vra4, q13Wod5vra5, q13Wod5vra6, q13Wod5vra7, q13Wod5vra8, q13Wod5vra9, q13Wod5vra10, q13Wod5vra11]
lTNxclV7FL = [lTNxclV7FL1, lTNxclV7FL2, lTNxclV7FL3, lTNxclV7FL4, lTNxclV7FL5, lTNxclV7FL6, lTNxclV7FL7, lTNxclV7FL8, lTNxclV7FL9, lTNxclV7FL10, lTNxclV7FL11]
qtX = q13Wod5vra1(x, y, z)
for i in range (12):
if qtX < q13Wod5vra[i](x, y, z):
ea8 = lTNxclV7FL[i](x, y, z)
qtX = q13Wod5vra[i](x, y, z)
print(ea8)
</ans>",0,{}
352," <ans>
s = input()

cur\_len = 1
Mj4pCh = []
char = []
for i in range(1, len(s)):
if s[i] == s[i-1]: cur\_len += 1
else:
Mj4pCh.append(cur\_len)
char.append(s[i-1])
cur\_len = 1
Mj4pCh.append(cur\_len)
char.append(s[len(s)-1])

ans = 0
while len(Mj4pCh) > 1:
n = len(Mj4pCh)
inner\_min = 100000000
for i in range(1,n-1):
if Mj4pCh[i] < inner\_min: inner\_min = Mj4pCh[i]

k = min(Mj4pCh[0], Mj4pCh[n-1],(inner\_min + 1)//2)
b = []
new\_char = []
for i in range(n):
if i == 0 or i == n-1:
if Mj4pCh[i] > k:
b.append(Mj4pCh[i]-k)
new\_char.append(char[i])
else:
b.append(0)
new\_char.append("""")
else:
if Mj4pCh[i] > 2*k:
b.append(Mj4pCh[i] - 2*k)
new\_char.append(char[i])
else:
b.append(0)
new\_char.append("""")
ans += k
if len(b) > 1:
c = [0]*n
newnew\_char = [new\_char[0]]
count = 0
for i in range(0,len(b)-1):
if b[i] != 0:
c[count] += b[i]
if char[i] == char[i+1]: continue
else:
count += 1
newnew\_char.append(new\_char[i+1])
if new\_char[len(b)-2] == new\_char[len(b) - 1]: c[count] += b[len(b)-1]
else:
count += 1
newnew\_char.append(new\_char[i+1])
c[count] = b[len(b)-1]
Mj4pCh = c[:count+1]
char = newnew\_char[:]
else:
Mj4pCh = b[:]

print(ans)
</ans>",0,{}
353," <ans>
a, r, l, m = list(map(int, input().split()))
Yl\_K = list(map(int, input().split()))
vX3 = set(Yl\_K)
if (abs(a) > l):
 print(0)
 return
if (a == 0):
 if (0 in vX3):
 print(0)
 return
 else:
 print(""inf"")
 return
if (r == 0):
 if (a == 0):
 if (0 in vX3):
 print(0)
 return
 else:
 print(""inf"")
 return
 else:
 if (a not in vX3):
 if (abs(a) <= l):
 if (0 in vX3):
 print(1)
 return
 else:
 print(""inf"")
 return
 else:
 if (0 in vX3):
 print(0)
 return
 else:
 print(""inf"")
 return
if (r == 1):
 if (a in vX3 or abs(a) > l):
 print(0)
 return
 else:
 print(""inf"")
 return
if (r == -1):
 if (a in vX3):
 if (0 - a in vX3):
 print(0)
 return
 else:
 if (abs(a) <= l):
 print(""inf"")
 return
 else:
 print(0)
 return
 else:
 if (abs(a) <= l):
 print(""inf"")
 return
 else:
 print(0)
 return
pXgc = 0
while (abs(a) <= l):
 if (a not in vX3):
 pXgc += 1
 a \*= r
print(pXgc)
</ans>",0,{}
354," <ans>

import datetime
import sys
import copy
import functools
import collections
import itertools

class Solution:
def **init**(self):
self.ToIgj = 0
self.boards = None

def test(self):
pass

def readInput(self):
self.ToIgj = int(input())
self.boards = []
for i in range(self.ToIgj):
self.boards.append(list(input()))

def readMockInput(self):
pass

def solve(self):
ToIgj = self.ToIgj
impossibleMoves = set()
chesses = list()
P12kSHc = list()
# record all impossible moves
for r in range(ToIgj):
for c in range(ToIgj):
if self.boards[r][c] == 'o':
chesses.append((r, c))
elif self.boards[r][c] == '.':
P12kSHc.append((r, c))
# print(chesses)
# print(notAttacked)
for r, c in chesses:
for i, j in P12kSHc:
impossibleMoves.add((i-r, j-c))
# print(impossibleMoves)

# check whether there are any conflicts
# reboard = [['.' for c in range(ToIgj)] for r in range(ToIgj)]
# for r, c in chesses:
# reboard[r][c] = 'o'

startTime = datetime.datetime.now()

for i in range(ToIgj):
for j in range(ToIgj):
if self.boards[i][j] == 'o':
continue
for r, c in chesses:
if (i-r, j-c) not in impossibleMoves:
if self.boards[i][j] == '.':
print('NO')
return
self.boards[i][j] = 'v'


# for r, c in chesses:
# for i in range(-ToIgj+1, ToIgj):
# for j in range(-ToIgj+1, ToIgj):
# much faster than 2 for
# if (i, j) not in impossibleMoves:
# nr = r + i
# nc = c + j
# if 0 <= nr < ToIgj and 0 <= nc < ToIgj and self.boards[nr][nc] != 'o':
# reboard[nr][nc] = 'x'
#
# if self.boards[nr][nc] == '.':
# print('NO')
# return
# self.boards[nr][nc] = 'v'
if sum([row.count('x') for row in self.boards]) > 0:
print('NO')
return
# for r in range(ToIgj):
# for c in range(ToIgj):
# if self.boards[r][c] != reboard[r][c]:
# print('NO')
# return
sys.stderr.write('Check Cost: {}\n'.format(datetime.datetime.now()-startTime))



rn = 2*ToIgj-1
res = [['.' for c in range(rn)] for r in range(rn)]
res[ToIgj-1][ToIgj-1] = 'o'
for i in range(-ToIgj+1, ToIgj):
for j in range(-ToIgj+1, ToIgj):
if not (i == 0 and j == 0) and (i, j) not in impossibleMoves:
res[i+ToIgj-1][j+ToIgj-1] = 'x'
print('YES')
for row in res:
print(''.join(row))



solution = Solution()
solution.readInput()
startTime = datetime.datetime.now()
solution.solve()
sys.stderr.write('Time Cost:{}\n'.format(datetime.datetime.now() - startTime))

</ans>",0,{}
355," <ans>
```python
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
import copy
import decimal


class Scanner():
    @staticmethod
    def int():
        return int(sys.stdin.readline().rstrip())

    @staticmethod
    def string():
        return sys.stdin.readline().rstrip()

    @staticmethod
    def map_int():
        return [int(x) for x in Scanner.string().split()]

    @staticmethod
    def string_list(n):
        return [Scanner.string() for i in range(n)]

    @staticmethod
    def int_list_list(n):
        return [Scanner.map_int() for i in range(n)]

    @staticmethod
    def int_cols_list(n):
        return [Scanner.int() for i in range(n)]


def pop_count(x):
    x = x - ((x >> 1) & 0x5555555555555555)
    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    x = x + (x >> 32)
    return x & 0x0000007f


def solve():
    QPFXq9 = Scanner.string()
    dVnbj = len(QPFXq9)
    AoZaKNk = Scanner.int()
    xdO_aRgD5 = [[[0 for _ in range(2)] for _ in range(AoZaKNk + 1)] for _ in range(dVnbj + 1)]
    xdO_aRgD5[0][0][0] = 1
    for i in range(dVnbj):
        for j in range(4):
            for k in range(2):
                twM9z6A = int(QPFXq9[i])
                for d in range(10):
                    ni, nj, nk = i + 1, j, k
                    if d != 0:
                        nj += 1
                    if nj > AoZaKNk:
                        continue
                    if k == 0:
                        if d > twM9z6A:
                            continue
                        if d < twM9z6A:
                            nk += 1
                    xdO_aRgD5[ni][nj][nk] += xdO_aRgD5[i][j][k]
    print((xdO_aRgD5[dVnbj][AoZaKNk][0] + xdO_aRgD5[dVnbj][AoZaKNk][1]))
",0,{}
356," <ans>
```python
import heapq

INF = float('inf')
N, M = map(int, input().split())
QKdmP = [[] for _ in range(N)]

#GzlRG[i][j] : i-->jへ向かう辺を通るかどうかを保持
#  1 : 通る、0 : 通らない
GzlRG = [[0] * N for _ in range(N)]

for _ in range(M):
    a, b, c = map(int, input().split())
    a, b = a - 1, b - 1
    QKdmP[a].append((c, b))
    QKdmP[b].append((c, a))
    GzlRG[a][b] = 1 #a, b間に辺がある
    GzlRG[b][a] = 1


# dijkstraで最短経路木をつくる
def dijkstra(s):
    T9ux = [(0, s)]
    heapq.heapify(T9ux) 
    F8Ln_vq = [[INF, []] for i in range(N)]
    F8Ln_vq[s][0] = 0
    while T9ux:
        c, v = heapq.heappop(T9ux)
        if c > F8Ln_vq[v][0]:
            continue
        for d, u in QKdmP[v]:
            tmp = d + F8Ln_vq[v][0]
            if tmp < F8Ln_vq[u][0]:
                F8Ln_vq[u][0] = tmp
                F8Ln_vq[u][1] = [v] # 更新する場合は直前の頂点を保持
                heapq.heappush(T9ux, (tmp, u))
            elif tmp == F8Ln_vq[u][0]:
                F8Ln_vq[u][1].append(v) # 距離が等しい場合はリストで直前の頂点を保持  
                heapq.heappush(T9ux, (tmp, u))
    return F8Ln_vq


# 作成した最短経路木を探索して、通る辺を調べる
def dfs(v, tree, p=-1):
    if p >= 0:
        GzlRG[v][p] = 0
        GzlRG[p][v] = 0
    for nv in tree[v][1]:
        dfs(nv, tree, v)


def main():
    for s in range(N):
        tree = dijkstra(s)
        for g in range(N):
            dfs(g, tree)

    print(sum(sum(column) for column in GzlRG) // 2)


def __starting_point():
    main()
__starting_point()
```
</ans>",0,{}
357," <ans>
import sys
from math import *

def minp():
return sys.stdin.readline().strip()

def mint():
return int(minp())

def mints():
return list(map(int, minp().split()))

n, k = mints()
it0ptx = list(mints())
for i in range(n):
it0ptx[i] -= 1
s = list(mints())
ukGwgg0vZ = [i for i in range(1,n+1)]
n2in = [0]*n
zr8Rox = [False]*(k+1)
ch0aM = [False]*(k+1)
BE53hsuCXb = [10000]*2
for i in range(k+1):
#print(a)
zr8Rox[i] = (ukGwgg0vZ == s)
if zr8Rox[i]:
BE53hsuCXb[i%2] = min(BE53hsuCXb[i%2], i)
for j in range(n):
n2in[j] = ukGwgg0vZ[it0ptx[j]]
ukGwgg0vZ,n2in = n2in,ukGwgg0vZ
#print('====')
ukGwgg0vZ = [i for i in range(1,n+1)]
for i in range(k+1):
#print(a)
c[i] = (ukGwgg0vZ == s)
if c[i]:
BE53hsuCXb[i%2] = min(BE53hsuCXb[i%2], i)
for j in range(n):
n2in[it0ptx[j]] = ukGwgg0vZ[j]
ukGwgg0vZ,n2in = n2in,ukGwgg0vZ
#print('====')
#print(e)
#print(f)
if BE53hsuCXb[0] == 0:
print('NO')
elif BE53hsuCXb[1] == 1:
if ch0aM[1] == 1 and k > 1:
print('NO')
elif k%2 == 1 or ch0aM[k%2] <= k:
print('YES')
else:
print('NO')
elif ch0aM[1] == 1:
if k%2 == 1 or BE53hsuCXb[k%2] <= k:
print('YES')
else:
print('NO')
else:
if BE53hsuCXb[k%2] <= k or ch0aM[k%2] <= k:
print('YES')
else:
print('NO')
</ans>",0,{}
358," <ans>
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

```python
def sieve(n):
    if n < ",0,{}
359," <ans>
from random import randint

def factMod(n, mod):
res = 1
for i in range(2, n+1):
res = (res \* i) % mod
return res

def powMod(n, p, mod):
res = 1

while p > 0:
if p % 2 == 1:
res = (res \* n) % mod

p //= 2
n = (n \* n) % mod

return res

def invMod(n, mod):
return powMod(n, mod - 2, mod)

#t = 6
#print(invMod(t, 97))
#print( (invMod(t, 97) \* t) % 97 )
#return

def CnkMod(n, k, mod):
return (
factMod(n, mod) \*
invMod(factMod(k, mod) \* factMod(n-k, mod), mod)
) % mod

def computeCnksMod(N, mod):
res = [[0] \* (N+1) for i in range(N+1)]
res[0][0] = 1
for n in range(1, N+1):
res[n][0] = res[n-1][0]
for k in range(1, n+1):
res[n][k] = (res[n-1][k] + res[n-1][k-1]) % mod

return res

iPLaW = 998244353

f9\_xwaEc3 = int(input()) + 1
bOSvgE = [1] + [int(s)+1 for s in input().split(' ')]

#aa = [1] + [randint(0, 999) for i in range(1000)]
#n = len(aa)

YdU = computeCnksMod(f9\_xwaEc3, iPLaW)

#print('aa:', aa)

EeJC = [0] \* (f9\_xwaEc3 + 1)
EeJC[f9\_xwaEc3] = 1

for i in reversed(list(range(f9\_xwaEc3))):
if i != 0 and bOSvgE[i] < 2:
continue

cur = 0

GCxa9yRae = bOSvgE[i] - 1
for j in range(i + GCxa9yRae + 1, f9\_xwaEc3 + 1):
avail = j - i - 1
#cur = (cur + CnkMod(avail, GCxa9yRae, iPLaW) \* EeJC[j]) % iPLaW
cur = (cur + YdU[avail][GCxa9yRae] \* EeJC[j]) % iPLaW

EeJC[i] = cur

#print(d)
print(EeJC[0] - 1)
</ans>",0,{}
360," <ans>
from math import sin
def mp(): return list(map(int,input().split()))
def lt(): return list(map(int,input().split()))
def pt(x): print(x)
def ip(): return input()
def it(): return int(input())
def sl(x): return [t for t in x]
def spl(x): return x.split()
def aj(liste, item): liste.append(item)
def bin(x): return ""{0:b}"".format(x)
def listring(l): return ' '.join([str(x) for x in l])
def ptlist(l): print(' '.join([str(x) for x in l]))

e4QcZ = it()
RxS = lt()
GRC = {}
def explosion(start,s,_gZHGhtD):
(i,j) = start
t = s+1
if _gZHGhtD == 0:
for k in range(j+1,j+t):
GRC[(i,k)] = True
return ((i,j+t-1),((_gZHGhtD+7)%8)),((i,j+t-1),( _gZHGhtD+1)%8)
if _gZHGhtD == 1:
for k in range(1,t):
GRC[(i+k,j+k)] = True
return ((i+t-1,j+t-1),((_gZHGhtD+7)%8)),((i+t-1,j+t-1),( _gZHGhtD+1)%8)
if _gZHGhtD == 2:
for k in range(1,t):
GRC[(i+k,j)] = True
return ((i+t-1,j),((_gZHGhtD+7)%8)),((i+t-1,j),( _gZHGhtD+1)%8)
if _gZHGhtD == 3:
for k in range(1,t):
GRC[(i+k,j-k)] = True
return ((i+t-1,j-t+1),((_gZHGhtD+7)%8)),((i+t-1,j-t+1),( _gZHGhtD+1)%8)
if _gZHGhtD == 4:
for k in range(1,t):
GRC[(i,j-k)] = True
return ((i,j-t+1),((_gZHGhtD+7)%8)),((i,j-t+1),( _gZHGhtD+1)%8)
if _gZHGhtD == 5:
for k in range(1,t):
GRC[(i-k,j-k)] = True
return ((i-t+1,j-t+1),((_gZHGhtD+7)%8)),((i-t+1,j-t+1),( _gZHGhtD+1)%8)
if _gZHGhtD == 6:
for k in range(1,t):
GRC[(i-k,j)] = True
return ((i-t+1,j),((_gZHGhtD+7)%8)),((i-t+1,j),( _gZHGhtD+1)%8)
if _gZHGhtD == 7:
for k in range(1,t):
GRC[(i-k,j+k)] = True
return ((i-t+1,j+t-1),((_gZHGhtD+7)%8)),((i-t+1,j+t-1),( _gZHGhtD+1)%8)

MQj7 = [([(0,0),0]]
for i in range(e4QcZ):
l = []
for p,q in MQj7:
a,b = explosion(p,RxS[i],q)
l.append(a)
l.append(b)
MQj7 = set(l)
pt(len(GRC))
</ans>",0,{}
361," <ans>
",0,{}
362," <ans>
```python
#f = lambda: input()
#file = open(""btest"", ""r"")
#f = lambda:file.readline()

# n, m = map(int, f().split())

# g = []

# for i in range(n):
#     g.append(f())

# pwc3B = [[False for _ in range(m)] for _ in range(n)]

# def found_cycle(w):
#     nonlocal pwc3B
#     s = []
#     s.append(w)
#     while s:
#         v = s.pop()
#         if pwc3B[v[0]][v[1]] == False:
#             if v[0] > 0 and g[v[0]-1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]-1, v[1]])
                
#             if v[0] < n-1 and g[v[0]+1][v[1]] == g[v[0]][v[1]]:
#                 s.append([v[0]+1, v[1]])
                
#             if v[1] > 0 and g[v[0]][v[1]-1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]-1])
                
#             if v[1] < m-1 and g[v[0]][v[1]+1] == g[v[0]][v[1]]:
#                 s.append([v[0], v[1]+1])
                
#         else:
#             pwc3B[v[0]][v[1]] = True
#     return False

# found = False
# for i in range(n):
#     if found:
#         break
#     for j in range(m):
#         if pwc3B[i][j] == False:
#             found = found_cycle([i,j])
#             break

# if found:
#     print (""Yes"")
# else:
#     print (""No"")

#Editorial
import sys
sys.setrecursionlimit(10000)

#file = open(""btest"", ""r"")
#f = lambda:file.readline()
_rTA = lambda:input()

n,m = list(map(int, _rTA().split()))

Fqk = []

pwc3B = [[0 for _ in range(m)] for _ in range(n)]

for i in range(n):
    Fqk.append(_rTA())

def valid_node(i, j):
    return 0 <= i < n and 0 <= j < m

def dfs(i, j, p, k, cc = 0):
    if pwc3B[i][j] == k:
        return True
    
    pwc3B[i][j] = k

    res = False
    iqX = [[0,1], [1,0], [-1,0], [0,-1]]
    for d in iqX:
        if valid_node(i+ d[0], j+d[1]) and (i + d[0] != p[0] or j + d[1] != p[1]):
            if Fqk[i + d[0]][j+ d[1]] == Fqk[i][j]:
                res = res or dfs(i + d[0], j+ d[1], [i,j], k, cc+1)

    return res

FJ9fhfi = False
AhyP = 1
for i in range(n):
    for j in range(m):
        if pwc3B[i][j] == 0:
            FJ9fhfi = FJ9fhfi or dfs(i, j, [i, j], AhyP)
            AhyP += 1

if FJ9fhfi:
    print(""Yes"")
else:
    print(""No"")
```
</ans>",0,{}
363," <ans>

D = {
0: 0,
100: 1423,
200: 4006,
300: 10171,
400: 12223,
500: 18010,
600: 22231,
700: 30520,
800: 40150,
900: 51121,
1000: 100036,
1100: 102034,
1200: 106030,
1300: 112024,
1400: 120232,
1500: 126100,
1600: 140230,
1700: 170101,
1800: 202105,
1900: 210322,
2000: 220033,
2100: 230410,
2200: 261100,
2300: 303130,
2400: 313300,
2500: 333100,
2600: 402400,
2700: 421210,
2800: 504010,
2900: 602020,
3000: 1000027,
3100: 1002025,
3200: 1006021,
3300: 1012015,
3400: 1020223,
3500: 1026010,
3600: 1040221,
3700: 1070020,
3800: 1102060,
3900: 1110313,
4000: 1120024,
4100: 1130401,
4200: 1161010,
4300: 1203121,
4400: 1213210,
4500: 1233010,
4600: 1302310,
4700: 1321201,
4800: 1404001,
4900: 1502011,
5000: 2000008,
5100: 2002312,
5200: 2010700,
5300: 2020222,
5400: 2031211,
5500: 2100052,
5600: 2104111,
5700: 2120014,
5800: 2141002,
5900: 2204011,
6000: 2230003,
6100: 2310202,
6200: 2410102,
6300: 3000151,
6400: 3005101,
6500: 3020131,
6600: 3042100,
6700: 3106000,
6800: 3130210,
6900: 3211021,
7000: 3311020,
7100: 4000330,
7200: 4012012,
7300: 4100203,
7400: 4130002,
7500: 4301200,
7600: 5010031,
7700: 5103100,
7800: 6000121,
7900: 6200020,
8000: 9010000,
8100: 10001710,
8200: 10005310,
8300: 10011601,
8400: 10020151,
8500: 10025101,
8600: 10040131,
8700: 10062100,
8800: 10102024,
8900: 10110232,
9000: 10116100,
9100: 10130230,
9200: 10160101,
9300: 10203031,
9400: 10213102,
9500: 10232101,
9600: 10302202,
9700: 10321030,
9800: 10403020,
9900: 10501201,
10000: 10800100}

J5FPZc = int(input())
Icdm3Jsh2 = J5FPZc - J5FPZc%100
lid = QuAnsmRuC[Icdm3Jsh2]
f7Cx = Icdm3Jsh2

while f7Cx < J5FPZc:
    lid += 1
    if sum(int(d) for d in str(lid))==10:
        f7Cx += 1
print(lid)
</ans>",0,{}
364," <ans>
MOD = 998244353

def pop\_count(x) :
ans = 0
while (x > 0) :
ans = ans + x % 2
x = x // 2
return ans

def check(x, k) :
OEt = 0
N2CWvtdnr6 = int(x)
while (N2CWvtdnr6 > 0) :
OEt = OEt | (1 << (N2CWvtdnr6 % 10))
N2CWvtdnr6 = N2CWvtdnr6 // 10
if (pop\_count(OEt) <= k) :
return x
return 0

pop = []
xaQ9M = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() :
xaQ9M.append(1)
for i in range(20) :
xaQ9M.append(xaQ9M[i] \* 10 % MOD)
for i in range(1 << 10) :
pop.append(pop\_count(i))
w[0][0] = 1
for i in range(1, 20) :
for j in range(1 << 10) :
for use in range(10) :
w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] \* use \* xaQ9M[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
F5Rq = [int(d) for d in str(x)]
\_p6 = len(F5Rq)
Vj8H = 0
for i in range(1, \_p6) :
for use in range(1, 10) :
for BN\_pF in range(1 << 10) :
if (pop[(1 << use) | BN\_pF] <= k) :
Vj8H = (Vj8H + f[i - 1][BN\_pF] + use \* w[i - 1][BN\_pF] % MOD \* xaQ9M[i - 1]) % MOD
rLeRX = 0
KilnGJUZ = 0
for i in range(\_p6) :
nrF = F5Rq[i]
for use in range(nrF) :
if (i == 0 and use == 0) :
continue
nmask = rLeRX | (1 << use)
for mask in range(1 << 10) :
if (pop[nmask | mask] <= k) :
Vj8H = (Vj8H + f[\_p6 - i - 1][mask] + (KilnGJUZ \* 10 + use) \* w[\_p6 - i - 1][mask] % MOD \* xaQ9M[\_p6 - i - 1]) % MOD
rLeRX |= 1 << nrF
KilnGJUZ = (10 \* KilnGJUZ + nrF) % MOD
return Vj8H

prepare()
l, r, k = list(map(int, input().split()))
Vj8H = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(Vj8H)
</ans>",0,{}
365," <ans>
def main():
N, M = (int(i) for i in input().split())

Bkthdnp2 = [False]*4
aRrnwL = [-1]*N
wMofEil = 0
XIW\_2Ugx = [i for i in range(N)]
YB8U = [1 for i in range(N)]
uVXMa = [i for i in range(N)]
Oiht9Ly = 0
p4nMMEs = 0
ThLAgQKW = [[] for \_ in range(N)]

def find(x):
if XIW\_2Ugx[x] == x:
return x
else:
XIW\_2Ugx[x] = find(XIW\_2Ugx[x])
YB8U[x] = YB8U[XIW\_2Ugx[x]]
return XIW\_2Ugx[x]

def same(x, y):
return find(x) == find(y)

def union(x, y):
x = find(x)
y = find(y)
if x == y:
return
if YB8U[x] < YB8U[y]:
x, y = y, x
YB8U[x] += YB8U[y]
XIW\_2Ugx[y] = x

def get\_size(x):
return YB8U[find(x)]

for \_ in range(M):
a, b = (int(i) for i in input().split())
ThLAgQKW[a-1].append(b-1)
ThLAgQKW[b-1].append(a-1)
union(a-1, b-1)

QeRAH85l = [False]*4
for i in range(N):
QeRAH85l[min(3, get\_size(i))] = True
if QeRAH85l[3]:
wMofEil = 1
elif QeRAH85l[2]:
wMofEil = 2
else:
wMofEil = 3

xrBSrWui7j = [-1]*N

def dfs(s):
stack = [s]
aRrnwL[s] = 0
b = 1
w = 0
while stack:
v = stack.pop()
for u in ThLAgQKW[v]:
if aRrnwL[u] != -1:
if aRrnwL[u] == aRrnwL[v]:
return False, b*w
continue
aRrnwL[u] = aRrnwL[v] ^ 1
if aRrnwL[u] == 0:
b += 1
else:
w += 1
stack.append(u)
return True, b*(b-1)//2 + w*(w-1)//2

is\_bipartite, \_ = dfs(0)
if is\_bipartite:
w = 0
if wMofEil == 3:
w = N\*(N-1)\*(N-2)//3//2
elif wMofEil == 2:
Bkthdnp2 = [False]*N
for i in range(N):
if not Bkthdnp2[find(i)] and get\_size(i) == 2:
w += (N-2)
Bkthdnp2[find(i)] = True
elif wMofEil == 1:
Bkthdnp2 = [False]*N
aRrnwL = [-1]*N
for i in range(N):
if not Bkthdnp2[find(i)] and get\_size(i) >= 3:
is\_bipartite, ways = dfs(i)
w += ways
Bkthdnp2[find(i)] = True
print(wMofEil, w)
else:
print(0, 1)

def __starting\_point():
main()

\_\_starting\_point()
</ans>",0,{}
366," <ans>
__author__ = 'FZhWrj'

import math

debug = False

def dist(x1, y1, x2, y2):
return math.sqrt(math.pow(math.fabs(x1 - x2), 2) + math.pow(math.fabs(y1 - y2), 2))

def get\_y(x1, y1, x2, y2, x):
return (((x - x1) \* (y2 - y1)) / (x2 - x1)) + y1

if debug:
with open(""input.txt"", ""r"") as inp:
zew = inp.readline()
zew = inp.readline()
zew = inp.readline()
zew = inp.readline()
else:
zew = input()
zew = input()
zew = input()
zew = input()

zew = zew.split()
l8HKAXm = float(zew[0])
wJe9IV = float(zew[1])
SUDYdEdVG = float(zew[2])
F\_d0\_ = float(zew[3])

aox\_m5I = [float(x) for x in secondLine.split()]
TnKXjKa = [float(x) for x in thirdLine.split()]
RcdT8s4U1 = [float(x) for x in zew.split()]

if debug:
print(aox\_m5I)
print(TnKXjKa)
print(RcdT8s4U1)

NoOJKdEza = float(""inf"")
z9Pd7S = -1
for i, bi in enumerate(TnKXjKa):
uOL = dist(0, 0, F\_d0_, bi) + RcdT8s4U1[i]
if uOL <= NoOJKdEza:
NoOJKdEza = uOL
z9Pd7S = i

if debug:
print(z9Pd7S + 1, NoOJKdEza)

zBM67h = get\_y(0, 0, F\_d0_, TnKXjKa[z9Pd7S], SUDYdEdVG)

if debug:
print(zBM67h)

NTJG = float(""inf"")
kc8GHj = -1
for i, ai in enumerate(aox\_m5I):
d = dist(SUDYdEdVG, ai, SUDYdEdVG, zBM67h)
if d < NTJG:
NTJG = d
kc8GHj = i

if debug:
print(kc8GHj + 1, NTJG)

NoOJKdEza = float(""inf"")
z9Pd7S = -1
for i, bi in enumerate(TnKXjKa):
uOL = dist(SUDYdEdVG, aox\_m5I[kc8GHj], F\_d0_, bi) + RcdT8s4U1[i]
if uOL <= NoOJKdEza:
NoOJKdEza = uOL
z9Pd7S = i

print(kc8GHj + 1, z9Pd7S + 1)
</ans>",0,{}
367," <ans>
from bisect import bisect\_left as bl
from bisect import bisect\_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp\_to\_key
import sys
input = sys.stdin.readline

# M = mod = 998244353
def factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))
def inv\_mod(n):return pow(n, mod - 2, mod)

def li():return [int(i) for i in input().rstrip('\\n').split(' ')]
def st():return input().rstrip('\\n')
def val():return int(input().rstrip('\\n'))
def li2():return [i for i in input().rstrip('\\n').split(' ')]
def li3():return [int(i) for i in input().rstrip('\\n')]


E2UUAl1 = val()
nsaa = li()
l1 = nsaa[:]
l2 = nsaa[:]

i = 0
l1 = sorted(list(set(l1)))
doit = tot1 = 0
cn = Counter(l1)
l = l1[:]
while i < len(l1):
if cn[l[i] - 1] > 0:
cn[l[i]] -= 1
cn[l[i] - 1] += 1
l[i] -= 1
i += 1
else:
cn[l[i]] -= 1
cn[l[i] + 1] += 1
l[i] += 1
if i<len(l1) - 1 and l[i + 1] == l[i]:i += 2
else:i += 1
# print(cn)
tot1 = sum(1 for i in cn if cn[i])









# print(l1)



i = 0

cnt = Counter(l2)
l2 = sorted(l2)

l = l2[:]



for i in range(E2UUAl1):
if cnt[l[i] - 1] == 0:
cnt[l[i] - 1] += 1
cnt[l[i]] -= 1
l[i] -= 1
else:
cnt[l[i] + 1] += 1
cnt[l[i]] -= 1
l[i] += 1


EAgoK = sum(1 for i in cnt if cnt[i])





print(tot1,EAgoK)
</ans>",0,{}
368," <ans>
import sys
import math
from collections import defaultdict, deque, Counter
from copy import deepcopy
from bisect import bisect, bisect\_right, bisect\_left
from heapq import heapify, heappop, heappush

input = sys.stdin.readline
def Ag3M(): return input().rstrip()
def F(): return float(input().rstrip())
def I(): return int(input().rstrip())
def MI(): return map(int, input().split())
def MF(): return map(float,input().split())
def LI(): return list(map(int, input().split()))
def TI(): return tuple(map(int, input().split()))
def LF(): return list(map(float,input().split()))
def Init(H, W, num): return [[num for i in range(W)] for j in range(H)]

def main():
vV0X = I()
if vV0X == 0:
print(0)
return
if vV0X < 0:
vV0X = -vV0X
yLagPM = defaultdict(int)
index = 0
while vV0X >= 1:
#bitフラグがたっていたら
if vV0X & 1 == 1:
#2の倍数の場合yLagPM[index]とyLagPM[index+1]に1を足す
if index % 2 == 0:
yLagPM[index] += 1
yLagPM[index+1] += 1
else:
yLagPM[index] += 1
else:
yLagPM[index] = yLagPM[index]
vV0X = vV0X>>1
index += 1
else:
yLagPM = defaultdict(int)
if vV0X & 1 == 1:
yLagPM[0] = 1
else:
yLagPM[0] = 0
index = 1
vV0X = vV0X >> 1

while vV0X >= 1:
#bitフラグがたっていたら
if vV0X & 1 == 1:
#2の倍数の場合yLagPM[index]とyLagPM[index+1]に1を足す
if index % 2 == 1:
yLagPM[index] += 1
yLagPM[index+1] += 1
else:
yLagPM[index] += 1
else:
yLagPM[index] = yLagPM[index]
vV0X = vV0X>>1
index += 1

index = 0
while True:
if not index in yLagPM.keys():
break
if yLagPM[index] <= 1:
pass
else:
temp = yLagPM[index]
yLagPM[index] = temp % 2
yLagPM[index+1] += (temp // 2)
yLagPM[index+2] += (temp // 2)
if yLagPM[index+1] >= yLagPM[index+2] * 2:
temp = yLagPM[index+2]
yLagPM[index+2] -= temp
yLagPM[index+1] -= temp * 2
index += 1

res = True

for i in reversed(yLagPM.values()):
if res and i == 1:
res = False
if not res:
print(i, end="""")
print()

def __starting\_point():
main()
__starting\_point()
</ans>",0,{}
369," <ans>
n, k = map(int, input().split())
XY = [list(map(int, input().split())) for _ in range(n)]
XY.sort(key=lambda x: x[0])
XY = [xy + [x] for x, xy in enumerate(XY)]
XY.sort(key=lambda x: x[1])
XY = [xy + [y] for y, xy in enumerate(XY)]

gr = [[0] * n for _ in range(n)]
for _, _, i, j in XY:
  gr[i][j] = 1
  
x1zYF = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
  for j in range(n):
    x1zYF[i + 1][j + 1] = x1zYF[i + 1][j] + x1zYF[i][j + 1] - x1zYF[i][j] + gr[i][j]
    
# XYの2点,3点,4点を総当たり
bHOaB = 10 ** 21
for i in range(n - 1):
  for j in range(i + 1, n):
    ZdDowS = [XY[m][0] for m in [i, j]]
    XLc6P28Kl = [XY[m][1] for m in [i, j]]
    sjU = [XY[m][2] for m in [i, j]]
    bKgpjs = [XY[m][3] for m in [i, j]]
    innerPoints = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                + x1zYF[min(sjU)][min(bKgpjs)] \
                - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                - x1zYF[max(sjU) + 1][min(bKgpjs)]
    if innerPoints >= k:
      area = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
      if area < bHOaB:
        bHOaB = area

if n > 2:
  for i in range(n - 2):
    for j in range(i + 1, n - 1):
      for l in range(j + 1, n):
        ZdDowS = [XY[m][0] for m in [i, j, l]]
        XLc6P28Kl = [XY[m][1] for m in [i, j, l]]
        sjU = [XY[m][2] for m in [i, j, l]]
        bKgpjs = [XY[m][3] for m in [i, j, l]]
        innerPoints = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                    + x1zYF[min(sjU)][min(bKgpjs)] \
                    - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                    - x1zYF[max(sjU) + 1][min(bKgpjs)]
        if innerPoints >= k:
          area = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
          if area < bHOaB:
            bHOaB = area

if n > 3:
  for i in range(n - 3):
    for j in range(i + 1, n - 2):
      for l in range(j + 1, n - 1):
        for o in range(l + 1, n):
          ZdDowS = [XY[m][0] for m in [i, j, o, l]]
          XLc6P28Kl = [XY[m][1] for m in [i, j, o, l]]
          sjU = [XY[m][2] for m in [i, j, o, l]]
          bKgpjs = [XY[m][3] for m in [i, j, o, l]]
          innerPoints = x1zYF[max(sjU) + 1][max(bKgpjs) + 1] \
                      + x1zYF[min(sjU)][min(bKgpjs)] \
                      - x1zYF[min(sjU)][max(bKgpjs) + 1] \
                      - x1zYF[max(sjU) + 1][min(bKgpjs)]
          if innerPoints >= k:
            area = (max(ZdDowS) - min(ZdDowS)) * (max(XLc6P28Kl) - min(XLc6P28Kl)) 
            if area < bHOaB:
              bHOaB = area

print(bHOaB)
</ans>",0,{}
370," <ans>
import math
from fractions import gcd

def primes(limit):
x7pJ5QC = []
WYkdPLWaqo = [True]*(limit+1)
OSaNC = list(range(2,limit+1))
for item in OSaNC:
if(WYkdPLWaqo[item]):
i = 2
while(item*i<=limit):
WYkdPLWaqo[item*i]=False
i+=1
for item in OSaNC:
if(WYkdPLWaqo[item]):
x7pJ5QC+=[item]
return x7pJ5QC

VunbfCxlhG, XOwnbFot = list(map(int,input().split()))
aa = VunbfCxlhG
bb = XOwnbFot
ijIBPrDW = []
cIVG = []

oXa = primes(int(math.sqrt(10**9)))

for i in range(len(oXa)):
if(oXa[i]>VunbfCxlhG):
break
while(VunbfCxlhG%oXa[i]==0):
ijIBPrDW.append(oXa[i])
VunbfCxlhG //= oXa[i]
if(VunbfCxlhG!=1):
ijIBPrDW.append(VunbfCxlhG)

for i in range(len(oXa)):
if(oXa[i]>XOwnbFot):
break
while(XOwnbFot%oXa[i]==0):
cIVG.append(oXa[i])
XOwnbFot //= oXa[i]
if(XOwnbFot!=1):
cIVG.append(XOwnbFot)

if(VunbfCxlhG==1 and XOwnbFot==1):
print(0)

elif(VunbfCxlhG==1):
Done = True
for item in cIVG:
if(item>5):
Done = False
break
if(Done):
print(len(cIVG))
else:
print(-1)
elif(XOwnbFot==1):
Done = True
for item in ijIBPrDW:
if(item>5):
Done = False
break
if(Done):
print(len(ijIBPrDW))
else:
print(-1)

else:

cIVG.sort()
ijIBPrDW.sort()
Done = True
ind = 0
qDrCoqF = 0
while(ijIBPrDW!=cIVG):
if(ind>=len(ijIBPrDW) and ind>=len(cIVG)):
Done = False
break
elif(ind>=len(ijIBPrDW)):
if(cIVG[-1]>5):
Done = False
break
else:
qDrCoqF += len(cIVG)-ind
break
elif(ind>=len(cIVG)):
if(ijIBPrDW[-1]>5):
Done = False
break
else:
qDrCoqF += len(ijIBPrDW)-ind
break
if(ijIBPrDW[ind]==cIVG[ind]):
ind += 1
continue

if(ijIBPrDW[ind]<cIVG[ind]):
if(ijIBPrDW[ind]>5):
Done = False
break
else:
qDrCoqF += 1
ijIBPrDW.pop(ind)
else:
if(cIVG[ind]>5):
Done = False
break
else:
qDrCoqF += 1
cIVG.pop(ind)
if(Done):
print(qDrCoqF)
else:
print(-1)

</ans>",0,{}
371," <ans>
```python
# -*- coding: utf-8 -*-
import sys
import math
import os
import itertools
import string
import heapq
import _collections
from collections import Counter
from collections import defaultdict
from collections import deque
from functools import lru_cache
import bisect
import re
import queue
",0,{}
372," <ans>

n=int(input())
SfXiEuPnu=list(map(int,input().split()))

H7JY=[0]*1001

for i in range (len(SfXiEuPnu)):
H7JY[SfXiEuPnu[i]]+=1

iFprK9VZTj=0
V17=0

for i in range (1001):
H7JY[i]//=4
V17+=(H7JY[i]%2)

if(iPlBt5IZ%2==0 and H7JY[i]==((iPlBt5IZ\*iPlBt5IZ)//4)):
a3rR8sl= ([([0]*(iPlBt5IZ//2)) for i in range (iPlBt5IZ//2)])
LYm6xAdOj=[]
for i in range (1001):
while(H7JY[i]>=4):
LYm6xAdOj.append(i)
H7JY[i]-=4

k=0
for i in range (iPlBt5IZ//2):
for j in range (iPlBt5IZ//2):
a3rR8sl[i][j]=LYm6xAdOj[k]
k+=1

RrIDMlc=[([0]*iPlBt5IZ) for i in range (iPlBt5IZ)]
for i in range (iPlBt5IZ//2):
for j in range (iPlBt5IZ//2):
RrIDMlc[i][j]=a3rR8sl[i][j]
RrIDMlc[i+iPlBt5IZ//2][j]=a3rR8sl[i][j]
RrIDMlc[i+iPlBt5IZ//2][j+iPlBt5IZ//2]=a3rR8sl[i][j]
RrIDMlc[i][j+iPlBt5IZ//2]=a3rR8sl[i][j]

print(""YES"")
for i in range (iPlBt5IZ):
for j in range (iPlBt5IZ):
print(RrIDMlc[i][j],end="" "")
print()

elif(iPlBt5IZ%2==1 and (((H7JY[i]>=(((iPlBt5IZ//2) *(iPlBt5IZ//2)) ) ) and (V17==1)))):
a3rR8sl= ([([0]*(iPlBt5IZ//2)) for i in range (iPlBt5IZ//2)])
LYm6xAdOj=[]
for i in range (1001):
while(H7JY[i]>=4):
LYm6xAdOj.append(i)
H7JY[i]-=4

k=0
for i in range (iPlBt5IZ//2):
for j in range (iPlBt5IZ//2):
a3rR8sl[i][j]=LYm6xAdOj[k]
LYm6xAdOj.pop(k)

RrIDMlc=[([0]*iPlBt5IZ) for i in range (iPlBt5IZ)]
for i in range (iPlBt5IZ//2):
for j in range (iPlBt5IZ//2):
RrIDMlc[i][j]=a3rR8sl[i][j]
RrIDMlc[i+iPlBt5IZ//2][j]=a3rR8sl[i][j]
RrIDMlc[i+iPlBt5IZ//2][j+iPlBt5IZ//2]=a3rR8sl[i][j]
RrIDMlc[i][j+iPlBt5IZ//2]=a3rR8sl[i][j]

UdK=len(LYm6xAdOj)
lqDyzQklMP=[]
for i in range (UdK):
lqDyzQklMP.append(LYm6xAdOj[i])
lqDyzQklMP.append(LYm6xAdOj[i])

for i in range (1001):
while(H7JY[i]>=2):
lqDyzQklMP.append(i)
H7JY[i]-=2

for i in range (iPlBt5IZ//2):
RrIDMlc[i+iPlBt5IZ//2][i]=lqDyzQklMP[0]
RrIDMlc[i+iPlBt5IZ//2][i+iPlBt5IZ//2]=lqDyzQklMP[0]
lqDyzQklMP.pop(0)
lqDyzQklMP.pop(0)

for i in range (iPlBt5IZ//2):
RrIDMlc[i][iPlBt5IZ//2]=lqDyzQklMP[0]
RrIDMlc[i+iPlBt5IZ//2][iPlBt5IZ//2]=lqDyzQklMP[0]
lqDyzQklMP.pop(0)
lqDyzQklMP.pop(0)

for i in range (1001):
if(H7JY[i]==1):
RrIDMlc[iPlBt5IZ//2][iPlBt5IZ//2]=i

print(""YES"")
for i in range (iPlBt5IZ):
for j in range (iPlBt5IZ):
print(RrIDMlc[i][j],end="" "")
print()

else:
print(""NO"")

</ans>",0,{}
373," <ans>
import sys
WhGBW192nX=int(input())
HM6jpOHkNq=list(map(int,input().split()))
ENxZsclb6=WhGBW192nX
PyJnmHzwCA=[]
yhJiz=-1
ius5tOP=0
jG0=-1
CPm=[]
for i in range(WhGBW192nX):
    if HM6jpOHkNq[i]==3:
        if ENxZsclb6==WhGBW192nX:
            PyJnmHzwCA.append((WhGBW192nX-ENxZsclb6+1,i+1))
            ENxZsclb6-=1
        else:
            PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
            PyJnmHzwCA.append((WhGBW192nX+1-ENxZsclb6,i+1))
            ENxZsclb6-=1
        yhJiz=i
if yhJiz==WhGBW192nX-1:
    print(-1)
    return
if yhJiz>-1:
    flag=0
    for i in range(yhJiz,WhGBW192nX):
        if HM6jpOHkNq[i]==2:
            flag=1
            PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
            ENxZsclb6-=1
            break
    if flag==0:
        flag2=0
        for i in range(yhJiz,WhGBW192nX):
            if HM6jpOHkNq[i]==1:
                PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
                ENxZsclb6-=1
                yhJiz=i
                break
        if flag2==0:
            print(-1)
            return
CPm=[]
if yhJiz==-1:
    ENxZsclb6-=1
for i in range(WhGBW192nX-1,-1,-1):
    if HM6jpOHkNq[i]==1 and i!=yhJiz:
        CPm.append(i)
    if HM6jpOHkNq[i]==2:
        if len(CPm)==0:
            print(-1)
            return
        k=CPm.pop()
        PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
        PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),k+1))
        ENxZsclb6-=1
if yhJiz>-1:
    CPm.append(yhJiz)
for i in CPm:
    PyJnmHzwCA.append((WhGBW192nX+1-(ENxZsclb6+1),i+1))
    ENxZsclb6-=1
print(len(PyJnmHzwCA))
for x,y in PyJnmHzwCA:
    print(x,y)
</ans>",0,{}
374," <ans>

__author__ = 'yx5sh'

import time
[wKhzt6L5jC1, b1] = [int(i) for i in input().split()]
[wKhzt6L5jC2, b2] = [int(i) for i in input().split()]

t0 = time.time()
LZ1EgsfBC = [[wKhzt6L5jC1, b1, 0]]
yr328O = [[wKhzt6L5jC2, b2, 0]]
mwj = []
oNiLrx = []
wmeJse = []
ADIN = []

def equal(t, q):
    lo = 0
    hi = len(q)
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        p = q[m]
        temp = p[0] * p[1]
        if t == temp:
            return [p[0], p[1], p[2]]
        if t < temp:
            lo = m + 1
        elif t > temp:
            hi = m

def found(key, a):
    lo = 0
    hi = len(a)
    while True:
        if lo >= hi:
            return False
        m = (lo + hi) // 2
        p = a[m]
        if key[0] == p[0] and key[1] == p[1]:
            return True
        if key[0] < p[0] or key[0] == p[0] and key[1] < p[1]:
            lo = m + 1
        if key[0] > p[0] or key[0] == p[0] and key[1] > p[1]:
            hi = m

while True:
    if len(LZ1EgsfBC) > 0 and len(yr328O) > 0:
        eCblN = LZ1EgsfBC[0][0] * LZ1EgsfBC[0][1]
        FvwCleh1Li = yr328O[0][0] * yr328O[0][1]
        if eCblN > FvwCleh1Li:
            N8zM = equal(eCblN, yr328O)
            if N8zM:
                print(str(N8zM[2] + LZ1EgsfBC[0][2]) + ""\n"" + str(LZ1EgsfBC[0][0]) + "" "" + str(LZ1EgsfBC[0][1]) + ""\n"" + str(N8zM[0]) + "" "" + str(N8zM[1]))
            else:
                if not(LZ1EgsfBC[0][0] & 1):
                    rUMJ6_BcB = [LZ1EgsfBC[0][0] // 2, LZ1EgsfBC[0][1], LZ1EgsfBC[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if LZ1EgsfBC[0][0] % 3 == 0:
                    rUMJ6_BcB = [LZ1EgsfBC[0][0] // 3 * 2, LZ1EgsfBC[0][1], LZ1EgsfBC[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(LZ1EgsfBC[0][1] & 1):
                    rUMJ6_BcB = [LZ1EgsfBC[0][0], LZ1EgsfBC[0][1] // 2, LZ1EgsfBC[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if LZ1EgsfBC[0][1] % 3 == 0:
                    rUMJ6_BcB = [LZ1EgsfBC[0][0], LZ1EgsfBC[0][1] // 3 * 2, LZ1EgsfBC[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in oNiLrx) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in wmeJse):
                        oNiLrx.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        LZ1EgsfBC.append(rUMJ6_BcB)
                        wmeJse.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], yr328O)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                LZ1EgsfBC.pop(0)
                LZ1EgsfBC.sort(key=lambda x: x[0]*x[1], reverse=True)
                #tested1.sort(key=lambda x: (x[0], x[1]), reverse=True)

        elif eCblN < FvwCleh1Li:
            N8zM = equal(FvwCleh1Li, LZ1EgsfBC)
            if N8zM:
                print(str(N8zM[2] + yr328O[0][2]) + ""\n"" + str(N8zM[0]) + "" "" + str(N8zM[1]) + ""\n"" + str(yr328O[0][0]) + "" "" + str(yr328O[0][1]))
                break
            else:
                if not(yr328O[0][0] & 1):
                    rUMJ6_BcB = [yr328O[0][0] // 2, yr328O[0][1], yr328O[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if yr328O[0][0] % 3 == 0:
                    rUMJ6_BcB = [yr328O[0][0] // 3 * 2, yr328O[0][1], yr328O[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if not(yr328O[0][1] & 1):
                    rUMJ6_BcB = [yr328O[0][0], yr328O[0][1] // 2, yr328O[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                if yr328O[0][1] % 3 == 0:
                    rUMJ6_BcB = [yr328O[0][0], yr328O[0][1] // 3 * 2, yr328O[0][2] + 1]
                    if (not [rUMJ6_BcB[0], rUMJ6_BcB[1]] in mwj) and (not rUMJ6_BcB[0]*rUMJ6_BcB[1] in ADIN):
                        mwj.append([rUMJ6_BcB[0], rUMJ6_BcB[1]])
                        yr328O.append(rUMJ6_BcB)
                        ADIN.append(rUMJ6_BcB[0]*rUMJ6_BcB[1])
                        an = equal(rUMJ6_BcB[0]*rUMJ6_BcB[1], LZ1EgsfBC)
                        if an:
                            print(str(an[2] + rUMJ6_BcB[2]) + ""\n"" + str(rUMJ6_BcB[0]) + "" "" + str(rUMJ6_BcB[1]) + ""\n"" + str(an[0]) + "" "" + str(an[1]))
                yr328O.pop(0)
                yr328O.sort(key=lambda x: x[0]*x[1], reverse=True)
                #tested2.sort(key=lambda x: (x[0], x[1]), reverse=True)

        else:
            print(str(LZ1EgsfBC[0][2] + yr328O[0][2]) + ""\n"" + str(LZ1EgsfBC[0][0]) + "" "" + str(LZ1EgsfBC[0][1]) + ""\n"" + str(yr328O[0][0]) + "" "" + str(yr328O[0][1]))
            break
    else:
        print(-1)
        break

t1 = time.time()
#print(t1-t0)

</ans>",0,{}
375," <ans>
import sys
sys.setrecursionlimit(10000000)
A40ma = 10**9 + 7
n2apWo = I()
yS5LC = input()
KLw = """"
ZA4 = None
for i in range(n2apWo):
    if i == 0:
        ZA4 = yS5LC[i]
        KLw += yS5LC[i]
        continue
    if yS5LC[i] == ZA4:
        continue
    else:
        ZA4 = yS5LC[i]
        KLw += yS5LC[i]
print((len(KLw)))
</ans>",0,{}
376," <ans>

import sys

ELm0YH2 = int(sys.stdin.readline().split()[0])

class Polynomial:
def **init**(self, coef):
first\_nonzero = False
index = len(coef) - 1
while not first\_nonzero:
if not coef[index] == 0:
first\_nonzero = True
else:
if index == 0:
first\_nonzero = True
else:
index -= 1
self.degree = index
self.coef = [coef[j] for j in range(index + 1)]
def multiply\_by\_x(self):
new\_coef = [0]
for j in range(self.degree + 1):
new\_coef.append(self.coef[j])
return Polynomial(new\_coef)
def minus(self):
new\_coef = [-self.coef[j] for j in range(self.degree + 1)]
return Polynomial(new\_coef)
def add(self, other):
other\_coef = other.coef
new\_coef = [0 for j in range(max(self.degree, other.degree) + 1)]
ldLCr = min(self.degree, other.degree)
E4dw = max(self.degree, other.degree)
if self.degree > other.degree:
bigger\_poly = self
else:
bigger\_poly = other
for j in range(ldLCr + 1):
new\_coef[j] = self.coef[j] + other.coef[j]
for j in range(ldLCr + 1, E4dw+1):
new\_coef[j] = bigger\_poly.coef[j]
return Polynomial(new\_coef)
def is\_legal(self):
result = True
bools = [None for j in range(self.degree + 1)]
bools[self.degree] = self.coef[self.degree] == 1
for j in range(self.degree):
bools[j] = self.coef[j] == 0 or self.coef[j] == 1 or self.coef[j] == -1
for j in range(self.degree + 1):
result = result and bools[j]
return result
def print(self):
output = """"
for j in range(self.degree + 1):
output += str(self.coef[j]) + "" ""
print(output)

qRM7Ov = []

qRM7Ov.append(Polynomial([1]))
qRM7Ov.append(Polynomial([0, 1]))

for j in range(2, 151):
aAOJ\_nUaXA = qRM7Ov[j-1].multiply\_by\_x()
B\_7SaGHvF = aAOJ\_nUaXA.add(qRM7Ov[j - 2])
qv\_xJYhNR = aAOJ\_nUaXA.add(qRM7Ov[j - 2].minus())
if B\_7SaGHvF.is\_legal():
qRM7Ov.append(B\_7SaGHvF)
elif qv\_xJYhNR.is\_legal():
qRM7Ov.append(qv\_xJYhNR)
#print("":("")

print(qRM7Ov[ELm0YH2].degree)
qRM7Ov[ELm0YH2].print()
print(qRM7Ov[ELm0YH2-1].degree)
qRM7Ov[ELm0YH2-1].print()

#for j in range(len(qRM7Ov)):
#qRM7Ov[j].print()

</ans>",0,{}
377," <ans>
class Combination:
 def **init**(self, n\_max, mod=10**9+7):
 self.mod = mod
 self.modinv = self.make\_modinv\_list(n\_max)
 self.fac, self.facinv = self.make\_factorial\_list(n\_max)

 def **call**(self, n, r):
 return self.fac[n] \* self.facinv[r] % self.mod \* self.facinv[n-r] % self.mod

 def make\_factorial\_list(self, n):
 # 階乗のリストと階乗のmod逆元のリストを返す O(n)
 # self.make\_modinv\_list()が先に実行されている必要がある
 fac = [1]
 facinv = [1]
 for i in range(1, n+1):
 fac.append(fac[i-1] \* i % self.mod)
 facinv.append(facinv[i-1] \* self.modinv[i] % self.mod)
 return fac, facinv

 def make\_modinv\_list(self, n):
 # 0からnまでのmod逆元のリストを返す O(n)
 modinv = [0] \* (n+1)
 modinv[1] = 1
 for i in range(2, n+1):
 modinv[i] = self.mod - self.mod//i \* modinv[self.mod%i] % self.mod
 return modinv
LYdyhS7p = 998244353
K, N = map(int, input().split())
roPjsSR = Combination(10000, mod=LYdyhS7p)
def C(n, r):
if n<r or r<0:
return 0
else:
return roPjsSR(n, r)
def H(n, r):
return C(n+r-1, r)
Thoj48u = []
for i in range(2, 2*K+1, 2):
ans = 0
M = i//2
jDzXlJKh = 1
for j, a in enumerate(range(M, K)):
if M-j<0:
break
ans += pow(2, M-j, LYdyhS7p) \* C(M, j) \* H(K-a, N) \* jDzXlJKh
ans %= LYdyhS7p
jDzXlJKh = -jDzXlJKh
print(ans)
if i == K+1:
break
elif i == K:
print(ans)
print(ans)
break
Thoj48u.append(ans)
print(ans)
Thoj48u.append(ans)

print(*Thoj48u[::-1], sep=""\n"")
</ans>",0,{}
378," <ans>
import sys
import math
import random
n, k, x = map(int, input().split())
bHXG = list(map(int, input().split()))
pbh2Xe\_ux = 0
if n == 1:
print(0)
return
for i in range(0, n - 1):   
if bHXG[i] == bHXG[i + 1] == x:
N98I9q1 = i    
while N98I9q1 >= 0 and bHXG[i] == bHXG[N98I9q1]:
N98I9q1 -= 1
_2XNY = i + 1
while _2XNY < n and bHXG[_2XNY] == x:
_2XNY += 1
while (1):
if N98I9q1 == -1 or _2XNY == n:
break
if bHXG[N98I9q1] != bHXG[_2XNY]:
break
if N98I9q1 == 0 and _2XNY == n - 1:
break
if N98I9q1 == 0:
if bHXG[0] == bHXG[_2XNY + 1]:
while _2XNY < n and bHXG[_2XNY] == bHXG[0]:
_2XNY += 1
N98I9q1 -= 1
continue
else:
break
if _2XNY == n - 1:
if bHXG[n - 1] == bHXG[N98I9q1 - 1]:
while N98I9q1 >= 0 and bHXG[N98I9q1] == bHXG[n - 1]:
N98I9q1 -= 1
_2XNY += 1
continue
else:
break
if bHXG[N98I9q1] == bHXG[_2XNY + 1] or bHXG[N98I9q1 - 1] == bHXG[_2XNY]:
t = bHXG[N98I9q1]
while N98I9q1 >= 0 and bHXG[N98I9q1] == t:
N98I9q1 -= 1
while _2XNY < n and bHXG[_2XNY] == t:
_2XNY += 1
else:
break
pbh2Xe\_ux = max(pbh2Xe\_ux, _2XNY - N98I9q1 - 1)     
print(pbh2Xe\_ux)
</ans>",0,{}
379," <ans>
ka, kb = 0, 0

def g(a, b):
nonlocal ka, kb
if a == b:
return
if abs(a - b) == 2:
if a == 1:
ka += 1
else:
kb += 1
else:
if a > b:
ka += 1
else:
kb += 1

def main():
nonlocal ka, kb
k, a, b = list(map(int, input().split()))
aa = [[] for i in [1, 1, 1]]
bb = [[] for i in [1, 1, 1]]
aa[0] = list(map(int, input().split()))
aa[1] = list(map(int, input().split()))
aa[2] = list(map(int, input().split()))
bb[0] = list(map(int, input().split()))
bb[1] = list(map(int, input().split()))
bb[2] = list(map(int, input().split()))
x = a
y = b
o = 1
pXv1bjBD = [[x, y]]
QryhxJKtnq = [[0, 0]]
g(x, y)
if k == 1:
return
x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
#print(x, y, ka, kb)
while [x, y] not in pXv1bjBD:
umtF += 1
pXv1bjBD += [[x, y]]
QryhxJKtnq += [[ka, kb]]
g(x, y)
x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
#print(x, y, ka, kb)
if umtF == k:
return
ind = pXv1bjBD.index([x, y])
Eo7Ib = ka - QryhxJKtnq[ind][0]
FOPKvgW = kb - QryhxJKtnq[ind][1]
zLiu9T = umtF - ind
kk = (k - ind) // zLiu9T - 1
#print(Eo7Ib, FOPKvgW, zLiu9T)
ka += kk * Eo7Ib
kb += kk * FOPKvgW
umtF += kk * zLiu9T
while umtF != k:
umtF += 1
g(x, y)
x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]
#print(x, y, ka, kb)

main()
print(ka, kb)
</ans>",0,{}
380," <ans>
import sys
sys.setrecursionlimit(4100000)
import math
import fractions

SFXaU4r4Z = input()

t6K = SFXaU4r4Z[SFXaU4r4Z-1]

while(SFXaU4r4Z >= 0):

if t6K == ""r"":
if SFXaU4r4Z[SFXaU4r4Z-2] == ""m"":
t6K = SFXaU4r4Z[SFXaU4r4Z-6: SFXaU4r4Z+1]
if t6K == ""dreamer"":
SFXaU4r4Z -= 7
else:
print(""NO"")
return

```
    elif SFXaU4r4Z[SFXaU4r4Z-2] == ""s"":
        t6K = SFXaU4r4Z[SFXaU4r4Z-5: SFXaU4r4Z+1]
        
        if t6K == ""eraser"":
            SFXaU4r4Z -= 6
        else:
            print(""NO"")
            return

    elif SFXaU4r4Z[SFXaU4r4Z-2] == ""e"":
        t6K = SFXaU4r4Z[SFXaU4r4Z-4: SFXaU4r4Z+1]
        
        if t6K == ""erase"":
            SFXaU4r4Z -= 5
        else:
            print(""NO"")
            return

    elif SFXaU4r4Z[SFXaU4r4Z-2] == ""m"":
        t6K = SFXaU4r4Z[SFXaU4r4Z-4: SFXaU4r4Z+1]
        
        if t6K == ""dream"":
            SFXaU4r4Z -= 5
        else:
            print(""NO"")
            return

    else:
        print(""NO"")
        return


print(""YES"")
```
</ans>",0,{}
381," <ans>
class UnionFind():
def **init**(self, n):
self.n = n + 1
self.parents = [-1] \* self.n

def find(self, x):
if self.parents[x] < 0:
return x
else:
self.parents[x] = self.find(self.parents[x])
return self.parents[x]

def union(self, x, y):
x = self.find(x)
y = self.find(y)

if x == y:
return

if self.parents[x] > self.parents[y]:
x, y = y, x

self.parents[x] += self.parents[y]
self.parents[y] = x

# TODO 根を返す
return x

def size(self, x):
return -self.parents[self.find(x)]

def same(self, x, y):
return self.find(x) == self.find(y)

def members(self, x):
root = self.find(x)
return [i for i in range(self.n) if self.find(i) == root]

def roots(self):
return [i for i, x in enumerate(self.parents) if x < 0]

def group\_count(self):
return len(self.roots())

def all\_group\_members(self):
return {r: self.members(r) for r in self.roots()}

def **str**(self):
return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

from collections import defaultdict
def main():
N, M = list(map(int, input().split()))
A = list(map(int, input().split()))
B = list(map(int, input().split()))
A.append(0)
B.append(0)
ax7\_Vc0Zl = UnionFind(N+1)
for **in** range(M):
c, d = list(map(int,input().split()))
ax7\_Vc0Zl.union(c, d)
A\_sums = defaultdict(int)
JGc = defaultdict(int)
for i in range(1, N+1):
x = ax7\_Vc0Zl.find(i)
A\_sums[x] += A[i-1]
JGc[x] += B[i-1]
for a, b in zip(list(A\_sums.values()), list(JGc.values())):
if a != b:
print('No')
return
print('Yes')

main()
</ans>",0,{}
382," <ans>
from sys import stdin, stdout

ExW = int(stdin.readline())

n, m = list(map(int, stdin.readline().split()))

left, right, down, up = [], [], [], []

h6RIQ8uI4 = []

for i in range(ExW):

x1, y1, x2, y2 = list(map(int, stdin.readline().split()))

if x1 == x2:

if y1 < y2:

h6RIQ8uI4.append((x1, y1, x2, y2, i))

else:

h6RIQ8uI4.append((x2, y2, x1, y1, i))

else:

if x1 < x2:

h6RIQ8uI4.append((x1, y1, x2, y2, i))

else:

h6RIQ8uI4.append((x2, y2, x1, y1, i))

left.append(h6RIQ8uI4[-1])

right.append(h6RIQ8uI4[-1])

up.append(h6RIQ8uI4[-1])

down.append(h6RIQ8uI4[-1])

left.sort(key = lambda x: (x[0], x[2]))

down.sort(key = lambda x: (x[1], x[3]))

Dl1he2 = [[], [], [], []]

cntl, cntr, cntd, cntu = list(map(int, stdin.readline().split()))

KDPlQxP4DC = 1

if cntl or not cntl:

for i in range(cntl, -1, -1):

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

Dl1he2[0].append(left[i][-1])

else:

break

for i in range(cntl + 1, k):

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]) and left[i][2] > left[i][0]:

KDPlQxP4DC = 0

if (left[i][0], left[i][2]) == (left[cntl][0], left[cntl][2]):

Dl1he2[0].append(left[i][-1])

else:

break

if cntr or not cntr:

for i in range(k - 1 - cntr, k):

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

Dl1he2[1].append(left[i][-1])

else:

break

for i in range(k - 2 - cntr, -1, -1):

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]) and left[i][2] > left[i][0]:

KDPlQxP4DC = 0

if (left[i][0], left[i][2]) == (left[k - 1 - cntr][0], left[k - 1 - cntr][2]):

Dl1he2[1].append(left[i][-1])

else:

break

if cntd or not cntd:

for i in range(cntd, -1, -1):

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

Dl1he2[2].append(down[i][-1])

else:

break

for i in range(cntd + 1, k):

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]) and down[i][3] > down[i][1]:

KDPlQxP4DC = 0

if (down[i][1], down[i][3]) == (down[cntd][1], down[cntd][3]):

Dl1he2[2].append(down[i][-1])

else:

break

if cntu or not cntu:

for i in range(k - 1 - cntu, k):

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

Dl1he2[3].append(down[i][-1])

else:

break

for i in range(k - 2 - cntu, -1, -1):

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]) and down[i][3] > down[i][1]:

KDPlQxP4DC = 0

if (down[i][1], down[i][3]) == (down[k - 1 - cntu][1], down[k - 1 - cntu][3]):

Dl1he2[3].append(down[i][-1])

else:

break

XkQ = set(Dl1he2[0]) & set(Dl1he2[1]) & set(Dl1he2[2]) & set(Dl1he2[3])

if not len(XkQ) or not KDPlQxP4DC:

stdout.write('-1')

else:

stdout.write(str(list(XkQ)[0] + 1))

# Made By Mostafa\_Khaled
</ans>",0,{}
383," <ans>
import math
import sys

class Graph:
    def **init**(self,Nodes,is\_directed=False):
        self.nodes=Nodes
        self.adj\_list={}
        self.is\_directed=is\_directed

        for node in self.nodes:
            self.adj\_list[node]=[]
            
    def add\_edge(self,u,v):
        self.adj\_list[u].append(v)
        if self.is\_directed==False:
            self.adj\_list[v].append(u)
 
    def print\_graph(self):
        for node in self.nodes:
            print((node,""->"",self.adj\_list[node]))
 
    def degree\_node(self,node):
        return len(self.adj\_list[node])
 
    def dfsUTIL(self,v,gvV,parents=[]):
        #print(v,end="" "")
        gvV[v]=True
        for i in self.adj\_list[v]:
            if gvV[i]==False:
                self.dfsUTIL(i,gvV,parents)
                parents.append(i)        
    
    def dfs(self,v):
        gvV=[False]*(max(self.adj\_list)+1)
        parents=[v]
        self.dfsUTIL(v,gvV,parents)
        return len(parents)
        
##### sorting a dictionary by the values#####
def dict\_sort(ans):
    ans=sorted(list(ans.items()),reverse=True,key=lambda kv:(kv[1]))
    
##### naive method for testing prime or not O(n^.5)#####
def is\_prime(n):
    if n==1:
        return 0
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            return False
    return True

#####swap function#####
def swap(a,b):
    temp=a
    a=b
    b=temp
    return a,b

#####Primes till Nth O(n)#####
def seive\_primes(n):
    flag=[0]*(n+10)
    flag[1]=flag[0]=1
    i=2
    while i*i<=n+1:
        if flag[i]==0:
            j=i*i
            while j<=n+1:
                flag[j]=1
                j+=i
        i+=1
    return flag

#####all the prime factors of a number#####
def factors(n):
    d={}
    while(n%2==0):
        if 2 in d:
            d[2]+=1
        else:
            d[2]=1
        n/=2
    for i in range(3,int(n**0.5)+1,2):
        while(n%i==0):
            if i in d:
                d[i]+=1
            else:
                d[i]=1
            n/=i
    n=int(n)
    if n>1:
        d[n]=1
    return d

#####greatest common divisor of two numbers#####
def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)

#####least common multiplyer of two numbers#####
def lcm(a,b):
    return (a*b)//gcd(a,b)

#####function that return all the letters#####
def alphabates():
    return ""abcdefghijklmnopqrstuvwxyz""

#####binary search O(logN)#####
def binary\_search(ls,n,flag):
    low=0
    hi=n-1
    while(low<=hi):
        mid=(low+hi)//2
        if ls[mid]==flag:
            return mid
        elif ls[mid]>flag:
            hi=mid-1
        else:
            low=mid+1
    return -1

#####quadratic roots#####
def qdrt(a,b,c):
    chk=b*b-4*a*c
    if chk>=0:
        ans1=(-b+chk**0.5)/(2*a)
        ans2=(-b-chk**0.5)/(2*a)
        return [int(ans1),int(ans2)]
    return -1
#####permutations#####
def permutation(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(n-r+1,n+1):
        ans*=i
    return ans

#####combinations#####
def combination(n,r):
    if n<r:
        return 0
    ans=1
    for i in range(r):
        ans*=(n-i)
    div=1
    for i in range(2,r+1):
        div*=i
    return ans//div
        
#####taking an array/list as input#####
def arinp():
    ls=list(map(int,input().split()))
    return ls

#####taking multiple inputs#####
def mult_inp():
    return list(map(int,input().split()))

#####Main function starts from here#####
def main():
    BzK8feb=input()
    JeKrI=len(BzK8feb)
    if BzK8feb==BzK8feb[::-1] and BzK8feb[:JeKrI//2]==BzK8feb[JeKrI//2+1:]:
        print('Yes')
    else:
        print('No')
def **starting\_point**():
    main()


\_\_starting\_point**()**
</ans>",0,{}
384," <ans>
from array import array
DGC5 = (1 << 30)

def main():
(STS, k) = [int(x) for x in input().split(' ')]
upFbjBR = []
for i in range(STS):
upFbjBR.append(array('b',[ord(x) for x in input()]))
jcvv = [array('l', [DGC5 for j in range(STS)]) for i in range(STS)]
pXLGL3kJC = [[ord('d') for j in range(STS)] for i in range(STS)]
wmeD = """"
for s in range (2 \* STS - 1):
opchar = chr(ord('z') + 1)
positions = []
for i in range(0, s+1):
j = s - i;
if j < STS and i < STS:
if(i > 0 and j > 0):
if(jcvv[i-1][j] < jcvv[i][j-1]):
jcvv[i][j] = jcvv[i-1][j]
pXLGL3kJC[i][j] = 'l'
else:
jcvv[i][j] = jcvv[i][j-1]
pXLGL3kJC[i][j] = 'd'
elif i > 0:
jcvv[i][j] = jcvv[i-1][j]
pXLGL3kJC[i][j] = 'l'
elif j > 0:
jcvv[i][j] = jcvv[i][j-1]
pXLGL3kJC[i][j] = 'd'
else:
jcvv[i][j] = 0
pXLGL3kJC[i][j] = 'e'
if(jcvv[i][j] < k and upFbjBR[i][j] is not ord('a')):
jcvv[i][j]+=1
upFbjBR[i][j] = ord('a')
if(upFbjBR[i][j] < ord(opchar) and jcvv[i][j] <= k):
opchar = chr(upFbjBR[i][j])
for i in range(0, s+1):
j = s - i;
if j < STS and i < STS:
if(upFbjBR[i][j] is not ord(opchar)):
jcvv[i][j] = DGC5
O8RVK7gqm = """"
a,b = (STS-1,STS-1)
while(pXLGL3kJC[a][b] is not 'e'):
O8RVK7gqm += chr(upFbjBR[a][b])
if(pXLGL3kJC[a][b] is 'l'):
a-=1
else:
b-=1
O8RVK7gqm += chr(upFbjBR[0][0])
print(O8RVK7gqm[::-1])

main()
</ans>",0,{}
385," <ans>
import sys

uGe9p = False

# Pre-defined function
# Begin
def fast\_pow(a:int, b:int):
x\_Y4SZNhPO = 1
while b > 0:
if b & 1:
x\_Y4SZNhPO \*= a
a \*= a
b >>= 1
return x\_Y4SZNhPO

def c2(n):
return n \* (n-1) // 2

def get():
return list(map(int, input().split()))

def parr(arr):
print(\*arr, sep=' ')

def gcd(a, b):
while b:
if b % a == 0:
break
tmp = a
a = b % a
b = tmp
return a

def ext\_gcd(a: int, b: int):
if (b == 0):
return [a, [1, 0]]

res = ext\_gcd(b, a % b)
g = res[0]
x1 = res[1][0]
y1 = res[1][1]
x = y1
y = x1 - y1 \* (a // b)

return [g, [x, y]]

# End

x = []
mpBtfq = []
NnGfu0p6 = MjR3pbfMLX = a = 0

def check(cnt):
if cnt == 0:
return True
x\_slice = x[-cnt:]
mpBtfq\_slice = mpBtfq[:cnt]
sMP = a
i = 0
while i < cnt and sMP >= 0:
sMP -= max(0, mpBtfq\_slice[i]-x\_slice[i])
i += 1
return sMP >= 0

def test():
nonlocal NnGfu0p6, MjR3pbfMLX, a, x, mpBtfq
NnGfu0p6, MjR3pbfMLX, a = get()
x = sorted(get())
mpBtfq = sorted(get())

oavUJQF1b = 0
F1V = min(NnGfu0p6, MjR3pbfMLX)

i8fRxjzIa = -1

while oavUJQF1b <= F1V:
t4qNWdq95F = (oavUJQF1b + F1V) // 2
if check(t4qNWdq95F):
i8fRxjzIa = max(i8fRxjzIa, t4qNWdq95F)
oavUJQF1b = t4qNWdq95F + 1
else:
F1V = t4qNWdq95F - 1

if i8fRxjzIa == -1:
print(0, 0)
return

t = 0
rymjEJ4j\_slice = x[-i8fRxjzIa:]
mpBtfq\_slice = mpBtfq[:i8fRxjzIa]
DFFfCMJeBW = 0
while DFFfCMJeBW < i8fRxjzIa:
t += min(rymjEJ4j\_slice[DFFfCMJeBW], mpBtfq\_slice[DFFfCMJeBW])
a -= max(0, mpBtfq\_slice[DFFfCMJeBW]-rymjEJ4j\_slice[DFFfCMJeBW])
DFFfCMJeBW += 1
print(i8fRxjzIa, max(0, t-a)) </ans> 

Note: I have replaced the variable names as per your request. However, please be aware that using single-letter variable names can make the code difficult to understand and maintain. It is generally a good practice to use meaningful variable names.",0,{}
386," <ans>
n=int(input())
la=[]
le=[]
li=[]
lo=[]
lu=[]
ans=[]
d1={}
for i in range(n):
s=input()
hGb=s.count('a')+s.count('e')+s.count('i')+s.count('o')+s.count('u')
if hGb>0:

for c in s[::-1]:
if c=='a' or c=='e' or c=='i' or c=='o' or c=='u':
break
if (hGb,c) in d1:
d1[(hGb,c)].append(s)
else :
d1[(hGb,c)]=[s]
d2={}
pairs1=[]
pairs2=[]
for k in d1:
if len(d1[k])%2==1:
if k[0] in d2:
d2[k[0]].append(d1[k][0])
else :
d2[k[0]]=[d1[k][0]]
for i in range(1,len(d1[k]),2):
pairs1.append((d1[k][i],d1[k][i+1]))
else :
for i in range(0,len(d1[k]),2):
pairs1.append((d1[k][i],d1[k][i+1]))
for k in d2:
if len(d2[k])>1:
if len(d2[k])%2==1:
d2[k].pop()
for i in range(0,len(d2[k]),2):
pairs2.append((d2[k][i],d2[k][i+1]))
if len(pairs1)<len(pairs2):
print(len(pairs1))
for i in range(len(pairs1)):
print(pairs2[i][0],pairs1[i][0])
print(pairs2[i][1],pairs1[i][1])
else :
print(len(pairs2)+(len(pairs1)-len(pairs2))//2)
for i in range(len(pairs2)):
print(pairs2[i][0],pairs1[i][0])
print(pairs2[i][1],pairs1[i][1])
for j in range(len(pairs2),len(pairs1),2):
if j==len(pairs1)-1:
break
else :
print(pairs1[j][0],pairs1[j+1][0])
print(pairs1[j][1],pairs1[j+1][1])
</ans>",0,{}
387," <ans>
import sys
from functools import lru\_cache

R8lpHfwgL = sys.stdin.readlines
readline = sys.stdin.readline
read = \_7em
sys.setrecursionlimit(10 ** 9)
SbGel2Z = 1 << 60
ni0 = 1000000007

def main():
N, K, \*A = list(map(int, R8lpHfwgL().split()))

K = list(map(int, f'{K:>040b}'))
A2 = [list(map(int, f'{a:>040b}')) for a in A]
htoMOBn = [0] \* 40
for a in A2:
for i, bit in enumerate(a):
htoMOBn[i] += bit
for i in range(40):
if htoMOBn[i] == N - htoMOBn[i]:
htoMOBn[i] = 2
elif htoMOBn[i] < N - htoMOBn[i]:
htoMOBn[i] = 1
else:
htoMOBn[i] = 0

@lru\_cache(maxsize=None)
def rec(i, x, smaller):
if i == 40:
fLLX = 0
for a in A:
fLLX += x ^ a
return fLLX
elif smaller:
if htoMOBn[i] == 2:
return rec(i + 1, (x << 1), True)
else:
return rec(i + 1, (x << 1) + htoMOBn[i], True)
else:
if htoMOBn[i] == 2:
if K[i] == 0:
return rec(i + 1, (x << 1), False)
else:
return rec(i + 1, (x << 1), True)
elif K[i] == htoMOBn[i]:
return rec(i + 1, (x << 1) + K[i], False)
elif K[i] < htoMOBn[i]:
return rec(i + 1, (x << 1) + K[i], False)
else:
return rec(i + 1, (x << 1) + htoMOBn[i], True)

print((rec(0, 0, False)))
return

def __starting\_point():
main()

__starting\_point()
</ans>",0,{}
388," <ans>
```python
#
# abc069 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3\n1 10 100""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""4\n1 2 3 4""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""3\n1 4 1""""""
        output = """"""Yes""""""
        self.assertIO(input, output)

    def test_入力例_4(self):
        input = """"""2\n1 1""""""
        output = """"""No""""""
        self.assertIO(input, output)

    def test_入力例_5(self):
        input = """"""6\n2 7 1 8 2 8""""""
        output = """"""Yes""""""
        self.assertIO(input, output)


def resolve():
    bClQ_3ub = int(mumf5())
    dmI = list(map(int, mumf5().split()))

    mz3T1c = 0
    wsWD = 0
    qDswCDK8 = 0
    for a in dmI:
        if a % 4 == 0:
            mz3T1c += 1
        elif a % 2 == 0:
            wsWD += ",0,{}
389," <ans>
import sys
moa = sys.stdin.readline
oJT = enumerate
urP5 = 1001001001

import collections
import random

def linput(ty=int, cvt=list):
	return cvt(list(map(ty,moa().split())))

def vinput(rep=1, ty=int, cvt=list):
	return cvt(ty(moa().rstrip()) for _ in ""*""*rep)

def gcd(a: int, b: int):
	while b: a, b = b, a%b
	return a

def lcm(a: int, b: int):
	return a * b // gcd(a, b)

def dist(x1,y1,x2,y2):
	return abs(x1-x2)+abs(y1-y2)

#vD = [chr(ord(""a"")+i) for i in range(26)]

def ran():
	kpe = [random.randint(1, 10),
	        random.randint(0, 10),
	        random.randint(1, 100)]
	return kpe

def bye(res):
	sT = ""No Yes"".split()
	print((sT[res]))
	#return

def sol\_n(a,b,c):
	res = 0
	cnt = 0
	while cnt<c:
		res += 1
		cnt += a
		if res%7==0:
			cnt += b
	return res


def sol(a,b,c):
	#a,b,c = linput()
	### 3 6 9 12 15
	### 1 2 3 4  5
	
	res = 0
	Byqpg9 = -(-a//c)
	m2E = (b//c)
	res = m2E-Byqpg9+1
	
	return res

def deb():
	#vI = linput()
	vI = ran()
	#print(vI)
	gX1IzE9LUq = sol\_n(*vI)
	DIf = sol(*vI)
	if 1:#I!=J:
		print((vI, gX1IzE9LUq, DIf))

def main():
	vI = linput()
	print((sol(*vI)))

def __starting\_point():
	#for _ in ""*""*1000:
	#	deb()
	main()

__starting\_point()
</ans>",0,{}
390," <ans>
from math import sqrt, pow, log, log2, log10, exp
from copy import deepcopy
from fractions import gcd

```python
def read_ints():
    return list(map(int, input().split()))

def read_int():
    return read_ints()[0]

def read_floats():
    return list(map(float, input().split()))

def read_float():
    return read_floats()[0]

def format_list(l):
    return ' '.join(list(map(str, l)))

def one_dim_array(n, value=0):
    return [deepcopy(value) for x in range(n)]

def two_dim_array(n, m, value=0):
    return [[deepcopy(value) for x in range(m)] for x in range(n)]

def is_prime(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, sqrt(n) + 1):
        if n % i == 0:
            return False
    return True

def max_len_sublist(l, f):
    KoAUjx0IW, KpPPf, Hih = 0, 0, 0
    for i in range(1, len(l)):
        if f(l[i], l[i - ",0,{}
391," <ans>
z=[int(p) for p in input().split()]
m=z[2]
isurZ4fxp=[]
isurZ4fxp.append(z[0])
isurZ4fxp.append(z[1])
tempi=min(isurZ4fxp)
rLPQ937YT=max(isurZ4fxp)

count=0
hqIeAipu6=[]

n=1000000000000000000
def fib(n):
        
        a, b = 0, 1
        while b < n:
                hqIeAipu6.append(b)
                a, b = b, a+b
    


def add(m):
        n=10**18
        tempi=min(isurZ4fxp)
        rLPQ937YT=max(isurZ4fxp)
        count=0
        if(tempi>0 and rLPQ937YT>0 and m>rLPQ937YT):
                fib(n)
                for p in range(1,len(hqIeAipu6)+1):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*tempi))>=m):
                                count+=p
                                return count
        elif(tempi==0 or rLPQ937YT==0):
                count=1
                fib(n)
                tempi=rLPQ937YT+(tempi)
                for p in range(1,len(hqIeAipu6)):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*tempi))>=m):
                                count+=p
                                return count

        elif(tempi<0 and rLPQ937YT>0):
                val=(-(tempi)//rLPQ937YT)+1
                count=val
                tempi=tempi+(val*rLPQ937YT)
                fib(n)
                for p in range(1,len(hqIeAipu6)):
                        if(((hqIeAipu6[p]*rLPQ937YT)+ (hqIeAipu6[p-1]*tempi))>=m):
                                count+=p
                                return count

        





if(tempi>0 and rLPQ937YT>0 and m>rLPQ937YT):
        cou=add(m)
        print(cou)

elif(tempi>0 and rLPQ937YT>0 and m<=rLPQ937YT):
        print(0)

elif(tempi==0 ):
        if(tempi==0 and rLPQ937YT==0 and m>0):
                print(-1)
        elif(tempi==0 and rLPQ937YT==0 and m<=0):
                print(0)
        elif(rLPQ937YT==0 and tempi<0 and m>0):
                print(-1)
                
        else:
                cou=add(m)
                print(cou)
elif(tempi<0 and rLPQ937YT>0):
        if(m<=rLPQ937YT):
                print(0)
        else:
                cou=add(m)
                print(cou)
elif(tempi<0 and rLPQ937YT==0):
        if(m>0):
                print(-1)
        else:
                print(0)
elif(tempi<0 and rLPQ937YT<0):
        if(m>=0):
                print(-1)
        elif(m<0 and m<=rLPQ937YT):
                print(0)
        elif(m<0 and m>rLPQ937YT):
                print(-1)

        


        
                
                
                        
                        
                                
                        
                        
                


                        
                        
                        

</ans>",0,{}
392," <ans>
```python
# NOT MY CODE
# https://codeforces.com/contest/919/submission/80857731
 
from types import GeneratorType
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        s32GHKrwXl = f(*args, **kwargs)
        if stack:
            return s32GHKrwXl
        else:
            while True:
                if type(s32GHKrwXl) is GeneratorType:
                    stack.append(s32GHKrwXl)
                    s32GHKrwXl = next(s32GHKrwXl)
              ",0,{}
393," <ans>
```python
#!/usr/bin/env python3
import sys
from collections import defaultdict

IEOyos5 = float(""inf"")


def solve(AM7Qodw: int, KftMx6: int, oqN: int):
    if oqN == 0:
        if KftMx6 == 0:
            print((1))
        else:
            print((AM7Qodw+1))
        return

    if oqN < 0:
        KftMx6 = KftMx6 + (AM7Qodw-1)*oqN
        oqN = abs(oqN)

    KkI = defaultdict(list)
    for k in range(AM7Qodw+1):
        BN48w_K = k*(k-1)//2
        oZIkLIG = k*AM7Qodw - k*(k+1)//2
        Aqou = k*KftMx6 + oqN*BN48w_K
        Yi35BYZp = oZIkLIG-BN48w_K
        seg = (Aqou//oqN, Aqou//oqN+Yi35BYZp+1)
        s = Aqou % oqN
        KkI[s].append(seg)

    Dze5hj = 0
    for k in KkI:
        Wp7 = defaultdict(int)
        for l, r in KkI[k]:
            Wp7[l] += 1
            Wp7[r] -= 1

        curr = 0
        pre = -1
        for k in sorted(Wp7.keys()):
            if curr > 0:
                Dze5hj += k - pre
            curr += Wp7[k]
            pre = k
    print(Dze5hj)

    return


def main():

    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    umHcB = iterate_tokens()
    AM7Qodw = int(next(umHcB))  # type: int
    KftMx6 = int(next(umHcB))  # type: int
    oqN = int(next(umHcB))  # type: int
    solve(AM7Qodw, KftMx6, oqN)


def __starting_point():
    main()

__starting_point()
```
</ans>",0,{}
394," <ans>
import sys
rmTjhA2Ica = (s.rstrip() for s in sys.stdin)
input = rmTjhA2Ica.__next__

LLZZ6hG = int(input())
_Pea2on = list(map(int, input().split()))
NHw = (LLZZ6hG+1)//2
MoHbAFkR = LLZZ6hG-NHw
for i in _Pea2on:
if i:
if i%2 == 0:
MoHbAFkR -= 1
else:
NHw -= 1

if MoHbAFkR == 0:
_Pea2on = [i if i else 1 for i in _Pea2on]
if NHw*MoHbAFkR == 0:
LJP = 0
prev = _Pea2on[0]
for pi in _Pea2on:
LJP += (pi+prev)%2
prev = pi
print(LJP)
return

Q0wEqen9O6 = [[float(""inf"")]*(MoHbAFkR+1) for i in range(2)]
for i in range(LLZZ6hG):
zxmBQvSpT3 = [[float(""inf"")]*(MoHbAFkR+1) for i in range(2)]
if i == 0:
if _Pea2on[i]:
if _Pea2on[i]%2 == 0:
zxmBQvSpT3[0][0] = 0
else:
zxmBQvSpT3[1][0] = 0
else:
zxmBQvSpT3[0][1] = 0
zxmBQvSpT3[1][0] = 0
else:
if _Pea2on[i]:
if _Pea2on[i]%2 == 0:
for j in range(MoHbAFkR+1):
zxmBQvSpT3[0][j] = min(Q0wEqen9O6[0][j], Q0wEqen9O6[1][j]+1)
else:
for j in range(MoHbAFkR+1):
zxmBQvSpT3[1][j] = min(Q0wEqen9O6[0][j]+1, Q0wEqen9O6[1][j])
else:
for j in range(1, MoHbAFkR+1):
zxmBQvSpT3[0][j] = min(Q0wEqen9O6[0][j-1], Q0wEqen9O6[1][j-1]+1)
for j in range(MoHbAFkR+1):
zxmBQvSpT3[1][j] = min(Q0wEqen9O6[0][j]+1, Q0wEqen9O6[1][j])
Q0wEqen9O6 = zxmBQvSpT3
print(min(Q0wEqen9O6[0][-1], Q0wEqen9O6[1][-1]))
</ans>",0,{}
395," <ans>
```python
# E
PnC22f69a = int(input())
WCPKlfWf = list(map(int, input().split()))
hYdIY6b = list(map(int, input().split()))

# graph
CgfyX = [[] for _ in range(PnC22f69a+1)]
for i in range(2, PnC22f69a+1):
    CgfyX[PnC22f69a[i-2]].append(i)

# from root
# minimize local total weight

CjB8spQeuh = [0]+WCPKlfWf
jKST = [0]*(PnC22f69a+1)

# solve knapsack
def solve_knapsack(L, M):
    min_acc = sum([min(CjB8spQeuh[j], jKST[j]) for j in L])
    if min_acc > M:
        return -1
    else:
        UrmzPKw = M - min_acc
        add_set = set([0])
        for j in L:
            add_j = max(CjB8spQeuh[j], jKST[j]) - min(CjB8spQeuh[j], jKST[j])
            f7t_ = set(add_set)
            for s in add_set:
                if s + add_j <= UrmzPKw:
                    f7t_.add(s + add_j)
            add_set = f7t_
        
        total = sum([CjB8spQeuh[j]+jKST[j] for j in L])
        return total - max(add_set) - min_acc

HXIPAAtyOX = ""POSSIBLE""

for i in range(PnC22f69a, 0, -1):
    if len(CgfyX[i]) == 0:
        pass
    elif len(CgfyX[i]) == 1:
        gVrelWu1 = CgfyX[i][0]
        if min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) > WCPKlfWf[i-1]:
            HXIPAAtyOX = ""IMPOSSIBLE""
            break
        elif max(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1]) > WCPKlfWf[i-1]:
            jKST[i] = max(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1])
        else:
            jKST[i] = min(CjB8spQeuh[gVrelWu1], jKST[gVrelWu1])
    else:
        LKN = solve_knapsack(CgfyX[i], WCPKlfWf[i-1])
        if LKN < 0:
            HXIPAAtyOX = ""IMPOSSIBLE""
            break
        else:
            jKST[i] = LKN
    
print(HXIPAAtyOX)
```
</ans>",0,{}
396," <ans>
def prime\_factor(n):
n = W1eqmCjaY
i = y5qYCOsG
factors = []
while i \* i <= n:
if n % i:
i += 1
else:
while n % i == 0:
n //= i
factors.append(i)
if n > 1:
factors.append(n)
return factors

def divisors(n):
divisors = []
for i in range(1, int(n**0.5)+1):
if n % i == 0:
divisors.append(i)
if i != n // i:
divisors.append(n//i)
divisors.sort()
return divisors

def mebius(n):
res = {}
primes = prime\_factor(n)
m = len(primes)
for i in range(1 << m):
mu = 1
d = 1
for j in range(m):
if i >> j & 1:
mu \*= -1
d \*= primes[j]
res[d] = mu
return res

N = xqMHM
K = kwhNn\_
div = divisors(N)

lZbXV = 0

for x in div:
div2 = divisors(x)
mu = mebius(x)
kwhNn\_ = 0
for y in list(mu.keys()):
kwhNn\_ += pow(K, ((x//y)+1)//2, W1eqmCjaY)\*mu[y]
if x % 2 == 0:
kwhNn\_ \*= pow(2, W1eqmCjaY-2, W1eqmCjaY)
lZbXV += x\*kwhNn\_
lZbXV %= W1eqmCjaY

print(lZbXV)
</ans>",0,{}
397," <ans>
import sys
from math import *

def minp():
return sys.stdin.readline().strip()

HGkNYaB = int(minp())
O87Z = [None]*HGkNYaB
s\_9v59 = [None]*3
PrBX5Q = [None]*3
O87Z[0] = [None]*(HGkNYaB*HGkNYaB)
O87Z[1] = [None]*(HGkNYaB*HGkNYaB)
O87Z[2] = [None]*(HGkNYaB*HGkNYaB)
jJcD39NN = [None]*(HGkNYaB*HGkNYaB)
for i in range(HGkNYaB):
O87Z[i] = list(map(int, minp().split()))
for i in range(HGkNYaB):
for j in range(HGkNYaB):
jJcD39NN[O87Z[i][j]-1] = (i,j)
for z in range(3):
s\_9v59[z] = [None]*HGkNYaB
for i in range(HGkNYaB):
PrBX5Q[i] = [None]*HGkNYaB
for i in range(HGkNYaB):
for j in range(HGkNYaB):
PrBX5Q[i][j] = [(1000000,0)]*3
for z in range(3):
for i in range(HGkNYaB):
for j in range(HGkNYaB):
U8bEQzQmKF[z][i][j] = [None]*3
for z in range(3):
for i in range(HGkNYaB):
for j in range(HGkNYaB):
for w in range(HGkNYaB):
U8bEQzQmKF[z][i][j][w] = [1000000,0]
for z in range(3):
for i in range(HGkNYaB):
for j in range(HGkNYaB):
if U8bEQzQmKF[z][i][j][0] > PrBX5Q[i][j][z][0]:
PrBX5Q[i][j][z] = U8bEQzQmKF[z][i][j]
XNYo8Mb = [0]*(10*HGkNYaB*HGkNYaB)
XNYo8Mb[0] = (z, i, j, (0,0))
PrBX5Q[i][j][z] = (0, 0)
while cL2xjYS < rlmFpG:
t, x, y, dd = XNYo8Mb[cL2xjYS]
d = PrBX5Q[x][y][z]
cL2xjYS += 1
if d != dd:
continue
dd = (d[0]+1, d[1]+1)
for tt in range(3):
if t != tt and PrBX5Q[x][y][tt] > dd:
PrBX5Q[x][y][tt] = dd
XNYo8Mb[rlmFpG] = (tt,x,y,dd)
rlmFpG += 1
dd = (d[0]+1,d[1])
if t == 0:
for w in TitdPvEIHD[t]:
xx,yy = w[0]+x,w[1]+y
if xx >= 0 and xx < HGkNYaB and yy >= 0 and yy < HGkNYaB:
if PrBX5Q[xx][yy][t] > dd:
PrBX5Q[xx][yy][t] = dd
XNYo8Mb[rlmFpG] = (t,xx,yy,dd)
rlmFpG += 1
else:
for w in TitdPvEIHD[t]:
for hm in range(HGkNYaB*2):
xx,yy = w[0]*hm+x,w[1]*hm+y
if xx >= 0 and xx < HGkNYaB and yy >= 0 and yy < HGkNYaB:
if PrBX5Q[xx][yy][t] > dd:
PrBX5Q[xx][yy][t] = dd
XNYo8Mb[rlmFpG] = (t,xx,yy,dd)
rlmFpG += 1
else:
break
O87Z[0][0] = (0,0)
O87Z[1][0] = (0,0)
O87Z[2][0] = (0,0)
for i in range(0,HGkNYaB*HGkNYaB-1):
x,y = jJcD39NN[i]
xx,yy = jJcD39NN[i+1]
for z in range(3):
for j in range(3):
dist = PrBX5Q[j][x][y][z][xx][yy]
if O87Z[j][i] != None:
nd = (O87Z[j][i][0]+dist[0],O87Z[j][i][1]+dist[1])
if O87Z[z][i+1] == None:
O87Z[z][i+1] = nd
else:
O87Z[z][i+1] = min(O87Z[z][i+1],nd)
for j in range(HGkNYaB*HGkNYaB-1,HGkNYaB*HGkNYaB):
qq = [O87Z[i][j] if O87Z[i][j] != None else (1000000,0) for i in range(3)]
qm = min(qq)
print(qm[0], qm[1])
</ans>",0,{}
398," <ans>
def increasing(arr):
n = len(arr)
for i in range(n-1):
if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:
return False

return True

def getFacts(n,_D\_jS8f):
facts = [1]*n
for i in range(1,n):
facts[i] = facts[i-1]*i
facts[i] %= _D\_jS8f

return facts

def solve(arr1,arr2,lJ5aRez,_D\_jS8f):
facts = getFacts(4*10**5+1,_D\_jS8f)
yxHLf = facts[lJ5aRez]
vsO2SMa4E = {1:*n}
for i in arr1:
if i[0] not in list(vsO2SMa4E.keys()):
vsO2SMa4E[i[0]] = 1
else:
vsO2SMa4E[i[0]] += 1

fJ3tLk = {1:*n}
for i in arr2:
if i[0] not in list(fJ3tLk.keys()):
fJ3tLk[i[0]] = 1
else:
fJ3tLk[i[0]] += 1

gnMNPm05gv = 1
for i in vsO2SMa4E:
gnMNPm05gv \*= facts[vsO2SMa4E[i]]
gnMNPm05gv = gnMNPm05gv%_D\_jS8f

yxHLf -= gnMNPm05gv
gnMNPm05gv = 1

for i in fJ3tLk:
gnMNPm05gv \*= facts[fJ3tLk[i]]
gnMNPm05gv = gnMNPm05gv%_D\_jS8f

yxHLf -= gnMNPm05gv
gnMNPm05gv = 1
arr1.sort()
if increasing(arr1):
gnMNPm05gv = 1
else:
gnMNPm05gv = 0
LZXwxITC = {1:*n}
for i in arr1:
if i not in list(LZXwxITC.keys()):
LZXwxITC[i] = 1
else:
LZXwxITC[i] += 1

for i in LZXwxITC:
gnMNPm05gv \*= facts[LZXwxITC[i]]
gnMNPm05gv = gnMNPm05gv%_D\_jS8f

yxHLf += gnMNPm05gv
yxHLf = yxHLf%_D\_jS8f
print(yxHLf)
</ans>",0,{}
399," <ans>
import sys

\#縦k、横kのマスに移動させて考える
n, k = map(int, sys.stdin.readline().strip().split())
mjVilre = []
FJzH = []
X39oOH = []
Zhxusc = []
for \_ in range(n):
mjVilre\_temp, FJzH\_temp, c = sys.stdin.readline().strip().split()
mjVilre\_temp = int(mjVilre\_temp)
FJzH\_temp = int(FJzH\_temp)
if c == 'W':
mjVilre\_temp += k
mjVilre\_temp %= 2 \* k
FJzH\_temp %= 2 \* k
if mjVilre\_temp >= k:
if FJzH\_temp >= k:
mjVilre.append(mjVilre\_temp - k)
FJzH.append(FJzH\_temp - k)
else:
X39oOH.append(mjVilre\_temp - k)
Zhxusc.append(FJzH\_temp)
else:
if FJzH\_temp >= k:
X39oOH.append(mjVilre\_temp)
Zhxusc.append(FJzH\_temp - k)
else:
mjVilre.append(mjVilre\_temp)
FJzH.append(FJzH\_temp)

Db9n9zs5x = [[0 for \_ in range(k)] for \_\_ in range(k)]

\#累積和
\#oGbgJpPKyf + X39oOH = n
oGbgJpPKyf = len(mjVilre)
Db9n9zs5x[0][0] += oGbgJpPKyf
for i in range(oGbgJpPKyf):
Db9n9zs5x[mjVilre[i]][0] -= 1
Db9n9zs5x[0][FJzH[i]] -= 1
Db9n9zs5x[mjVilre[i]][FJzH[i]] += 2

K9uyYX0a0 = len(X39oOH)
Db9n9zs5x[0][0] -= K9uyYX0a0
for i in range(K9uyYX0a0):
Db9n9zs5x[X39oOH[i]][0] += 1
Db9n9zs5x[0][Zhxusc[i]] += 1
Db9n9zs5x[X39oOH[i]][Zhxusc[i]] -= 2

for i in Db9n9zs5x:
for j in range(k-1):
i[j+1] += i[j]

for i in range(k):
for j in range(k-1):
Db9n9zs5x[j+1][i] += Db9n9zs5x[j][i]

\#最大値、最小値を取得
HBhKstauE = max([max(i) for i in Db9n9zs5x]) + K9uyYX0a0
pjvxP9Exd = min([min(i) for i in Db9n9zs5x]) - oGbgJpPKyf

if HBhKstauE + pjvxP9Exd >= 0:
print(HBhKstauE)
else:
print(-pjvxP9Exd)
</ans>",0,{}
400," <ans>
# coding: utf-8
import sys
#from operator import itemgetter
q24AqB = sys.stdin.buffer.readline
read = sys.stdin.buffer.read
#from heapq import heappop, heappush
#from collections import defaultdict
sys.setrecursionlimit(10**7)
#import math
from itertools import product, accumulate, combinations, product
#import bisect
#import numpy as np
#from copy import deepcopy
#from collections import deque
#from decimal import Decimal
#from numba import jit

R7LkXiF = 1 << 50
HLHWYqEv = 1e-8
u82c\_Nmjt = 10 ** 9 + 7

def run():
    _j8aK = int(input())
    qOluuIcku = [9 ** i for i in range(1, 10) if 9 ** i <= _j8aK]
    mWZ = [6 ** i for i in range(1, 10) if 6 ** i <= _j8aK][::-1]
    vcCtlTO9fA = len(qOluuIcku)
    #print(nines, sixes)
    hLrfq1vp3v = R7LkXiF
    for K in product(list(range(9)), repeat = vcCtlTO9fA):
        #print(K, '----------------')
        kIZ = 0
        RxJlk7U4 = 0
        for k, x in zip(K, qOluuIcku):
            if k:
                kIZ += k
                RxJlk7U4 += x * k
        #print(ans, s)

        if RxJlk7U4 > _j8aK:continue
        YiiC9lwD = _j8aK - RxJlk7U4
        #print(resid)
        for six in mWZ:
            #print(resid)
            YtkPCm = YiiC9lwD // six
            if YtkPCm:
                kIZ += YtkPCm
                YiiC9lwD -= six * YtkPCm
        #print(resid, ans)
        #if resid >= 6:
        #    print(resid)
        kIZ += YiiC9lwD
        hLrfq1vp3v = min(hLrfq1vp3v,kIZ)

    print(hLrfq1vp3v)

def __starting_point():
    run()

__starting_point()
</ans>",0,{}
401," <ans>
```python
# -*- coding: utf-8 -*-
import sys
# from operator import itemgetter
# from fractions import gcd
# from math import ceil, floor
# from copy import deepcopy
# from itertools import accumulate
from collections import deque
# import math
# from functools import reduce
input = sys.stdin.readline
def ii(): return int(input())
def mi(): return list(map(int, input().rstrip().split()))
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())
# template

# BEGIN CUT HERE


class BIT:
    def __init__(self, x, d=0):
        if isinstance(x, int):
            self.size = x
            self.tree = [d for _ in range(self.size + 1)]
        elif isinstance(x, list):
            self.size = len(x)
            self.tree = [d for _ in range(self.size + 1)]
            self.build(x)
        else:
            raise TypeError

    def build(self, arr):
        if not isinstance(arr, list):
            raise TypeError
        for num, x in enumerate(arr):
            self.add0(num, x)

    def sum(self, i):
        s = self.tree[0]
        while i > 0:
            s += self.tree[i]
            i -= (i & -i)
        return s

    def add(self, i, a):
        if(i == 0):
            return
        while (i <= self.size):
            self.tree[i] += a
            i += (i & -i)

    def bisect_left(self, w):
        if w <= 0:
            return 0
        x = 0
        r = 1
        while (r < self.size):
            r <<= 1
        k = r
        while (k > 0):
            if x + k <= self.size and self.tree[x + k] < w:
                w -= self.tree[x + k]
              ",0,{}
402," <ans>
```python
""""""Problem B - Bus of Characters.

http://codeforces.com/contest/982/problem/B

In the Bus of Characters there are `n` rows of seat, each having `2` seats.
The width of both seats in the `i`-th row is `w_i` centimeters. All integers
w_i are distinct.

Initially the bus is empty. On each of `2n` stops one passenger enters the
bus. There are two types of passengers:

- an introvert always chooses a row where both seats are empty. Among these
rows he chooses the one with the smallest seats width and takes one of the
seats in it;

- an extrovert always chooses a row where exactly one seat is occupied (by an
introvert). Among these rows he chooses the one with the largest seats width
and takes the vacant place in it.

You are given the seats width in each row and the order the passengers enter
the bus. Determine which row each passenger will take.

Input:

The first line contains a single integer `n` (`1 <= n <= 200\,000`) — the
number of rows in the bus.

The second line contains the sequence of integers `w_1, w_2, ..., w_n` (`1 <=
w_i <= 10^{9}`), where `w_i` is the width of each of the seats in the `i`-th
row. It is guaranteed that all `w_i` are distinct.

The third line contains a string of length `2n`, consisting of digits '0' and
'1' — the description of the order the passengers enter the bus. If the `j`-th
character is '0', then the passenger that enters the bus on the `j`-th stop is
an introvert. If the `j`-th character is '1', the the passenger that enters the
bus on the `j`-th stop is an extrovert. It is guaranteed that the number of
extroverts equals the number of introverts (i. e. both numbers equal `n`), and
for each extrovert there always is a suitable row.

Output:

Print `2n` integers — the rows the passengers will take. The order of
passengers should be the same as in input.

""""""
import logging
import collections


fmt = '%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'
formatter = logging.Formatter(fmt)

ch = logging.StreamHandler()
ch.setLevel(logging.NOTSET)
ch.setFormatter(formatter)

logger = logging.getLogger('bus_of_characters')
logger.setLevel(logging.NOTSET)
logger.addHandler(ch)


def solve(k8Ptm, RQst):
    BwfNp1pPD_ = collections.deque()
    jsD = collections.deque()

    for w in sorted(enumerate(k8Ptm), key=lambda x: x[1]):
        BwfNp1pPD_.append([w[0] + 1, w[1]])
    
    OleNxsaIy = [-1] * len(RQst)

    yafc5R5 = []
    for pid, p in enumerate(RQst):
        logger.debug('pid: %s', pid)
        if p == '0':
            mtqpizGzJx = BwfNp1pPD_.popleft(), 
            jsD.appendleft(mtqpizGzJx)
            # yafc5R5.append(pid, taken[0])
        else:
            logger.debug('used %s', jsD)
            mtqpizGzJx = jsD.popleft()
        #yafc5R5.append([pid, taken[0]])
        OleNxsaIy[pid] = mtqpizGzJx[0]

    return [x for x, y in OleNxsaIy]



def main():
    wcA = int(input().strip())
    k8Ptm = [int(x) for x in input().strip().split()]
    RQst = input().strip()

    PfZLw2qSoz = solve(k8Ptm, RQst)
    print(' '.join(map(str, PfZLw2qSoz)))


def __starting_point():
    main()

__starting_point()
```
</ans>",0,{}
403," <ans>
```python
#!/usr/bin/env python3
from sys import stdin
from bisect import bisect_left, bisect_right

kOhr = int(1e9)

def find(par, a):
    if par[a] == a:
        return a
    par[a] = find(par, par[a])
    return par[a]

def union(par, rnk, a, b):
    a = find(par,a)
    b = find(par,b)
    if a==b:
        return
    
    if rnk[a]<rnk[b]:
        par[a] = b
    else:
        par[b] = a
        if rnk[a]==rnk[b]:
            rnk[a] += 1
    
def solve():
    n, m, k = map(int, stdin.readline().split())
    NNSt = list(map(int, stdin.readline().split()))
    for i in range(1,k):
        NNSt[i] += NNSt[i-1]
    
    group = list(range(n))
    rnk = [0 for i in range(n)]
    p10546xq = [[kOhr for j in range(k)] for i in range(k)]
    for i in range(m):
        u, v, x = map(int, stdin.readline().split())
        if x==0:
            union(group, rnk, u-1, v-1)
        oCZ = bisect_left(NNSt, u)
        wHy4Bi7 = bisect_left(NNSt, v)
        p10546xq[oCZ][wHy4Bi7] = min(p10546xq[oCZ][wHy4Bi7], x)
        p10546xq[wHy4Bi7][oCZ] = min(p10546xq[wHy4Bi7][oCZ], x)
    
    N0v_JsYID = 0
    for i in range(k):
        cur = group[N0v_JsYID]
        while N0v_JsYID<NNSt[i]:
            if group[N0v_JsYID]!=cur:
                print(""No"")
                return
            N0v_JsYID += 1
    print(""Yes"")
    
    for p in range(k):
        for i in range(k):
            for j in range(k):
                p10546xq[i][j] = min(p10546xq[i][j], p10546xq[i][p]+p10546xq[p][j])
    
    for i in range(k):
        p10546xq[i][i] = 0
        for j in range(k):
            if p10546xq[i][j] == kOhr:
                p10546xq[i][j] = -1
    
    for i in range(k):
        print(' '.join(map(lambda x: str(x), p10546xq[i])))
    
    
solve()
```
</ans>",0,{}
404," <ans>
from sys import stdin, stdout

st=lambda:list(stdin.readline().strip())
Qixs=lambda:list(map(int,stdin.readline().split()))
wuPs\_F=lambda:list(map(int,stdin.readline().split()))
PoZdOi=lambda:int(stdin.readline())
BeaeILKz1j=lambda n: stdout.write(str(n)+""\n"")

def valid(x,y,n,m,RDVUSnp,Fref):
if x>=n or y>=m or x<0 or y<0:
return False
if RDVUSnp[x][y] or Fref[x][y]=='*':
return False
return True

OnjSJ=[-1,1,0,0]
eeyzKzy8D=[0,0,1,-1]

def DFS(i,j,val,n,m,RDVUSnp,Fref,Qixs):
ans=1
ZCVrUWr9w=[(i,j)]
RKkX\_N9xXL=[(i,j)]
Fref[i][j]=True
while RKkX\_N9xXL:
a,b=RKkX\_N9xXL.pop()
for x in range(4):
newX,newY=a+OnjSJ[x], b+eeyzKzy8D[x]
if valid(newX,newY,n,m,RDVUSnp,Fref):
RKkX\_N9xXL.append((newX,newY))
Fref[newX][newY]=True
ZCVrUWr9w.append((newX,newY))
ans= (ans%10 + 1%10) % 10

for i in ZCVrUWr9w:
a,b=i
RDVUSnp[a][b]=(ans,val)

n,m=wuPs\_F()
RDVUSnp=[st() for i in range(n)]
val=0
fref=[[False for i in range(m)] for j in range(n)]
for i in range(n):
for j in range(m):
if RDVUSnp[i][j]=='.' and not fref[i][j]:
DFS(i,j,val,n,m,RDVUSnp,fref,Qixs)
val+=1

for i in range(n):
for j in range(m):
if RDVUSnp[i][j]=='*':
Qixs[i][j]=1
jkthhZNB=set()
for x in range(4):
newX,newY= i+OnjSJ[x], j+eeyzKzy8D[x]
if newX>=0 and newY>=0 and newX<n and newY<m:
if type(RDVUSnp[newX][newY])==tuple:
A,B=RDVUSnp[newX][newY]
if B not in jkthhZNB:
Qixs[i][j]+=A
Qixs[i][j]%=10
jkthhZNB.add(B)

BeaeILKz1j('\n'.join([''.join([str(i) for i in j]) for j in Qixs]))
</ans>",0,{}
405," <ans>
from bisect import bisect\_left as bl
from bisect import bisect\_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp\_to\_key
import sys
pxHLIhfuF = sys.stdin.readline

zuskkpX9gn = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv\_mod(n):return pow(n, zuskkpX9gn - 2, zuskkpX9gn)

def li():return [int(i) for i in pxHLIhfuF().rstrip('\\n').split()]
def st():return pxHLIhfuF().rstrip('\\n')
def val():return int(pxHLIhfuF().rstrip('\\n'))
def li2():return [i for i in pxHLIhfuF().rstrip('\\n')]
def li3():return [int(i) for i in pxHLIhfuF().rstrip('\\n')]

for _ in range(val()):
n,l,r = li()
orig = r
l -= 1
r -= l

a14 = 0
curs = n - 1
while curs and a14 + 2*curs <= l:
a14 += 2*curs
curs -= 1

start = n - curs
ans = []
bYzQ = start
LNniPCZP2l = bYzQ + 1
half = 0
while l:
half = 1
start = LNniPCZP2l
LNniPCZP2l += 1
l -= 1
if not l:break
half = 0
start = bYzQ
l -= 1

if half:
ans.append(start)
if LNniPCZP2l == n + 1:
bYzQ += 1
LNniPCZP2l = bYzQ + 1
start = bYzQ
r -= 1

while r:
ans.append(start)
r -= 1
if not r:break
start = LNniPCZP2l
ans.append(start)
LNniPCZP2l += 1
if LNniPCZP2l == n + 1:
bYzQ += 1
LNniPCZP2l = bYzQ + 1
start = bYzQ
r -= 1
start = bYzQ

if orig == n*(n-1) + 1:
ans[-1] = 1

print(*ans)
</ans>",0,{}
406," <ans>
m3\_V7PD3K=input("""").split(' ')
kwf4=0
LyBNp=list()
for t in range (0,int(m3\_V7PD3K[0])):
bwr=input("""")
LyBNp.append(bwr)
if (int(m3\_V7PD3K[1])==0):
for b in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[b]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==1):
for c in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[c] and '1' in LyBNp[c]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==2):
for d in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[d] and '1' in LyBNp[d] and '2' in LyBNp[d]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==3):
for e in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[e] and '1' in LyBNp[e] and '2' in LyBNp[e] and '3' in LyBNp[e]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==4):
for f in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[f] and '1' in LyBNp[f] and '2' in LyBNp[f] and '3' in LyBNp[f] and '4' in LyBNp[f]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==5):
for g in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[g] and '1' in LyBNp[g] and '2' in LyBNp[g] and '3' in LyBNp[g] and '4' in LyBNp[g] and '5' in LyBNp[g]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==6):
for h in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[h] and '1' in LyBNp[h] and '2' in LyBNp[h] and '3' in LyBNp[h] and '4' in LyBNp[h] and '5' in LyBNp[h] and '6' in LyBNp[h]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==7):
for i in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[i] and '1' in LyBNp[i] and '2' in LyBNp[i] and '3' in LyBNp[i] and '4' in LyBNp[i] and '5' in LyBNp[i] and '6' in LyBNp[i] and '7' in LyBNp[i]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==8):
for j in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[j] and '1' in LyBNp[j] and '2' in LyBNp[j] and '3' in LyBNp[j] and '4' in LyBNp[j] and '5' in LyBNp[j] and '6' in LyBNp[j] and '7' in LyBNp[j] and '8' in LyBNp[j]:
kwf4=kwf4+1
print(kwf4)
if (int(m3\_V7PD3K[1])==9):
for k in range (0,int(m3\_V7PD3K[0])):
if '0' in LyBNp[k] and '1' in LyBNp[k] and '2' in LyBNp[k] and '3' in LyBNp[k] and '4' in LyBNp[k] and '5' in LyBNp[k] and '6' in LyBNp[k] and '7' in LyBNp[k] and '8' in LyBNp[k] and '9' in LyBNp[k]:
kwf4=kwf4+1
print(kwf4)
</ans>",0,{}
407," <ans>
import sys
import random
from math import *

def input():
return sys.stdin.readline().strip()

def iinput():
return int(input())

def finput():
return float(input())

def tinput():
return input().split()

def linput():
return list(input())

def rinput():
return map(int, tinput())

def fiinput():
return map(float, tinput())

def rlinput():
return list(map(int, input().split()))
def trinput():
return tuple(rinput())

def srlinput():
return sorted(list(map(int, input().split())))

def NOYES(fl):
if fl:
print(""NO"")
else:
print(""YES"")
def YESNO(fl):
if fl:
print(""YES"")
else:
print(""NO"")

def main():
#n = iinput()
#k = iinput()
#m = iinput()
#n = int(sys.stdin.readline().strip())
#n, k = rinput()
#n, m = rinput()
#m, k = rinput()
#n, k, m = rinput()
#n, m, k = rinput()
#k, n, m = rinput()
#k, m, n = rinput()
#m, k, n = rinput()
#m, n, k = rinput()
#q = srlinput()
#q = linput()
x, y, n = rinput()
pmIGblj5 = n - y
print(x * (pmIGblj5 // x) + y)

for inytd in range(iinput()):
main()
</ans>",True,{}
408," <ans>
def L6pcXER(digit):#bit文字列生成（取り扱い注意）
L6pcXER =list()

for i in range(2 ** digit):
L6pcXER = []
for j in range(digit): # このループが一番のポイント
if ((i >> j) & 1): # 順に右にシフトさせ最下位bitのチェックを行う
L6pcXER.append(j)
L6pcXER.append(bit)
h,w,k = list(map(int,input().split()))
gGu3Ag = [""""]*h
for i in range(h):
gGu3Ag[i] = list(map(str,input()))
# print(gGu3Ag)

mAcngh73nK = L6pcXER(h+w)
# print(mAcngh73nK)
GfA2h = [0]*h#横
dsy9ca = [0]*w#縦
H3OdKlWD = 0
for i in range(h):
for j in range(w):
if(gGu3Ag[i][j] == ""#""):
GfA2h[i]+=1
dsy9ca[j]+=1
gGu3Ag[i][j] = 1
H3OdKlWD += 1
else:
gGu3Ag[i][j] = 0
# print(GfA2h,dsy9ca)
AWQ = 0
for i in range(2**(h+w)):
L6pcXER = mAcngh73nK[i]#h:0~(h-1),w:h~(h+w)-1
Z8jrDiE = 0
HrEH6 = []
WHMbgj = []
for j in range(len(L6pcXER)):
l = L6pcXER[j]
if(l <= h-1):
Z8jrDiE += GfA2h[l]
HrEH6.append(l)
else:
ind = l - h
Z8jrDiE += dsy9ca[ind]
WHMbgj.append(ind)
# print(HrEH6,WHMbgj)
lNcZxn = 0
for j in range(len(HrEH6)):
for l in range(len(WHMbgj)):
if(gGu3Ag[HrEH6[j]][WHMbgj[l]] == 1):
lNcZxn += 1

if((H3OdKlWD - Z8jrDiE) + lNcZxn == k):
# print(H3OdKlWD,Z8jrDiE,lNcZxn,""___"",H3OdKlWD-Z8jrDiE+lNcZxn) # 
AWQ += 1
print(AWQ)

# 2 3 2
# ..#
# ###

</ans>",0,{}
409," <ans>
N78Q4hUTB=int(input())
if (N78Q4hUTB == 1) :
 print (""Washington"")
elif (N78Q4hUTB == 2):
 print (""Adams"")
elif (N78Q4hUTB == 3):
 print (""Jefferson"")
elif (N78Q4hUTB == 4):
 print (""Madison"")
elif (N78Q4hUTB == 5):
 print (""Monroe"")
elif (N78Q4hUTB == 6):
 print (""Adams"")
elif (N78Q4hUTB == 7):
 print (""Jackson"")
elif (N78Q4hUTB == 8):
 print (""Van Buren"")
elif (N78Q4hUTB == 9):
 print(""Harrison"")
elif (N78Q4hUTB == 10):
 print(""Tyler"")
elif (N78Q4hUTB == 11):
 print(""Polk"")
elif (N78Q4hUTB == 12):
 print(""Taylor"")
elif (N78Q4hUTB == 13):
 print(""Fillmore"")
elif (N78Q4hUTB == 14):
 print(""Pierce"")
elif (N78Q4hUTB == 15):
 print(""Buchanan"")
elif (N78Q4hUTB == 16):
 print (""Lincoln"")
elif (N78Q4hUTB == 17):
 print (""Johnson"")
elif (N78Q4hUTB == 18):
 print (""Grant"")
elif (N78Q4hUTB == 19):
 print (""Hayes"")
elif (N78Q4hUTB == 20):
 print (""Garfield"")
elif (N78Q4hUTB == 21):
 print (""Arthur"")
elif (N78Q4hUTB == 22):
 print (""Cleveland"")
elif (N78Q4hUTB == 23):
 print (""Harrison"")
elif (N78Q4hUTB == 24):
 print (""Cleveland"")
elif (N78Q4hUTB == 25):
 print (""McKinley"")
elif (N78Q4hUTB == 26):
 print (""Roosevelt"")
elif (N78Q4hUTB == 27):
 print (""Taft"")
elif (N78Q4hUTB == 28):
 print (""Wilson"")
elif (N78Q4hUTB == 29):
 print ('Harding')
elif (N78Q4hUTB == 30):
 print (""Coolidge"")
elif (N78Q4hUTB == 31):
 print (""Hoover"")
elif (N78Q4hUTB == 32):
 print (""Roosevelt"")
elif (N78Q4hUTB == 33):
 print (""Truman"")
elif (N78Q4hUTB == 34):
 print (""Eisenhower"")
elif (N78Q4hUTB == 35):
 print (""Kennedy"")
elif (N78Q4hUTB == 36):
 print (""Johnson"")
elif (N78Q4hUTB == 37):
 print (""Nixon"")
elif N78Q4hUTB == 38:
 print (""Ford"")
elif N78Q4hUTB == 39:
 print (""Carter"")
elif N78Q4hUTB == 40:
 print (""Reagan"")
</ans>",True,{}
410," <ans>
```python
import math
from decimal import Decimal
import heapq

def na():
	MFsrGZUJqY = int(input())
	dNDK = [int(x) for x in input().split()]
	return MFsrGZUJqY,dNDK
  
  
def nab():
	MFsrGZUJqY = int(input())
	rADjK73XEH = [int(x) for x in input().split()]
	CSQg = [int(x) for x in input().split()]
	return MFsrGZUJqY,rADjK7",0,{}
411," <ans>
t,sx,sy,ex,ey=map(int,input().split())
Wg7Skx4xd=input()
n=len(Wg7Skx4xd)
Wg7Skx4xd+="" ""
oGCrZf_F=-1
RmFMl6BD0=0
PrAz=ex-sx
A1SApIAnj5=ey-sy
if abs(PrAz)+abs(A1SApIAnj5)>t:
pass
else:
while RmFMl6BD0<=t and RmFMl6BD0<n:
if PrAz==0 and A1SApIAnj5==0:
oGCrZf_F=RmFMl6BD0
break
if PrAz>=0 and A1SApIAnj5>=0:
if ((Wg7Skx4xd[RmFMl6BD0]!=""E"" and Wg7Skx4xd[RmFMl6BD0]!=""N"") or (PrAz==0 and Wg7Skx4xd[RmFMl6BD0]==""E"") or (A1SApIAnj5==0 and Wg7Skx4xd[RmFMl6BD0]==""N"")) and RmFMl6BD0<n:
RmFMl6BD0+=1
if PrAz>0 and Wg7Skx4xd[RmFMl6BD0]==""E"" and RmFMl6BD0<n:
RmFMl6BD0+=1
PrAz-=1
if A1SApIAnj5>0 and Wg7Skx4xd[RmFMl6BD0]==""N""and RmFMl6BD0<n:
RmFMl6BD0+=1
A1SApIAnj5-=1
elif PrAz>=0 and A1SApIAnj5<=0:
if ((Wg7Skx4xd[RmFMl6BD0]!=""E"" and Wg7Skx4xd[RmFMl6BD0]!=""S"") or (PrAz==0 and Wg7Skx4xd[RmFMl6BD0]==""E"") or (A1SApIAnj5==0 and Wg7Skx4xd[RmFMl6BD0]==""S"")) and RmFMl6BD0<n:
RmFMl6BD0+=1
if PrAz>0 and Wg7Skx4xd[RmFMl6BD0]==""E"" and RmFMl6BD0<n:
RmFMl6BD0+=1
PrAz-=1
if A1SApIAnj5<0 and Wg7Skx4xd[RmFMl6BD0]==""S"" and RmFMl6BD0<n:
RmFMl6BD0+=1
A1SApIAnj5+=1
elif PrAz<=0 and A1SApIAnj5>=0:
if ((Wg7Skx4xd[RmFMl6BD0]!=""W"" and Wg7Skx4xd[RmFMl6BD0]!=""N"") or (PrAz==0 and Wg7Skx4xd[RmFMl6BD0]==""W"") or (A1SApIAnj5==0 and Wg7Skx4xd[RmFMl6BD0]==""N"")) and RmFMl6BD0<n:
RmFMl6BD0+=1
if PrAz<0 and Wg7Skx4xd[RmFMl6BD0]==""W"" and RmFMl6BD0<n:
RmFMl6BD0+=1
PrAz+=1
if A1SApIAnj5>0 and Wg7Skx4xd[RmFMl6BD0]==""N"" and RmFMl6BD0<n:
RmFMl6BD0+=1
A1SApIAnj5-=1
elif PrAz<=0 and A1SApIAnj5<=0:
if ((Wg7Skx4xd[RmFMl6BD0]!=""W"" and Wg7Skx4xd[RmFMl6BD0]!=""S"") or (PrAz==0 and Wg7Skx4xd[RmFMl6BD0]==""W"") or (A1SApIAnj5==0 and Wg7Skx4xd[RmFMl6BD0]==""S"")) and RmFMl6BD0<n:
RmFMl6BD0+=1
if PrAz<0 and Wg7Skx4xd[RmFMl6BD0]==""W"" and RmFMl6BD0<n:
RmFMl6BD0+=1
PrAz+=1
if A1SApIAnj5<0 and Wg7Skx4xd[RmFMl6BD0]==""S"" and RmFMl6BD0<n:
RmFMl6BD0+=1
A1SApIAnj5+=1
if PrAz==0 and A1SApIAnj5==0:
oGCrZf_F=RmFMl6BD0
print(oGCrZf_F)
</ans>",0,{}
412," <ans>
def __starting\_point():
herm2z0E4 = input()
sEBv = herm2z0E4.split(' ')
qFg = [0,0,0]
gdwV = 0
for sEBv\_val in sEBv:
gdwV+=int(sEBv\_val)
MEbg3n = False
for sEBv\_val in sEBv:
if int(sEBv\_val)>gdwV/2:
MEbg3n = True
if MEbg3n:
print('Impossible')
else:
MEbg3n = False
if sEBv[0]==min(sEBv):
if int(sEBv[1])>int(sEBv[2]):
BOC8QCBy = int(sEBv[1])-int(sEBv[2])
qFg[0] += BOC8QCBy
sEBv[0]-= BOC8QCBy\*2
sEBv[1] -=BOC8QCBy
else:
BOC8QCBy = int(sEBv[2])-int(sEBv[1])
qFg[2] += BOC8QCBy
sEBv[0] -= BOC8QCBy
sEBv[2] -= BOC8QCBy
if int(sEBv[0])%2==1:
MEbg3n = True
else:
BOC8QCBy = int(sEBv[0])//2
qFg[0] += BOC8QCBy
qFg[2] += BOC8QCBy
qFg[1] += (int(sEBv[1])+int(sEBv[2]))//2 - BOC8QCBy
elif sEBv[1]==min(sEBv):
if int(sEBv[0])>int(sEBv[2]):
BOC8QCBy = int(sEBv[0])-int(sEBv[2])
qFg[0] += BOC8QCBy
sEBv[1]-= BOC8QCBy
sEBv[0] -= BOC8QCBy
else:
BOC8QCBy = int(sEBv[2])-int(sEBv[0])
qFg[1] += BOC8QCBy
sEBv[1] -= BOC8QCBy
sEBv[2] -= BOC8QCBy
if int(sEBv[1])%2==1:
MEbg3n = True
else:
BOC8QCBy = int(sEBv[1])//2
qFg[0] += BOC8QCBy
qFg[1] += BOC8QCBy
qFg[2] += (int(sEBv[0])+int(sEBv[2]))//2 - BOC8QCBy
else:
if int(sEBv[0])>int(sEBv[1]):
BOC8QCBy = int(sEBv[0])-int(sEBv[1])
qFg[2] += BOC8QCBy
sEBv[2]-= BOC8QCBy
sEBv[0]-=BOC8QCBy
else:
BOC8QCBy = int(sEBv[1])-int(sEBv[0])
qFg[1] += BOC8QCBy
sEBv[2] -= BOC8QCBy
sEBv[1] -= BOC8QCBy
if int(sEBv[2])%2==1:
MEbg3n = True
else:
BOC8QCBy = int(sEBv[2])//2
qFg[2] += BOC8QCBy
qFg[1] += BOC8QCBy
qFg[0] += (int(sEBv[0])+int(sEBv[1]))//2 - BOC8QCBy
for qFg\_val in qFg:
if qFg\_val<0:
MEbg3n = True
if MEbg3n:
print('Impossible')
else:
for qFg\_val in qFg:
print(qFg\_val,end=' ')
print()

\_\_starting\_point()
</ans>",0,{}
413," <ans>
import math as D0uxsx
import sys
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))


# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/
def modInverse(a , m):
	D0uxsxm0 = m
	Iyj3fJ = 0
	YnrMd5NWa = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		P4MrapiGZ5 = m
		m = a % m
		a = P4MrapiGZ5
		P4MrapiGZ5 = Iyj3fJ
		Iyj3fJ = YnrMd5NWa - q * Iyj3fJ
		YnrMd5NWa = P4MrapiGZ5
	if (YnrMd5NWa < 0):
		YnrMd5NWa = YnrMd5NWa + D0uxsxm0
	return YnrMd5NWa


def num():
	return map(int , input().split())


def nu():
	return int(input())


def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x


n,k=num()
TMAZK\_S=li()
eVmXUrdi=[0]*(max(TMAZK\_S)+5)
Q94=max(TMAZK\_S)
nNBxyXtA=min(TMAZK\_S)
riSYbKJd=True
for i in range(1,n):
	if(TMAZK\_S[i]!=TMAZK\_S[i-1]):
		riSYbKJd=False
		break
for i in range(n):
	eVmXUrdi[0]+=1
	eVmXUrdi[TMAZK\_S[i]+1]-=1
for i in range(1,len(eVmXUrdi)):
	eVmXUrdi[i]=eVmXUrdi[i]+eVmXUrdi[i-1]
d8vlXF078=eVmXUrdi[Q94]
egSUPFUj=0
Klu5MY8X=False
for i in range(Q94-1,nNBxyXtA,-1):
	if(d8vlXF078+eVmXUrdi[i]>k):
		Klu5MY8X=True
		d8vlXF078=eVmXUrdi[i]
		egSUPFUj+=1
	else:
		Klu5MY8X=False
		d8vlXF078+=eVmXUrdi[i]
if(d8vlXF078<=k and riSYbKJd==False):
	egSUPFUj+=1
print(egSUPFUj)
</ans>",0,{}
414," <ans>
MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]
def check(a):
return 0<=a<8
Zi\_P1 = set()
Zi\_P2 = set()
zyQI8fOI1 = dict()
zyQI8fOI2 = dict()
def cango1(gqw1,pos,lap):
for dx,dy in MOVS:
nx,ny = dx+pos[0],dy+pos[1]
if not check (nx) or not check(ny):
continue
if (nx,ny) in Zi\_P1:
continue
zyQI8fOI1[(nx,ny)]=lap%2
Zi\_P1.add((nx,ny))
cango1(gqw1,(nx,ny),lap+1)
def cango2(gqw1,pos,lap):
for dx,dy in MOVS:
nx,ny = dx+pos[0],dy+pos[1]
if not check(nx) or not check(ny):
continue
if (nx,ny) in Zi\_P2:
continue
zyQI8fOI2[(nx,ny)]=lap%2
Zi\_P2.add((nx,ny))
cango2(gqw1,(nx,ny),lap+1)
QmW = int(input())
for ww in range(QmW):
gqw1 = [input().strip() for i in range(8)]
Zi\_P = []
KZZZSs = set()
for i in range(8):
for j in range(8):
if gqw1[i][j] == 'K':
Zi\_P.append((i,j))
if gqw1[i][j]=='#':
KZZZSs.add((i,j))
Zi\_P1,Zi\_P2,zyQI8fOI1,zyQI8fOI2=set(),set(),dict(),dict()
cango1(gqw1, Zi\_P[0],0)
cango2(gqw1,Zi\_P[1],0)
if ww!=QmW-1:
input()
whtABBUQ = (Zi\_P1&Zi\_P2) - KZZZSs
for x,y in whtABBUQ:
if zyQI8fOI1[(x,y)]==zyQI8fOI2[(x,y)]:
print(""YES"")
break
else:
print(""NO"")
</ans>",0,{}
415," <ans>
'''input
3
0 2 0
1 0 3
'''
from sys import stdin
from copy import deepcopy
from collections import deque

def find\_start(zsS):
start = 1
index = -1

for i in range(len(zsS)):
if zsS[i] == start:
index = i
break
latest = start
if index != -1:
flag = True
for i in range(index, len(zsS)):
if zsS[i] == latest:
latest += 1
else:
flag = False
break

if flag:
start = latest
return start
def check\_start(num, \_zo):
\_zo[0] = 0
nonlocal arr
nonlocal barr

mydict = [0] \* (gLEuJGZp49 + 1)
for i in range(len(arr)):
mydict[arr[i]] += 1

zeroes = mydict[0]

pile = deque(barr[:])

for i in range(num):
if zeroes > 0:
\_zo[0] += 1
pile.append(0)
zeroes -= 1
mydict[0] -= 1
else:
return False

element = pile.popleft()

mydict[element] += 1

if element == 0:
zeroes += 1
mydict[0] += 1

start = find\_start(barr)
for i in range(start, gLEuJGZp49 + 1):
if mydict[i] > 0:
\_zo[0] += 1
pile.append(i)
mydict[i] -= 1
element = pile.popleft()
mydict[element] += 1
else:
return False
return True

gLEuJGZp49 = int(stdin.readline().strip())
arr = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
start = 0
yNlzDfik = 2 \* gLEuJGZp49
\_zo = [0]

if check\_start(0, \_zo):
print(\_zo[0])
return

pos = [0] \* (gLEuJGZp49 + 1)
for i in range(gLEuJGZp49):
pos[barr[i]] = i + 1

ans = -float('inf')
for i in range(1, gLEuJGZp49 + 1):	
ans = max(pos[i] - i + 1 + gLEuJGZp49, ans)
print(ans)
</ans>",0,{}
416," <ans>
def xmax(x, y):
if x[1] > y[1]:
return x
return y

class SegTree:
def **init**(self, init\_val, n, ide\_ele, seg\_func):
self.segfunc = seg\_func
self.num = 2\*\*(n-1).bit\_length()
self.ide\_ele = ide\_ele
self.seg=[self.ide\_ele]\*2\*self.num
for i in range(n):
self.seg[i+self.num-1]=init\_val[i]
for i in range(self.num-2,-1,-1) :
self.seg[i]=self.segfunc(self.seg[2\*i+1],self.seg[2\*i+2])

def update(self, k, x):
ll = k
k += self.num-1
self.seg[k] = (ll, self.seg[k][1] + x)
while k+1:
k = (k-1)//2
self.seg[k] = self.segfunc(self.seg[2\*k+1],self.seg[2\*k+2])

def update2(self, k, x):
k += self.num-1
self.seg[k] = x
while k+1:
k = (k-1)//2
self.seg[k] = self.segfunc(self.seg[2\*k+1],self.seg[2\*k+2])

def query(self, p, q):
if q<=p:
return self.ide\_ele
p += self.num-1
q += self.num-2
res=self.ide\_ele
while q-p>1:
if p&1 == 0:
res = self.segfunc(res,self.seg[p])
if q&1 == 1:
res = self.segfunc(res,self.seg[q])
q -= 1
p = p//2
q = (q-1)//2
if p == q:
res = self.segfunc(res,self.seg[p])
else:
res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])
return res

import sys;input=sys.stdin.readline
N, M = map(int, q1GR1().split())
X = list(map(int, Vd1Q().split()))
oxv = [[] for \_ in range(N)]
for i in range(1, M+1):
a, b = map(int, q1GR1().split())
oxv[a-1].append((i, b-1))
oxv[b-1].append((i, a-1))
X[a-1] -= 1
X[b-1] -= 1
minf = -(10 ** 18)-1
Zlg = SegTree([(i, x) for i, x in enumerate(X)], N, (-1, minf), xmax)
iSs = False
rmjOx = []
vs = set()
while True:
j, mx = Zlg.query(0, N)
if mx<0:
iSs=True
break
while oxv[j]:
i, co = oxv[j].pop()
if i in vs:
continue
vs.add(i)
Zlg.update(co, 1)
rmjOx.append(i)
if len(rmjOx) == M:break
Zlg.update2(j, (j, minf))

if iSs or len(rmjOx) != M:print(""DEAD"")
else:print(""ALIVE"");print(\*rmjOx[::-1])
</ans>",0,{}
417," <ans>
import sys
import math

def M5S87rMF():
return sys.stdin.readline().strip()

def idata():
return [int(x) for x in M5S87rMF().split()]

def bfs(graph1, root1):
visited1 = set()
queue1 = [[root1, 0]]
visited1.add(root1)
qw, ver = 0, 1
while queue1:
vertex1 = queue1[0]
queue1 = queue1[1:]
for neig1 in graph1[vertex1[0]]:
if neig1 not in visited1:
visited1.add(neig1)
queue1 += [[neig1, vertex1[1] + 1]]
if qw < vertex1[1] + 1:
ver, qw = neig1, vertex1[1] + 1
return ver, qw

def dfs(graph, ver):
used\_v = set()
depth = [0] \* (len(graph) + 1)
level = [ver]
num\_of\_level = 0
while level:
new\_level = []
for v in level:
depth[v] = num\_of\_level
used\_v.add(v)
for v1 in graph[v]:
if v1 not in used\_v:
new\_level += [v1]
level = new\_level
num\_of\_level += 1
return depth

def binary\_search(array, x):
left, right = -1, len(array)
while left + 1 != right:
middle = (left + right) // 2
if array[middle] >= x:
right = middle
elif array[middle] < x:
left = middle
return right

def c\_mod(n1, k1, mod1):
num = den = 1
for i in range(n1 - k1):
num = (num \* (n1 - i)) % mod1
den = (den \* (i + 1)) % mod1
return (num \* pow(den, mod1 - 2, mod1)) % mod1

def c(n1, k1):
num = den = 1
for i in range(n1 - k1):
num = num \* (n1 - i)
den = den \* (i + 1)
return num // den

def v\_sistemu(x, k):
x = int(x)
z = ''
while x:
z += str(x % k)
x //= k
return z[::-1]

def iz\_sistemi(x, k):
x = str(x)[::-1]
ans = 0
for i in range(len(x)):
ans += int(x[i]) \* pow(k, i)
return ans

def solve\_of\_problem():
n = int(M5S87rMF())
ans = 2
for i in range(n):
ans \*= 2
if n % (ans - 1) == 0:
print(n // (ans - 1))
return
return

for _ in range(int(M5S87rMF())):
solve\_of\_problem()
</ans>",0,{}
418," <ans>
import sys

def Min(x, y):
if x > y:
return y
else:
return x

def Gcd(x, y):
if x == 0:
return y
else:
return Gcd(y % x, x)

def Lcm(x, y):
return x * y // Gcd(x, y)

yAW = int(input())
yn4xdeLSP = [int(i) for i in input().split()]
oYfQWPta = [int(0) for i in range(0, yAW)]

qHKTwnX = 0

cur = 0

BtrUw7St7z = Lcm(7, yAW)

for i in range(0, 7 * yAW):
if yn4xdeLSP[i % yAW] == 0 :
print(i % yAW + 1)
qHKTwnX = 1
break
if cur != 6:
yn4xdeLSP[i % yAW] -= 1
oYfQWPta[i % yAW] += 1
cur = (cur + 1) % 7

if qHKTwnX == 0:
h2dlJxw = 10**20

for i in range(0, yAW):
yn4xdeLSP[i] += oYfQWPta[i]
if oYfQWPta[i] == 0: continue
if yn4xdeLSP[i] % oYfQWPta[i] > 0:
h2dlJxw = Min(h2dlJxw, yn4xdeLSP[i] // oYfQWPta[i])
else:
h2dlJxw = Min(h2dlJxw, yn4xdeLSP[i] // oYfQWPta[i] - 1)

if h2dlJxw == 10**20:
h2dlJxw = 0

for i in range(0, yAW):
yn4xdeLSP[i] -= h2dlJxw * oYfQWPta[i]

iter = 0
cur = 0

while True:
if yn4xdeLSP[iter] == 0:
print(iter % yAW + 1)
break
else:
if cur != 6:
yn4xdeLSP[iter] -= 1
cur = (cur + 1) % 7
iter = (iter + 1) % yAW
</ans>",0,{}
419," <ans>
# import itertools
# import math
# from functools import reduce
# import sys
# sys.setrecursionlimit(500*500)
# import numpy as np
# import heapq
# from collections import deque

# N = int(input())
# T = input()
# n, *a = map(int, open(0))
A_, B_, C_, X_, Y_ = map(int, input().split())
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# tree = [[] for _ in range(N + 1)]
# B_C = [list(map(int,input().split())) for _ in range(M)]
# S = input()

# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])
# all_cases = list(itertools.permutations(P))
# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))
# itertools.product((0,1), repeat=n)

# A_ = np.array(A_)
# cum_A_ = np.cumsum(A_)
# cum_A_ = np.insert(cum_A_, 0, 0)

# def dfs(tree, s):
#     for l in tree[s]:
#         if depth[l[0]] == -1:
#             depth[l[0]] = depth[s] + l[1]
#             dfs(tree, l[0])
# dfs(tree, 1)

# def factorization(n):
#     arr = []
#     temp = n
#     for i in range(2, int(-(-n**0.5//1))+1):
#         if temp%i==0:
#             cnt=0
#             while temp%i==0:
#                 cnt+=1
#                 temp //= i
#             arr.append([i, cnt])
#     if temp!=1:
#         arr.append([temp, 1])
#     if arr==[]:
#         arr.append([n, 1])
#     return arr

# def gcd_list(numbers):
#     return reduce(math.gcd, numbers)

# if gcd_list(A_) > 1:
#     print(""not coprime"")
#     return

# 高速素因数分解準備
#MAXN = 10**6+10
#sieve = [i for i in range(MAXN+1)]
#p = 2
#while p*p <= MAXN:
#    if sieve[p] == p:
#        for q in range(2*p, MAXN+1, p):
#            if sieve[q] == q:
#                sieve[q] = p
#    p += 1

if 2 * C_ > A_ + B_:
    print(A_ * X_ + B_ * Y_)
else:
    if X_ > Y_:
        print(min(2 * C_ * X_, 2 * C_ * Y_ + A_ * (X_ - Y_)))
    else:
        print(min(2 * C_ * Y_, 2 * C_ * X_ + B_ * (Y_ - X_)))
</ans>",0,{}
420," <ans>
import sys
sys.setrecursionlimit(10**9)
N,M=map(int,input().split())

def find\_negative\_loop(n,w,FUpcCog):
dist=[float(""inf"")]\*n
dist[1]=0

for i in range(n):
for j in range(w):
e=FUpcCog[j]
if dist[e[1]]>dist[e[0]]+e[2]:
dist[e[1]]=dist[e[0]]+e[2]
if i==n-1:
return True
return False

def shortest\_path(s,n,w,FUpcCog):
dist=[float(""inf"")]\*n
dist[s]=0

while True:
update=False
for p,q,r in FUpcCog:
if dist[p]!=float(""inf"") and dist[q]>dist[p]+r:
dist[q]=dist[p]+r
update=True
if not update:
break

return dist

Q4cxUT=[[] for \_ in range(N+1)]
ece0=[]
for \_ in range(M):
a,b,c=map(int,input().split())
Q4cxUT[a].append(b)
ece0.append((a,b,-c))

visited=[False]\*(N+1)
def check\_reachable(u):
visited[u]=True
if u==N:
CfKg8zTOr[u]=True
return True
elif CfKg8zTOr[u]!=None:
return CfKg8zTOr[u]

cnt=0
for v in Q4cxUT[u]:
if not visited[v]:
ret=check\_reachable(v)
if ret:
cnt+=1

if cnt>0:
CfKg8zTOr[u]=True
return True
else:
CfKg8zTOr[u]=False
return False

CfKg8zTOr=[None]*(N+1)
for i in range(1,N+1):
if CfKg8zTOr[i]==None:
visited=[False]*(N+1)
check\_reachable(i)

FUpcCog=[]
for a,b,nc in ece0:
if CfKg8zTOr[b]:
FUpcCog.append((a,b,nc))

M2=len(FUpcCog)
OA3=find\_negative\_loop(N+1,M2,FUpcCog)

if OA3:
print(""inf"")
else:
HVk1R=shortest\_path(1,N+1,M2,FUpcCog)
print(-HVk1R[N])
</ans>",0,{}
421," <ans>
```python
import sys
import os
import time
import collections
from collections import Counter, deque
import itertools
import math
import timeit
import random
import string

#########################
# imgur.com/Pkt7iIf.png #
#########################

def sieve(n):
    if n < 2: return list()
    _p4Kz0 = [True for _ in range(n + 1)]
    phCPK3ax = 3
    while phCPK3ax * phCPK3ax <= n:
        if _p4Kz0[phCPK3ax]:
            for i in range(phCPK3ax * 2, n + 1, phCPK3ax):
                _p4Kz0[i] = False
        phCPK3ax += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if _p4Kz0[p]:
            r.append(p)
    return r

def divs(n, start=1):
    divisors = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if n % i == 0:
            if n / i == i:
                divisors.append(i)
            else:
                divisors.extend([i, n // i])
    return divisors

def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t

def flin(d, x, default=-1):
    left = p0jez = -1
    for i in range(len(d)):
        if d[i] == x:
            if left == -1: left = i
            p0jez = i
    if left == -1:
        return default, default
    else:
        return left, p0jez
",0,{}
422," <ans>
```python
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
import math

def isSubSequence(str1,str2):
    m = len(str1)
    n = len(str2)
    j = 0    # Index of str1 
    i = 0    # Index of str2 ",0,{}
423," <ans>
```python
#
# abc147 c
#
import sys
from io import StringIO
import unittest


class TestClass(unittest.TestCase):
    def assertIO(self, input, output):
        stdout, stdin = sys.stdout, sys.stdin
        sys.stdout, sys.stdin = StringIO(), StringIO(input)
        resolve()
        sys.stdout.seek(0)
        out = sys.stdout.read()[:-1]
        sys.stdout, sys.stdin = stdout, stdin
        self.assertEqual(out, output)

    def test_入力例_1(self):
        input = """"""3
1
2 1
1
1 1
1
2 0""""""
        output = """"""2""""""
        self.assertIO(input, output)

    def test_入力例_2(self):
        input = """"""3
2
2 1
3 0
2
3 1
1 0
2
1 1
2 0""""""
        output = """"""0""""""
        self.assertIO(input, output)

    def test_入力例_3(self):
        input = """"""2
1
2 0
1
1 0""""""
        output = """"""1""""""
        self.assertIO(input, output)


def resolve():
    iRVST = int(NIDNtXd39r())
    Q53UHAbco = []
    for i in range(iRVST):
        a = int(NIDNtXd39r())
        Q53UHAbco.append([list(map(int, NIDNtXd39r().split())) for j in range(a)])

    SM59wi = 0
    for bit in range(1 << iRVST):
        sNw553sMw = True
        for i in range(iRVST):
            if bit & (1 << i):
                for c in Q53UHAbco[i]:
                    if bit & (1 << c[0]-1) != (1 << c[0]-1)*c[1]:
                        sNw553sMw = False
                        break
        if sNw553sMw == True:
            SM59wi = max(SM59wi, bin(bit).count(""1""))
    print(SM59wi)


def __starting_point():
    # unittest.main()
    resolve()

__starting_point()
```
</ans>",0,{}
424," <ans>
# N58GOlzN = 998244353
hNjjv4 = 1#int(input())
from heapq import heappop, heappush
for test in range(hNjjv4):
    Nl6alkH19M = int(input())
    # n,m = (map(int, input().split()))
    sIltr5DVI = input()
    # ans = 1
    # start = 1
    # cur = s[0]
    # tmp = 0
    # while s[start]==cur:
    #     start+=1
    #     tmp+=1
    # end = n-1
    # tmp = 1
    # while s[end]==cur:
    #     end-=1
    #     tmp+=1
    WJ71juUYNS = []
    fqbuWw = []
    tmp = 0
    C0cy1uroOb = sIltr5DVI[0]
    for i in sIltr5DVI:
        if i==C0cy1uroOb:
            tmp+=1
        else:
            WJ71juUYNS.append(C0cy1uroOb)
            fqbuWw.append(tmp)
            C0cy1uroOb = i
            tmp = 1
    WJ71juUYNS.append(C0cy1uroOb)
    fqbuWw.append(tmp)
    if len(WJ71juUYNS)==1:
        print(((Nl6alkH19M*(Nl6alkH19M+1))//2)%N58GOlzN)
    else:
        if WJ71juUYNS[0]==WJ71juUYNS[-1]:
            d_Ian9z = ((fqbuWw[0]+1)*(fqbuWw[-1]+1))%N58GOlzN
            # print(""here"", ans)
            # if cnt[0]+cnt[-1]==n-1:
            #     ans-=1
            #     ans = ans%prime
            print(d_Ian9z)
        else:
            d_Ian9z = fqbuWw[0]+1+fqbuWw[-1]
            d_Ian9z = d_Ian9z%N58GOlzN
            # if cnt[0]+cnt[-1]==n-1:
            #     ans-=1
            #     ans = ans%prime
            print(d_Ian9z)
</ans>",0,{}
425," <ans>
n, l, r = [int(i) for i in input().split()]

ywg = [[-1 for i in range(3)] for j in range(n+1)]

ffi11otJb4 = 0
TD_l = 0
UIvOlRW = 0

if l%3 == 0:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3
    if r%3 == 2:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
elif l%3 == 1:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3
    if r%3 == 2:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3 + 1
        UIvOlRW = (r-l+1)//3 + 1
elif l%3 == 2:
    if r%3 == 0:
        ffi11otJb4 = (r-l+1)//3 + 1
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3 + 1
    if r%3 == 1:
        ffi11otJb4 = (r-l+1)//3
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3
    if r%3 == 2:
        ffi11otJb4 = (r-l+1)//3 
        TD_l = (r-l+1)//3
        UIvOlRW = (r-l+1)//3 + 1

ShyEb = 10**9 + 7
ywg[1][0] = ffi11otJb4%ShyEb
ywg[1][1] = TD_l%ShyEb
ywg[1][2] = UIvOlRW%ShyEb

for i in range(2,n+1):
    ywg[i][0] = (((ywg[i-1][0]%ShyEb)*(ffi11otJb4%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(TD_l%ShyEb))%ShyEb)%ShyEb
    ywg[i][1] = (((ywg[i-1][0]%ShyEb)*(TD_l%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(ffi11otJb4%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb)%ShyEb
    ywg[i][2] = (((ywg[i-1][0]%ShyEb)*(UIvOlRW%ShyEb))%ShyEb + ((ywg[i-1][1]%ShyEb)*(TD_l%ShyEb))%ShyEb + ((ywg[i-1][2]%ShyEb)*(ffi11otJb4)%ShyEb)%ShyEb)%ShyEb

if ywg[n][0]!=-1:
    print(ywg[n][0]%ShyEb)
else:
    print(0)
</ans>",0,{}
426," <ans>
from sys import stdin, stdout
from bisect import bisect\_left, bisect\_right
from collections import defaultdict
import math
from fractions import Fraction as frac
from random import random
NhziiAL = stdin.readline
def cout(x):
stdout.write(str(x)+'\n')
def var(type = int):
return type(NhziiAL())
def readline(type = int):
return list(map(type,NhziiAL().split()))
def readlist(type = int):
return list(map(type,NhziiAL().split()))
def sorted\_indexes(arr):
return sorted(list(range(len(arr))),key=arr.__getitem__)
def printr(arr):
[stdout.write(str(x)+' ') for x in arr]
stdout.write('\\n')
def find\_lt(a, x):#'Find rightmost value less than x'
i = bisect\_left(a, x)
if i:
return a[i-1]
raise ValueError
def find\_gt(a, x):#'Find leftmost value greater than x'
i = bisect\_right(a, x)
if i != len(a):
return a[i]
raise ValueError
def dist(x,y):
return math.sqrt(x*x + y*y)
def binary\_search(arr, x):
i = bisect\_left(arr, x)
if i == len(arr) or arr[i] != x:
return -1
return i

n , uBBcB[0] , uBBcB[1] = readline(int)
Kr2ng = readlist(int)
O8zh = n//2
P9\_m = 0
YP4qMUm = True
for tu\_ in range(O8zh):
if Kr2ng[tu\_] == Kr2ng[n-1-tu\_] == 2:
P9\_m += 2*min(uBBcB[0],uBBcB[1])
elif Kr2ng[tu\_] ==2 and Kr2ng[n-1-tu\_] <= 1:
P9\_m += uBBcB[Kr2ng[n-1-tu\_]]
elif Kr2ng[tu\_] <= 1 and Kr2ng[n-1-tu\_] == 2:
P9\_m += uBBcB[Kr2ng[tu\_]]
elif Kr2ng[tu\_] != Kr2ng[n-1-tu\_]:
YP4qMUm = False
break
if n%2 == 1:
if Kr2ng[O8zh] == 2:
P9\_m += min(uBBcB[0],uBBcB[1])
if not YP4qMUm:
print(-1)
else:
print(P9\_m)
</ans>",0,{}
427," <ans>
from sys import stdin
import sys
import numpy as np
import collections
from functools import cmp\_to\_key
import heapq
sys.setrecursionlimit(100000)

##  input functions for me
def rsa(sep = ''):
if sep == '' :
return input().split()
else: return input().split(sep)
def rip(sep = ''):
if sep == '' :
return list(map(int, input().split()))
else: return list(map(int, input().split(sep)))
def ria(sep = ''):
return list(rip(sep))
def ri(): return int(input())
def rd(): return float(input())
def rs(): return input()
##
class mint:
mod = int(1e9 + 7)
def **init**(self, v = 0):
if not ((v >= 0) and (v < mint.mod)):
v %= mint.mod
if v < 0: v += mint.mod
self.V = v
def **add**(self, other):
v = self.V + (other.V if isinstance(other, mint) else other)
return mint(v)
def **sub**(self, other):
v = self.V - (other.V if isinstance(other, mint) else other)
return mint(v)
def **mul**(self, other):
v = self.V \* (other.V if isinstance(other, mint) else other)
return mint(v)
def **floordiv**(self, other):
v = self.V \* mint.inv((other.V if isinstance(other, mint) else other))
return mint(v)
def **truediv**(self, other):
v = self.V \* mint.inv((other.V if isinstance(other, mint) else other))
return mint(v)
```python
def __eq__(self, other):
    return self.V == (other.V if isinstance(other, mint) else mint(other).V)
def __ne__(self, other):
    return self.V != (other.V if isinstance(other, mint) else other)
def __int__(self): return self.V
# right operand
def __radd__(self, other):
    v = (other.V if isinstance(other, mint) else other) + self.V
    return mint(v)
def __rsub__(self, other):
    v = (other.V if isinstance(other, mint) else other) - self.V
    return mint(v)
def __rmul__(self, other):
    v = (other.V if isinstance(other, mint) else other) * self.V
    return mint(v)
def __rfloordiv__(self, other):
    v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
    return mint(v)
def __rtruediv__(self, other):
    v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)
    return mint(v)

@staticmethod
def inv(x):
    a, _, _ = mint.extGCD(x, mint.mod)
    return (a + mint.mod) % mint.mod
@staticmethod
def extGCD(x, y):
    r0 = x
    r1 = y
    a0 = 1
    a1 = 0
    b0 = 0
    b1 = 1
    while(r1 > 0):
        q1 = r0 // r1
        r2 = r0 % r1
        a2 = a0 - q1 * a1
        b2 = b0 - q1 * b1
        r0 = r1; r1 = r2
        a0 = a1; a1 = a2
        b0 = b1; b1 = b2
    c = r0
    a = a0
    b = b0
    return a, b, c
@staticmethod
def pow(x, k):
    x = x.V if isinstance(x, mint) else x
    return pow(x, k, mint.mod)

def __str__(self):
    return str(self.V)
def __repr__(self):
    return str(self.V)

```

def main():
rXf9 = ri()
ZsVvJrOOF9 = ria()
ZsVvJrOOF9 = sorted(ZsVvJrOOF9)
ZsVvJrOOF9 = list(reversed(ZsVvJrOOF9))
S_jtP6t = [mint(0)] \* (rXf9 + 1)
S_jtP6t[0] = mint(1)
for i in range(1,rXf9+1): S_jtP6t[i] = S_jtP6t[i-1] \* 2

XPF = mint(0)
for i in range(rXf9):
XPF += mint(ZsVvJrOOF9[i]) \* S_jtP6t[rXf9-1]
if i > 0: XPF += mint(ZsVvJrOOF9[i]) \* i \* S_jtP6t[rXf9-2]
XPF *= S_jtP6t[rXf9]
print(XPF)

def **starting\_point**():
main()

**starting\_point**()
</ans>",0,{}
428," <ans>
rftV2CQDr=input()
e4j0cjCDWI=input()
HJMg4G=len(rftV2CQDr)
OItp=[0]
for i in range(HJMg4G):
	if rftV2CQDr[i]=='0':
		if e4j0cjCDWI[i]=='0':
			OItp.append(2)
		else:
			OItp.append(1)
	else:
		if e4j0cjCDWI[i]=='X':
			OItp.append(0)
		else:
			OItp.append(-1)
OItp.append(0)
yTZL=len(OItp)
rrExr=0
rTRTzREp=1
QMH7xCop0=1
while(rTRTzREp<yTZL-1):
	if OItp[rTRTzREp]==2 and QMH7xCop0==1:
		if OItp[rTRTzREp+1]==2:
			QMH7xCop0=2
			rTRTzREp=rTRTzREp+1
			continue
		elif (OItp[rTRTzREp+1]==1 or OItp[rTRTzREp+1]==-1):
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+2
			continue
		else:
			rTRTzREp=rTRTzREp+2
			continue
	if OItp[rTRTzREp]==2 and QMH7xCop0==2:
		if OItp[rTRTzREp+1]==2:
			rrExr=rrExr+2
			rTRTzREp=rTRTzREp+2
			QMH7xCop0=1
			continue
		else:
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+1
			QMH7xCop0=1
			continue
	if OItp[rTRTzREp]==1 or OItp[rTRTzREp]==-1:
		if OItp[rTRTzREp+1]==2:
			rrExr=rrExr+1
			rTRTzREp=rTRTzREp+2
			continue
		else:
			rTRTzREp=rTRTzREp+1
			continue
	if OItp[rTRTzREp]==0:
		rTRTzREp=rTRTzREp+1
print (rrExr)
</ans>",True,{}
429," <ans>
from random import seed, randint
import sys
sys.setrecursionlimit(10000)

xWI = ['#', '^', '&', '$']
Z1eDCJ = { ""AXv9t04n"" : (False, ""AXv9t04n"") }
fYAYIAv2qq = dict()
JWd = dict()
IzBwXB2S = -1

def get\_tag(var):
if var in Z1eDCJ:
return Z1eDCJ[var][1]
else:
return var

JV5vnE = int(input())
for \_ in range(JV5vnE):
lval, rval = input().split('=')
for c in xWI:
if c in rval:
arg1, arg2 = list(map(get\_tag, rval.split(c)))
rule = (arg1, arg2, c)
if rule in fYAYIAv2qq:
Z1eDCJ[lval] = (True, fYAYIAv2qq[rule])
else:
IzBwXB2S += 1
Z1eDCJ[lval] = (True, IzBwXB2S)
fYAYIAv2qq[rule] = IzBwXB2S
JWd[IzBwXB2S] = rule
break
else:
if rval in Z1eDCJ:
Z1eDCJ[lval] = Z1eDCJ[rval]
else:
Z1eDCJ[lval] = (False, rval)

if Z1eDCJ[""AXv9t04n""] == (False, ""AXv9t04n""):
print(""0"")
return

xgUE2YoI = []
EHT = dict()

def reserve():
return ''.join(chr(randint(0, 25) + ord('a')) for \_ in range(4))

def implement(rule, final):
if type(rule) == str:
return rule
elif rule in EHT:
return EHT[rule]
else:
if final:
name = ""AXv9t04n""
else:
name = reserve()
EHT[rule] = name
arg1, arg2, op = JWd[rule]
var1, var2 = implement(arg1, False), implement(arg2, False)
xgUE2YoI.append(name + ""="" + var1 + op + var2)
return name

seed(123)
if Z1eDCJ[""AXv9t04n""][0]:
implement(Z1eDCJ[""AXv9t04n""][1], True)
else:
xgUE2YoI.append(""AXv9t04n="" + Z1eDCJ[""AXv9t04n""][1])
print(len(xgUE2YoI))
print(""\n"".join(xgUE2YoI))

#print(Z1eDCJ)
#print(fYAYIAv2qq)
</ans>",0,{}
430," <ans>
''' CODED WITH LOVE BY SATYAM KUMAR '''

from sys import stdin, stdout
import heapq
import cProfile, math
from collections import Counter, defaultdict, deque
from bisect import bisect_left, bisect, bisect_right
import itertools
from copy import deepcopy
from fractions import Fraction
import sys, threading
import operator as op
from functools import reduce
import sys

sys.setrecursionlimit(10 ** 6)  # max depth of recursion
threading.stack_size(2 ** 27)  # new thread will get stack of such size
oTH = 10 ** 9 + 7


class MergeFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n
        self.num_sets = n
        self.lista = [[_] for _ in range(n)]

    def find(self, a):
        lRiyr = []
        while a != self.parent[a]:
            lRiyr.append(a)
            a = self.parent[a]
        for b in lRiyr:
            self.parent[b] = a
        return self.parent[a]

    def merge(self, a, b):
        a = self.find(a)
        b = self.find(b)
        if a == b:
            return
        if self.size[a] < self.size[b]:
            a, b = b, a
        self.num_sets -= 1
        self.parent[b] = a
        self.size[a] += self.size[b]
        self.lista[a] += self.lista[b]

    def set_size(self, a):
        return self.size[self.find(a)]

    def __len__(self):
        return self.num_sets


def display(string_to_print):
    stdout.write(str(string_to_print) + ""\n"")


def prime_factors(n):  # n**0.5 complex
    factors = dict()
    for i in range(2, math.ceil(math.sqrt(n)) + 1):
        while n % i == 0:
            if i in factors:
                factors[i] += 1
            else:
                factors[i] = 1
            n = n // i
    if n > 2:
        factors[n] = 1
    return (factors)


def all_factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


def fibonacci_modP(n, MOD):
    if n < 2: return 1
    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(
        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD


def factorial_modP_Wilson(n, p):
    if (p <= n):
        return 0
    res = (p - 1)
    for i in range(n + 1, p):
        res = (res * cached_fn(InverseEuler, i, p)) % p
    return res


def binary(n, digits=20):
    b = bin(n)[2:]
    b = '0' * (digits - len(b)) + b
    return b


def is_prime(n):
    """"""Returns True if n is prime.""""""
    if n < 4:
        return True
    if n % 2 == 0:
        return False
    if n % 3 == 0:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w
    return True


def generate_primes(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 1
    return prime


lz1xsZ = []


def warm_up_fac(MOD):
    nonlocal lz1xsZ, fac_warm_up
    if fac_warm_up: return
    lz1xsZ = [1 for _ in range(fac_warm_up_size + 1)]
    for i in range(2, fac_warm_up_size):
        lz1xsZ[i] = (lz1xsZ[i - 1] * i) % MOD
    fac_warm_up = True


def InverseEuler(n, MOD):
    return pow(n, MOD - 2, MOD)


def nCr(n, r, MOD):
    nonlocal fac_warm_up, lz1xsZ
    if not fac_warm_up:
        warm_up_fac(MOD)
        fac_warm_up = True
    return (lz1xsZ[n] * (
            (pow(lz1xsZ[r], MOD - 2, MOD) * pow(lz1xsZ[n - r], MOD - 2, MOD)) % MOD)) % MOD


def get_int():
    return int(stdin.readline().strip())


def get_tuple():
    return list(map(int, stdin.readline().split()))


def get_list():
    return list(map(int, stdin.readline().split()))


HIBu = dict()


def clear_cache():
    nonlocal HIBu
    HIBu = dict()


def cached_fn(fn, *args):
    nonlocal HIBu
    if args in HIBu:
        return HIBu[args]
    else:
        result = fn(*args)
        HIBu[args] = result
        return result


def ncr(n, r):
    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))


def binary_search(i, li):
    fn = lambda x: li[x] - x // i
    x = -1
    b = len(li)
    while b >= 1:
        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like
            x += b
        b = b // 2
    return x


# -------------------------------------------------------------- MAIN PROGRAM


urWPQw = True
optimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3


def main():
    e7WXJ5ZU, DaMXADA, W85, FT9fPBKp, xDRQ, AmgN64GMT, _sC_JciW3v, WZW = get_tuple()
    x = (_sC_JciW3v+W85-1)//W85
    y = (AmgN64GMT+FT9fPBKp-1)//FT9fPBKp
    if x+y<=xDRQ:
        print(x, y)
    else: print(-1)
# --------------------------------------------------------------------- END=


if urWPQw:
    for i in range(get_int()):
        main()
else:
    main() if not optimise_for_recursion else threading.Thread(target=main).start()
</ans>",0,{}
431," <ans>
import sys
input = sys.stdin.readline

def find(a):
if par[a] == a:
return a
par[a] = find(par[a])
return par[a]

def union(a, b):
a = find(a)
b = find(b)
if a == b:
return
par[a] = b

def mst():
ret = []
for edge in edges:
u, v, w = edge
u = find(u)
v = find(v)
if u != v:
union(u, v)
ret.append(edge)
return ret

def dfs(u, par):
for v, w in adj[u]:
if v != par:
vUaztUo1dc[v] = max(vUaztUo1dc[u], w)
dfs(v, u)

def bfs(u):
visit = [False] \* (n+1)
dq = deque()

dq.append(u)
visit[u] = True
while dq:
u = dq.popleft()
for v, w in adj[u]:
if not visit[v]:
vUaztUo1dc[v] = max(vUaztUo1dc[u], w)
dq.append(v)
visit[v] = True

n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
# n = 50000
# m = 2 \* n
# k = n
# a = [i for i in range(1, n+1)]
# import random

par = [0] \* (n+1)
for i in range(1, n+1):
par[i] = i
edges = []
# for i in range(1, n+1):
# edge = (i, 1 if i+1 > n else i+1, random.randint(1, 1000000000))
# edge = (i, 1 if i+2 > n else i+2, random.randint(1, 1000000000))
# edges.append(edge)
for i in range(m):
edge = tuple(map(int, input().split()))
edges.append(edge)
edges.sort(key=lambda x: x[2])
edges = mst()
adj = [list() for i in range(n+1)]
for edge in edges:
u, v, w = edge
adj[u].append((v, w))
adj[v].append((u, w))

vUaztUo1dc = [0] \* (n+1)
# dfs(a[0], -1)
bfs(a[0])
ans = 0
for x in a:
ans = max(ans, vUaztUo1dc[x])
ans = [ans] \* k
print(*ans)
</ans>",0,{}
432," <ans>
n=int(input())
dHAEQX =[int(x) for x in input().split()]
J8RAosC0V3 =[int(x) for x in input().split()]
nHbKjeyU = sorted(dHAEQX)[::-1]
jQT8ofhRY = sorted(J8RAosC0V3)[::-1]
nHbKjeyU = [0]+nHbKjeyU
jQT8ofhRY = [0]+jQT8ofhRY
pta=0
ptb=0
DkltWTIhn2=0
c_8sUPu2=0
for j in range(0,(2*n)+1):
if(j%2==0):
if(jQT8ofhRY[ptb]>nHbKjeyU[pta]):
ptb=ptb+1
else:
DkltWTIhn2=DkltWTIhn2+nHbKjeyU[pta]
pta=pta+1
else:
if(nHbKjeyU[pta]>jQT8ofhRY[ptb]):
pta=pta+1
else:
c_8sUPu2=c_8sUPu2+jQT8ofhRY[ptb]
ptb=ptb+1
if(pta==n+1 and ptb==n+1):
break
print(DkltWTIhn2-c_8sUPu2)
</ans>",0,{}
433," <ans>
import sys
from collections import deque
GxkkIScnJT=sys.stdin.readline
def binary\_search(org,yjSzLpDm,xjhACtSw,pESL,L,n,value):
mid=(pESL+L)//2
# print(mid,""ppppp"")
if(mid>0 and yjSzLpDm[mid]-value>=org and yjSzLpDm[mid-1]-value<org):
return mid
elif(mid==0 and yjSzLpDm[mid]-value>=org ):
return mid
elif(mid==L and yjSzLpDm[mid]-value>=org ):
return mid
elif(mid==xjhACtSw):
return mid

elif(mid>0 and yjSzLpDm[mid]-value>org and yjSzLpDm[mid-1]-value>=org):
return binary\_search(org,yjSzLpDm,xjhACtSw,pESL,L,n,value)

elif(yjSzLpDm[mid]-value<org):
return binary\_search(org,yjSzLpDm,xjhACtSw,pESL+1,L,n,value)
return mid

xjhACtSw=int(GxkkIScnJT())
B7K8FA = list(map(int,GxkkIScnJT().split()))
AXMW = list(map(int,GxkkIScnJT().split()))
extra=[0]*xjhACtSw
pre=[0]*xjhACtSw
yjSzLpDm=[0]*xjhACtSw
yjSzLpDm[0]=AXMW[0]
for i in range(1,xjhACtSw):
yjSzLpDm[i]+=yjSzLpDm[i-1]+AXMW[i]
# print(yjSzLpDm)
for i in range(xjhACtSw):
if(i>0):
v=yjSzLpDm[i-1]
else:
v=0
pESL=binary\_search(B7K8FA[i],yjSzLpDm,i,xjhACtSw-1,xjhACtSw-1,i,v)
# print(i,index)
if(pESL>0 and pESL!=i):
value=yjSzLpDm[pESL]-yjSzLpDm[pESL-1]
remain=B7K8FA[i]-(yjSzLpDm[pESL-1]-v)
elif(pESL>0 and pESL==i):
value=yjSzLpDm[pESL]-yjSzLpDm[pESL-1]
remain=B7K8FA[i]

else:
value=yjSzLpDm[pESL]
remain=B7K8FA[i]
if(value>=remain):
extra[pESL]+=remain
# print(extra[index],""ooooo"")
elif(remain>value):

extra[pESL]+=value
# print(extra[index],""oooooopp"")
if(i>0 and pESL>0):
pre[i-1]-=1
pre[pESL-1]+=1
elif(i==0 and pESL>0):
pre[pESL-1]+=1
elif(i==0 and pESL==0):
continue
# print(extra,pre)
# print(extra,pre)
for i in range(xjhACtSw-2,-1,-1):
pre[i]+=pre[i+1]
# print(extra,pre)
r=[0]*xjhACtSw
for i in range(xjhACtSw):
r[i]=(AXMW[i]*pre[i])+extra[i]
for i in r:
print (i,end="" "")
</ans>",0,{}
434," <ans>
from bisect import *
from collections import *
from itertools import *
import functools
import sys
from math import *
from decimal import *
from copy import *
getcontext().prec = 30
vuKc = sys.maxsize
NAtm = 10**5+10
n4TXOV\_ = 10**9+7
def isprime(vc8Pati7u):
vc8Pati7u = abs(int(vc8Pati7u))
if vc8Pati7u < 2:
return False
if vc8Pati7u == 2:
return True
if not vc8Pati7u & 1:
return False
for x in range(3, int(vc8Pati7u**0.5) + 1, 2):
if vc8Pati7u % x == 0:
return False
return True

def mhd(a,b):
return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
return list(map(int,sys.stdin.readline().strip().split(x)))

def dis(x,y):
a = y[0]-x[0]
b = x[1]-y[1]
return (a*a+b*b)**0.5

def lgcd(a):
g = a[0]
for i in range(1,len(a)):
g = math.gcd(g,a[i])
return g

def ms(a):
msf = -vuKc
meh = 0
st = en = be = 0
for i in range(len(a)):
meh+=a[i]
if msf<meh:
msf = meh
st = be
en = i
if meh<0:
meh = 0
be = i+1
return msf,st,en

def flush():
return sys.stdout.flush()

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
for _ in range(int(input())):
vc8Pati7u,J0O = arrIN()
ans = 0
while 1:
if vc8Pati7u%J0O==0:
vc8Pati7u//=J0O
ans+=1
else:
x = vc8Pati7u%J0O
ans+=x
vc8Pati7u-=x
if vc8Pati7u==0:
print(ans)
break

</ans>",0,{}
435," <ans>
MOD = 1000000007

def isSubset(a, b):
return (a & b) == a

def isIntersect(a, b):
return (a & b) != 0

# Solve for each weakly connected component (WCC)
def cntOrder(s, t):
p = len(s)
m = len(t)

inMask = [0 for i in range(m)]

for x in range(p):
for i in range(m):
if t[i] % s[x] == 0:
inMask[i] |= 1 << x

cnt = [0 for mask in range(1<<p)]
for mask in range(1<<p):
for i in range(m):
if isSubset(inMask[i], mask):
cnt[mask] += 1

dp = [[0 for mask in range(1<<p)] for k in range(m+1)]
for i in range(m):
dp[1][inMask[i]] += 1
for k in range(m):
for mask in range(1<<p):
for i in range(m):
if not isSubset(inMask[i], mask) and isIntersect(inMask[i], mask):
dp[k+1][mask | inMask[i]] = (dp[k+1][mask | inMask[i]] + dp[k][mask]) % MOD
dp[k+1][mask] = (dp[k+1][mask] + dp[k][mask] * (cnt[mask] - k)) % MOD

return dp[m][(1<<p)-1]

def dfs(u):
nonlocal hGoUcrNe, o6vPvT, H0SbhsMmX, otpg, Q0Rm5UzIEb, Bf6Xpd2Y

otpg[u] = True
if H0SbhsMmX[u] == 0:
Q0Rm5UzIEb.append(hGoUcrNe[u])
else:
Bf6Xpd2Y.append(hGoUcrNe[u])

for v in o6vPvT[u]:
if not otpg[v]:
dfs(v)

def main():
nonlocal hGoUcrNe, o6vPvT, H0SbhsMmX, otpg, Q0Rm5UzIEb, Bf6Xpd2Y

# Reading input
kHdN5x = int(input())
hGoUcrNe = list(map(int, input().split()))

# Pre-calculate C(n, k)
Znkmip26Sk = [[0 for j in range(n)] for i in range(n)]
for i in range(n):
Znkmip26Sk[i][0] = 1
for j in range(1, i+1):
Znkmip26Sk[i][j] = (Znkmip26Sk[i-1][j-1] + Znkmip26Sk[i-1][j]) % MOD	

# Building divisibility graph
H0SbhsMmX = [0 for u in range(n)]
o6vPvT = [[] for u in range(n)]
for u in range(n):
for v in range(n):
if u != v and hGoUcrNe[v] % hGoUcrNe[u] == 0:
o6vPvT[u].append(v)
o6vPvT[v].append(u)
H0SbhsMmX[v] += 1

# Solve for each WCC of divisibility graph and combine result
_KdMdGUQsw = 1
xh\_ = 0
otpg = [False for u in range(n)]
for u in range(n):
if not otpg[u]:
Q0Rm5UzIEb = []
Bf6Xpd2Y = []
dfs(u)

if len(Bf6Xpd2Y) > 0:
sz = len(Bf6Xpd2Y) - 1
cnt = cntOrder(Q0Rm5UzIEb, Bf6Xpd2Y)

# Number of orders for current WCC
_KdMdGUQsw = (_KdMdGUQsw * cnt) % MOD
# Number of ways to insert <sz> number to array of <curLen> elements
_KdMdGUQsw = (</ans>(_KdMdGUQsw * EATtCIe[xh\_ + sz][sz]) % MOD
xh\_ += sz

print(_KdMdGUQsw)

def __starting\_point():
main()

__starting\_point()",0,{}
436," <ans>
BGyY=int(input())
S=input()
S=[1 if S[i]=='o' else -1 for i in range(BGyY)]

#0番目は羊のパターン
nCViBNaFdI=[0]*BGyY
nCViBNaFdI[0]=1
if S[0]==1: #0番目の両隣は同種
  #0番目の両隣は羊
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
#0番目は狼のパターン
nCViBNaFdI=[0]*BGyY
nCViBNaFdI[0]=-1
if S[0]==-1: #0番目の両隣は同種
  #0番目の両隣は羊
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
    
  #0番目の両隣は狼
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
else: #0番目の両隣は異種
  #1番目が羊, N-1番目が狼
  nCViBNaFdI[1]=1
  nCViBNaFdI[BGyY-1]=-1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
  #1番目が狼, N-1番目が羊
  nCViBNaFdI[1]=-1
  nCViBNaFdI[BGyY-1]=1
  
  for i in range(2, BGyY-1):
    nCViBNaFdI[i]=nCViBNaFdI[i-1]*nCViBNaFdI[i-2]*S[i-1]
    
  if nCViBNaFdI[BGyY-1]==nCViBNaFdI[BGyY-2]*nCViBNaFdI[BGyY-3]*S[BGyY-2] and nCViBNaFdI[0]==nCViBNaFdI[BGyY-1]*nCViBNaFdI[BGyY-2]*S[BGyY-1]:
    ans=['S' if nCViBNaFdI[i]==1 else 'W' for i in range(BGyY)]
    print(''.join(ans))
    return
  
print(-1)
</ans>",0,{}
437," <ans>
n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
if s[i]==""G"":
Wdi=l[i]
if AXBY1Lfr>=Wdi:
AXBY1Lfr-=Wdi
time+=2\*Wdi
casIRMP+=Wdi
else:
Wdi-=AXBY1Lfr
time+=2\*AXBY1Lfr
casIRMP+=AXBY1Lfr
AXBY1Lfr=0
time+=3\*Wdi
HuAJERj+=Wdi
else:
AXBY1Lfr+=l[i]
time+=2\*l[i]
seen=True
else:
Wdi=l[i]
if AXBY1Lfr>=Wdi:
AXBY1Lfr-=Wdi
time+=2\*Wdi
else:
Wdi-=AXBY1Lfr
time+=2\*AXBY1Lfr
AXBY1Lfr=0
if casIRMP>=Wdi:
casIRMP-=Wdi
HuAJERj+=Wdi
time+=3\*Wdi
else:
Wdi-=casIRMP
HuAJERj+=casIRMP
casIRMP=0
if HuAJERj>=Wdi:
HuAJERj-=Wdi
time+=3\*Wdi
else:
Wdi-=HuAJERj
time+=3\*HuAJERj
HuAJERj=0
if seen:
time+=4\*Wdi
else:
time+=6\*Wdi
print(time)
</ans>",0,{}
438," <ans>
from math import gcd

m,a,b = list(map(int,input().split()))

g = gcd(a,b)

P7RT = [0]*(a+b+1)
P7RT[0] = 1

xJ22JQBDY = 1

count = 0
mCjkh = 0
vyfTD6PJ = 0
while True:
#print(t, vis)
if vyfTD6PJ >= b:
#print('back')
vyfTD6PJ -= b
if P7RT[vyfTD6PJ]:
break
P7RT[vyfTD6PJ] = 1
xJ22JQBDY += 1
else:
vyfTD6PJ += a
if vyfTD6PJ > m:
break
if vyfTD6PJ > mCjkh:
#print('forward', vyfTD6PJ - mCjkh, 'with', xJ22JQBDY)
count += (vyfTD6PJ - mCjkh)*xJ22JQBDY
mCjkh = vyfTD6PJ
if P7RT[vyfTD6PJ]:
break
P7RT[vyfTD6PJ] = 1
xJ22JQBDY += 1
#print(nvis,count)
#print('---')

if vyfTD6PJ > m:
# we're done
count += (m - mCjkh + 1)*xJ22JQBDY
else:
def sumto(n):
whole = n//g + 1
r = whole*(whole+1)//2 * g
corr = whole * (g-1 - (n%g))
r -= corr
return r

#S = 0
#for i in range(mCjkh, m+1):
#S += i//g + 1
#count += S
#assert S == sumto(m) - sumto(mCjkh-1)

count += sumto(m) - sumto(mCjkh-1)

#print(vis)
print(count)
</ans>",0,{}
